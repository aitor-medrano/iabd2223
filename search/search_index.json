{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Inteligencia Artificial y Big Data","text":"Logo de IABD <p>Apuntes realizados para el curso de especialista de Inteligencia Artificial y Big Data impartido en el IES Severo Ochoa de Elche. El curriculum viene fijado por el Real Decreto 279/2021.</p> <p>Este curso se ha dise\u00f1ado mediante un proceso de flexibilizaci\u00f3n del curriculum, mediante el cual hemos repartido los diferentes resultados de aprendizaje a lo largo de tres unidades formativas. Cada una de las unidades formativas contiene varias unidades de trabajo centradas en un \u00e1rea de trabajo concreta. En cada unidad formativa vamos a realizar como hilo conductor un Proyecto de Innovaci\u00f3n Aplicada (PIAFP) que dirija el aprendizaje del alumnado.</p> <p>En este sitio web podr\u00e1s consultar los apuntes y ejercicios que he trabajado directamente con el alumnado durante el curso 22/23:</p> <ul> <li>Sistemas de almacenamiento</li> <li>Ecosistema Hadoop</li> <li>Datos en el cloud</li> <li>Spark</li> <li>Flujo de datos</li> </ul> <p>Y los materiales creados para el seguimiento de los Proyectos de Innovaci\u00f3n Aplicada:</p> <ul> <li>PIA FP</li> </ul> <p>Despliega el men\u00fa de la izquierda para consultar los materiales.</p>"},{"location":"cloud/index.html","title":"Datos en el cloud","text":""},{"location":"cloud/index.html#resultados-de-aprendizaje","title":"Resultados de aprendizaje","text":"<ul> <li>RA5075.1 Gestiona soluciones a problemas propuestos, utilizando sistemas de almacenamiento y herramientas asociadas al centro de datos.  </li> <li>RA5075.2 Gestiona sistemas de almacenamiento y el amplio ecosistema alrededor de ellos facilitando el procesamiento de grandes cantidades de datos sin fallos y de forma r\u00e1pida.  </li> <li>RA5075.3 Genera mecanismos de integridad de los datos, comprobando su mantenimiento en los sistemas de ficheros distribuidos y valorando la sobrecarga que conlleva en el tratamiento de los datos.</li> </ul>"},{"location":"cloud/index.html#planificacion-16h","title":"Planificaci\u00f3n (16h)","text":"Sesi\u00f3n Fecha Duraci\u00f3n (h) 33.- Cloud Lunes 21 Nov 2p + 2o 33.- AWS Lunes 21 Nov 1p + 1o 40.- Almacenamiento en AWS Mi\u00e9rcoles 30 Nov 2p + 2o 44.- Computaci\u00f3n en AWS Lunes 5 Dic 1p + 1o 44.- Hadoop en AWS (EMR) Lunes 5 Dic 1p + 1o 46.- Datos en AWS Mi\u00e9rcoles 7 Dic 2p + 2o 46.- AWS Athena Mi\u00e9rcoles 7 Dic"},{"location":"cloud/01cloud.html","title":"Cloud Computing","text":""},{"location":"cloud/01cloud.html#la-nube","title":"La Nube","text":"<p>Ya hemos visto que la industria 4.0 incluye el Big Data y la computaci\u00f3n en la nube como uno de los elementos principales de su transformaci\u00f3n.</p> <p>El Cloud Computing permite obtener servicios de computaci\u00f3n a trav\u00e9s de internet de manera que s\u00f3lo se pague por los recursos que usa y en el momento en que los necesita. Dicho de otro modo, es la entrega bajo demanda de potencia de c\u00f3mputo, bases de datos, almacenamiento, aplicaciones y otros recursos inform\u00e1ticos, a trav\u00e9s de Internet con un sistema de precios de pago por uso.</p> <p>Los modelos productivos basados en la adquisici\u00f3n de hardware de manera propietaria ha quedado atr\u00e1s, al implicar un proceso largo y costoso de compra de licencias, recursos f\u00edsicos como oficinas y equipamiento y recursos humanos (tanto t\u00e9cnicos como de seguridad) para su implantaci\u00f3n, gesti\u00f3n y mantenimiento.</p> <p>As\u00ed pues plantea un cambio de perspectiva. La infraestructura se deja de considerar hardware para verla (y usarla) como software.</p> <p></p> <p>Si buscamos una definici\u00f3n formal, seg\u00fan el NIST (National Institute for Standards and Technology) la computaci\u00f3n en la nube es \"un modelo que permite un acceso ubicuo, conveniente y bajo demanda a una red de recursos de computaci\u00f3n configurables (por ejemplo, redes, servidores, almacenamiento, aplicaciones y servicios) que se pueden aprovisionar r\u00e1pidamente y entregar con una interacci\u00f3n m\u00ednima con el proveedor del servicio\".</p>"},{"location":"cloud/01cloud.html#ventajas","title":"Ventajas","text":"<p>As\u00ed pues, los beneficios que ofrece la nube son:</p> <ul> <li>Alta disponibilidad, dada su naturaleza de recursos distribuidos.</li> <li>Escalabilidad: Si un usuario necesita m\u00e1s o menos capacidad de proceso o de almacenamiento, el proveedor se lo facilitar\u00e1 pr\u00e1cticamente en tiempo real. Adem\u00e1s, permite escalar la aplicaci\u00f3n a nivel mundial, desplegando las aplicaciones en diferente regiones de todo el mundo con s\u00f3lo unos clicks.</li> <li>Tolerancia a fallos, ya que ofrecen una arquitectura de respaldo de copias de seguridad y a prueba de ataques.</li> <li>Elasticidad: de la misma manera que podemos escalar hacia arriba, podemos reducir los requisitos y buscar soluciones m\u00e1s econ\u00f3micas.</li> <li>Alcance global: cualquier usuario autorizado puede acceder o actualizar informaci\u00f3n desde cualquier lugar del mundo, en cualquier momento y mediante cualquier dispositivo.</li> <li>Agilidad: Permite amoldar los recursos al crecimiento de la empresa/proyecto, de manera casi instant\u00e1nea. No hay que esperar a adquirir y montar los recursos (en vez de tardar del orden de semanas pasamos a minutos).</li> <li>Capacidades de latencia del cliente, pudiendo elegir c\u00f3mo de cerca se despliegan las aplicaciones.</li> <li>C\u00e1lculo de costes de manera predictiva, siguiendo un modelo basado en el consumo (pay-as-you go pricing). S\u00f3lo se paga por los recursos que se utilizan, para ello se proporciona el precio de cada recurso por hora.</li> </ul> <p>Una de las ventajas m\u00e1s interesante para las empresas puede que sea la reducci\u00f3n de los costes, ya que no necesitamos instalar ning\u00fan tipo de hardware ni software, ni pagar por las actualizaciones futuras en t\u00e9rminos de ese hardware y software que ya no vamos a necesitar o que se ha quedado corto para nuestras necesidades.</p> <p>En relaci\u00f3n con los costes, es conveniente aclarar dos conceptos relacionados con la contabilidad y las finanzas: CapEx y OpEx.</p>"},{"location":"cloud/01cloud.html#capex-vs-opex","title":"CapEx vs OpEx","text":"<p>Hay dos tipos diferentes de gastos que se deben tener en cuenta:</p> CapEx vs OpEx <ul> <li>La inversi\u00f3n de capital (CapEx, Capital Expenditure) hace referencia a la inversi\u00f3n previa de dinero en infraestructura f\u00edsica, que se podr\u00e1 deducir a lo largo del tiempo. El coste previo de CapEx tiene un valor que disminuye con el tiempo.</li> <li>Los gastos operativos (OpEx, Operational Expenses) son dinero que se invierte en servicios o productos y se factura al instante. Este gasto se puede deducir el mismo a\u00f1o que se produce. No hay ning\u00fan pago previo, ya que se paga por un servicio o producto a medida que se usa.</li> </ul> <p>As\u00ed pues, si nuestra empresa es due\u00f1a de su infraestructura, comprar\u00e1 equipos que se incluir\u00e1n como recursos en su balance de cuentas. Dado que se ha realizado una inversi\u00f3n de capital, los contables clasifican esta transacci\u00f3n como CapEx. Con el tiempo, a fin de contabilizar la duraci\u00f3n \u00fatil limitada de los activos, estos se deprecian o se amortizan.</p> <p>Los servicios en la nube, por otro lado, se clasifican como OpEx debido a su modelo de consumo. Si nuestra empresa utiliza la nube, no tiene ning\u00fan recurso que pueda amortizar, y su proveedor de servicios en la nube (AWS / Azure) administra los costes asociados con la compra y la vida \u00fatil del equipo f\u00edsico. En consecuencia, los gastos de explotaci\u00f3n tienen un impacto directo en el beneficio neto, la base imponible y los gastos asociados en el balance contable.</p> <p>En resumen, CapEx requiere unos costes financieros previos considerables, as\u00ed como unos gastos continuos de mantenimiento y soporte t\u00e9cnico. En cambio, OpEx es un modelo basado en el consumo, y los gastos se deducen en el mismo a\u00f1o.</p> <p>As\u00ed pues, la inform\u00e1tica en la nube es un modelo basado en el consumo, lo que significa que los usuarios finales solo pagan por los recursos que usan. Lo que usan es lo que pagan.</p> <p>Volviendo a las virtudes, los modelos basados en el consumo y OpEx aportan una serie de ventajas:</p> <ul> <li>Sin costes por adelantado.</li> <li>No es necesario comprar ni administrar infraestructuras costosas que es posible que los usuarios no aprovechen del todo, con lo cual el riesgo se reduce al m\u00ednimo.</li> <li>Se puede pagar para obtener recursos adicionales cuando se necesiten.</li> <li>Se puede dejar de pagar por los recursos que ya no se necesiten.</li> </ul> <p>Info</p> <p>Una soluci\u00f3n on-premise implica que somos propietarios de los servidores, que hemos de contratar a un equipo de administradores de sistemas para su mantenimiento, que necesitamos unas instalaciones adecuadas y que hemos de protegerlas contra todo tipo de fallos.</p> <p>Esta elasticidad facilita que la capacidad de c\u00f3mputo se ajuste a la demanda real, en contraposici\u00f3n por un planteamiento de infraestructura in-house/on-premise donde tenemos que estimar cual va a ser la necesidad de la empresa y adquirir la infraestructura por adelantado teniendo en cuenta que:</p> <ul> <li>hay que aprovisionar por encima de la demanda, lo que es un desperdicio econ\u00f3mico.</li> <li>si la demanda crece por encima de la estimaci\u00f3n, tendr\u00e9 un impacto negativo en la demanda con la consiguiente p\u00e9rdida de clientes.</li> </ul> Consumo respecto a Capacidad / Tiempo"},{"location":"cloud/01cloud.html#coste-total-de-propiedad","title":"Coste total de propiedad","text":"<p>El coste total de propiedad (CTO) es la estimaci\u00f3n financiera que ayuda a identificar los costes directos e indirectos de un sistema. Permite comparar el coste de ejecutar una infraestructura completa o una carga de trabajo espec\u00edfica en las instalaciones del cliente frente a hacerlo en la nube.</p> <p>Los elementos a considerar sobre el coste total de propiedad son:</p> <p></p> <p>Cuando migramos a una soluci\u00f3n en la nube, por ejemplo AWS, los \u00fanicos costes que deberemos pagar son:</p> <ul> <li>Costes de computaci\u00f3n (procesador, memoria): se factura por horas o por segundos (s\u00f3lo m\u00e1quinas Linux)</li> <li>Costes de almacenamiento: se factura por GB</li> <li>Costes de transferencia de datos: se factura por GB de salida (excepto casos excepcionales, los datos de entrada no se facturan)</li> </ul> <p>As\u00ed pues, es necesario presupuestar y desarrollar casos de negocio para migrar a la nube y ver si son viables para nuestra organizaci\u00f3n. Para ello, podemos utilizar la calculadora de costes que ofrecen las plataformas cloud:</p> <ul> <li>AWS: https://calculator.aws y en concreto en https://calculator.s3.amazonaws.com/index.html</li> <li>Azure: https://azure.microsoft.com/es-es/pricing/tco/calculator/</li> <li>Google Cloud: https://cloud.google.com/products/calculator?hl=es</li> </ul> <p>Estas calculadoras permiten:</p> <ul> <li>Calcular los costes mensuales.</li> <li>Identificar oportunidades para reducir los costes mensuales.</li> <li>Utilizar plantillas para comparar servicios y modelos de implementaci\u00f3n.</li> </ul> <p>La realidad es que el coste de desplegar y utilizar las aplicaciones en la nube es menor cada vez que se a\u00f1ade un gasto. Se dice que una soluci\u00f3n cloud supone una mejora de un orden de magnitud, es decir, 10 veces m\u00e1s econ\u00f3micas. Sin embargo, operar en la nube realmente abarata los costes cuando automatizamos los procesos y los servicios se dise\u00f1an para trabajar en la nube, es decir, la mayor\u00eda de servicios no se ejecutan 24x7, sino que se detienen o reducen en tama\u00f1o cuando no son necesarios. As\u00ed pues, los proveedores cloud utilizan procesos automatizados para construir, gestionar, monitorizan y escalar todos sus servicios. Esta automatizaci\u00f3n de los procesos nos permitir\u00e1n ahorrar dinero e irnos el fin de semana tranquilos a casa.</p> <p>Un concepto que conviene conocer es el de econom\u00eda de escala, el cual plantea que al disponer de miles de clientes, la plataforma cloud adquiere los productos a un precio inferior al de mercado y que luego repercute en los clientes, que acaban pagando un precio por uso m\u00e1s bajo.</p>"},{"location":"cloud/01cloud.html#inconvenientes","title":"Inconvenientes","text":"<p>Ya hemos comentado las virtudes de utilizar una soluci\u00f3n cloud, pero tambi\u00e9n cabe destacar sus desventajas:</p> <ul> <li>Necesita una conexi\u00f3n a internet continua y r\u00e1pida.</li> <li>En las arquitecturas h\u00edbridas, puede haber bastante latencia.</li> <li>Hay funcionalidades que todav\u00eda no est\u00e1n implementadas, aunque su avance es continuo y salen soluciones nuevas cada mes.</li> <li>Puede haber una falta de confianza:<ul> <li>Los datos guardados pueden ser accedidos por otros</li> <li>Nuestros datos ya no est\u00e1n en la empresa</li> <li>Problemas legales (datos protegidos por leyes europeas que se encuentran en servidor americanos, ...)</li> </ul> </li> <li>Dependencia tecnol\u00f3gica con compa\u00f1\u00edas ajenas (Amazon, Microsoft, ...).</li> </ul>"},{"location":"cloud/01cloud.html#servicios-en-la-nube","title":"Servicios en la nube","text":"<p>Los servicios en la nube son servicios que se utilizan a trav\u00e9s de Internet, eliminando las limitaciones de nuestros equipos. Su principal ventaja es que su CapEx es 0, ya que no necesita ning\u00fan tipo de inversi\u00f3n inicial ni contrato a largo plazo.</p> <p></p>"},{"location":"cloud/01cloud.html#iaas","title":"IaaS","text":"<p>La infraestructura como servicio (Infrastructure as a Service) proporciona a las empresas recursos inform\u00e1ticos, incluyendo servidores, m\u00e1quinas virtuales, redes, almacenamiento y espacio en centros de datos con pago en funci\u00f3n del uso.</p> <p>Los elementos que forman parte de IaaS son:</p> <ul> <li>Servidores y almacenamiento.</li> <li>Firewall y seguridad en red.</li> <li>Planta f\u00edsica o edificio del centro de datos.</li> </ul> <p>Se contrata el hardware y el cliente es el responsable de la instalaci\u00f3n y mantenimiento del software que corre en dichas m\u00e1quinas, as\u00ed como configurar la red, el almacenamiento y el control de acceso. Configurar una m\u00e1quina virtual nueva es considerablemente m\u00e1s r\u00e1pido que adquirir, instalar y configurar un servidor f\u00edsico. Adem\u00e1s, permite escalar la infraestructura bajo demanda para dar soporte a las cargas de trabajo din\u00e1micas.</p>"},{"location":"cloud/01cloud.html#paas","title":"PaaS","text":"<p>La plataforma como servicio (Platform as a Service) proporciona un entorno basado en cloud con todos los requisitos necesarios para dar soporte a todo el ciclo de vida de creaci\u00f3n y puesta en marcha de aplicaciones basadas en web (cloud), sin el coste y la complejidad de comprar y gestionar el hardware, software, aprovisionamiento y alojamiento necesario.</p> <p>Los elementos que forman parte de PaaS son todos los de IaaS m\u00e1s:</p> <ul> <li>Sistema operativo</li> <li>Herramientas de desarrollo (lenguajes de programaci\u00f3n, librer\u00edas, servicios, ...), administraci\u00f3n de bases de datos, an\u00e1lisis empresarial, etc...</li> </ul> <p>Este enfoque acelera el desarrollo y la comercializaci\u00f3n de aplicaciones, ya que desplegar una nueva aplicaci\u00f3n es cuesti\u00f3n de minutos.</p> <p>El cliente no necesita administrar la infraestructura subyacente. El proveedor cloud gestiona el sistema operativo, la implementaci\u00f3n de parches a la base de datos, la configuraci\u00f3n del firewall y la recuperaci\u00f3n de desastres. De esta manera, el cliente puede centrarse en la administraci\u00f3n de c\u00f3digo o datos.</p>"},{"location":"cloud/01cloud.html#saas","title":"SaaS","text":"<p>Finalmente, las aplicaciones basadas en cloud, o software como servicio (Sofware as a Service), se ejecutan en sistemas en la nube que no tienen porque residir en la misma m\u00e1quina ni en la misma red. Estos servicios pertenecen y los administran otras empresas a las cuales el cliente se conecta a trav\u00e9s de Internet y, por lo general, de un navegador web.</p> <p>As\u00ed pues, podemos considerar SaaS como aplicaciones hospedadas y utilizables dentro de un PaaS.</p> <p></p> <p>Respecto al usuario, cuenta con una licencia seg\u00fan un modelo de suscripci\u00f3n o de pago por uso y no necesitan administrar la infraestructura que respalda el servicio. Por ello, SaaS permite iniciar sesi\u00f3n y empezar r\u00e1pidamente a utilizar las aplicaciones desde el minuto 0.</p> <p>Si el sistema fallase, no se pierden datos, ya que al estar en el cloud hay copias de seguridad continuas y al ser tolerante a fallos y el\u00e1stico, el servicio permite escalar din\u00e1micamente en funci\u00f3n de las necesidades de uso.</p> <p>Cada uno de estos tipos de servicios implican en mayor o menor medida al usuario, compartiendo la responsabilidad de cada \u00e1rea entre el proveedor cloud y el usuario. Este concepto se conoce como principio de responsabilidad compartida y lo estudiaremos en detalle en la pr\u00f3xima sesi\u00f3n.</p> <p></p> <p>\u00bfQu\u00e9 es la inform\u00e1tica sin servidor / Serverless computing?</p> <p>Igual que PaaS, la inform\u00e1tica sin servidor permite que los desarrolladores creen aplicaciones m\u00e1s r\u00e1pidamente, ya que elimina la necesidad de administrar la infraestructura. En las aplicaciones sin servidor, el proveedor de servicios en la nube aprovisiona, escala y administra autom\u00e1ticamente la infraestructura necesaria para ejecutar el c\u00f3digo. Las arquitecturas sin servidor son muy escalables y controladas por eventos, y solo usan recursos cuando se produce una funci\u00f3n o un desencadenador concretos.</p> <p>Es importante tener en cuenta que los servidores siguen ejecutando el c\u00f3digo. El t\u00e9rmino \"sin servidor\" procede del hecho de que las tareas asociadas a la administraci\u00f3n y el aprovisionamiento de la infraestructura son invisibles para el desarrollador. Este enfoque permite a los desarrolladores centrar su atenci\u00f3n en la l\u00f3gica de negocio y ofrecer m\u00e1s valor al n\u00facleo de la empresa.</p>"},{"location":"cloud/01cloud.html#tipos-de-arquitectura-segun-la-infraestructura","title":"Tipos de arquitectura seg\u00fan la infraestructura","text":""},{"location":"cloud/01cloud.html#arquitecturas-on-premise","title":"Arquitecturas on premise","text":"<p>Tambi\u00e9n conocido como in-house es la arquitectura cl\u00e1sica, en la que la empresa adquiere el hardware por adelantado. De esta manera, las empresas tienen el control total sobre los recursos y la seguridad, pero tambi\u00e9n la responsabilidad respecto al mantenimiento y actualizaci\u00f3n del hardware.</p>"},{"location":"cloud/01cloud.html#arquitecturas-cloud","title":"Arquitecturas cloud","text":"<p>Son aquellas donde los recursos se virtualizan y no son propiedad de la empresa, sino que se pueden aprovisionar y quitar bajo las necesidades de cada momento. S\u00f3lo se paga por lo que se consume.</p> <p>A su vez, podemos distinguirlas entre:</p> <ul> <li> <p>Nube p\u00fablica: los recursos virtualizados se comparten de forma p\u00fablica y entre varios clientes a la vez, permitiendo el acceso via internet.</p> <p>Los clouds p\u00fablicos pertenecen y son administrados por proveedores que ofrecen a trav\u00e9s de una red p\u00fablica acceso r\u00e1pido a recursos inform\u00e1ticos asequibles.</p> </li> <li> <p>Nube privada: los recursos virtualizados son privados, mediante un cluster dedicado para el cliente, normalmente mediante una conexi\u00f3n privada, ya sea de fibra propia o una VPN. Este tipo de nube lo utiliza \u00fanicamente una \u00fanica organizaci\u00f3n, ya sea gestionada internamente o por terceros y alojada internamente o externamente.</p> </li> </ul> <p>El planteamiento de todo en la nube suele utilizarse en proyectos nuevos o en la actualizaci\u00f3n de cero de los proyectos existentes. Abarca implementaciones que s\u00f3lo utilizan recursos de bajo nivel (redes, servidores, etc) o bien servicios de alto nivel (serverless, bases de datos administradas...).</p>"},{"location":"cloud/01cloud.html#arquitecturas-hibridas","title":"Arquitecturas h\u00edbridas","text":"<p>Brindan gran flexibilidad, ya que las empresas deciden donde se ejecutan sus aplicaciones, ya sea en su propia infraestructura in-house o con servicios cloud. De esta manera, controlan la seguridad y el cumplimiento de los requisitos legales de sus aplicaciones.</p> <p>Un cloud h\u00edbrido utiliza una base de cloud privado combinada con la integraci\u00f3n y el uso de servicios cloud p\u00fablicos.</p> <p>En realidad, un cloud privado no puede existir aislado del resto de los recursos TIC de una empresa ni del cloud p\u00fablico. La mayor\u00eda de las empresas con clouds privados evolucionan para gestionar cargas de trabajo en todos los centros de datos (privados y p\u00fablicos) creando as\u00ed clouds h\u00edbridos. Normalmente, las aplicaciones cr\u00edticas y los datos confidenciales se mantienen en el cloud privado, dejando el cloud p\u00fablico para las aplicaciones m\u00e1s recientes y la infraestructura IaaS para obtener recursos virtuales de forma flexible.</p> <p>El planteamiento h\u00edbrido es el m\u00e1s habitual (respecto a un cloud puro), donde los servicios se van migrando poco a poco (buscando primero ampliar o resolver carencias) coexistiendo con la infraestructura actual que est\u00e1 en la organizaci\u00f3n, normalmente conectada mediante VPN y enlaces dedicados.</p>"},{"location":"cloud/01cloud.html#plataformas-cloud","title":"Plataformas Cloud","text":"<p>En la actualidad existen multitud de proveedores que ofrecen servicios en la nube clasificados de acuerdo al modelo de servicio. A continuaci\u00f3n nombramos los m\u00e1s conocidos y m\u00e1s utilizados.</p> <p>Los proveedores cloud de nube p\u00fablica m\u00e1s importantes son:</p> <ul> <li>Amazon, con Amazon Web Services (https://aws.amazon.com/es/): Amazon fue el primer proveedor cloud, pionero y con mayor crecimiento. AWS proporciona una plataforma confiable en la nube que utilizan miles de empresa en todo el mundo.</li> <li>Microsoft, con Azure (https://azure.microsoft.com/es-es/): Ha realizado una fuerte inversi\u00f3n en los \u00faltimos a\u00f1os y es la plataforma cloud con mayor crecimiento. Ofrece servicios en las tres capas, no s\u00f3lo en IaaS, sino tambi\u00e9n PaaS y SaaS.</li> <li>Google, con Google Cloud (https://cloud.google.com): Google tambi\u00e9n es un proveedor de nube p\u00fablica mediante su plataforma Google Cloud Platform (GCP). Le cost\u00f3 entrar en este \u00e1rea, pero en los \u00faltimos a\u00f1os ha crecido mucho y actualmente es ampliamente utilizada por grandes compa\u00f1\u00edas.</li> </ul> <p>En el caso de nube privada, destacar a OpenStack (https://www.openstack.org). Se trata de un proyecto de software de infraestructura de computaci\u00f3n en la nube, es de c\u00f3digo abierto y es uno de los proyectos open source m\u00e1s activos del mundo.</p> <p>Si entramos a ejemplos concretos para cada tipo de servicio en la nube tenemos:</p> Tipo de Servicio Proveedor Descripci\u00f3n IaaS AWS EC2 M\u00e1quinas virtuales en Amazon, con procesador, memoria y almacenamiento a medida Azure VM Igual pero en Azure Google Compute Engine Igual pero en Google PaaS AWS RDS, AWS Lambda Base de datos, funciones serverless Google App Engine Alojamiento y despliegue web Heroku Plataforma que permite el despliegue de aplicaciones en la nube SaaS Microsoft Office 365 Paquete ofim\u00e1tico de Microsoft en la nube Aplicaciones web de Google Correo electr\u00f3nico, calendario, fotos Trello, Notion, GitHub, Dropbox, Spotify Tableros Kanban, gesti\u00f3n de tareas, repositorio de c\u00f3digo fuente... <p>Herramientas DevOps relacionadas</p> <p>Aunque se salen del \u00e1mbito del curso de IABD, es conveniente conocer algunas herramientas asociadas a perfiles DevOps como:</p> <ul> <li>Terraform (https://www.terraform.io/): Facilita la definici\u00f3n, aprovisionamiento y orquestaci\u00f3n de servicios mediante un lenguaje declarativo.</li> <li>Ansible (https://www.ansible.com/): Permite centralizar la configuraci\u00f3n de numerosos servidores, dispositivos de red y proveedores cloud de una forma sencilla y automatizada.</li> <li>Docker (https://www.docker.com/): Permite la creaci\u00f3n de contenedores a modo de m\u00e1quinas virtuales ligeras, donde se instalan los servicios/recursos necesarios.</li> <li>Kubernetes (K8s) (https://kubernetes.io/es/): Orquesta los contenedores para facilitar el despliegue, la supervisi\u00f3n de servicios, el reemplazo, el escalado autom\u00e1tico y la administraci\u00f3n de los servicios. Facilita la portabilidad de contenedores a la nube.</li> </ul> <p>En Octubre de 2020, el informe de Synergy Cloud Market Growth Rate Nudges Up as Amazon and Microsoft Solidify Leadership permite observar el predominio de Amazon seguido del crecimiento de la plataforma Azure:</p> Posici\u00f3n competitiva plataformas cloud - Synergy"},{"location":"cloud/01cloud.html#infraestructura-cloud","title":"Infraestructura cloud","text":"<p>Las diferentes plataformas cloud ofrecen una infraestructura dividida en regiones y zonas.</p>"},{"location":"cloud/01cloud.html#regiones-y-zonas-de-disponibilidad","title":"Regiones y Zonas de disponibilidad","text":"<p>A lo largo de todo el globo terr\u00e1queo se han construido enormes centros de datos que se conocen como regiones. Estas regiones son zonas geogr\u00e1ficas, y dentro de cada una de ellas hay diferentes grupo de centros de datos l\u00f3gicos que se conocen como zonas de disponibilidad (AZ - Availability Zone) situadas en ubicaciones aisladas. Normalmente cada regi\u00f3n contiene 3 o m\u00e1s zonas de disponibilidad.</p> <p>Cada zona de disponibilidad est\u00e1 aislada, pero las zonas de disponibilidad de una regi\u00f3n est\u00e1n conectadas mediante redes troncales privadas que proporciona un menor coste y una latencia de red entre regiones mejor que las conexiones p\u00fablicas de Internet. Una zona de disponibilidad se representa mediante un c\u00f3digo de regi\u00f3n seguido de un identificador de letra, por ejemplo, <code>us-east-1a</code>.</p> <p>AWS Academy</p> <p>Dentro de AWS Academy siempre vamos a trabajar dentro de la regi\u00f3n us-east-1, correspondiente al Norte de Virginia (es la regi\u00f3n asignada tambi\u00e9n a la capa gratuita, y adem\u00e1s, es la m\u00e1s econ\u00f3mica).</p> <p>Dicho de otro modo, cada regi\u00f3n consta de varias zonas de disponibilidad aisladas y separadas f\u00edsicamente dentro de un \u00e1rea geogr\u00e1fica. Cada zona de disponibilidad tiene alimentaci\u00f3n, refrigeraci\u00f3n y seguridad f\u00edsica independientes y est\u00e1 conectada a trav\u00e9s de redes redundantes de latencia ultrabaja.</p> <p>Por ejemplo, en AWS, dentro de la regi\u00f3n us-east-1 del Norte de Virginia, se encuentran 6 zonas de disponibilidad: us-east-1a, us-east-1b, us-east-1c, us-east-1d, us-east-1e, us-east-1f. En cambio, en us-east-2 s\u00f3lo tiene tres AZ: us-east-2a, us-east-2b y us-east-2c. Conviene destacar que no todos los servicios de AWS est\u00e1n disponibles en todas las regiones.</p> Ejemplo de infraestructura AWS <p>Si seguimos desgranando, cada zona de disponibilidad contiene al menos 3 centros de datos, y cada centro de datos suele albergar entre 50.000 y 100.000 servidores f\u00edsicos. Si hacemos c\u00e1lculos podemos ver que una regi\u00f3n puede incluir varios cientos de miles de servidores.</p> <p>La elecci\u00f3n de una regi\u00f3n se basa normalmente en los requisitos de conformidad o en la intenci\u00f3n de reducir la latencia. Cuanto m\u00e1s cerca est\u00e9 la regi\u00f3n de los clientes finales, m\u00e1s r\u00e1pido ser\u00e1 su acceso. En otras ocasiones elegiremos la regi\u00f3n que asegura las leyes y regulaciones que nuestras aplicaciones deben cumplir. Finalmente, en el caso de una nube h\u00edbrida, elegiremos la regi\u00f3n m\u00e1s cercana a nuestro centro de datos corporativo.</p> <p>Las zonas de disponibilidad permiten que los clientes trabajen con bases de datos y aplicaciones de producci\u00f3n con un nivel de disponibilidad, tolerancia a errores y escalabilidad mayor que el que ofrecer\u00eda un centro de datos \u00fanico.</p> <p>Tolerancia a fallos</p> <p>La soluci\u00f3n ideal es replicar los datos y la aplicaci\u00f3n en varias zonas de disponibilidad de una regi\u00f3n, y posteriormente, replicarlos a su vez entre diferentes regiones.</p> <p> Ejemplo de cluster con diferentes AZ </p> <p>Las AZ est\u00e1n f\u00edsicamente separadas entre s\u00ed por una distancia significativa de muchos kil\u00f3metros, aunque todas est\u00e1n dentro de un rango de 100 km de separaci\u00f3n.</p> <p>La replicaci\u00f3n de datos entre regiones y zonas de disponibilidad es responsabilidad del cliente, mediante el dise\u00f1o de una arquitectura con un cl\u00faster que reparta las peticiones a partir de un balanceador de carga entre, al menos, dos AZ distintas. As\u00ed, si cae una AZ, la otra dar\u00e1 respuesta a todas las peticiones.</p> <p>Un fallo en una AZ (normalmente en uno de los centros de datos que contiene) no afectar\u00e1 los servicios que est\u00e1n dise\u00f1ados para trabajar fuera de las AZ, como las diferentes opciones de almacenamiento ni de los servicios globales como DNS o CDN. Cabe destacar que si cae un centro de datos de una AZ no implica que caigan el resto de centros de datos de la misma AZ donde nuestras aplicaciones pueden estar replicadas. Adem\u00e1s, cada AZ est\u00e1 aislada del resto de AZ dentro de la misma regi\u00f3n.</p> <p>Cada AZ est\u00e1 dise\u00f1ada como una zona de error independiente:</p> <ul> <li>Est\u00e1n f\u00edsicamente separadas dentro de una regi\u00f3n metropolitana t\u00edpica.</li> <li>Se ubican en terrenos de menor riesgo de inundaci\u00f3n.</li> <li>Utilizan sistemas de alimentaci\u00f3n ininterrumpida discretos y generaci\u00f3n de copia de seguridad en las instalaciones</li> <li>La alimentaci\u00f3n se suministra desde distintas redes de empresas de servicios p\u00fablicos independientes.</li> <li>Est\u00e1n conectadas de forma redundante a varios ISP.</li> </ul>"},{"location":"cloud/01cloud.html#despliegue","title":"Despliegue","text":"<p>Por ejemplo, en el siguiente gr\u00e1fico podemos ver las 28 regiones que tiene AWS que incluyen 90 zonas de disponibilidad (en Noviembre de 2022 han a\u00f1adido a Espa\u00f1a como una nueva regi\u00f3n - <code>eu-south-2</code>):</p> Regiones 2021Regiones 2022 <p> Regiones AWS </p> <p> Regiones AWS </p> <p>Pod\u00e9is consultar el mapa interactivo de:</p> <ul> <li>AWS en https://aws.amazon.com/es/about-aws/global-infrastructure/ (y las regiones en https://aws.amazon.com/es/about-aws/global-infrastructure/regions_az/)</li> <li>Azure en https://infrastructuremap.microsoft.com/explore.</li> <li>Google Cloud en https://cloud.google.com/about/locations#regions</li> </ul> <p>La localizaci\u00f3n exacta de cada una de estas regiones y zonas de disponibilidad es difusa a prop\u00f3sito. A los proveedores, por temas de seguridad, no les interesa que se sepa donde se localizan los recursos.</p>"},{"location":"cloud/01cloud.html#ubicaciones-de-borde","title":"Ubicaciones de borde","text":"<p>Las ubicaciones de borde y las cach\u00e9s de borde regionales mejoran el rendimiento almacenando en cach\u00e9 el contenido lo m\u00e1s cerca de los usuarios para reducir la latencia al m\u00ednimo. A menudo, las ubicaciones de borde est\u00e1n cerca de las zonas de gran poblaci\u00f3n que generan vol\u00famenes de tr\u00e1fico elevados.</p> <p>As\u00ed pues, se trata de un CDN (Content Delivery Network) que se utiliza para distribuir el contenido (datos, v\u00eddeos, aplicaciones y API) a los usuarios finales. Por ejemplo, Amazon Cloudfront despliega m\u00e1s de 410 puntos de presencia (m\u00e1s de 400 ubicaciones de borde y 13 cach\u00e9s de nivel medio regional) a trav\u00e9s de 90 ciudades en 47 pa\u00edses.</p> Mapa de ubicaciones de borde de AWS <p>El acceso a estos CDN se realiza gracias al DNS interno que utiliza cada proveedor. En el caso de AWS se conoce como Amazon Route 53, de manera que resuelve los dominios m\u00e1s r\u00e1pido y redirige el tr\u00e1fico a los nodos Cloudfront.</p>"},{"location":"cloud/01cloud.html#referencias","title":"Referencias","text":"<ul> <li>Curso Academy Cloud Foundation de Amazon Web Services.</li> <li>Azure Fundamentals AZ-900 FAQ</li> <li>Google Cloud vs AWS en 2022</li> <li>Conceptos fundamentales de Azure</li> <li>AWS Certified Cloud Practitioner Training 2020 - Full Course</li> </ul>"},{"location":"cloud/01cloud.html#actividades","title":"Actividades","text":"<p>A lo largo de este bloque, vamos a trabajar con AWS como plataforma Cloud. Para ello, es necesario activar la cuenta educativa de AWS que habr\u00e1s recibido en tu email.</p> <ol> <li> <p>(RA5075.2 / CE5.2a / 1p) Contesta a las siguientes preguntas justificando tus repuestas:</p> <ol> <li>A nivel financiero, \u00bfqu\u00e9 ventajas supone apostar por un modelo cloud respecto a una soluci\u00f3n on-premise?</li> <li>De los modelos As a Service, \u00bfcu\u00e1l permite crear aplicaciones que est\u00e9n disponibles para cualquier persona en cualquier lugar?.</li> </ol> </li> <li> <p>(RA5075.2 / CE5.2a / 1p) Realiza el m\u00f3dulo 1 (Informaci\u00f3n general sobre los conceptos de la nube) del curso ACF de AWS.</p> </li> </ol>"},{"location":"cloud/02aws.html","title":"Amazon Web Services","text":"<p>Amazon Web Services ofrece un conjunto de servicios que funcionan a modo de piezas de un puzzle, de manera que uniendo unos con otros podemos dise\u00f1ar la arquitectura necesaria para nuestras aplicaciones.</p>"},{"location":"cloud/02aws.html#servicios","title":"Servicios","text":"<p>Los servicios de AWS se clasifican en categor\u00edas:</p> <p></p> <p>Servicios y regiones</p> <p>Los servicios y los productos de AWS se encuentran disponibles por regi\u00f3n, por lo que es posible que dependiendo de la regi\u00f3n a la que accedamos no veamos todos los servicios. Para obtener una lista de los servicios de AWS ofrecidos por regi\u00f3n, podemos consultar la Lista de servicios regionales.</p> <p>A continuaci\u00f3n vamos a comentar las categor\u00edas m\u00e1s importantes junto a algunos de sus servicios m\u00e1s destacados:</p>"},{"location":"cloud/02aws.html#almacenamiento","title":"Almacenamiento","text":"<p>Los servicios que ofrece AWS para gestionar el almacenamiento de datos son:</p> <ul> <li>Amazon Simple Storage Service (Amazon S3): servicio de almacenamiento de objetos que ofrece escalabilidad, disponibilidad de datos (ofrece una durabilidad del 99.999999999%), seguridad y rendimiento. Se utiliza para almacenar y proteger cualquier cantidad de datos para sitios web, aplicaciones m\u00f3viles, copias de seguridad y restauraci\u00f3n, archivado, aplicaciones empresariales, dispositivos de Internet de las cosas (IoT) y en nuestro caso, como Data Lake para anal\u00edtica de datos.</li> <li>Amazon Simple Storage Service Glacier (Amazon S3 Glacier): es un tipo de almacenamiento S3 seguro, duradero y de muy bajo coste para archivar datos y realizar copias de seguridad a largo plazo. Est\u00e1 dise\u00f1ado para ofrecer una durabilidad del 99,999999999% y proporcionar capacidades integrales de seguridad y conformidad que permiten cumplir requisitos normativos estrictos.</li> <li>Amazon Elastic Block Store (Amazon EBS): almacenamiento en bloques de alto rendimiento dise\u00f1ado para utilizarse con Amazon EC2 para cargas de trabajo que hacen un uso intensivo de transacciones y de rendimiento. Cada volumen EBS se replica autom\u00e1ticamente dentro de su AZ para prevenir fallos de hardware y ofrece alta disponibilidad y durabilidad. Se utiliza para una amplia gama de cargas de trabajo que requieren un rendimiento con baja latencia, como bases de datos relacionales y no relacionales, aplicaciones empresariales, aplicaciones en contenedores, motores de an\u00e1lisis de bigdata, sistemas de archivos y flujos de trabajo multimedia.</li> <li>Amazon Elastic File System (Amazon EFS): proporciona un sistema de ficheros NFS el\u00e1stico, escalable y completamente administrado para utilizarlo tanto con los servicios cloud de AWS como con los recursos on-premise. Dise\u00f1ado para escalar a petabytes bajo demanda, aumenta y reduce su tama\u00f1o autom\u00e1ticamente a medida que se agregan y eliminan archivos. Reduce la necesidad de aprovisionar y administrar capacidad para admitir el crecimiento.</li> </ul> Servicios de almacenamiento de AWS <p>Estos servicios los veremos en mayor profundidad en la sesi\u00f3n Almacenamiento en AWS.</p>"},{"location":"cloud/02aws.html#informatica-computacion","title":"Inform\u00e1tica / Computaci\u00f3n","text":"<p>Los servicios que ofrece AWS relativos a la inform\u00e1tica o computaci\u00f3n son:</p> <ul> <li>Amazon Elastic Compute Cloud (Amazon EC2): proporciona capacidad inform\u00e1tica de tama\u00f1o ajustable (de forma el\u00e1stica, tanto hacia arriba como hacia abajo) en forma de m\u00e1quinas virtuales en la nube en cuesti\u00f3n de minutos.<ul> <li>Amazon EC2 Auto Scaling: permite agregar o eliminar autom\u00e1ticamente instancias EC2 de acuerdo con las condiciones que defina.</li> </ul> </li> <li>Amazon Elastic Beanstalk: servicio para desplegar y escalar aplicaciones y/o servicios web desarrolladas en Java / PHP / Python en servidores web conocidos, como Apache, Nginx, Passenger o IIS.</li> <li>AWS Lambda: permite ejecutar c\u00f3digo sin necesidad de aprovisionar ni administrador servidores (serverless). Se sube el c\u00f3digo fuente a ejecutar, y AWS se encarga de ejecutarlo y escalarlo conforme necesite. S\u00f3lo se paga por el tiempo de computaci\u00f3n (cuando el c\u00f3digo no se ejecuta, no se paga nada).</li> </ul> <p>Estos servicios los veremos en mayor profundidad en la sesi\u00f3n Computaci\u00f3n en AWS.</p> <p>Los servicios que est\u00e1n relacionado con el uso de contenedores son:</p> <ul> <li>Amazon Elastic Container Service (Amazon ECS): servicio de organizaci\u00f3n de contenedores altamente escalable y de gran rendimiento (permite lanzar miles de contenedores en segundos), compatible con los contenedores Docker. Mantiene y escala la flota de nodos que ejecutan los contenedores eliminando la complejidad de poner en marcha la infraestructura.<ul> <li>Amazon Fargate: motor para ECS que permite ejecutar contenedores sin tener que administrar servidores ni cl\u00fasteres.</li> </ul> </li> <li>Amazon EC2 Container Registry (Amazon ECR): registro de contenedores Docker completamente administrado que facilita las tareas de almacenamiento, administraci\u00f3n e implementaci\u00f3n de im\u00e1genes de contenedores Docker.</li> <li>Amazon Elastic Kubernetes Service (Amazon EKS): facilita la implementaci\u00f3n, administraci\u00f3n y el escalado de aplicaciones en contenedores que utilizan Kubernetes dentro de AWS.</li> </ul>"},{"location":"cloud/02aws.html#bases-de-datos","title":"Bases de Datos","text":"<p>Los servicios que ofrece AWS para gestionar los datos son:</p> <ul> <li>Amazon Relational Database Service (Amazon RDS): facilita las tareas de configuraci\u00f3n, operaci\u00f3n y escalado de una base de datos relacional en la nube. El servicio ofrece capacidad de tama\u00f1o ajustable al mismo tiempo que automatiza tareas administrativas que demandan mucho tiempo, como el aprovisionamiento de hardware, la configuraci\u00f3n de bases de datos, la implementaci\u00f3n de parches y la creaci\u00f3n de copias de seguridad</li> <li>Amazon Aurora: es una base de datos relacional compatible con MySQL/MariaDB y PostgreSQL. Amazon vende que es hasta cinco veces m\u00e1s r\u00e1pida que las bases de datos MySQL est\u00e1ndar y tres veces m\u00e1s r\u00e1pida que las bases de datos PostgreSQL est\u00e1ndar.</li> <li>Amazon DynamoDB: es una base de datos de documentos y clave-valor que ofrece un rendimiento de milisegundos de un solo d\u00edgito a cualquier escala, con seguridad integrada, copias de seguridad y restauraci\u00f3n, y almacenamiento en cach\u00e9 en memoria.</li> <li>Amazon Redshift: es un servicio de datawarehouse que permite ejecutar consultas anal\u00edticas de petabytes de datos almacenados localmente en Amazon Redshift, adem\u00e1s de ejecutar consultas anal\u00edticas de exabytes de datos almacenados en Amazon S3 de forma directa. Ofrece un rendimiento r\u00e1pido a cualquier escala.</li> </ul> Servicios de datos de AWS <p>Estos servicios los veremos en mayor profundidad en la sesi\u00f3n Datos en AWS.</p>"},{"location":"cloud/02aws.html#redes","title":"Redes","text":"<p>Los servicios que ofrece AWS para gestionar las redes son:</p> <ul> <li>Amazon Virtual Private Cloud (Amazon VPC): permite aprovisionar secciones aisladas de forma l\u00f3gica de la nube de AWS.</li> <li>Elastic Load Balancing: distribuye autom\u00e1ticamente el tr\u00e1fico entrante de las aplicaciones en varios destinos, tales como instancias de Amazon EC2, contenedores, direcciones IP y funciones Lambda.</li> <li>Amazon CloudFront: servicio r\u00e1pido de red de entrega de contenido (CDN) que suministra datos, videos, aplicaciones  y APIs de manera segura a clientes de todo el mundo, con baja latencia y altas velocidades de transferencia.</li> <li>AWS Transit Gateway: servicio que permite a los clientes conectar sus nubes privadas virtuales de Amazon (VPC) y sus redes en las instalaciones (on-premise) a un \u00fanico gateway.</li> <li>Amazon Route 53: servicio web de DNS escalable y en la nube dise\u00f1ado para direccionar a los usuarios finales a las aplicaciones de Internet de una forma confiable.</li> <li>AWS Global Accelerator: utiliza las ubicaciones de borde para encontrar la ruta \u00f3ptima a la regi\u00f3n donde reside nuestra aplicaci\u00f3n (haciendo uso tanto de protocolos HTTP como TCP/UDP).</li> <li>AWS Direct Connect: ofrece una manera de establecer una conexi\u00f3n de red privada dedicada desde un centro de datos u oficina a AWS, lo que puede reducir los costes de red y aumentar el rendimiento del ancho de banda.</li> <li>AWS VPN: proporciona un t\u00fanel privado seguro desde una red o dispositivo a la red global de AWS.</li> </ul>"},{"location":"cloud/02aws.html#seguridad-en-aws","title":"Seguridad en AWS","text":"<p>Los servicios que ofrece AWS para gestionar la seguridad, identidad y conformidad son:</p> <ul> <li>AWS Identity and Access Management (IAM): le permite administrar el acceso a los recursos y servicios de AWS de manera segura. Con IAM, puede crear y administrar usuarios y grupos de AWS. Puede utilizar los permisos de IAM para permitir y denegar el acceso de usuarios y grupos a los recursos de AWS.</li> <li>AWS Organizations: permite restringir los servicios y acciones autorizadas en sus cuentas.</li> <li>Amazon Cognito facilita incorporar control de acceso, inscripci\u00f3n e inicio de sesi\u00f3n de usuarios a sus aplicaciones web y m\u00f3viles.</li> <li>AWS Artifact proporciona acceso bajo demanda a los informes de seguridad y conformidad de AWS y a los acuerdos en l\u00ednea.</li> <li>AWS Key Management Service (AWS KMS): permite crear y administrar claves de acceso. Puede utilizar AWS KMS para controlar el uso del cifrado en una amplia gama de servicios de AWS y en sus aplicaciones.</li> <li>AWS Shield: es un servicio administrado de protecci\u00f3n contra ataques de denegaci\u00f3n de servicio distribuidos (DDoS) que protege las aplicaciones que se ejecutan en AWS.</li> </ul>"},{"location":"cloud/02aws.html#servicios-de-administracion-de-costes","title":"Servicios de administraci\u00f3n de costes","text":"<p>Los servicios que ofrece AWS para administrar los costes son:</p> <ul> <li>Informe de uso y coste de AWS contiene el conjunto m\u00e1s completo de datos de uso y gasto de AWS disponibles e incluye metadatos adicionales sobre los servicios, los precios y las reservas de AWS.</li> <li>Presupuestos de AWS facilita la definici\u00f3n de presupuestos personalizados que generar\u00e1n una alerta cuando los costes o el uso superen, o se prev\u00e9 que superen, el importe presupuestado.</li> <li>AWS Cost Explorer cuenta con una interfaz sencilla que permite visualizar, comprender y administrar los costes y el uso de AWS a lo largo del tiempo.</li> </ul>"},{"location":"cloud/02aws.html#administracion-y-gobernanza-de-datos","title":"Administraci\u00f3n y gobernanza de datos","text":"<p>La consola de administraci\u00f3n de AWS proporciona una interfaz de usuario basada en la web que permite obtener acceso a su cuenta de AWS.</p> <p>Los servicios que ofrece AWS para administrar y gobernar los datos son:</p> <ul> <li>AWS Config: proporciona un servicio que facilita realizar un seguimiento del inventario de recursos y sus cambios.</li> <li>AWS CloudTrail: realiza un seguimiento de la actividad de los usuarios y del uso de la API. Esto significa que cada vez que alguien carga datos, ejecuta c\u00f3digo, crea una instancia EC2, cambia un tipo de unidad S3 o cualquier otra acci\u00f3n que se pueda realizar en AWS, CloudTrail lo registrar\u00e1. Esto resulta muy \u00fatil por razones de seguridad para que los administradores puedan saber qui\u00e9n est\u00e1 utilizando su cuenta y qu\u00e9 est\u00e1n haciendo. Si algo sale mal o si surge un problema de seguridad, CloudTrail ser\u00e1 la mejor prueba para averiguar lo ocurrido.</li> <li>Amazon CloudWatch: permite monitorizar recursos y aplicaciones. Si CloudTrail monitoriza personas, CloudWatch monitoriza servicios. CloudWatch es perfecto para asegurar de que los servicios de la nube funcionan sin problemas y no utilizan m\u00e1s o menos recursos de los esperados, lo que es importante para el seguimiento del presupuesto. CloudWatch es excelente para asegurarse de que todos los recursos est\u00e1n funcionando, lo que puede resultar complicado si una gran empresa utiliza cientos de m\u00e1quinas y unidades diferentes. Para ello, se pueden pueden configurar alertas para que se lancen cuando una m\u00e9trica alcanza un l\u00edmite espec\u00edfico.</li> <li>AWS Auto Scaling: ofrece caracter\u00edsticas que permiten escalar varios recursos para satisfacer la demanda.</li> <li>Interfaz de l\u00ednea de comandos de AWS (AWS CLI) proporciona una herramienta unificada para administrar los servicios de AWS.</li> <li>AWS TrustedAdvisor: proporciona consejos para optimizar el rendimiento y la seguridad.</li> <li>AWS Well-Architected Tool: ayuda a revisar y mejorar las cargas de trabajo.</li> </ul> <p>Por ejemplo, haciendo usos de esos servicios se puede mostrar una soluci\u00f3n sencilla:</p> <p></p>"},{"location":"cloud/02aws.html#redes-en-aws","title":"Redes en AWS","text":"<p>Suponemos que los conceptos de red, subred y direcci\u00f3n IP y el modelo de la OSI est\u00e1n claros.</p> <p>Dentro de AWS se utiliza el m\u00e9todo CIDR para describir redes, por ejemplo, <code>192.0.2.0/24</code> (los primeros 24 bits son est\u00e1ticos, y los \u00faltimos 8 flexibles). Cabe destacar que AWS reserva las primeras cuatro direcciones IP y la \u00faltima direcci\u00f3n IP de cada subred para fines de redes internas. Por ejemplo, una subred / 28 tendr\u00eda 16 direcciones IP disponibles. De ah\u00ed hay que restar las 5 IP reservadas por AWS para obtener 11 direcciones IP para nuestro uso dentro de la subred.</p> <p>Muchos de los conceptos de redes f\u00edsicas son v\u00e1lidos para las redes cloud, con la ventaja que en la nube nos ahorraremos gran parte de la complejidad.</p>"},{"location":"cloud/02aws.html#amazon-vpc","title":"Amazon VPC","text":"<p>AWS utiliza las VPC (Amazon Virtual Private Cloud) como redes privadas virtuales donde est\u00e1n conectados todos los recursos con los que trabajamos, de manera que el acceso queda aislado de otros usuarios. Dicho de otro modo, Amazon VPC permite lanzar recursos de AWS en la red virtual que definamos. Esta red virtual se asemeja en gran medida a una red tradicional que ejecutar\u00edamos en nuestro propio centro de datos, con los beneficios de utilizar la infraestructura escalable de AWS, pudiendo crear una VPC que abarque varias AZ.</p> <p>Al definir la red virtual podemos seleccionar nuestro propio intervalo de direcciones IP, crear subredes y configurar las tablas de enrutamiento y gateways de red. Tambi\u00e9n podemos colocar el backend (servidores de aplicaciones o de bases de datos) en una subred privada sin acceso a Internet p\u00fablico. Finalmente, podemos a\u00f1adir varias capas de seguridad, como grupos de seguridad y listas de control de acceso a la red (ACL de red), para ayudar a controlar el acceso a las instancias de EC2 en cada subred.</p> <p>Sin entrar en mayor detalle, ya que se sale del \u00e1mbito del curso, vamos a repasar algunos de los componentes m\u00e1s importantes:</p> <ul> <li> <p>Un gateway de Internet (IGW) es un componente de la VPC que permite la comunicaci\u00f3n entre instancias de la VPC e Internet. Un caso espec\u00edfico es un Gateway NAT, que se utiliza para proporcionar conectividad a Internet a instancias EC2 en las subredes privadas.</p> </li> <li> <p>Despu\u00e9s de crear una VPC, podemos agregar subredes. Cada subred est\u00e1 ubicada por completo dentro de una zona de disponibilidad y no puede abarcar otras zonas. Si el tr\u00e1fico de una subred se direcciona a una gateway de Internet, la subred recibe el nombre de subred p\u00fablica. Si una subred no dispone de una ruta a la gateway de Internet, recibe el nombre de subred privada. Para que las subredes privadas puedan conectarse a Internet dirigiendo el tr\u00e1fico al gateway NAT hemos de configurar las tablas enrutamiento.</p> </li> <li> <p>Una tabla de enrutamiento contiene un conjunto de reglas llamadas rutas que se utilizan para determinar el destino del tr\u00e1fico de red. Cada subred de una VPC debe estar asociada a una tabla de enrutamiento, que es la que controla el direccionamiento de la subred. Las reglas de las tablas de enrutamiento se colocan de m\u00e1s a menos restrictivas. Tienen una ruta local integrada, la cual no se puede eliminar.\u200b Las rutas adicionales se agregan a la tabla.\u200b</p> </li> <li> <p>Aunque lo veremos en el siguiente apartado, las VPC utilizan un grupo de seguridad, que act\u00faa como un firewall virtual. Cuando se lanza una instancia, se asocia uno o varios grupos de seguridad a ella. Los grupos de seguridad tienen reglas que controlan el tr\u00e1fico de entrada y de salida de las instancias, las cuales podemos modificar. \u200bLos grupos de seguridad predeterminados deniegan todo el tr\u00e1fico de entrada y permiten todo el tr\u00e1fico de salida.\u200b</p> </li> </ul>"},{"location":"cloud/02aws.html#vpc-wizard","title":"VPC Wizard","text":"<p>Cada vez que vayamos a crear un recurso en AWS nos va a preguntar en qu\u00e9 VPC queremos desplegar la soluci\u00f3n. Siempre hay una VPC predeterminada. Muchas de las configuraciones se pueden realizar mediante el asistente de VPC Wizard, el cual facilita la creaci\u00f3n de arquitecturas de red v\u00e1lidas para soluciones cloud e h\u00edbridas.</p> VPC Wizard: Paso 1 <p>Como podemos ver en el imagen, el asistente nos ofrece 4 modelos de redes:</p> <ol> <li>VPC con un \u00fanica subred p\u00fablica</li> <li>VPC con subredes p\u00fablicas y privadas</li> <li>VPC con subredes p\u00fablicas y privadas y acceso VPN a hardware on-premise</li> <li>VPC con un \u00fanica subred privada solo accesible via VPN con hardware on-premise.</li> </ol> <p>Si elegimos el primero, podemos ver que la informaci\u00f3n a completar se reduce al bloque de direcciones (se suele dejar el bloque por defecto) y un nombre para la VPC.</p> VPC Wizard: Paso 2 <p>Una vez creada ya podemos modificar la configuraci\u00f3n DHCP, la tabla de enrutamiento o los permisos via ACL, crear subredes sobre la propia VPC, etc...</p> <p>Redes y subredes</p> <p>Mientras que las VPC pertenecen a una \u00fanica regi\u00f3n de AWS y pueden abarcar varias zonas de disponibilidad, las subredes pertenecen a una \u00fanica zona de disponibilidad.</p>"},{"location":"cloud/02aws.html#ip-elastica","title":"IP El\u00e1stica","text":"<p>Una IP el\u00e1stica es una direcci\u00f3n IP p\u00fablica que AWS reserva para que la podamos asignar a una instancia para poder acceder a ella a trav\u00e9s de internet de forma fija. Normalmente salvo que decidamos hacer una estructura de red m\u00e1s compleja, mediante un VPC personalizado, en realidad AWS da una IP al azar a nuestras instancias al arrancarlas. La diferencia es que si le asignamos una IP el\u00e1stica ya quedar\u00e1 fija entre reinicios, especialmente \u00fatil si nuestra m\u00e1quina aloja un dominio. Tambi\u00e9n es muy \u00fatil para poder reasignar instancias y otros recursos en caso de fallo, de manera que podamos desconectar la ip el\u00e1stica de la instancia y asociarla a otra para redirigir el tr\u00e1fico de red\u200b.</p> IP El\u00e1sticas <p>Para evitar el acaparamiento de direcciones IP, AWS cobra 0,005\u20ac por cada hora y direcci\u00f3n IP el\u00e1stica que tengamos reservada sin asignar a ninguna instancia. Sin embargo, su uso es gratuito si la tenemos asignadas a una instancia o recurso en ejecuci\u00f3n.</p> <p>De manera predeterminada, todas las cuentas de AWS est\u00e1n limitadas a cinco IP el\u00e1sticas por regi\u00f3n, aunque se puede solicitar un aumento del l\u00edmite.</p> <p>M\u00e1s informaci\u00f3n en https://docs.aws.amazon.com/es_es/AWSEC2/latest/UserGuide/elastic-ip-addresses-eip.html</p>"},{"location":"cloud/02aws.html#seguridad-en-la-nube","title":"Seguridad en la Nube","text":"<p>La capacidad de proteger la integridad y la confidencialidad de los datos es esencial. Un agujero de seguridad puede tirar a la basura todo nuestro trabajo y hacer perder a la empresa el prestigio y much\u00edsimo dinero.</p>"},{"location":"cloud/02aws.html#modelo-de-responsabilidad-compartida-de-aws","title":"Modelo de responsabilidad compartida de AWS","text":"<p>La seguridad es una caracter\u00edstica que tiene una responsabilidad compartida entre AWS y el cliente. Este modelo de responsabilidad compartida est\u00e1 dise\u00f1ado para minimizar la carga operativa del cliente, pero a\u00fan as\u00ed sigue siendo responsable de algunos aspectos de la seguridad general.</p> <p></p>"},{"location":"cloud/02aws.html#responsabilidad-de-aws","title":"Responsabilidad de AWS","text":"<p>AWS es responsable de proteger la infraestructura en la que se ejecutan todos los servicios ofrecidos por la nube de AWS (en algunas preguntas de la certificaci\u00f3n se refieren a ellos por servicios de la nube):</p> <ul> <li>Seguridad f\u00edsica de los centros de datos con acceso controlado basado en las necesidades en instalaciones sin identificaci\u00f3n, con guardias de seguridad permanentes, autenticaci\u00f3n de dos factores, revisi\u00f3n y registro de accesos, videovigilancia, y destrucci\u00f3n y desmagnetizaci\u00f3n de discos.</li> <li>Infraestructura de hardware, como servidores, dispositivos de almacenamiento y otros dispositivos de los que dependen los servicios de AWS.</li> <li>Infraestructura de software, que aloja sistemas operativos, aplicaciones de servicios y software de virtualizaci\u00f3n.</li> <li>Infraestructura de red, como routers, conmutadores, balanceadores de carga, firewalls y cableado. AWS tambi\u00e9n monitoriza la red en l\u00edmites externos, protege los puntos de acceso y proporciona infraestructura redundante con detecci\u00f3n de intrusiones de forma constante</li> </ul>"},{"location":"cloud/02aws.html#responsabilidad-del-cliente","title":"Responsabilidad del cliente","text":"<p>El cliente es responsable del cifrado de los datos en reposo y los datos en tr\u00e1nsito, de todo lo que se pone en la nube. Los pasos de seguridad que debe tomar depender\u00e1n de los servicios que utilice y de la complejidad del sistema.</p> <p>Si entramos en m\u00e1s detalle, es responsable de:</p> <ul> <li>El sistema operativo de la instancia de Amazon EC2: incluidas las actualizaciones, los parches de seguridad y su mantenimiento.</li> <li>La protecci\u00f3n de las aplicaciones que se lanzan en los recursos AWS: contrase\u00f1as, acceso basado en roles, etc.</li> <li>Configuraci\u00f3n del grupo de seguridad.</li> <li>SO o firewalls basados en host: incluidos los sistemas de detecci\u00f3n o prevenci\u00f3n de intrusiones.</li> <li>Configuraciones de red.</li> <li>Administraci\u00f3n de cuentas: Configuraci\u00f3n de inicio de sesi\u00f3n y credenciales para cada usuario.</li> </ul> <p>Respecto al contenido cr\u00edtico, el cliente es responsable de administrar:</p> <ul> <li>El contenido que elige almacenar en AWS.</li> <li>Los servicios de AWS que se utilizan con el contenido.</li> <li>En qu\u00e9 pa\u00eds se almacena ese contenido.</li> <li>El formato y la estructura de ese contenido y si est\u00e1 enmascarado, cifrado o es an\u00f3nimo.</li> <li>Qui\u00e9n tiene acceso a ese contenido y c\u00f3mo se conceden, administran y revocan esos derechos de acceso.</li> </ul>"},{"location":"cloud/02aws.html#aws-iam","title":"AWS IAM","text":"<p>AWS Identity and Access Management (IAM) permite administrar el acceso a los recursos de AWS (de inform\u00e1tica, almacenamiento, base de datos, ...).</p> <p>Una sola cuenta de AWS puede tener servicios administrados por decenas de personas diferentes que pueden estar en distintos departamentos u oficinas, tener diferentes responsabilidades o niveles de antig\u00fcedad, e incluso estar en distintos pa\u00edses. Para mantener un entorno seguro en la nube con todas estas variables en cuesti\u00f3n, es esencial seguir las pr\u00e1cticas recomendadas de IAM.</p> <p>IAM se puede utilizar para gestionar la autenticaci\u00f3n y para especificar y aplicar pol\u00edticas de autorizaci\u00f3n para especificar qu\u00e9 usuarios pueden obtener acceso a cada servicio. Es decir, permite definir qui\u00e9n, a qu\u00e9 y c\u00f3mo se accede a los recursos AWS.</p> <p>Los principales componentes son:</p> <ul> <li>Usuario: persona o aplicaci\u00f3n que se puede autenticar en AWS. Cada usuario debe tener un nombre \u00fanico (sin espacios en el nombre) dentro de la cuenta de AWS y un conjunto de credenciales de seguridad que no se comparte con otros usuarios. Estas credenciales son diferentes de las credenciales de seguridad de usuario ra\u00edz de la cuenta de AWS. Cada usuario est\u00e1 definido en una \u00fanica cuenta de AWS.</li> <li>Grupo: conjunto de usuarios de IAM, a los que se les concede una autorizaci\u00f3n id\u00e9ntica. As\u00ed pues, permite asociar las mismas pol\u00edticas a varios usuarios de una manera sencilla. Hay que tener en cuenta que:<ul> <li>Un grupo puede contener muchos usuarios y un usuario puede pertenecer a varios grupos.</li> <li>Un grupo solo puede contener usuarios y, a su vez, un grupo no puede contener otros grupos.</li> <li>No hay ning\u00fan grupo predeterminado que incluya autom\u00e1ticamente a todos los usuarios de la cuenta de AWS.</li> </ul> </li> <li>Pol\u00edtica de IAM: documento que define permisos para determinar lo que los usuarios pueden hacer en la cuenta de AWS. Una pol\u00edtica normalmente concede acceso a recursos determinados y especifica lo que el usuario puede hacer con esos recursos, aunque tambi\u00e9n pueden denegar expl\u00edcitamente el acceso.</li> <li>Rol: herramienta para conceder acceso temporal a recursos de AWS espec\u00edficos de una cuenta de AWS. Un rol de IAM puede tener asociadas pol\u00edticas de permisos y se puede utilizar para delegar acceso temporal a usuarios o aplicaciones. Dicho de otro modo, un rol de IAM es similar a un usuario, ya que es una identidad de AWS con pol\u00edticas de permisos que establecen qu\u00e9 puede hacer o no la identidad en AWS. Sin embargo, en lugar de estar asociada \u00fanicamente a una persona, el objetivo es que pueda asignarse un rol a cualquier persona que lo necesite. Tambi\u00e9n es conveniente destacar que cuando se asume un rol, se proporcionan credenciales de seguridad temporales para la sesi\u00f3n de rol, de manera que es conveniente utilizar roles para delegar el acceso a usuarios, aplicaciones o servicios que normalmente no tendr\u00edan acceso a los recursos de AWS. Veremos el uso de roles en la configuraci\u00f3n de la creaci\u00f3n de instancias EC2.</li> </ul> <p>Consejo</p> <p>Es recomendable crear una cuenta de usuario IAM por separado con privilegios administrativos en lugar de utilizar el usuario de la cuenta ra\u00edz.</p>"},{"location":"cloud/02aws.html#autenticacion","title":"Autenticaci\u00f3n","text":"<p>Cuando se define un usuario de IAM se indica qu\u00e9 tipo de acceso puede utilizar el usuario para obtener acceso a los recursos de AWS:</p> <ul> <li>acceso mediante programaci\u00f3n: mediante email y clave de acceso secreta cuando realice una llamada a la API de AWS mediante la CLI de AWS, el SDK de AWS o cualquier otra herramienta de desarrollo.</li> <li>acceso a la consola de administraci\u00f3n de AWS: mediante usuario / contrase\u00f1a m\u00e1s el ID/alias de cuenta. Es recomendable activar MFA (Multi-Factor Authentication) para a\u00f1adir una capa m\u00e1s de seguridad.</li> <li>acceso mediante ambos tipos</li> </ul>"},{"location":"cloud/02aws.html#autorizacion","title":"Autorizaci\u00f3n","text":"<p>Una vez que el usuario se ha autenticado, se ha de determinar qu\u00e9 permisos debe concederse a un usuario, servicio o aplicaci\u00f3n.</p> <p>De forma predeterminada, los usuarios de IAM no tienen permiso para obtener acceso a los recursos o los datos en una cuenta de AWS. En su lugar, debe conceder permisos de forma expl\u00edcita a un usuario, grupo o rol mediante la creaci\u00f3n de una pol\u00edtica de IAM, ya que por defecto, se denegar\u00e1n todas las acciones que no se hayan permitido expl\u00edcitamente.</p> <p>Consejo</p> <p>Seguir el principio de m\u00ednimo privilegio: conceder \u00fanicamente los privilegios de usuario m\u00ednimos que necesita el usuario.</p> <p>El alcance de las configuraciones del servicio de IAM es global, se aplican en todas las regiones de AWS.</p>"},{"location":"cloud/02aws.html#politicas-iam","title":"Pol\u00edticas IAM","text":"<p>Una pol\u00edtica de IAM es una instrucci\u00f3n formal mediante un documento JSON con los permisos que se conceder\u00e1 a una entidad. Las entidades incluyen usuarios, grupos, roles o recursos.</p> <p>Las pol\u00edticas especifican cu\u00e1les son las acciones permitidas, cu\u00e1les son los recursos a los que estas tienen permiso y cu\u00e1l ser\u00e1 el efecto cuando el usuario solicite acceso a los recursos.</p> <p>Info</p> <p>Una sola pol\u00edtica se puede asociar a varias entidades. Una sola entidad puede tener varias pol\u00edticas asociadas a ella.</p> <p>Hay dos tipos de pol\u00edticas de IAM:</p> <ul> <li> <p>pol\u00edticas basadas en identidad: controlan qu\u00e9 acciones puede realizar dicha identidad, en qu\u00e9 recursos y en qu\u00e9 condiciones. A su vez se dividen en administradas (asociada a varios usuarios/grupos/roles) o insertadas (un \u00fanico usuario/grupo/rol).</p> </li> <li> <p>pol\u00edticas basadas en recursos: son documentos de pol\u00edtica JSON que se asocian a un recurso (por ejemplo, un bucket de S3). Estas pol\u00edticas controlan qu\u00e9 acciones puede realizar una entidad principal especificada en dicho recurso y en qu\u00e9 condiciones. Destacar que no todos los servicios de AWS soportan este tipo de pol\u00edticas.</p> </li> </ul>"},{"location":"cloud/02aws.html#politicas-y-permisos","title":"Pol\u00edticas y permisos","text":"<p>El usuario solo podr\u00e1 realizar la acci\u00f3n si la acci\u00f3n solicitada no est\u00e1 denegada de forma expl\u00edcita y adem\u00e1s est\u00e1 permitida de forma expl\u00edcita.</p> <p>Cuando IAM determina si se concede un permiso, primero comprueba la existencia de cualquier pol\u00edtica de denegaci\u00f3n expl\u00edcita aplicable. Si no existe ninguna denegaci\u00f3n expl\u00edcita, comprueba si existe alguna pol\u00edtica de permisos expl\u00edcitos aplicable. Si no existe una pol\u00edtica de denegaci\u00f3n expl\u00edcita ni de permiso expl\u00edcito, IAM vuelve a la forma predeterminada, que consiste en denegar el acceso. Este proceso se denomina denegaci\u00f3n impl\u00edcita.</p> Permisos IAM <p>Otros servicios relacionados con la seguridad</p> <ul> <li>AWS Organizations: Permite configurar los permisos de una organizaci\u00f3n que contiene varias cuentas de usuario en unidades organizativas (UO), y unificar tanto la seguridad como la facturaci\u00f3n</li> <li>AWS Key Management Service (AWS KMS): servicio que permite crear y administrar claves de cifrado</li> <li>Amazon Cognito: permite controlar el acceso a recursos de AWS desde aplicaciones con una credencial \u00fanica mediante SAML.</li> <li>AWS Shield: servicio administrado de protecci\u00f3n contra ataques de denegaci\u00f3n de servicio distribuidos (DDoS) que protege las aplicaciones ejecutadas en AWS.</li> </ul>"},{"location":"cloud/02aws.html#practicas-recomendadas","title":"Pr\u00e1cticas recomendadas","text":"<ol> <li>Proteger las claves de acceso de usuario ra\u00edz de la cuenta de AWS.</li> <li>Crear usuarios individuales de IAM.</li> <li>Utilizar grupos de usuarios para asignar permisos a los usuarios de IAM.</li> <li>Conceder menos privilegios.</li> <li>Comenzar a utilizar los permisos con las pol\u00edticas administradas de AWS.</li> <li>Validar las pol\u00edticas que hayamos creado.</li> <li>Utilizar pol\u00edticas administradas (se pueden asignar a varias identidades) por el cliente en lugar de pol\u00edticas en integradas (s\u00f3lo existen en una identidad de IAM).</li> <li>Utilizar los niveles de acceso para revisar los permisos de IAM.</li> <li>Configurar una pol\u00edtica de contrase\u00f1as seguras para los usuarios.</li> <li>Habilitar la autenticaci\u00f3n multifactor (MFA).</li> <li>Utilizar roles para aplicaciones que se ejecutan en instancias de Amazon EC2.</li> <li>Utilizar roles para delegar permisos.</li> <li>No compartir claves de acceso.</li> <li>Cambiar las credenciales regularmente.</li> <li>Eliminar credenciales innecesarias.</li> <li>Utilizar las condiciones de la pol\u00edtica para obtener mayor seguridad.</li> <li>Supervisar la actividad de nuestra cuenta de AWS.</li> </ol>"},{"location":"cloud/02aws.html#aws-cli","title":"AWS CLI","text":"<p>AWS permite el acceso mediante la consola para administrar todos los servicios.</p> <p>Primero hemos de instalar la herramienta AWS CLI que facilita la administraci\u00f3n de los productos de AWS desde un terminal.</p> <p>Antes de continuar, comprueba que no tengas una versi\u00f3n antigua instalada:</p> <pre><code>aws --version\n</code></pre> <p>Nos centraremos en su versi\u00f3n 2, la cual es la m\u00e1s reciente.</p> <p>Versi\u00f3n 2</p> <p>Si tienes instalada la versi\u00f3n 1, es recomendable desinstalarla e instalar la versi\u00f3n 2.</p> <p>Para su instalaci\u00f3n, dependiendo del sistema operativo que utilicemos, tenemos diferentes instaladores en https://docs.aws.amazon.com/es_es/cli/latest/userguide/getting-started-install.html</p> <p>El siguiente paso ser\u00e1 validarse en AWS. Para ello, desde nuestra consola del curso Leaner Labs , tras arrancar el laboratorio, pulsaremos (1) en la opci\u00f3n AWS Details, y posteriormente veremos los datos de acceso temporales al pulsar (2) en Show de la opci\u00f3n AWS CLI:</p> Credenciales de AWS <p></p> <p>Esos datos los podemos pegar en el archivo <code>~/.aws/credentials</code> o exportarlos como variables de entorno (es importante poner el nombre de las claves en may\u00fasculas):</p> <pre><code>export AWS_ACCESS_KEY_ID=ASDFEJEMPLO\nexport AWS_SECRET_ACCESS_KEY=asdfClaveEjemplo\nexport AWS_SESSION_TOKEN=asdfr...&lt;resto del token de seguridad&gt;\n</code></pre> <p><code>aws configure</code></p> <p>Otra forma de configurar estos valores es mediante el comando <code>aws configure</code>, el cual nos preguntar\u00e1 los siguientes datos:</p> <pre><code>AWS Access Key ID [****************6YUJ]:\nAWS Secret Access Key [****************4TEz]:\nDefault region name [us-east-1]:\nDefault output format [None]:\n</code></pre> <p>El problema es que no nos solicita el token de sesi\u00f3n, por lo cual s\u00f3lo lo podemos utilizar si tenemos una cuenta real de AWS.</p> <p>Orden</p> <p>Al ejecutar comandos AWS CLI, AWS CLI buscar\u00e1 las credenciales primero en las variables de entorno y, a continuaci\u00f3n, en el archivo de configuraci\u00f3n.</p> <p>Para comprobar que todo ha ido bien, mediante <code>aws sts get-caller-identity</code> podremos ver nuestro id de usuario.</p> <p>Una vez configurado nuestro usuario, mediante <code>aws ec2 describe-instances</code> podremos obtener informaci\u00f3n sobre nuestras instancias.</p>"},{"location":"cloud/02aws.html#aws-cloudshell","title":"AWS Cloudshell","text":"<p>Es un shell integrado en la consola web que facilita la gesti\u00f3n, exploraci\u00f3n e interacci\u00f3n con los recursos AWS. Al acceder ya estaremos pre-autenticados con las credencias de la consola, y la mayor\u00eda de herramientas operacionales ya est\u00e1n pre-instaladas, con lo que es entrar y ponerse a trabajar.</p> <p>De esta manera podemos trabajar con AWS CLI con solo entrar a nuestro usuario de AWS.</p> Interfaz de Cloudshell"},{"location":"cloud/02aws.html#referencias","title":"Referencias","text":"<ul> <li>Overview of Amazon Web Services</li> <li>Redes y entrega de contenido en AWS</li> <li>Seguridad en la nube con AWS</li> </ul>"},{"location":"cloud/02aws.html#actividades","title":"Actividades","text":"<ol> <li>(RA5075.2 / CE5.2a / 1p) Realiza el m\u00f3dulo 3 (Informaci\u00f3n general sobre la infraestructura global de AWS) del curso ACF de AWS.</li> <li>(RA5075.2 / CE5.2a / 1p) Instala en tu ordenador AWS CLI y con\u00e9ctate a AWS desde el terminal. Realiza una captura donde se vea los datos de ejecutar <code>aws sts get-caller-identity</code>.</li> </ol>"},{"location":"cloud/03s3.html","title":"Almacenamiento en la nube","text":"<p>El almacenamiento en la nube, por lo general, es m\u00e1s confiable, escalable y seguro que los sistemas de almacenamiento tradicionales en las instalaciones.</p> <p>El an\u00e1lisis de Big Data, el almacenamiento de datos, el Internet de las cosas (IoT), las bases de datos y las aplicaciones de copias de seguridad y archivo dependen de alg\u00fan tipo de arquitectura de almacenamiento de datos.</p> <p>El almacenamiento m\u00e1s b\u00e1sico es el que incluyen las propias instancias, tambi\u00e9n conocido como el almac\u00e9n de instancias, o almacenamiento ef\u00edmero, es un almacenamiento temporal que se agrega a la instancia de EC2.</p> <p>El almac\u00e9n de instancias es una buena opci\u00f3n para el almacenamiento temporal de informaci\u00f3n que cambia con frecuencia, como buffers, memorias cach\u00e9, datos de pruebas y dem\u00e1s contenido temporal. Tambi\u00e9n se puede utilizar para los datos que se replican en una flota de instancias, como un grupo de servidores web con balanceo de carga. Si las instancias se detienen, ya sea debido a un error del usuario o un problema de funcionamiento, se eliminar\u00e1n los datos en el almac\u00e9n de instancias.</p> <p>Almacenamiento de bloque o de objeto</p> <p>AWS permite almacenar los datos en bloques o como objetos. Si el almacenamiento es en bloques, los datos se almacenan por trozos (bloques), de manera si se modifica una parte de los datos, solo se ha de modificar el bloque que lo contiene. En cambio, si el almacenamiento es a nivel de objeto, una modificaci\u00f3n implica tener que volver a actualizar el objeto entero. Esto provoca que el almacenamiento por bloque sea m\u00e1s r\u00e1pido. En cambio, el almacenamiento de objetos es m\u00e1s sencillo y por tanto m\u00e1s barato.</p> <p>AWS ofrece m\u00faltiples soluciones que vamos a revisar:</p> Servicios de almacenamiento de AWS"},{"location":"cloud/03s3.html#amazon-ebs","title":"Amazon EBS","text":"<p>Amazon Elastic Block Store (https://aws.amazon.com/es/ebs/) ofrece vol\u00famenes de almacenamiento a nivel de bloque de alto rendimiento para utilizarlos con instancias de Amazon EC2 para las cargas de trabajo con un uso intensivo de transacciones y de rendimiento.</p> <p>Los beneficios adicionales incluyen la replicaci\u00f3n en la misma zona de disponibilidad, el cifrado f\u00e1cil y transparente, los vol\u00famenes el\u00e1sticos y las copias de seguridad mediante instant\u00e1neas.</p> <p>Importante</p> <p>AmazonEBS se puede montar en una instancia de EC2 solamente dentro de la misma zona de disponibilidad.</p>"},{"location":"cloud/03s3.html#volumenes","title":"Vol\u00famenes","text":"<p>IOPS</p> <p>El t\u00e9rmino IOPS, operaciones de entrada y salida por segundo, representa una medida de rendimiento frecuente que se utiliza para comparar dispositivos de almacenamiento. Un art\u00edculo muy interesante es What you need to know about IOPS.</p> <p>Los vol\u00famenes de EBS proporcionan almacenamiento externo a EC2 que persiste independientemente de la vida de la instancia. Son similares a discos virtuales en la nube. AmazonEBS ofrece tres tipos de vol\u00famenes: SSD de uso general, SSD de IOPS provisionadas y magn\u00e9ticos (HDD). Los tres tipos de vol\u00famenes difieren en caracter\u00edsticas de rendimiento y coste, para ofrecer diferentes posibilidades seg\u00fan las necesidades de las aplicaciones:</p> <ul> <li>Unidades de estado s\u00f3lido (SSD): optimizadas para cargas de trabajo de transacciones que implican operaciones de lectura/escritura frecuentes de peque\u00f1o tama\u00f1o de E/S. Proporciona un equilibrio entre precio y rendimiento, y es el tipo recomendado para la mayor\u00eda de las cargas de trabajo. Los tipos existentes son <code>gp3</code> (1.000 MiB/s) y <code>gp2</code>(128-250 MiB/s) ambas con un m\u00e1ximo de 16.000 IOPS.</li> <li>SSD de IOPS provisionadas: proporciona un rendimiento elevado con cargas de trabajo cr\u00edticas, baja latencia o alto rendimiento. Los tipos existentes con <code>io2 Block Express</code> (4.000 MiB/s con un m\u00e1ximo 246.000 IOPS) e <code>io2</code> (1.000 MiB/s con 64.000 IOPS)</li> <li>Unidades de disco duro (HDD): optimizadas para grandes cargas de trabajo de streaming. Los tipos existentes con <code>st1</code> (500 MiB/s con 500 IOPS) y <code>sc1</code> (250 MiB/s con 250 IOPS).</li> </ul> <p>M\u00e1s informaci\u00f3n sobre los diferentes vol\u00famenes: https://docs.aws.amazon.com/es_es/AWSEC2/latest/UserGuide/ebs-volume-types.html</p> <p>Para crear o configurar un volumen, dentro de las instancias EC2, en el men\u00fa lateral podemos ver las opciones de Elastic Block Store y el submen\u00fa Vol\u00famenes:</p> Vol\u00famenes en EBS <p>Los vol\u00famenes de Amazon EBS est\u00e1n asociados a la red, y su duraci\u00f3n es independiente a la vida de una instancia. Al tener un alto nivel de disponibilidad y de confianza, pueden aprovecharse como particiones de arranque de instancias de EC2 o asociarse a una instancia de EC2 en ejecuci\u00f3n como dispositivos de bloques est\u00e1ndar.</p> <p>Cuando se utilizan como particiones de arranque, las instancias de Amazon EC2 pueden detenerse y, posteriormente, reiniciarse, lo que le permite pagar solo por los recursos de almacenamiento utilizados al mismo tiempo que conserva el estado de la instancia. Los vol\u00famenes de Amazon EBS tienen mayor durabilidad que los almacenes de instancias de EC2 locales porque los vol\u00famenes de Amazon EBS se replican autom\u00e1ticamente en el backend (en una \u00fanica zona de disponibilidad).</p> <p>Los vol\u00famenes de Amazon EBS ofrecen las siguientes caracter\u00edsticas:</p> <ul> <li>Almacenamiento persistente: el tiempo de vida de los vol\u00famenes es independiente de cualquier instancia de Amazon EC2.</li> <li>De uso general: son dispositivos de bloques sin formato que se pueden utilizar en cualquier sistema operativo.</li> <li>Alto rendimiento: ofrecen al menos el mismo o m\u00e1s rendimiento que las unidades de Amazon EC2 locales.</li> <li>Nivel de fiabilidad alto: tienen redundancia integrada dentro de una zona de disponibilidad.</li> <li>Dise\u00f1ados para ofrecer resiliencia: la AFR (tasa anual de errores) de Amazon EBS oscila entre 0,1 % y 1 %.</li> <li>Tama\u00f1o variable: los tama\u00f1os de los vol\u00famenes var\u00edan entre 1 GB y 16 TB.</li> <li>F\u00e1ciles de usar: se pueden crear, asociar, almacenar en copias de seguridad, restaurar y eliminar f\u00e1cilmente.</li> </ul> <p>Un volumen en una instancia</p> <p>S\u00f3lo una instancia de Amazon EC2 a la vez puede montarse en un volumen de Amazon EBS.</p>"},{"location":"cloud/03s3.html#instantaneas","title":"Instant\u00e1neas","text":"<p>Sin embargo, para los que quieran a\u00fan m\u00e1s durabilidad, con Amazon EBS es posible crear instant\u00e1neas uniformes puntuales de los vol\u00famenes, que luego se almacenan en Amazon S3 y se replican autom\u00e1ticamente en varias zonas de disponibilidad.</p> <p>Estas instant\u00e1neas se pueden utilizar como punto de partida para nuevos vol\u00famenes de Amazon EBS (clonando o restaurando copias de seguridad) y permiten proteger la durabilidad de los datos a largo plazo. Como todo recurso S3, tambi\u00e9n se pueden compartir f\u00e1cilmente con compa\u00f1eros del equipo de desarrollo y otros desarrolladores de AWS.</p>"},{"location":"cloud/03s3.html#amazon-efs","title":"Amazon EFS","text":"<p>Amazon Elastic File System (https://aws.amazon.com/es/efs/) ofrece almacenamiento para las instancias EC2 a las que pueden acceder varias m\u00e1quinas virtuales de forma simult\u00e1nea, de manera similar a un NAS (Network Area Storage). Se ha implementado como un sistema de archivos de uso compartido que utiliza el protocolo de sistemas de archivos de red (NFS), al que acceden varios miles de instancia EC2 as\u00ed como servidores on-premise a traves de una VPN o conexiones directas (AWS Direct Connect).</p> <p>Se trata de un almacenamiento de archivos simple, escalable y el\u00e1stico para utilizarlo con los servicios de AWS y los recursos disponibles en las instalaciones. Mediante una interfaz sencilla permite crear y configurar sistemas de archivos de forma r\u00e1pida y simple.</p> <p>EFS est\u00e1 dise\u00f1ado para escalar a petabytes de manera din\u00e1mica bajo demanda sin interrumpir las aplicaciones, por lo que se ampliar\u00e1 y reducir\u00e1 de forma autom\u00e1tica a medida que agregue o elimine archivos, no necesitando asignar espacio inicial. Respecto al rendimiento, su IOPS escala de forma autom\u00e1tica conforme crece el tama\u00f1o del sistema de archivos, ofreciendo dos modos, el de uso general (ofrece alrededor de 7000 operaciones por segundo y fichero) y el max I/O (para miles de instancias que acceden al mismo archivo de forma simultanea), pudiendo admitir un rendimiento superior a 10 GB/seg y hasta 500.000 IOPS.</p> <p>Las instancias se conectan a EFS desde cualquier AZ de la regi\u00f3n. Todas las lecturas y escrituras son consistentes en todas las AZ. Por ejemplo, una lectura en una AZ garantiza que tendr\u00e1 la misma informaci\u00f3n, aunque los datos se hayan escrito en otra AZ.</p> EFS compartido entre instancias <p>Respecto al coste (https://aws.amazon.com/es/efs/pricing/), dependiendo del tipo de acceso y la administraci\u00f3n del ciclo de vida, el acceso est\u00e1ndar se factura desde 0,30$ Gb/mes, mientras que si el acceso es poco frecuente, baja a 0,013$ Gb/mes m\u00e1s 0,01$ por transferencia y Gb/mes.</p> <p>Su casos de uso m\u00e1s comunes son para Big Data y an\u00e1lisis, flujos de trabajo de procesamiento multimedia, administraci\u00f3n de contenido, servidores web y directorios principales.</p> <p>Respecto a su acceso, de manera similar al resto de servicios de almacenamiento, es un servicio completamente administrado al que se puede acceder desde la consola, una API o la CLI de AWS.</p>"},{"location":"cloud/03s3.html#amazon-s3","title":"Amazon S3","text":"<p>S3 (https://aws.amazon.com/es/s3/) es un servicio de almacenamiento persistente de objetos creado para almacenar y recuperar cualquier cantidad de datos desde cualquier lugar mediante una URL: sitios web y aplicaciones m\u00f3viles, aplicaciones corporativas y datos de sensores o dispositivos de Internet de las cosas (IoT) y an\u00e1lisis de Big Data.</p> <p>S3 es un servicio de almacenamiento a nivel de objetos, y tal como hab\u00edamos comentado, significa que adem\u00e1s de que los datos contengan metadatos que ayudan a catalogar el objeto, si desea cambiar una parte de un archivo, tiene que realizar la modificaci\u00f3n y luego volver a cargar todo el archivo modificado. Esto puede tener implicaciones de rendimiento y consistencia, que conviene tener en cuenta.</p> <p>Los datos se almacenan como objetos dentro de recursos conocidos como buckets. Los objetos pueden ser pr\u00e1cticamente cualquier archivo de datos, como im\u00e1genes, videos o registros del servidor. </p> <p>Es una soluci\u00f3n administrada de almacenamiento en la nube que se dise\u00f1\u00f3 para brindar un escalado sin problemas, ofreciendo 99,99% de disponibilidad (4 nueves) y 99,999999999% (11 nueves) de durabilidad. Adem\u00e1s de poder almacenar pr\u00e1cticamente todos los objetos que deseemos dentro de un bucket (los objetos pueden ser de hasta 5TB), S3 permite realizar operaciones de escritura, lectura y eliminaci\u00f3n de los objetos almacenados en el bucket. Los nombres de los buckets son universales y deben ser \u00fanicos entre todos los nombres de buckets existentes en Amazon S3.</p> <p>De forma predeterminada, en Amazon S3 los datos se almacenan de forma redundante en varias instalaciones y en diferentes dispositivos de cada instalaci\u00f3n.</p> Replicaci\u00f3n en S3 <p>Los datos que almacenamos en S3 no est\u00e1n asociados a ning\u00fan servidor en particular (aunque los buckets se asocien a regiones, los archivos se dice que est\u00e1n almacenados de forma global), con lo que no necesitamos administrar ning\u00fan tipo de servidor.</p> Replicaci\u00f3n en S3 <p>Amazon S3 contiene billones de objetos y, con regularidad, tiene picos de millones de solicitudes por segundo, por ende, es un servicio de alto rendimiento, con una latencia de primer byte que se mide en milisegundos para la mayor\u00eda de las clases de almacenamiento.</p>"},{"location":"cloud/03s3.html#elementos-de-un-objeto","title":"Elementos de un objeto","text":"<p>Cada objeto que almacenamos en S3 tiene:</p> <ul> <li>una clave: nombre que se le asigna al objeto y que se utiliza para recuperarlo.</li> <li>un id de versi\u00f3n: podemos mantener un hist\u00f3rico de cambios mediante el versionado de los archivos, de manera que cuando actualicemos un objeto, en vez de sustituirlo, se crea una nuevo versi\u00f3n manteniendo un hist\u00f3rico. M\u00e1s informaci\u00f3n en https://docs.aws.amazon.com/es_es/AmazonS3/latest/userguide/versioning-workflows.html</li> <li>un valor: contenido real que se almacena.</li> <li>metadatos: pares clave-valor, que podemos definir nosotros como usuarios.</li> <li>subrecursos: que utiliza AWS para almacenar informaci\u00f3n adicional.</li> </ul>"},{"location":"cloud/03s3.html#clases-de-almacenamiento","title":"Clases de almacenamiento","text":"<p>S3 ofrece una variedad de clases de almacenamiento (https://docs.aws.amazon.com/es_es/S3/latest/userguide/storage-class-intro.html) a nivel de objetos que est\u00e1n dise\u00f1adas para diferentes casos de uso. Entre estas clases se incluyen las siguientes:</p> <ul> <li>S3 Est\u00e1ndar: dise\u00f1ada para ofrecer almacenamiento de objetos de alta durabilidad, disponibilidad y rendimiento para los datos a los que se accede con frecuencia. Como ofrece baja latencia y alto nivel de rendimiento, es una opci\u00f3n adecuada para aplicaciones en la nube, sitios web din\u00e1micos, distribuci\u00f3n de contenido, aplicaciones para dispositivos m\u00f3viles y videojuegos, y el an\u00e1lisis de big data.</li> <li>S3 Est\u00e1ndar - Acceso poco frecuente: se utiliza para los datos a los que se accede con menos frecuencia, pero que requieren acceso r\u00e1pido cuando es necesario. Es una opci\u00f3n ideal para el almacenamiento y las copias de seguridad a largo plazo, adem\u00e1s de almac\u00e9n de datos para los archivos de recuperaci\u00f3n de desastres.</li> <li>S3 \u00danica zona \u2013 Acceso poco frecuente: dise\u00f1ada para guardar los datos a los que se accede con menos frecuencia, pero que requieren acceso r\u00e1pido cuando es necesario, pero sin tener replicas (la clase S3 est\u00e1ndar replica los datos en un m\u00ednimo de tres AZ). Es una buena opci\u00f3n para almacenar copias de seguridad secundarias de los datos que se encuentran en las instalaciones o de los datos que se pueden volver a crear f\u00e1cilmente.</li> <li>S3 Intelligent-Tiering: dise\u00f1ada para optimizar los costes mediante la migraci\u00f3n autom\u00e1tica de los datos entre capas, sin que se perjudique el rendimiento ni se produzca una sobrecarga operativa. Se encarga de monitorizar los patrones de acceso de los objetos y traslada aquellos a los que no se ha accedido durante 30 d\u00edas consecutivos a la capa de acceso poco frecuente. Si se accede a un objeto en la capa de acceso poco frecuente, este se traslada autom\u00e1ticamente a la capa de acceso frecuente. Funciona bien con datos de larga duraci\u00f3n con patrones de acceso desconocidos o impredecibles.</li> <li> <p>S3 Glacier (https://aws.amazon.com/es/s3/glacier/): es una clase de almacenamiento seguro, duradero y de bajo coste para archivar datos a largo plazo. Para que los costes se mantengan bajos, S3 Glacier proporciona tres opciones de recuperaci\u00f3n (recuperaci\u00f3n acelerada, est\u00e1ndar y masiva), que van desde unos pocos minutos a unas horas. Podemos cargar objetos directamente en S3 Glacier o utilizar pol\u00edticas de ciclo de vida para transferir datos entre cualquiera de las clases de almacenamiento de S3 para datos activos y S3 Glacier.</p> <p>Pol\u00edtica de ciclo de vida</p> <p>Una pol\u00edtica de ciclo de vida define qu\u00e9 va a pasar con los datos partiendo de su almacenamiento masivo en S3 est\u00e1ndar, pasando a uso poco frecuente y seguidamente a Glacier y finalmente para su eliminaci\u00f3n, en base a plazos o m\u00e9tricas y reduciendo costes de forma autom\u00e1tica.</p> <p> Pol\u00edtica de ciclo de vida </p> <p>Para ello, se puede monitorizar un bucket completo, un prefijo o una etiqueta de objeto, de manera que podamos evaluar los patrones de acceso y ajustar la pol\u00edtica de ciclo de vida.</p> </li> <li> <p>S3 Glacier Deep Archive: es la clase de almacenamiento de menor coste en S3. Admite la retenci\u00f3n a largo plazo y la preservaci\u00f3n digital de datos a los que es posible que se acceda solo una o dos veces por a\u00f1o. Dise\u00f1ado inicialmente los a sectores con niveles de regulaci\u00f3n muy estrictos, como los servicios financieros, la sanidad y los sectores p\u00fablicos, los cuales retienen conjuntos de datos durante un periodo de 7 a 10 a\u00f1os o m\u00e1s para cumplir los requisitos de conformidad normativa. Tambi\u00e9n se puede utilizar para casos de uso de copias de seguridad y de recuperaci\u00f3n de desastres. Todos los objetos almacenados en S3 Glacier Deep Archive se replican y almacenan en al menos tres zonas de disponibilidad geogr\u00e1ficamente dispersas, y se pueden restaurar en 12 horas.</p> </li> </ul>"},{"location":"cloud/03s3.html#buckets","title":"Buckets","text":"<p>Amazon S3 almacena los datos en buckets, los cuales son los bloques b\u00e1sicos donde se estructura la informaci\u00f3n, actuando como contenedores l\u00f3gicos de objetos. Los buckets son esencialmente el prefijo de un conjunto de archivos y, como tales, deben tener un nombre \u00fanico en todo Amazon S3 a nivel mundial.</p> <p>Podemos controlar el acceso a cada bucket mediante mecanismos de control de acceso (ACL) que pueden aplicarse tanto a objetos individuales como a los buckets, es decir, qui\u00e9n puede crear, eliminar y enumerar objetos en el bucket. Tambi\u00e9n podemos obtener registros de acceso al bucket y a sus objetos, adem\u00e1s de elegir la regi\u00f3n geogr\u00e1fica donde Amazon S3 almacenar\u00e1 el bucket y su contenido. Para cargar los datos (como fotos, v\u00eddeos o documentos), primero hemos de crear un bucket en una regi\u00f3n de AWS y, a continuaci\u00f3n, cargar casi cualquier cantidad de objetos en el bucket (los objetos pueden ocupar hasta 5TB).</p> Creamos el bucket <p>Cuando creamos un bucket en S3, este se asocia a una regi\u00f3n de AWS espec\u00edfica. Cuando almacenamos datos en el bucket, estos se almacenan de forma redundante en varias instalaciones de AWS dentro de la regi\u00f3n seleccionada. S3 est\u00e1 dise\u00f1ado para almacenar los datos de forma duradera, incluso en el caso de producirse una p\u00e9rdida de datos simult\u00e1nea en dos instalaciones de AWS.</p> <p>Por ejemplo, vamos a crear un bucket dentro de la regi\u00f3n <code>us-east-1</code> con el nombre <code>s3severo8a</code> (recuerda que el nombre debe ser \u00fanico y en min\u00fasculas, as\u00ed como evitar las tildes, \u00f1, etc...).</p> Cargando el bucket <p>Para almacenar un objeto en S3, debemos cargarlo en un bucket.</p> <p>Para cargar un archivo, una vez elegido el bucket sobre el que queremos cargar, simplemente arrastrando el fichero, \u00e9ste se subir\u00e1 a S3 (tambi\u00e9n podemos establecer permisos sobre los datos y cualquier metadato).</p> <p>Ya hemos comentado que un objeto est\u00e1 compuesto por los datos y cualquier metadato que describa a ese archivo, incluida la direcci\u00f3n URL. En nuestro caso su URL ser\u00eda https://s3severo8a.s3.amazonaws.com/labS3.csv</p> <p>Acceso denegado</p> <p>Si intentamos acceder al fichero mediante la URL obtendremos un fichero XML indic\u00e1ndonos que no tenemos permisos para visualizar el recurso:</p> <pre><code>&lt;Error&gt;\n&lt;Code&gt;AccessDenied&lt;/Code&gt;\n&lt;Message&gt;Access Denied&lt;/Message&gt;\n&lt;RequestId&gt;ZCZ6XBHYC8C8SYSH&lt;/RequestId&gt;\n&lt;HostId&gt;btHdjBYCmNFdndkpfKiOKlSoxN0yvn+kkGoFWYGKr4F2oLYE0OkxpwlxLLlafoH+uvHFRpS4fw0=&lt;/HostId&gt;\n&lt;/Error&gt;\n</code></pre> <p>S3 administra autom\u00e1ticamente el almacenamiento detr\u00e1s de cada bucket a medida que aumenta la cantidad de datos. S3 tambi\u00e9n es escalable, lo que permite gestionar un volumen elevado de solicitudes. No es necesario aprovisionar el almacenamiento ni el rendimiento, y solo se facturar\u00e1 por lo que utilicemos.</p>"},{"location":"cloud/03s3.html#casos-de-uso","title":"Casos de uso","text":"<p>Esta flexibilidad para almacenar una cantidad pr\u00e1cticamente ilimitada de datos y para acceder a ellos desde cualquier lugar convierte a S3 en un servicio adecuado para distintos casos:</p> <ul> <li>Como ubicaci\u00f3n para cualquier dato de aplicaci\u00f3n, ya sea nuestra propia aplicaci\u00f3n hospedada on-premise, como las aplicaciones de EC2 o mediante servidores en otros hostings. Esta caracter\u00edstica puede resultar \u00fatil para los archivos multimedia generados por el usuario, los registros del servidor u otros archivos que su aplicaci\u00f3n deba almacenar en una ubicaci\u00f3n com\u00fan. Adem\u00e1s, como el contenido se puede obtener de manera directa a trav\u00e9s de Internet, podemos delegar la entrega de contenido de nuestra aplicaci\u00f3n y permitir que los clientes la consigan ellos mismos.</li> <li>Para el alojamiento web est\u00e1tico. S3 puede entregar el contenido est\u00e1tico de un sitio web, que incluye HTML, CSS, JavaScript y otros archivos.</li> <li>Para almacenar copias de seguridad de sus datos. Para una disponibilidad y capacidad de recuperaci\u00f3n de desastres incluso mejores, S3 puede hasta configurarse para admitir la replicaci\u00f3n entre regiones, de modo que los datos ubicados en un bucket de S3 en una regi\u00f3n puedan replicarse de forma autom\u00e1tica en otra regi\u00f3n de S3.</li> </ul> <p>Diferencias entre EBS y S3</p> <ul> <li>EBS solo se puede utilizar cuando se conecta a una instancia EC2 y se puede acceder a Amazon S3 por s\u00ed solo.</li> <li>EBS no puede contener tantos datos como S3.</li> <li>EBS solo se puede adjuntar a una instancia EC2, mientras que varias instancias EC2 pueden acceder a los datos de un bucket de S3.</li> <li>S3 experimenta m\u00e1s retrasos que Amazon EBS al escribir datos.</li> </ul> <p>As\u00ed pues, es el usuario o el dise\u00f1ador de la aplicaci\u00f3n quien debe decidir si el almacenamiento de Amazon S3 o de Amazon EBS es el m\u00e1s apropiado para una aplicaci\u00f3n determinada.</p>"},{"location":"cloud/03s3.html#costes","title":"Costes","text":"<p>Con S3, los costes espec\u00edficos var\u00edan en funci\u00f3n de la regi\u00f3n y de las solicitudes espec\u00edficas que se realizan. Solo se paga por lo que se utiliza, lo que incluye gigabytes por mes; transferencias desde otras regiones; y solicitudes <code>PUT</code>, <code>COPY</code>, <code>POST</code>, <code>LIST</code> y <code>GET</code>. Como regla general, solo se paga por las transferencias que cruzan el l\u00edmite de su regi\u00f3n, lo que significa que no paga por las transferencias entrantes a S3 ni por las transferencias salientes desde S3 a las ubicaciones de borde de Amazon CloudFront dentro de esa misma regi\u00f3n.</p> <p>Para calcular los costes de S3 hay que tener en cuenta:</p> <ol> <li> <p>Clase de almacenamiento y cantidad almacenada:</p> <ul> <li>El almacenamiento est\u00e1ndar est\u00e1 dise\u00f1ado para proporcionar 99,999.999.999% (11 nueves) de durabilidad y 99,99% (4 nueves) de disponibilidad. Por ejemplo, los primeros 50 TB/mes cuestan 0,023$ por GB.</li> <li>El almacenamiento Est\u00e1ndar - Acceso poco frecuente ofrece la misma durabilidad de 99,999.999.999% (11 nueves) de S3, pero con 99,9% (3 nueves) de disponibilidad en un a\u00f1o concreto. Su precio parte desde los 0,0125$ por GB.</li> <li>Y si elegimos el almacenamiento poco frecuente pero en una \u00fanica zona, el precio pasa a ser de 0,01$ por GB.</li> <li>Si fuese a la capa Glacier, con una opci\u00f3n de recuperaci\u00f3n de 1 minutos a 12 horas el precio baja a 0,004$ por GB.</li> <li>Finalmente, con Glacier Deep Archive (archivos que se recuperan 1 o 2 veces al a\u00f1o con plazos de recuperaci\u00f3n de 12 horas) baja hasta 0,000.99$ por GB</li> </ul> </li> <li> <p>Solicitudes: se consideran la cantidad y el tipo de las solicitudes. Las solicitudes GET generan cargos (0,000.4$ por cada 1.000 solicitudes) a tasas diferentes de las de otras solicitudes, como <code>PUT</code> y <code>COPY</code> (0,005$ cada 1.000 solicitudes).</p> </li> <li> <p>Transferencia de datos: se considera la cantidad de datos transferidos fuera de la regi\u00f3n de S3, los datos salientes, siendo el primer GB gratuito y luego comienza a facturar a 0,09$ por GB. La transferencia entrante de datos es gratuita.</p> </li> </ol> <p>La informaci\u00f3n actualizada y detallada se encuentra disponible en https://aws.amazon.com/es/s3/pricing/.</p>"},{"location":"cloud/03s3.html#sitio-web-estatico","title":"Sitio web est\u00e1tico","text":"<p>Vamos a hacer un caso pr\u00e1ctico de uso de S3. AWS permite que un bucket funcione como un sitio web est\u00e1tico. Para ello, una vez creado el bucket, sobre sus propiedades, al final de la p\u00e1gina, podemos habilitar el alojamiento de web est\u00e1ticas.</p> <p>Para este ejemplo, primero creamos un bucket llamado <code>severo8a-web</code>.</p> <p>A continuaci\u00f3n subiremos nuestro archivo siteEstatico.zip descomprimido al bucket.</p> <p>Para que la web sea visible, tenemos que modificar los permisos para que no bloquee el acceso p\u00fablico. As\u00ed pues, en la pesta\u00f1a de permisos del bucket deshabilitamos todas las opciones.</p> Haciendo el bucket p\u00fablico <p>Una vez que tenemos el bucket visible, tenemos que a\u00f1adir una pol\u00edtica para acceder a los recursos del mismo (la pol\u00edtica tambi\u00e9n la podemos crear desde el generador de pol\u00edticas que tenemos disponible en la misma p\u00e1gina de edici\u00f3n):</p> Pol\u00edticaAsistente para generar la pol\u00edtica <pre><code>{\n\"Id\": \"Policy1633602259164\",\n\"Version\": \"2012-10-17\",\n\"Statement\": [\n{\n\"Sid\": \"PublicReadGetObject\",\n\"Effect\": \"Allow\",\n\"Principal\": \"*\",\n\"Action\": \"s3:GetObject\",\n\"Resource\": \"arn:aws:s3:::severo8a-web/*\"\n}\n]\n}\n</code></pre> <p> Editor de pol\u00edticas </p> <p>Tras ello, s\u00f3lo nos queda configurar el bucket como un sitio web. Para ello, en las propiedades, en la parte final de la p\u00e1gina, tenemos la opci\u00f3n de Alojamiento de sitios web est\u00e1ticos, la cual debemos habilitar y posteriormente nos mostrar\u00e1 la URL de acceso a nuestro sitio web, en nuestro caso en http://severo8a-web.s3-website-us-east-1.amazonaws.com/</p> Sitio Web p\u00fablico <p>M\u00e1s informaci\u00f3n en https://docs.aws.amazon.com/AmazonS3/latest/userguide/WebsiteHosting.html</p>"},{"location":"cloud/03s3.html#s3-select","title":"S3 Select","text":"<p>Amazon S3 Select permite utilizar instrucciones SQL sencillas para filtrar el contenido de los objetos de Amazon S3 y recuperar exactamente el subconjunto de datos que necesitemos. Si utilizamos S3 Select para filtrar los datos, podemos reducir la cantidad de datos que Amazon transfiere, lo que reduce tambi\u00e9n los costes y la latencia para recuperarlos.</p> <p>Admite los formatos CSV, JSON o Apache Parquet, ya sea en crudo o comprimidos con GZIP o BZIP2 (solo para objetos CSV y JSON), as\u00ed como objetos cifrados del lado del servidor.</p> <p>Las expresiones SQL se pasan a Amazon S3 en la solicitud. Amazon S3 Select es compatible con un subconjunto de SQL. Para obtener m\u00e1s informaci\u00f3n sobre los elementos SQL compatibles es recomendable consultar la referencia SQL de S3.</p> Cargando el bucket <p>Por ejemplo, si trabajamos sobre el bucket que hab\u00edamos creado, tras seleccionarlo, en las Acciones de objeto, elegiremos la opci\u00f3n de Consultar con S3 Select , y si no queremos configurar nada, podemos ejecutar una consulta de tipo select desde la propia ventana mediante el bot\u00f3n Ejecutar consulta SQL.</p> <p>Si nos fijamos en la imagen, se crea una tabla ficticia denominada <code>s3object</code> que referencia al documento cargado. Si queremos hacer referencia a columna, podemos hacerlo por su posici\u00f3n (por ejemplo <code>s._1</code> referencia a la primera columna) o por el nombre de la columna (en nuestro caso, <code>s.VendorID</code>). Es importante marcar la casilla Excluir la primera l\u00ednea de CSV datos si la primera fila de nuestro CSV contiene etiquetas a modo de encabezado.</p> <p>Si pulsamos sobre el bot\u00f3n de Agregar SQL desde plantillas, podremos seleccionar entre algunas consultas predefinidas (contar, elegir columnas, filtrar los datos, etc...).</p> <p>Autoevaluaci\u00f3n</p> <p>Los datos que hemos cargado en el ejemplo est\u00e1n relacionados con trayectos de taxis. 1. El campo <code>VendorID</code> tiene dos posibles valores: 1 y 2: \u00bf Cuantos viajes han hecho los vendor de tipo 1? 2. Cuando el campo <code>payment_type</code> tiene el valor 1, est\u00e1 indicando que el pago se ha realizado mediante tarjeta de cr\u00e9dito. A su vez, el campo <code>total_amount</code> almacena el coste total de cada viaje \u00bfCuantos viajes se han realizado y cuanto han recaudado los trayectos que se han pagado mediante tarjeta de cr\u00e9dito?</p> <p>Para transformar el tipo de un campo, se emplea la funci\u00f3n <code>cast</code> .Por ejemplo si queremos que interprete el campo total como de tipo float har\u00edamos <code>cast(s.total as float)</code> o si fuera entero como <code>cast(s.total as int)</code>.</p> <p> </p> <p>Puedes probar tambi\u00e9n con los datos almacenados en un fichero comprimido.</p> <p>La consola de Amazon S3 limita la cantidad de datos devueltos a 40 MB. Para recuperar m\u00e1s datos, deberemos utilizar la AWS CLI o la API REST.</p> <p>M\u00e1s informaci\u00f3n en https://docs.aws.amazon.com/es_es/AmazonS3/latest/userguide/selecting-content-from-objects.html.</p>"},{"location":"cloud/03s3.html#acceso","title":"Acceso","text":"<p>Podemos obtener acceso a S3 a trav\u00e9s de la consola, de la interfaz de l\u00ednea de comandos de AWS (CLI de AWS) o del SDK de AWS. Tambi\u00e9n se puede acceder a S3 de forma privada a trav\u00e9s de una VPC.</p> <p>Por ejemplo, como ya conoces la AWS CLI, podr\u00edamos utilizarla para crear un bucket:</p> Creando un bucketResultado <pre><code>aws s3api create-bucket --bucket s3severo8a-cli --region us-east-1\n</code></pre> <pre><code>{\n\"Location\": \"/s3severo8a-cli\"\n}\n</code></pre> <p>Otra forma es el acceso a los datos de los bucket directamente a trav\u00e9s de servicios REST, mediante puntos de enlace que admiten el acceso HTTP o HTTPS.</p> <p>Para facilitar la integraci\u00f3n de S3 con otros servicios, S3 ofrece notificaciones de eventos que permiten configurar notificaciones autom\u00e1ticas cuando se producen determinados eventos, como la carga o la eliminaci\u00f3n de un objeto en un bucket espec\u00edfico. Estas notificaciones se pueden enviar o utilizarse para desencadenar otros procesos, como funciones de AWS Lambda.</p>"},{"location":"cloud/03s3.html#seguridad","title":"Seguridad","text":"<p>Por defecto, todos los buckets de S3 son privados y solo pueden acceder los usuarios a los que se les concede acceso expl\u00edcitamente. Normalmente utilizaremos S3 para almacenar datos que utiliza una aplicaci\u00f3n que se ejecuta fuera de S3 o para hacer copias de seguridad de informaci\u00f3n confidencial. Para estos casos de uso comunes, el acceso p\u00fablico a los buckets que contienen datos nunca debe ser otorgado.</p> <p>Disponemos de varias herramientas y posibilidades para controlar el acceso a los buckets u objetos de S3:</p> <ul> <li>Uso del bloqueo de acceso p\u00fablico, la cual anula de manera sencilla cualquier otra pol\u00edtica o permisos de objetos.</li> <li>La escritura de pol\u00edticas IAM que indiquen los usuarios o roles que pueden acceder a buckets y objetos espec\u00edficos.</li> <li>La escritura de pol\u00edticas de bucket que definan el acceso a buckets u objetos espec\u00edficos, ya sea para conceder acceso entre cuentas de AWS o para conceder acceso p\u00fablico o an\u00f3nimo a los datos de Amazon S3. Se utiliza cuando el usuario o el sistema no pueden autenticarse mediante IAM.</li> <li>Creaci\u00f3n de puntos de acceso de S3, los cuales son nombres de alojamiento \u00fanicos que aplican permisos y controles de red definidos para las solicitudes que se realizan a trav\u00e9s de \u00e9l. Podemos crear puntos de acceso individualizados con nombres y permisos personalizados para cada aplicaci\u00f3n que accede a los datos.</li> <li>Configuraci\u00f3n de listas de control de acceso (ACL). Se utilizan con menos frecuencia (las ACL preceden a la IAM). Si utilizamos ACL, se recomienda no establecer un acceso muy permisivo.</li> </ul> <p>La seguridad es cr\u00edtica</p> <p>Recuerda que hay que controlar el acceso a los recursos, y en especial a S3. Si lo dejamos abierto, cualquier podr\u00e1 introducir datos con el consiguiente incremento en el coste. Tambi\u00e9n podemos cifrar los datos en tr\u00e1nsito y habilitar el cifrado del lado del servidor en nuestros objetos.</p>"},{"location":"cloud/03s3.html#s3-y-python","title":"S3 y Python","text":"<p>AWS ofrece diferentes interfaces para interactuar con S3, siendo Python una de las formas. A continuaci\u00f3n, vamos a crear una serie de scripts en nuestra m\u00e1quina local que accede, a\u00f1ade o recupere objetos de S3.</p> <p>Para autenticarnos en AWS desde nuestro sistema local, recuerda que necesitas copiar las credenciales de acceso en <code>~/.aws/credentials</code> (tambi\u00e9n puedes hacerlo mediante las variables de entorno).</p> <p>Para acceder a AWS desde Python, Amazon ofrece el SDK Boto3. Antes de utilizarlo, lo instalaremos mediante:</p> <pre><code>pip install boto3\n</code></pre> <p>Pod\u00e9is consultar toda la informaci\u00f3n relativa a Boto3 en su documentaci\u00f3n oficial en https://boto3.amazonaws.com/v1/documentation/api/latest/index.html</p> <p>Existen dos posibilidades para acceder a AWS mediante Boto3:</p> <ul> <li>Recursos: representan un interfaz orientado a objetos de AWS, de manera que cada recurso contendr\u00e1 un identificador, unos atributos y un conjunto de operaciones. Un ejemplo de recurso es el S3. M\u00e1s informaci\u00f3n sobre recursos en la documentaci\u00f3n oficial.</li> <li>Clientes: ofrecen un interfaz de bajo nivel que se mapea 1:1 con el API de cada servicio. Los clientes se generan a partir de la definici\u00f3n JSON del servicio. M\u00e1s informaci\u00f3n en la documentaci\u00f3n oficial.</li> </ul> <p>En resumen, los recursos son una abstracci\u00f3n a m\u00e1s alto nivel de los servicios AWS que los clientes. Se recomienda el uso de los recursos al no tener que preocuparse de c\u00f3mo se realiza por debajo la comunicaci\u00f3n e interacci\u00f3n con los servicios. Sin embargo, a d\u00eda de hoy no hay recursos para todos los servicios AWS, y por ello, en ocasiones no queda otra opci\u00f3n que utilizar los clientes.</p> <p>Para demostrar las diferencias, vamos a ver c\u00f3mo podemos realizar algunas operaciones haciendo uso del cliente o del recurso (en estos ejemplos nos vamos a centrar en el servicio S3 - https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/s3.html.):</p> Buckets de un usuarioElementos de un bucketCreaci\u00f3n de un bucketEliminaci\u00f3n de un recurso/bucket s3-buckets.py<pre><code>import boto3\n# Opci\u00f3n 1\nprint('Buckets mediante resource:')\ns3resource = boto3.resource('s3', region_name='us-east-1')\nbuckets = s3resource.buckets.all()\nfor bucket in buckets:\nprint(f'\\t{bucket.name}')\n# Opci\u00f3n 2\nprint('Buckets mediante el cliente:')\ns3client = boto3.client('s3')\nresponse = s3client.list_buckets()\nfor bucket in response['Buckets']:\nprint(f'\\t{bucket[\"Name\"]}')\n</code></pre> s3-bucket-objects.py<pre><code>import boto3\ns3 = boto3.resource('s3', region_name='us-east-1')\nbucket = s3.Bucket('s3severo8a')\nfor obj in bucket.objects.all():\nprint(obj.key)\n</code></pre> s3-create-bucket.py<pre><code>import boto3\n# Opci\u00f3n 1 - resource\ns3r = boto3.resource('s3', region_name='us-east-1')\nbucket = s3r.Bucket('s3severo8a-python-resource')\nbucket.create()\n# Opci\u00f3n 2 - cliente\ns3c = boto3.client('s3')\nresponse = s3c.create_bucket(\nBucket='s3severo8a-python-client'\n)\n</code></pre> s3-delete.py<pre><code>import boto3\ns3r = boto3.resource('s3', region_name='us-east-1')\nbucket = s3r.Bucket('s3severo8a-python-resource')\n# Elimina todos los objetos del bucket\nbucket.objects.delete()\n# Elimina el bucket\nbucket.delete()\n</code></pre>"},{"location":"cloud/03s3.html#caso-de-uso-1-comunicacion-con-s3","title":"Caso de uso 1 - Comunicaci\u00f3n con S3","text":"<p>Vamos a trabajar con el archivo datosPeliculas.json el cual contiene un listado de pel\u00edculas con las que trabajaremos en las siguientes sesiones.</p> <p>Primero vamos a ver c\u00f3mo podemos subir el archivo a S3 mediante Python:</p> upload-movies-s3.py<pre><code>import boto3\nficheroUpload = \"datosPeliculas.json\"\nnombreBucket = \"s3severo8a-boto3\"\n# Opci\u00f3n 1 - resource\ns3r = boto3.resource('s3', region_name='us-east-1')\n# 1.1 mediante upload_file\nbucket = s3r.Object(nombreBucket, 'datosSubidosR1.txt')\nbucket.upload_file(ficheroUpload)\n# 1.2 mediante put\nobject = s3r.Object(nombreBucket, 'datosSubidosR2.txt')\nobject.put(Body=b'Ejemplo de datos binarios')\n# Opci\u00f3n 2 - cliente\ns3c = boto3.client('s3')\n# 2.1 mediante upload_file\nresponse = s3c.upload_file(ficheroUpload, nombreBucket, \"datosSubidosC1.json\")\n# 2.2 mediante upload_fileobj\nwith open(ficheroUpload, \"rb\") as f:\ns3c.upload_fileobj(f, nombreBucket, \"datosSubidosC2.json\")\n# Cliente: Ejemplo de como crear un objeto y a\u00f1adirle contenido desde Python\ns3c.put_object(Body=b'Ejemplo de datos binarios',\nBucket=nombreBucket, Key=\"datosSubidosC3\")\n</code></pre> <p>Si lo que queremos es descargar un recurso de S3 para tenerlo en nuestro sistema local haremos:</p> <pre><code>import boto3\n# Opci\u00f3n 1 - descarga\ns3c = boto3.client('s3')\ns3c.download_file('s3severo8a-boto3', 'datosPeliculas.json',\n'datosDescargados.json')\n# Opci\u00f3n 2 - Abrimos el fichero y metemos el contenido\nwith open('fichero.json', 'wb') as f:\ns3c.download_fileobj('s3severo8a-boto3', 'datosPeliculas.json', f)\n</code></pre>"},{"location":"cloud/03s3.html#caso-de-uso-2-s3select-desde-python","title":"Caso de uso 2 - S3Select desde Python","text":"<p>En este caso, vamos a coger datos de pel\u00edculas de un dataset p\u00fablico disponible en https://www.kaggle.com/sankha1998/tmdb-top-10000-popular-movies-dataset</p> <p>El contenido del dataset es similar a:</p> TMDb_updated.csv<pre><code>,title,overview,original_language,vote_count,vote_average\n0,Ad Astra,\"The near future...\",en,2853,5.9\n1,Bloodshot,\"After he ...\",en,1349,7.2\n2,Bad Boys for Life,\"Marcus and Mike ...\",en,2530,7.1\n</code></pre> <p>Una vez descargado TMDb_updated.CSV, vamos a cargar la informaci\u00f3n en S3 dentro del bucket <code>s3severo8a-boto3</code>.</p>"},{"location":"cloud/03s3.html#s3select","title":"S3Select","text":"<p>Podemos realizar una consulta desde Python para automatizar un proceso ETL utilizando S3Select para recuperar el subconjunto de los datos, en concreto, informaci\u00f3n sobre las pel\u00edculas que tienen m\u00e1s de 10.000 votaciones.</p> <p>S3Select vs AWS Athena</p> <p>Este tipo de procesamiento es m\u00e1s c\u00f3modo realizarlo mediante AWS Athena, el cual s\u00ed que permite realizar join entre diferentes datasets. S3Select s\u00f3lo permite trabajar con una \u00fanica tabla.</p> <p>Para ello, mediante S3Select ejecutaremos la consulta <code>SELECT s.title, s.overview, s.vote_count, s.vote_average FROM s3object s WHERE cast(s.vote_count as int)&gt; 10000</code> y almacenaremos el resultado en un nuevo CSV dentro del mismo bucket:</p> s3select.py<pre><code>import boto3\ns3 = boto3.client('s3')\n# 1.- Realizamos la consulta mediante S3Select\nresp = s3.select_object_content(\nBucket='s3severo8a-boto3',\nKey='TMDb_updated.csv',\nExpressionType='SQL',\nExpression=\"SELECT s.title, s.overview, s.vote_count, s.vote_average FROM s3object s WHERE cast(s.vote_count as int)&gt; 10000\",\nInputSerialization={'CSV': {\"FileHeaderInfo\": \"USE\",\n'AllowQuotedRecordDelimiter': True},\n'CompressionType': 'NONE'},\nOutputSerialization={'CSV': {}},\n)\n# 2.- Unimos los datos que vamos recibiendo en streaming\nregistros = [\"title,overview,vote_count,vote_average\\n\"]\nfor evento in resp['Payload']:\nif 'Records' in evento:\nregistros.append(evento['Records']['Payload'].decode())\n# 3.- Generamos el contenido en un String\nfile_str = ''.join(registros)\n# 4.- Creamos un nuevo objeto en S3\ns3.put_object(Body=file_str, Bucket='s3severo8a-boto3',\nKey=\"TMDb_filtered.csv\")\n</code></pre>"},{"location":"cloud/03s3.html#referencias","title":"Referencias","text":"<ul> <li>Amazon EBS</li> <li>Amazon S3</li> <li>Amazon EFS</li> <li>Python, Boto3, and AWS S3: Demystified</li> <li>S3Select mediante Python: Ditch the Database</li> </ul>"},{"location":"cloud/03s3.html#actividades","title":"Actividades","text":"<ol> <li> <p>(RA5075.2 / CE5.2a / 1p) Realizar el m\u00f3dulo 7 (Almacenamiento) del curso ACF de AWS.</p> </li> <li> <p>(RA5075.2 / CE5.2a, CE5.2d  / 1p) Sigue el ejemplo de la web est\u00e1tica para crear un bucket que muestre el contenido como un sitio web. Adjunta una captura de pantalla del navegador una vez puedas acceder a la web.</p> </li> <li> <p>(RA5075.2 / CE5.2a / 1p) A partir del ejemplo de S3 Select, realiza las consultas propuestas en la autoevaluaci\u00f3n (utilizando el archivo comprimido) y realiza capturas donde se vea tanto la consulta como su resultado.</p> </li> <li> <p>(RA5075.2 / CE5.2a / 1p) Realiza los casos de uso 1 y 2 de interacci\u00f3n desde Python con S3.</p> </li> </ol>"},{"location":"cloud/04computacion.html","title":"Computaci\u00f3n en la nube","text":""},{"location":"cloud/04computacion.html#introduccion","title":"Introducci\u00f3n","text":"<p>Los servicios de m\u00e1quinas virtuales fueron los primeros servicios tanto de AWS como de Azure, los cuales proporcionan infraestructura como servicio (IaaS). Posteriormente se a\u00f1adieron otros servicios como tecnolog\u00eda sin servidor (serverless), tecnolog\u00eda basada en contenedores y plataforma como servicio (PaaS).</p> <p>Ya hemos comentado el coste de ejecutar servidores in-house (compra, mantenimiento del centro de datos, personal, etc...) adem\u00e1s de la posibilidad de que la capacidad del servidor podr\u00eda permanecer sin uso e inactiva durante gran parte del tiempo de ejecuci\u00f3n de los servidores, lo que implica un desperdicio.</p>"},{"location":"cloud/04computacion.html#amazon-ec2","title":"Amazon EC2","text":"<p>Amazon Elastic Compute Cloud (Amazon EC2 - https://docs.aws.amazon.com/ec2/) proporciona m\u00e1quinas virtuales en las que podemos alojar el mismo tipo de aplicaciones que podr\u00edamos ejecutar en un servidor en nuestras oficinas. Adem\u00e1s, ofrece capacidad de c\u00f3mputo segura y de tama\u00f1o ajustable en la nube. Las instancias EC2 admiten distintas cargas de trabajo (servidores de aplicaciones, web, de base de datos, de correo, multimedia, de archivos, etc..)</p> <p>La computaci\u00f3n el\u00e1stica (Elastic Compute) se refiere a la capacidad para aumentar o reducir f\u00e1cilmente la cantidad de servidores que ejecutan una aplicaci\u00f3n de manera autom\u00e1tica, as\u00ed como para aumentar o reducir la capacidad de procesamiento (CPU), memoria RAM o almacenamiento de los servidores existentes.</p> <p>La primera vez que lancemos una instancia de Amazon EC2, utilizaremos  el asistente de lanzamiento de instancias de la consola de administraci\u00f3n de AWS, el cual nos facilita paso a paso la configuraci\u00f3n y creaci\u00f3n de nuestra m\u00e1quina virtual.</p>"},{"location":"cloud/04computacion.html#paso-1-ami","title":"Paso 1: AMI","text":"<p>Una imagen de Amazon Machine (AMI) proporciona la informaci\u00f3n necesaria para lanzar una instancia EC2. As\u00ed pues, el primer paso consiste en elegir cual ser\u00e1 la AMI de nuestra instancia. Por ejemplo, una AMI que contenga un servidor de aplicaciones y otra que contenga un servidor de base de datos.</p> <p>Si vamos a montar un cluster, tambi\u00e9n podemos lanzar varias instancias a partir de una sola AMI.</p> <p></p> <p>Las AMI incluyen los siguientes componentes:</p> <ul> <li>Una plantilla para el volumen ra\u00edz de la instancia, el cual contiene un sistema operativo y todo lo que se instal\u00f3 en \u00e9l (aplicaciones, librer\u00edas, etc.). Amazon EC2 copia la plantilla en el volumen ra\u00edz de una instancia EC2 nueva y, a continuaci\u00f3n, la inicia.</li> <li>Permisos de lanzamiento que controlan qu\u00e9 cuentas de AWS pueden usar la AMI.</li> <li>La asignaci\u00f3n de dispositivos de bloques que especifica los vol\u00famenes que deben asociarse a la instancia en su lanzamiento, si corresponde.</li> </ul>"},{"location":"cloud/04computacion.html#tipos-de-ami","title":"Tipos de AMI","text":"<p>Puede elegir entre los siguientes tipos de AMI:</p> <ul> <li>Quick Start: AWS ofrece una serie de AMI predise\u00f1adas, tanto Linux como Windows, para lanzar las instancias.</li> <li>Mis AMI: estas son las AMI que hemos creado nosotros, ya sea a partir de m\u00e1quinas locales que hayamos creado en VmWare, VirtualBox, o una previa que hemos creado en una instancia EC2, configurado y luego exportado.</li> <li>AWS Marketplace: cat\u00e1logo que incluye miles de soluciones de software creadas por empresas terceras (las cuales pueden cobrar por su uso). Estas AMI pueden ofrecer casos de uso espec\u00edficos para que pueda ponerse en marcha r\u00e1pidamente.</li> <li>AMI de la comunidad: estas son AMI creadas por personas de todo el mundo.AWS no controla estas AMI, as\u00ed que deben utilizarse bajo la propia responsabilidad, evitando su uso en entornos corporativos o de producci\u00f3n.</li> </ul> <p>Las AMI dependen de la regi\u00f3n</p> <p>Las AMI que creamos se hacen en la regi\u00f3n en la que estamos conectados. Si la necesitamos en otra regi\u00f3n, debemos realizar un proceso de copia.</p>"},{"location":"cloud/04computacion.html#paso-2-tipo-de-instancias","title":"Paso 2: Tipo de instancias","text":"<p>El segundo paso es seleccionar un tipo de instancia, seg\u00fan nuestro caso de uso. Los tipos de instancia incluyen diversas combinaciones de capacidad de CPU, memoria, almacenamiento y red.</p> Paso 3 - Eligiendo el tipo de instancia <p>Cada tipo de instancia se ofrece en uno o m\u00e1s tama\u00f1os, lo cual permite escalar los recursos en funci\u00f3n de los requisitos de la carga de trabajo de destino.</p>"},{"location":"cloud/04computacion.html#categorias","title":"Categor\u00edas","text":"<p>Las categor\u00edas de tipos de instancia incluyen instancias de uso general, optimizadas para inform\u00e1tica, optimizadas para memoria, optimizadas para almacenamiento y de inform\u00e1tica acelerada.</p> Categor\u00eda Tipo de instancia Caso de uso Uso general a1, m4, m5, t2, t3 Amplio Computaci\u00f3n c5, c6 Alto rendimiento Memoria r5, r6, x1, z1 Big Data Inform\u00e1tica acelerada f1, g3, g4, p2, p3 Machine Learning Almacenamiento d2, h1, i3 Sistemas de archivos distribuidos"},{"location":"cloud/04computacion.html#tipos-de-instancias","title":"Tipos de instancias","text":"<p>Los tipos de instancias (https://aws.amazon.com/es/ec2/instance-types/) ofrecen familias, generaciones y tama\u00f1os. As\u00ed pues, el tipo de instancia <code>t3.large</code> referencia a la familia <code>T</code>, de la tercera generaci\u00f3n y con un tama\u00f1o <code>large</code>.</p> <p>En general, los tipos de instancia que son de una generaci\u00f3n superior son m\u00e1s potentes y ofrecen una mejor relaci\u00f3n calidad/precio.</p> <p>Comparando tipos de instancias</p> <p>Cuando se comparan los tama\u00f1os hay que examinar la parte del coeficiente en la categor\u00eda de tama\u00f1o. Por ejemplo, una instancia <code>t3.2xlarge</code> tiene el doble de CPU virtual y memoria que una <code>t3.xlarge</code>. A su vez, la instancia <code>t3.xlarge</code> tiene el doble de CPU virtual y memoria que una <code>t3.large</code>.</p> <p>Tambi\u00e9n se debe tener en cuenta que el ancho de banda de red tambi\u00e9n est\u00e1 vinculado al tama\u00f1o de la instancia de Amazon EC2. Si ejecutar\u00e1 trabajos que requieren un uso muy intensivo de la red, es posible que deba aumentar las especificaciones de la instancia para que satisfaga sus necesidades.</p> <p>A la hora de elegir un tipo de instancia, nos centraremos en la cantidad de n\u00facleos, el tama\u00f1o de la memoria, el rendimiento de la red y las tecnolog\u00edas de la propia CPU (si tiene habilitada GPU y FPGA)</p>"},{"location":"cloud/04computacion.html#paso-3-par-de-claves","title":"Paso 3: Par de claves","text":"<p>Para poner conectarnos a la instancia v\u00eda SSH y poder configurarla, necesitaremos hacerlo a trav\u00e9s de un par de claves SSH. As\u00ed pues, el siguiente paso es elegir un par de claves existente (formato X.509), continuar sin un par de claves o crear un par de claves nuevo antes de crear y lanzar la instancia EC2.</p> Paso 3 - Eligiendo el par de claves <p>Amazon EC2 utiliza la criptograf\u00eda de clave p\u00fablica para cifrar y descifrar la informaci\u00f3n de inicio de sesi\u00f3n. La clave p\u00fablica la almacena AWS, mientras que la clave privada la almacenamos nosotros.</p> <p>Guarda tus claves</p> <p>Si creamos una par de claves nuevas, hemos de descargarlas y guardarlas en un lugar seguro. Esta es la \u00fanica oportunidad de guardar el archivo de clave privada. Si perdemos las claves, tendremos que destruir la instancia y volver a crearla.</p> <p>Para conectarnos a la instancia desde nuestra m\u00e1quina local, necesitamos hacerlo via un cliente SSH / Putty adjuntando el par de claves descargado. Si la AMI es de Windows, utilizaremos la clave privada para obtener la contrase\u00f1a de administrador que necesita para iniciar sesi\u00f3n en la instancia. En cambio, si la AMI es de Linux, lo haremos mediante ssh:</p> <pre><code>ssh -i /path/miParClaves.pem miNombreUsuarioInstancia@miPublicDNSInstancia\n</code></pre> <p>Por ejemplo, si utilizamos la Amazon Linux AMI y descargamos las claves de AWS Academy (suponiendo que la ip p\u00fablica de la m\u00e1quina que hemos creado es <code>3.83.80.52</code>) nos conectar\u00edamos mediante:</p> <pre><code>ssh -i labsuser.pem ec2-user@3.83.80.52\n</code></pre> <p>Claves en AWS Academy</p> <p>Nuestro usuario tiene creado por defecto un par de claves que se conocen como <code>vockey</code>. Esta claves se pueden descargar desde la opci\u00f3n AWS Details del laboratorio de Learner Lab. M\u00e1s adelante, en esta misma sesi\u00f3n, veremos c\u00f3mo utilizarlas.</p> <p>M\u00e1s informaci\u00f3n en: https://docs.aws.amazon.com/es_es/AWSEC2/latest/UserGuide/AccessingInstances.html</p>"},{"location":"cloud/04computacion.html#paso-4-configuracion-de-la-red","title":"Paso 4: Configuraci\u00f3n de la red","text":"<p>El siguiente paso es especificar la ubicaci\u00f3n de red en la que se implementar\u00e1 la instancia EC2, teniendo en cuenta la regi\u00f3n donde nos encontramos antes de lanzar la instancia. En este paso, elegiremos la VPC y la subred dentro de la misma, ya sea de las que tenemos creadas o pudiendo crear los recursos en este paso.</p> Paso 4 - Configurando la red <p>Respecto a la asignaci\u00f3n p\u00fablica de ip sobre esta instancia, cuando se lanza una instancia en una VPC predeterminada, AWS le asigna una direcci\u00f3n IP p\u00fablica de forma predeterminada. En caso contrario, si la VPC no es la predeterminada, AWS no asignar\u00e1 una direcci\u00f3n IP p\u00fablica, a no ser que lo indiquemos de forma expl\u00edcita.</p>"},{"location":"cloud/04computacion.html#grupo-de-seguridad","title":"Grupo de seguridad","text":"<p>Un grupo de seguridad es un conjunto de reglas de firewall que controlan el tr\u00e1fico de red de una o m\u00e1s instancias, por lo que se encuentra fuera del sistema operativo de la instancia, formando parte de la VPC.</p> Grupo de seguridad <p>Dentro del grupo, agregaremos reglas para habilitar el tr\u00e1fico hacia o desde nuestras instancias asociadas. Para cada una de estas reglas especificaremos el puerto, el protocolo (TCP, UDP, ICMP), as\u00ed como el origen (por ejemplo, una direcci\u00f3n IP u otro grupo de seguridad) que tiene permiso para utilizar la regla.</p> <p>De forma predeterminada, se incluye una regla de salida que permite todo el tr\u00e1fico saliente. Es posible quitar esta regla y agregar reglas de salida que solo permitan tr\u00e1fico saliente espec\u00edfico.</p> <p>Servidor Web</p> <p>Si hemos seguido el ejemplo anterior y hemos a\u00f1adido en los datos de usuario el script para instalar Apache, debemos habilitar las peticiones entrantes en el puerto 80. Para ello crearemos una regla que permita el tr\u00e1fico HTTP.</p> <p></p> <p>AWS eval\u00faa las reglas de todos los grupos de seguridad asociados a una instancia para decidir si permite que el tr\u00e1fico llegue a ella. Si desea lanzar una instancia en una nube virtual privada (VPC), debe crear un grupo de seguridad nuevo o utilizar uno que ya exista en esa VPC.</p> <p>Las reglas de un grupo de seguridad se pueden modificar en cualquier momento, y las reglas nuevas se aplicar\u00e1n autom\u00e1ticamente a todas las instancias que est\u00e9n asociadas al grupo de seguridad.</p>"},{"location":"cloud/04computacion.html#asociar-un-rol-de-iam","title":"Asociar un rol de IAM","text":"<p>Si necesitamos que nuestras instancias EC2 ejecuten una aplicaci\u00f3n que debe realizar llamadas seguras de la API a otros servicios de AWS, en vez de dejar anotadas las credenciales en el c\u00f3digo de la aplicaci\u00f3n (esto es una muy mala pr\u00e1ctica que puede acarrear problemas de seguridad), debemos asociar un rol de IAM a una instancia EC2.</p> <p>El rol de IAM asociado a una instancia EC2 se almacena en un perfil de instancia. Si creamos el rol desde esta misma pantalla, AWS crear\u00e1 un perfil de instancia autom\u00e1ticamente y le otorgar\u00e1 el mismo nombre que al rol. En el desplegable la lista que se muestra es, en realidad, una lista de nombres de perfiles de instancia.</p> <p></p> <p>Cuando definimos un rol que una instancia EC2 puede utilizar, estamos configurando qu\u00e9 cuentas o servicios de AWS pueden asumir dicho rol, as\u00ed como qu\u00e9 acciones y recursos de la API puede utilizar la aplicaci\u00f3n despu\u00e9s de asumir el rol. Si cambia un rol, el cambio se extiende a todas las instancias que tengan el rol asociado.</p> <p>La asociaci\u00f3n del rol no est\u00e1 limitada al momento del lanzamiento de la instancia, tambi\u00e9n se puede asociar un rol a una instancia que ya exista.</p>"},{"location":"cloud/04computacion.html#paso-5-almacenamiento","title":"Paso 5: Almacenamiento","text":"<p>Al lanzar la instancia EC2 configuraremos las opciones de almacenamiento. Por ejemplo el tama\u00f1o del volumen ra\u00edz en el que est\u00e1 instalado el sistema operativo invitado o vol\u00famenes de almacenamiento adicionales cuando lance la instancia.</p> <p>Algunas AMI est\u00e1n configuradas para lanzar m\u00e1s de un volumen de almacenamiento de forma predeterminada y, de esa manera, proporcionar almacenamiento independiente del volumen ra\u00edz. Para cada volumen que tenga la instancia, podemos indicar el tama\u00f1o de los discos, los tipos de volumen, si el almacenamiento se conservar\u00e1 en el caso de terminaci\u00f3n de la instancia y si se debe utilizar el cifrado.</p> Paso 5 - Almacenamiento <p>En la sesi\u00f3n anterior ya comentamos algunos de los servicios de almacenamiento como pueden ser Amazon EBS (almacenamiento por bloques de alto rendimiento) o Amazon EFS (almacenamiento el\u00e1stico compartido entre diferentes instancias).</p>"},{"location":"cloud/04computacion.html#paso-6-detalles-avanzados","title":"Paso 6: Detalles avanzados","text":"<p>Las etiquetas son marcas que se asignan a los recursos de AWS. Cada etiqueta est\u00e1 formada por una clave y un valor opcional, siendo ambos campos case sensitive.</p> <p></p> <p>El etiquetado es la forma en que asocia metadatos a una instancia EC2. De esta manera podemos clasificar los recursos de AWS, como las instancias EC2, de diferentes maneras. Por ejemplo, en funci\u00f3n de la finalidad, el propietario o el entorno.</p> <p>Los beneficios potenciales del etiquetado son la capacidad de filtrado, la automatizaci\u00f3n, la asignaci\u00f3n de costes y el control de acceso.</p>"},{"location":"cloud/04computacion.html#script-de-datos-de-usuario","title":"Script de datos de usuario","text":"<p>Al momento de crear las instancias EC2, de forma opcional, podemos especificar un script de datos de usuario durante el lanzamiento de la instancia. Los datos de usuario pueden automatizar la finalizaci\u00f3n de las instalaciones y las configuraciones durante el lanzamiento de la instancia. Por ejemplo, un script de datos de usuario podr\u00eda colocar parches en el sistema operativo de la instancia y actualizarlo, recuperar e instalar claves de licencia de software, o instalar sistemas de software adicionales.</p> <p>Por ejemplo, si queremos instalar un servidor de Apache, de manera que arranque autom\u00e1ticamente y que muestre un Hola Mundo podr\u00edamos poner</p> <pre><code>#!/bin/bash\nyum update -y\nyum -y install httpd\nsystemctl enable httpd\nsystemctl start httpd\necho '&lt;html&gt;&lt;h1&gt;Hola Mundo desde el Severo!&lt;/h1&gt;&lt;/html&gt;' &gt; /var/www/html/index.html\n</code></pre> <p></p> <p>Script en Windows</p> <p>Si nuestra instancia es de Windows, el script de datos de usuario debe escribirse en un formato que sea compatible con una ventana del s\u00edmbolo del sistema (comandos por lotes) o con Windows PowerShell.</p> <p>De forma predeterminada, los datos de usuario s\u00f3lo se ejecutan la primera vez que se inicia la instancia.</p>"},{"location":"cloud/04computacion.html#paso-7-resumen","title":"Paso 7: Resumen","text":"<p>El paso final es una p\u00e1gina resumen con todos los datos introducidos. A la derecha se nos muestra todas las caracter\u00edsticas seleccionadas, pudiendo indicar cuantas instancias del mismo tipo queremos crear.</p> Paso 7 - Resumen <p>Por \u00faltimo, una vez lanzada la instancia, podemos observar la informaci\u00f3n disponible sobre la misma: direcci\u00f3n IP y la direcci\u00f3n DNS, el tipo de instancia, el ID de instancia \u00fanico asignado a la instancia, el ID de la AMI que utiliz\u00f3 para lanzar la instancia, el ID de la VPC, el ID de la subred, etc...</p> Caracter\u00edsticas de la instancia creada <p>En resumen, las instancias EC2 se lanzan desde una plantilla de AMI en una VPC de nuestra cuenta. Podemos elegir entre muchos tipos de instancias, con diferentes combinaciones de CPU, RAM, almacenamiento y redes. Adem\u00e1s, podemos configurar grupos de seguridad para controlar el acceso a las instancias (especificar el origen y los puertos permitidos). Al crear una instancia, mediante los datos de usuario, podemos especificar un script que se ejecutar\u00e1 la primera vez que se lance una instancia.</p>"},{"location":"cloud/04computacion.html#uso-de-la-consola","title":"Uso de la consola","text":"<p>En la sesi\u00f3n anterior ya utilizamos AWS CLI para conectarnos a AWS. En el caso concreto de EC2, es muy \u00fatil para crear, arrancar y detener instancias.</p> <p>Todos los comandos comenzar\u00e1n por <code>aws ec2</code>, seguida de la opci\u00f3n deseada. Si usamos el comando <code>aws ec2 help</code> obtendremos un listado enorme con todas las posibilidades.</p> <p>Vamos a comentar un par de casos de uso. Por ejemplo, para ejecutar una instancia utilizaremos el comando:</p> <pre><code>aws ec2 run-instances --image-id ami-04ad2567c9e3d7893 --count 1 --instance-type c3.large --key-name MiParejaDeClaves --security-groups MiGrupoSeguridad --region us-east-1\n</code></pre> <p>Los par\u00e1metros que permiten configurar la instancia son:</p> <ul> <li><code>image-id</code>: este par\u00e1metro va seguido de un ID de AMI. Recordad que todas las AMI tienen un ID de \u00fanico.</li> <li><code>count</code>: puede especificar m\u00e1s de una instancia.</li> <li><code>instance-type</code>:  tipo de instancia que se crear\u00e1, como una instancia <code>t2.micro</code></li> <li><code>key-name</code>: supongamos que <code>MiParejaDeClaves</code> ya existe.</li> <li><code>security-groups</code> : supongamos que <code>MiGrupoSeguridad</code> ya existe.</li> <li><code>region</code>: las AMI se encuentran en una regi\u00f3n de AWS, por lo que debe especificar la regi\u00f3n donde la CLI de AWS encontrar\u00e1 la AMI y lanzar\u00e1 la instancia EC2.</li> </ul> <p>Para que cree la instancia EC2, se debe cumplir que el comando tiene el formato correcto, y que todos los recursos y permisos existen, as\u00ed como saldo suficiente.</p> <p>Si queremos ver las instancias que tenemos creadas ejecutaremos el comando:</p> <pre><code>aws ec2 describe-instances\n</code></pre> <p>Comandos AWS CLI</p> <p>Es muy \u00fatil utilizar alguna de las cheatsheet disponibles en la red con los comandos m\u00e1s \u00fatiles a la hora de trabajar con AWS CLI.</p>"},{"location":"cloud/04computacion.html#caso-de-uso-mediante-aws-cli","title":"Caso de uso mediante AWS CLI","text":"<p>A continuaci\u00f3n vamos a crear un grupo de seguridad que permita el acceso via HTTP al puerto 80 y HTTPS al puerto 443 y conexi\u00f3n mediante SSH al puerto 22.</p> <p>Para ello, primero creamos el grupo de seguridad utilizando el comando create-security-group:</p> <pre><code>aws ec2 create-security-group --group-name iabd-front \\\n--description \"Grupo de seguridad para frontend\"\n</code></pre> <p>A continuaci\u00f3n a\u00f1adimos el acceso a ssh utilizando el comando authorize-security-group-ingress:</p> <pre><code>aws ec2 authorize-security-group-ingress --group-name iabd-front \\\n--protocol tcp --port 22 --cidr 0.0.0.0/0\n</code></pre> <p>A continuaci\u00f3n habilitamos el acceso http:</p> <pre><code>aws ec2 authorize-security-group-ingress --group-name iabd-front \\\n--protocol tcp --port 80 --cidr 0.0.0.0/0\n</code></pre> <p>A continuaci\u00f3n habilitamos el acceso https:</p> <pre><code>aws ec2 authorize-security-group-ingress --group-name iabd-front \\\n--protocol tcp --port 443 --cidr 0.0.0.0/0\n</code></pre> <p>Si queremos consultar el grupo de seguridad:</p> <pre><code>aws ec2 describe-security-groups --group-name iabd-front\n</code></pre> <p>Una vez creado y configurado el grupo de seguridad, vamos a crear una instancia utilizando el comando run-instances a partir de la AMI <code>ami-03ae0589c3c7b8599</code> (es una imagen Ubuntu 20.04), y crearemos un instancia de tipo <code>t3.large</code> (su coste aproximado es de menos de 10 c\u00e9ntimos por hora) con el grupo de seguridad que acabamos de crear y 30GB de almacenamiento EBS:</p> <pre><code>aws ec2 run-instances --image-id ami-03ae0589c3c7b8599 \\\n--count 1 --instance-type t3.large \\\n--key-name vockey --security-groups iabd-front \\\n--tag-specifications \"ResourceType=instance,Tags=[{Key=Name,Value=iabd}]\" \\\n--ebs-optimized \\\n--block-device-mapping \"[ { \\\"DeviceName\\\": \\\"/dev/sda1\\\", \\\"Ebs\\\": { \\\"VolumeSize\\\": 30 } } ]\"\n</code></pre> <p>El comando describe-instances tambi\u00e9n nos permite obtener informaci\u00f3n de nuestras instancias utilizando filtros. Asi pues, por ejemplo, si queremos obtener la ip p\u00fablica de la instancia que acabamos de crear podemos hacer:</p> <pre><code>aws ec2 describe-instances \\\n--filters \"Name=tag:Name,Values=iabd\" \\\n--query \"Reservations[*].Instances[*].PublicIpAddress\" \\\n--output text\n</code></pre> <p>El siguiente paso es conectarnos a nuestra instancia. Como hemos creado la instancia utilizando las credenciales vockey, vamos a descargar las claves desde la consola de Learner Labs donde antes hab\u00edamos consultado nuestras credenciales.</p> Claves SSH en AWS Academy <p>Una vez descargada la clave, ya sea mediante Download PEM o Download PPK, nos conectaremos utilizando el usuario <code>ubuntu</code> mediante:</p> SSH mediante Linux / MacPutty mediante Windows <p>Si nos situamos sobre la carpeta que contiene en el archivo descargado, cambiamos los permisos para que la clave s\u00f3lo tenga permisos de lectura:</p> <pre><code>chmod 400 labsuser.pem\n</code></pre> <p>Una vez que ya tenemos permisos de lectura sobre el archivo, nos conectamos mediante el comando <code>ssh</code>:</p> <pre><code>ssh -i labsuser.pem ubuntu@&lt;ip-publica&gt;\n</code></pre> <p>Descargamos el archivo <code>labuser.ppk</code>, y una vez configurada la ip p\u00fablica, en Connection -&gt; SSH -&gt; Auth, en la parte inferior donde podemos cargarlo mediante el bot\u00f3n Browse:</p> <p> Configuraci\u00f3n de Putty </p>"},{"location":"cloud/04computacion.html#ciclo-de-vida-de-las-instancias","title":"Ciclo de vida de las instancias","text":"<p>Las instancias en todo momento tienen un estado que se puede consultar:</p> <ul> <li>Pending (pendiente): nada m\u00e1s lanzarse o al arrancar una instancia detenida.</li> <li>Running (en ejecuci\u00f3n): cuando arranc\u00f3 la instancia por completo y est\u00e1 lista  para su uso. En este momento se empieza a facturar.</li> <li>Rebooting (reiniciada): AWS recomienda reiniciar las instancias con la consola de Amazon EC2, la CLI de AWS o los SDK de AWS, en lugar de utilizar el reinicio desde el sistema operativo invitado. Una instancia reiniciada permanece en el mismo host f\u00edsico, mantiene el mismo DNS p\u00fablico y la misma IP p\u00fablica y, si tiene vol\u00famenes del almac\u00e9n de instancias, conserva los datos en ellos.</li> <li>Shutting down (en proceso de terminaci\u00f3n / apag\u00e1ndose)</li> <li>Terminated (terminada): las instancias terminadas permanecen visibles en la consola de Amazon EC2 durante un tiempo antes de que se destruya la m\u00e1quina virtual. Sin embargo, no es posible conectarse a una instancia terminada ni recuperarla.</li> <li>Stopping (deteni\u00e9ndose): las instancias que cuentan con vol\u00famenes EBS se pueden detener.</li> <li>Stopped (detenida): no generar\u00e1 los mismos costes que una instancia en el estado running. S\u00f3lo se paga por el almacenamiento de datos. Solo se pueden detener las instancias que utilizan como almacenamiento EBS.</li> </ul> Ciclo de vida de una instancia <p>IPs est\u00e1ticas</p> <p>A cada instancia que recibe una  IP p\u00fablica se le asigna tambi\u00e9n un DNS externo. Por ejemplo, si la direcci\u00f3n IP p\u00fablica asignada a la instancia es <code>203.0.113.25</code>, el nombre de host DNS externo podr\u00eda ser <code>ec2-203-0-113-25.compute-1.amazonaws.com</code>. AWS libera la direcci\u00f3n IP p\u00fablica de la instancia cuando la instancia se detiene o se termina. La instancia detenida recibe una direcci\u00f3n IP p\u00fablica nueva cuando se reinicia. Si necesitamos una IP p\u00fablica fija, se recomienda utilizar una IP el\u00e1stica, asoci\u00e1ndola primero a la regi\u00f3n donde vaya a residir la instancia EC2. Recuerda que las IP el\u00e1sticas se pagan por cada hora que las tenemos reservadas y se deja de pagar por ellas si est\u00e1n asociadas a una instancia en ejecuci\u00f3n.</p>"},{"location":"cloud/04computacion.html#monitorizacion","title":"Monitorizaci\u00f3n","text":"<p>Aunque ya lo veremos en una sesi\u00f3n m\u00e1s adelante, podemos monitorizar las instancias EC2 mediante la herramienta Amazon CloudWatch con los datos que recopila y procesa, los cuales convierte en m\u00e9tricas legibles en intervalos por defecto de 5 minutos (aunque se puede habilitar el monitoreo detallado y monitorizar cada minuto)</p> <p>Estas estad\u00edsticas se registran durante un periodo de 15 meses, lo que nos permite obtener informaci\u00f3n hist\u00f3rica y sobre el rendimiento de nuestras instancias.</p>"},{"location":"cloud/04computacion.html#costes-de-las-instancias","title":"Costes de las instancias","text":"<p>Normalmente cuando iniciemos una instancia usaremos instancias bajo demanda (el cr\u00e9dito concedido por AWS Academy es en esa modalidad), pero conviene conocer el resto de formas que ofrecen diferentes facturaciones.</p> <p>AWS ofrece diferentes tipos pago de instancia:</p> Tipo Descripci\u00f3n Beneficios Uso bajo demanda se paga por hora, no tiene compromisos a largo plazo, y es apto para la capa gratuita de AWS. bajo coste y flexibilidad. Cargas de trabajo de corto plazo, con picos o impredecibles. Tambi\u00e9n para desarrollo o prueba de aplicaciones. spot Se puja por ellas. Se ejecutan siempre que est\u00e9n disponibles y que su oferta est\u00e9 por encima del precio de la instancia de spot. AWS puede interrumpirlas con una notificaci\u00f3n de 2 minutos. Los precios pueden ser considerablemente m\u00e1s econ\u00f3micos en comparaci\u00f3n con las instancias bajo demanda. Carga de trabajo din\u00e1mica y a gran escala. Aplicaciones con horarios flexibles de inicio y finalizaci\u00f3n. Aplicaciones que solo son viables con precios de computaci\u00f3n muy bajos. Usuarios con necesidades de computaci\u00f3n urgentes de grandes cantidades de capacidad adicional. instancia reservada Pago inicial completo, parcial o nulo para las instancias que reserve. Descuento en el cargo por hora por el uso de la instancia  (hasta 72%). Plazo de 1 o 3 a\u00f1os. Asegura capacidad de c\u00f3mputo disponible cuando se la necesita. Cargas de trabajo de uso predecible o estado estable. Aplicaciones que requieren capacidad reservada, incluida la recuperaci\u00f3n de desastres. Usuarios capaces de afrontar pagos iniciales para reducir a\u00fan m\u00e1s los costes de computaci\u00f3n. host reservado / dedicado Servidor f\u00edsico con capacidad de instancias EC2 totalmente dedicado a su uso. Ahorro de dinero en costes de licencia. Asistencia para cumplir los requisitos normativos y de conformidad. Licencia Bring your own (BYOL). Conformidad y restricciones normativas. Seguimiento del uso y las licencias. Control de la ubicaci\u00f3n de instancias. <p>La facturaci\u00f3n por segundo est\u00e1 disponible para las instancias bajo demanda, las instancias reservadas y las instancias de spot que solo utilizan Amazon Linux y Ubuntu.</p> <p>Las instancias reservadas supondr\u00e1n un ahorro econ\u00f3mico importante, si hay posibilidades econ\u00f3micas y previsi\u00f3n (de 12 a 36 meses), hasta de un 75% seg\u00fan las diferentes opciones:</p> <ul> <li>AURI - All up-front reserved instance: se realiza un pago inicial completo.</li> <li>PURI - Partial up-front reserved instance: se realiza una pago inicial parcial y cuotas mensuales.</li> <li>NURI - No up-front reserved instance: sin pago inicial, se realiza un pago mensual.</li> </ul> Modelos de pago de las instancias reservadas <p>El planteamiento ideal es utilizar instancias reservadas para la carga m\u00ednima de base de nuestro sistema, bajo demanda para autoescalar seg\u00fan necesidades y quiz\u00e1s las instancias spot para cargas opcionales que se contemplar\u00e1n s\u00f3lo si el coste es bajo.</p> <p>Puedes consultar el coste de las diferentes instancias en https://aws.amazon.com/es/ec2/pricing/reserved_instances, y consultar precios en https://aws.amazon.com/es/ec2/pricing/reserved-instances/pricing/</p>"},{"location":"cloud/04computacion.html#optimizacion-de-costes","title":"Optimizaci\u00f3n de costes","text":"<p>Los cuatro pilares de la optimizaci\u00f3n de costes son:</p> <ul> <li>Adaptaci\u00f3n del tama\u00f1o: consiste en conseguir el equilibrio adecuado de los tipos de instancias. Los servidores pueden desactivarse o reducirse y seguir cumpliendo con sus requisitos de rendimiento. Si seguimos las m\u00e9tricas de Amazon Cloudwatch podremos ver el porcentaje de actividades de las instancias o los rangos horarios donde est\u00e1n inactivas. Se recomienda primero adaptar el tama\u00f1o, y una vez que ya es estable la configuraci\u00f3n, utilizar instancias reservadas.</li> <li>Aumento de la elasticidad: mediante soluciones el\u00e1sticas podemos reducir la capacidad del servidor (por ejemplo, deteniendo o hibernando las instancias que utilizan Amazon EBS que no est\u00e1n activas, como puedan ser entornos de prueba o durante las noches) o utilizar el escalado autom\u00e1tico para administrar picos de cargas.</li> <li>Modelo de precios \u00f3ptimo: hay que conocer las opciones de precios disponibles, analizando los patrones de uso para combinar los tipos de compra. Por ejemplo, utilizar instancias bajo demanda e instancias de spot para las cargas de trabajo variables, incluso el uso de funciones serverless.</li> <li>Optimizaci\u00f3n de las opciones de almacenamiento: hay que reducir la sobrecarga de almacenamiento sin utilizar siempre que sea posible (reduciendo el tama\u00f1o de los vol\u00famenes) y elegir las opciones de almacenamiento m\u00e1s econ\u00f3micas si cumplen los requisitos de rendimiento de almacenamiento. Otro caso puede ser el eliminar las instancias EBS que ya no se necesitan o las copias de seguridad ya pasadas.</li> </ul>"},{"location":"cloud/04computacion.html#aws-lambda","title":"AWS Lambda","text":"<p>La inform\u00e1tica serverless permite crear y ejecutar aplicaciones y servicios sin aprovisionar ni administrar servidores.</p> <p>AWS Lambda (https://aws.amazon.com/es/lambda/) es un servicio de inform\u00e1tica sin servidor que proporciona tolerancia a errores y escalado autom\u00e1tico, y que se factura por el tiempo de ejecuci\u00f3n (cantidad de milisegundos por el n\u00famero de invocaciones a la funci\u00f3n). Para ello, permite la ejecuci\u00f3n de c\u00f3digo en el servidor con soporte para m\u00faltiples lenguajes (Java, C#, Python, Go, ...) sin necesidad de configurar una instancia EC2.</p> <p>Un origen de eventos es un servicio de AWS (S3, DynamoDB, Elastic Load Balancing...) o una aplicaci\u00f3n creada por un desarrollador que desencadena la ejecuci\u00f3n de una funci\u00f3n de Lambda. Podemos encadenar funciones Lambda para flujos de trabajo mediante AWS Step Functions.</p>"},{"location":"cloud/04computacion.html#creando-una-funcion","title":"Creando una funci\u00f3n","text":"<p>Al crear una funci\u00f3n Lambda, primero le asignaremos un nombre a la funci\u00f3n. Tras  elegir el entorno de ejecuci\u00f3n (versi\u00f3n de Python, Node.js, etc...), hemos de elegir el rol de ejecuci\u00f3n (en el caso de AWS Academy, elegimos el rol LabRole), mediante un permiso de IAM, dependiendo de los servicios con los que tenga que interactuar...(al menos el rol <code>AWSLambdaBasicExecutionRole</code> y <code>AWSLambdaVPCAccessExecutionRole</code>).</p> <p>Respecto a la configuraci\u00f3n de la funci\u00f3n, deberemos:</p> <ul> <li>Agregar un desencadenador / origen de evento.</li> <li>Agregar el c\u00f3digo de la funci\u00f3n.</li> <li>Especificar la cantidad de memoria en MB que se asignar\u00e1 a la funci\u00f3n (de 128MB a 3008MB)</li> <li>Si queremos, podemos configurar las variables del entorno, la descripci\u00f3n, el tiempo de espera, la VPC espec\u00edfica en la que se debe ejecutar la funci\u00f3n, las etiquetas que desea utilizar y otros ajustes.</li> </ul> Ejemplo de funci\u00f3n Lambda <p>Cargando c\u00f3digo</p> <p>Adem\u00e1s de poder utilizar el IDE que ofrece AWS, podemos subir nuestras propias funciones en formato zip o desde S3. El fichero que contiene las funciones por defecto se llamar\u00e1 <code>lambda_function</code> y el manejador <code>def_handler</code>. Si queremos cambiar alguno de esos nombres, hay que editar el controlador en la configuraci\u00f3n en tiempo de ejecuci\u00f3n de la funci\u00f3n.</p>"},{"location":"cloud/04computacion.html#restricciones","title":"Restricciones","text":"<p>Las restricciones m\u00e1s destacables son:</p> <ul> <li>Permite hasta 1000 ejecuciones simult\u00e1neas en una \u00fanica regi\u00f3n.</li> <li>La cantidad m\u00e1xima de memoria que se puede asignar para una sola funci\u00f3n Lambda es de 3008 MB.</li> <li>El tiempo de ejecuci\u00f3n m\u00e1ximo para una funci\u00f3n Lambda es de 15 minutos.</li> </ul>"},{"location":"cloud/04computacion.html#aws-elastic-beanstalk","title":"AWS Elastic Beanstalk","text":"<p>AWS ElasticBeanstalk es un servicio PaaS que facilita la implementaci\u00f3n, el escalado y la administraci\u00f3n de aplicaciones y servicios web con rapidez. Nosotros, como desarrolladores, s\u00f3lo deberemos cargar el c\u00f3digo, elegir el tipo de instancia y de base de datos, configurar y ajustar el escalador autom\u00e1tico. Beanstalk autom\u00e1ticamente administra la implementaci\u00f3n, desde el aprovisionamiento de capacidad, el balanceo de carga y el escalado autom\u00e1tico hasta la monitorizaci\u00f3n del estado de las aplicaciones. Al mismo tiempo, si queremos, podemos mantener el control total de los recursos de AWS que alimentan la aplicaci\u00f3n y acceder a los recursos subyacentes en cualquier momento.</p> Ejemplo de despliegue con Beanstalk <p>Es compatible con Java, .NET, PHP, Node.js, Python, Ruby, Go y Docker, y se desplegan en servidores como Apache, Nginx o IIS.</p> <p>No se aplican cargos por utilizar ElasticBeanstalk, solo se paga por los recursos que AWS utilice (instancia, base de datos, almacenamiento S3, etc...)</p>"},{"location":"cloud/04computacion.html#referencias","title":"Referencias","text":"<ul> <li>Amazon EC2</li> <li>Funciones Lambda en AWS</li> </ul>"},{"location":"cloud/04computacion.html#actividades","title":"Actividades","text":"<ol> <li>(RA5075.2 / CE5.2b / 1p) Realizar el m\u00f3dulo 6 (Inform\u00e1tica) del curso ACF de AWS.</li> <li>(RA5075.2 / CE5.2b / 1p) Crea una instancia ec2 mediante AWS CLI, siguiendo todos los pasos del apartado Uso de la consola. Adjunta una captura con todos los comandos empleados y el resultado que aparece en la consola. Adem\u00e1s, con\u00e9ctate mediante SSH a la m\u00e1quina creada, y realiza una nueva captura.</li> </ol>"},{"location":"cloud/05emr.html","title":"AWS Elastic Map Reduce","text":"Logo de AWS EMR <p>Amazon EMR es un servicio de Amazon Web Services que permite crear clusters Hadoop y Spark, mediante el cual podemos realizar anal\u00edticas sobre datos y cargas de BI, as\u00ed como transformar y mover grandes vol\u00famenes de datos, tanto cargando como almacenando datos en servicios de AWS como S3 y DynamoDB.</p> <p>Para ello, utiliza una distribuci\u00f3n propia de AWS que permite seleccionar los componentes que van a lanzarse en el cluster (Hive, Spark, Presto, etc...)</p> Servicios Hadoop en EMR <p>Ofrece elasticidad sobre el cluster, pudiendo modificar din\u00e1micamente el dimensionamiento del cluster seg\u00fan necesidades, tanto hacia arriba como hacia abajo de cl\u00faster que est\u00e1n en ejecuci\u00f3n.</p> <p>Respecto al hardware, se ejecuta sobre m\u00e1quinas EC2 (IaaS), las cuales podemos configurar seg\u00fan necesidades. Utiliza HDFS y S3 para el almacenamiento, de manera que podemos guardar los datos de entrada y los de salida en S3, mientras que los resultados intermedios los almacenamos en HDFS.</p> <p>Los cluster de EMR se componen de:</p> <ul> <li>un nodo maestro, encargado de gestionar el cluster y ejecutar los servicios de coordinaci\u00f3n de datos.</li> <li>varios nodos principales, los cuales ejecutan las tareas y almacenan los datos en el cl\u00faster HDFS.</li> <li>nodos tareas, los cuales son opcionales, y no almacenan datos, y podemos a\u00f1adir a un cluster para incrementar la capacidad de procesamiento (e eliminarlos una vez no los necesitamos para reducir costes).</li> </ul> <p>A nivel de servicios, podemos definir su arquitectura en cuatro capas:</p> <ul> <li>Almacenamiento: mediante HFDS, EMR FS o el sistema de archivos local (almacenamiento de las instancias EC2).</li> <li>Gestor de recursos del cluster: YARN</li> <li>Frameworks de procesamiento de datos: Hadoop MapReduce y Apache Spark</li> <li>Aplicaciones: Apache Spark, Apache Hive, etc...</li> </ul>"},{"location":"cloud/05emr.html#lanzando-emr","title":"Lanzando EMR","text":"<p>Antes de lanzar EMR, necesitamos crear un repositorio de informaci\u00f3n donde guardar los datos de entrada y salida, as\u00ed como los logs que EMR genere.</p> <p>Para ello, en S3 generaremos un bucket al que llamaremos <code>s3severo8a-emr</code>.</p> <p>Podemos lanzar un cluster de EMR de tres formas, mediante la consola, el CLI o con un API. Vamos a centrar en el uso de la consola.</p> <p>A continuaci\u00f3n, accedemos al servicio de EMR, y creamos un cluster el cual hemos llamado <code>ClusterEMRs8a</code> y le indicamos la carpeta en S3 que acabamos de crear, as\u00ed como en el modo de lanzamiento elegimos Cl\u00faster:</p> Creando un cl\u00faster en EMR <p>A continuaci\u00f3n, elegimos como tipo de instancia <code>m4.large</code> (2 CPU y 8 GiB RAM) y como par de claves <code>vockey</code>, las cuales podemos descargar desde AWS Details al lanzar nuestro Learner Lab:</p> Eligiendo instancias y clave SSH <p>Tras darle a crear, a los 10 minutos aproximadamente, nuestro cl\u00faster estar\u00e1 listo para trabajar con \u00e9l.</p> <p>Modos de lanzamiento</p> <p>Normalmente, cuando utilizamos un cl\u00faster para procesar anal\u00edticas, interactuar con aplicaciones de big data o procesamiento de datasets de forma peri\u00f3dica, el cl\u00faster est\u00e1 siempre corriendo, a no ser que lo detengamos nosotros de forma expl\u00edcita. Pero si queremos que s\u00f3lo exista durante la ejecuci\u00f3n de uno o m\u00e1s trabajos, el cual se le conoce como cl\u00faster transient o de ejecuci\u00f3n por pasos, al terminar de ejecutar los pasos indicados, el cl\u00faster se detendr\u00e1.</p>"},{"location":"cloud/05emr.html#preparando-al-cluster","title":"Preparando al cl\u00faster","text":"<p>En un cluster EMR, el nodo maestro es una instancia EC2 que coordina al resto de instancias EC2 que corren los nodos principales y de tareas. Este nodo expone un DNS p\u00fablico el cual podemos utilizar para conectarnos.</p> <p>Por defecto, EMR crea un grupo de seguridad para el nodo maestro el cual determina el acceso. De inicio, es grupo de seguridad no permite las conexiones SSH. Por ello, antes de poder conectarnos al cluster, necesitamos modificar el grupo de seguridad del nodo principal para permitir todo el tr\u00e1fico TCP y el SSH.</p> Permitiendo todas las conexiones de entrada <p>De forma paralela, por defecto, EMR bloquea el arranque de los cl\u00faster que permitan las conexiones del exterior (esto nos puede pasar si al crear el cl\u00faster le asignamos un grupo de seguridad que ya ten\u00edamos creado y que permit\u00eda el tr\u00e1fico entrante).</p> <p>Para permitir el acceso desde el exterior, podemos arrancar un cl\u00faster con el trafico cerrado, y una vez ya ha arrancado cambiar su grupo de seguridad, o en la opci\u00f3n de Bloquear el acceso p\u00fablico de EMR, desactivarlo:</p> Desactivando el bloqueo del acceso p\u00fablico"},{"location":"cloud/05emr.html#conectandonos-al-cluster","title":"Conect\u00e1ndonos al cl\u00faster","text":"<p>Una vez arrancado, nos podemos conectar al nodo principal.</p> Cluster arrancado <p>Por ejemplo, podemos conectarnos a:</p> <ul> <li>El namenode de HDFS</li> <li>Hue (mal traducido a Tonalidad)</li> <li>El interfaz de Tez</li> <li>O la de YARN</li> </ul> <p>Parece que funciona pero...</p> <p>Una vez arrancado, a d\u00eda de hoy tenemos un par de propiedades que modificar, ya que el acceso web a HDFS est\u00e1 bloqueado, y la ruta de HDFS en Hue est\u00e1 mal configurada.</p> <p>As\u00ed pues, vamos a conectarnos v\u00eda SSH para activar el navegador web de HDFS. Con nuestras claves <code>labsuser.pem</code> descargadas, nos conectamos al cl\u00faster (recuerda poner <code>hadoop@</code> delante de la URL del namenode):</p> <pre><code>ssh -i labsuser.pem hadoop@ec2-34-232-48-47.compute-1.amazonaws.com\n</code></pre> <p>Al conectarnos, tanto EC2 como EMR nos dar\u00e1n la bienvenida:</p> <pre><code>       __|  __|_  )\n       _|  (     /   Amazon Linux 2 AMI\n      ___|\\___|___|\n\nhttps://aws.amazon.com/amazon-linux-2/\n22 package(s) needed for security, out of 32 available\nRun \"sudo yum update\" to apply all updates.\n\nEEEEEEEEEEEEEEEEEEEE MMMMMMMM           MMMMMMMM RRRRRRRRRRRRRRR    \nE::::::::::::::::::E M:::::::M         M:::::::M R::::::::::::::R   \nEE:::::EEEEEEEEE:::E M::::::::M       M::::::::M R:::::RRRRRR:::::R \n  E::::E       EEEEE M:::::::::M     M:::::::::M RR::::R      R::::R\n  E::::E             M::::::M:::M   M:::M::::::M   R:::R      R::::R\n  E:::::EEEEEEEEEE   M:::::M M:::M M:::M M:::::M   R:::RRRRRR:::::R \n  E::::::::::::::E   M:::::M  M:::M:::M  M:::::M   R:::::::::::RR   \n  E:::::EEEEEEEEEE   M:::::M   M:::::M   M:::::M   R:::RRRRRR::::R  \n  E::::E             M:::::M    M:::M    M:::::M   R:::R      R::::R\n  E::::E       EEEEE M:::::M     MMM     M:::::M   R:::R      R::::R\nEE:::::EEEEEEEE::::E M:::::M             M:::::M   R:::R      R::::R\nE::::::::::::::::::E M:::::M             M:::::M RR::::R      R::::R\nEEEEEEEEEEEEEEEEEEEE MMMMMMM             MMMMMMM RRRRRRR      RRRRRR\n\n[hadoop@ip-172-31-15-67 ~]$\n</code></pre>"},{"location":"cloud/05emr.html#visualizando-hdfs","title":"Visualizando HDFS","text":"<p>Para poder visualizar el sistema de archivos de HDFS, primero le cambiamos los permisos al <code>hdfs-site.xml</code> para poder editarlo sin problemas:</p> <pre><code>sudo chmod 777 /etc/hadoop/conf/hdfs-site.xml\nnano /etc/hadoop/conf/hdfs-site.xml\n</code></pre> <p>Editamos la propiedad <code>dfs.webhdfs.enabled</code> y la ponemos a <code>true</code>:</p> <pre><code>&lt;property&gt;\n&lt;name&gt;dfs.webhdfs.enabled&lt;/name&gt;\n&lt;value&gt;false&lt;/value&gt;\n&lt;/property&gt;\n</code></pre> <p>S\u00f3lo nos queda reiniciar el servicio de HDFS:</p> <pre><code>sudo systemctl restart hadoop-hdfs-namenode\n</code></pre> <p>Y ahora desde el interfaz de HDFS ya podemos navegar por las carpetas y ver el contenido:</p> Interfaz de HDFS"},{"location":"cloud/05emr.html#hue-y-hdfs","title":"Hue y HDFS","text":"<p>Cuando arranca Hue, la primera vez nos pide crear un usuario (en nuestro caso, hemos creado el usuario <code>iabd</code> con contrase\u00f1a <code>IABDiabd1.</code>)</p> Login de acceso a Hue <p>Si intentamos visualizar los archivos, de igual modo, Hue no tiene bien configurado el acceso a HDFS:</p> Error al mostrar los archivos en Hue <p>Para ello, igual que hemos realizado antes, cambiamos los permisos y editamos el fichero de configuraci\u00f3n:</p> <pre><code>sudo chmod 777 /etc/hue/conf/hue.ini\nnano /etc/hue/conf/hue.ini\n</code></pre> <p>Y configuramos bien el puerto de acceso (debe ser 50070), dentro del grupo <code>[[hdfs_clusters]]</code> de <code>[hadoop]</code> editamos la propiedad <code>webhdfs_url</code>:</p> <pre><code>webhdfs_url = http://ip-172-31-15-67.ec2.internal:50070/webhdfs/v1\n</code></pre> <p>Y reiniciamos el servicio:</p> <pre><code>sudo systemctl restart hue\n</code></pre> <p>S\u00f3lo nos queda crear un carpeta para nuestro usuario en HDFS:</p> <pre><code>hdfs dfs -mkdir /user/iabd\n</code></pre> <p>Y ya podemos trabajar con Hue.</p> Visualizando HDFS desde Hue"},{"location":"cloud/05emr.html#escalando","title":"Escalando","text":"<p>Podemos ajustar el n\u00famero de instancias EC2 con las que trabaja nuestro cl\u00faster de EMR, ya sea manualmente o de forma autom\u00e1tica en respuesta a la demanda que reciba.</p> Escalando un cl\u00faster EMR <p>Para ello, podemos activar el escalado gestionado mediante EMR o crear una pol\u00edtica de escalado a medida. Independiente del modo, hemos de considerar que siempre hemos de tener de uno a tres nodos maestros, y que una vez creado el cl\u00faster, este n\u00famero no lo podemos cambiar. Lo que s\u00ed que podemos es a\u00f1adir y eliminar nodos principales o de tareas.</p> A\u00f1adiendo un nodo de tipo tarea <p>Conviene destacar que no podemos reconfigurar y redimensionar el cl\u00faster al mismo tiempo, de manera que hasta que no acabe la reconfiguraci\u00f3n de un grupo de instancias no se puede iniciar el redimensionado.</p>"},{"location":"cloud/05emr.html#costes","title":"Costes","text":"<p>Es muy importante ser conscientes de los costes que lleva utilizar EMR. A grosso modo, EMR supone un 25% de sobrecoste a las instancias ECS, es decir, pagaremos el coste del alquiler de las m\u00e1quinas EC2 m\u00e1s un sobre un incremento del 25%.</p> <p>Por ejemplo, para 20 nodos con 122 Gb RAM, 16 vCPU, pagar\u00edamos unos 32 \u20ac/h.</p>"},{"location":"cloud/05emr.html#referencias","title":"Referencias","text":"<ul> <li>Tutorial de EMR en AWS</li> <li>AWS EMR Tutorial - Johnny Chivers - Youtube</li> </ul>"},{"location":"cloud/05emr.html#actividades","title":"Actividades","text":"<ol> <li>(RA5075.2 / CE5.2b / 1p) Arranca un cl\u00faster EMR con 3 m\u00e1quinas y modifica las configuraciones de HDFS y Hue para poder visualizar los archivos.</li> <li>(RA5075.2 / CE5.2e / 1p) A continuaci\u00f3n, a\u00f1ade un cuarto nodo al cl\u00faster y sube un archivo a HDFS. Tras ello, reescala el cl\u00faster para que quede en tres nodos. Vuelve a acceder a HDFS y comprueba que el archivo sigue estando disponible.</li> </ol>"},{"location":"cloud/06datos.html","title":"Datos en la nube","text":"<p>Ya hemos visto que el almacenamiento en la nube ofrece un gran n\u00famero de ventajas. Otro de los productos estrella de la computaci\u00f3n en la nube es el uso de bases de datos, ya sean distribuidas o no.</p> <p>La principal ventaja de utilizar un servicio de base de datos basado en la nube es que no requieren de la administraci\u00f3n por parte del usuario. \u00c9ste s\u00f3lo utiliza el servicio sin necesidad de tener conocimientos avanzados sobre su administraci\u00f3n. Estos servicios se conocen como administrados, ya que la propia plataforma cloud se encarga de gestionar el escalado, las copias de seguridad autom\u00e1ticas, la tolerancia a errores y la alta disponibilidad, y por tanto, estos servicios forman parte de una soluci\u00f3n PaaS.</p> <p>Si nosotros cre\u00e1semos una instancia EC2 e instal\u00e1semos cualquier sistema gestor de base de datos, como MariaDB o PostgreSQL, ser\u00edamos responsables de varias tareas administrativas, como el mantenimiento del servidor y la huella energ\u00e9tica, el software, la instalaci\u00f3n, la implementaci\u00f3n de parches y las copias de seguridad de la base de datos, as\u00ed como de garantizar su alta disponibilidad, de planificar la escalabilidad y la seguridad de los datos, y de instalar el sistema operativo e instalarle los respectivos parches.</p>"},{"location":"cloud/06datos.html#datos-relacionales-amazon-rds","title":"Datos relacionales - Amazon RDS","text":"<p>AWS ofrece Amazon RDS (https://aws.amazon.com/es/rds/) como servicio administrado que configura y opera una base de datos relacional en la nube, de manera que como desarrolladores s\u00f3lo hemos de enfocar nuestros esfuerzos en los datos y optimizar nuestras aplicaciones.</p>"},{"location":"cloud/06datos.html#instancias-de-bases-de-datos","title":"Instancias de bases de datos","text":"<p>Una instancia de base de datos es un entorno de base de datos aislado que puede contener varias bases de datos creadas por el usuario. Se puede acceder a \u00e9l utilizando las mismas herramientas y aplicaciones que utiliza con una instancia de base de datos independiente.</p> <p>Cuando vamos a crear una instancia de base de datos, primero hemos de indicar qu\u00e9 motor de base de datos ejecutar. Actualmente, RDS admite seis motores de bases de datos:</p> <ul> <li>MySQL, compatible con las versiones 5.6, 5.7 y 8.0.</li> <li>Amazon Aurora</li> <li>Microsoft SQL Server, que permite implementar varias versiones de SQL Server (2012, 2014, 2016, 2017 y 2019), incluidas las Express, Web, Standard y Enterprise.</li> <li>PostgreSQL, compatible con las versiones 9.6, 10, 11 y 12.</li> <li>MariaDB, compatible con las versiones 10.2, 10.3, 10.4 y 10.5</li> <li>y Oracle, compatible con Oracle 12 y Oracle 19, con dos modelos de licencia diferentes: Licencia incluida y Bring-Your-Own-License (BYOL).</li> </ul> <p>Los recursos que se encuentran en una instancia de base de datos se definen en funci\u00f3n de la clase de instancia de base de datos, y el tipo de almacenamiento se determina por el tipo de disco. Las instancias y el almacenamiento de base de datos difieren en cuanto a las caracter\u00edsticas de rendimiento y al precio, lo que permite adaptar el coste y el rendimiento a las necesidades de nuestra base de datos.</p> Instancia de RDS <p>Por ejemplo, si seleccionamos el motor de MariaDB, podemos observar como mediante la creaci\u00f3n sencilla nos ofrece tres propuestas de tama\u00f1o, dependiendo de si es para el entorno de producci\u00f3n, desarrollo y pruebas o el de la capa gratuita.</p> Configuraci\u00f3n de tama\u00f1o de la instancia con MariaDB"},{"location":"cloud/06datos.html#alta-disponibilidad","title":"Alta disponibilidad","text":"<p>Una de las caracter\u00edsticas m\u00e1s importantes de RDS es la capacidad de configurar la instancia de base de datos para una alta disponibilidad con una implementaci\u00f3n Multi-AZ. Al hacerlo, se genera de manera autom\u00e1tica una copia en espera de la instancia de base de datos en otra zona de disponibilidad dentro de la misma VPC. Despu\u00e9s de propagar la copia de la base de datos, las transacciones se replican de forma s\u00edncrona a la copia en espera.</p> Alta disponibilidad en Multi-AZ <p>Por lo tanto, si la instancia de base de datos principal falla en una implementaci\u00f3n Multi-AZ, RDS activa autom\u00e1ticamente la instancia de base de datos en espera como la nueva instancia principal.</p>"},{"location":"cloud/06datos.html#replica-de-lectura","title":"R\u00e9plica de lectura","text":"<p>RDS tambi\u00e9n admite la creaci\u00f3n de r\u00e9plicas de lectura para MySQL, MariaDB, PostgreSQLy Amazon Aurora. </p> R\u00e9plica de lectura <p>Las actualizaciones que se realizan en la instancia principal se copian de manera as\u00edncrona en la instancia de r\u00e9plica de lectura, de manera que direccionando las consultas a esta nueva r\u00e9plica reduciremos la carga de la instancia principal.</p> <p>Las r\u00e9plicas de lectura tambi\u00e9n pueden convertirse en la instancia de base de datos principal, pero, debido a la replicaci\u00f3n as\u00edncrona, este proceso debe hacerse de forma manual.</p> <p>Las r\u00e9plicas de lectura pueden crearse en una regi\u00f3n diferente a la utilizada por la base de datos principal, lo que puede mejorar la recuperaci\u00f3n de desastres y/o disminuir la latencia al dirigir las lecturas a una r\u00e9plica de lectura lo m\u00e1s cercana al usuario.</p>"},{"location":"cloud/06datos.html#casos-de-uso","title":"Casos de uso","text":"<p>AmazonRDS es ideal para las aplicaciones web y m\u00f3viles que necesitan una base de datos con alto rendimiento, enorme escalabilidad en el almacenamiento y alta disponibilidad.</p> <p>Se recomienda RDS cuando nuestra aplicaci\u00f3n necesite:</p> <ul> <li>Transacciones o consultas complejas</li> <li>Tasa de consulta o escritura media a alta: hasta 30.000 IOPS (15.000 lecturas + 15.000 escrituras)</li> <li>No m\u00e1s de una \u00fanica partici\u00f3n o nodo de trabajo</li> <li>Alta durabilidad</li> </ul> <p>En cambio, no se recomienda cuando:</p> <ul> <li>Tasas de lectura o escritura muy grandes (por ejemplo, 150.000 escrituras por segundo)</li> <li>Fragmentaci\u00f3n causada por el gran tama\u00f1o de los datos o las altas demandas de rendimiento</li> <li>Solicitudes y consultas GET o PUT simples que una base de datos NoSQL puede manejar</li> <li>Personalizaci\u00f3n del sistema de administraci\u00f3n de bases de datos relacionales (en este caso, es mejor instalar por nuestra cuenta el SGBD que necesitemos en una instancia EC2).</li> </ul>"},{"location":"cloud/06datos.html#costes","title":"Costes","text":"<p>El coste se calcula en base al tiempo de ejecuci\u00f3n (calculado en horas) as\u00ed como las caracter\u00edsticas de la base de datos. Las caracter\u00edsticas de la base de datos var\u00edan seg\u00fan el motor, el tipo de instancia y su cantidad, as\u00ed como la clase de memoria de la base de datos.</p> <p>Otros gastos asociados son:</p> <ul> <li>almacenamiento aprovisionado: el almacenamiento para copias de seguridad de hasta el 100% del almacenamiento de nuestra base de datos activa es gratuito. Una vez que se termina la instancia de base de datos, el almacenamiento para copias de seguridad se factura por GB por mes.</li> <li>cantidad de solicitudes de entrada y de salida.</li> </ul> <p>Aunque se recomienda utilizar la calculadora de costes para afinar en el presupuesto, por ejemplo, una base de datos con MariaDB con una instancia <code>db.m4.large</code> con 2 procesadores y 8GB de RAM, en una \u00fanica AZ, con un porcentaje de utilizaci\u00f3n del 100%  y 30GB para almacenar los datos, cuesta alrededor de 131$ mensuales. En cambio si la cambiamos por dos instancias m\u00e1s potentes, como puede ser la <code>db.m4.4xlarge</code>, con 16 procesadores y 64 GB de RAM, en multi-AZ ya sube a unos 4.100$ al mes.</p> <p>Es importante recordar que si reservamos las instancias estos costes se reducir\u00edan en proporci\u00f3n a 2350$ (reserva de un a\u00f1o) o 1526$ (reserva de tres a\u00f1os).</p>"},{"location":"cloud/06datos.html#ejemplo-rds","title":"Ejemplo RDS","text":"<p>A continuaci\u00f3n vamos a hacer un ejemplo sencillo donde vamos a crear una base de datos con la informaci\u00f3n que vimos en el bloque de SQL. Para ello, crearemos una instancia de MariaDB y nos conectaremos desde HeidiSQL.</p> Creaci\u00f3n de la BD en RDS <p>As\u00ed pues, desde la consola de AWS, crearemos nuestra base de datos a la que llamaremos <code>instituto</code>.</p> <p>En nuestro caso hemos seguido la creaci\u00f3n est\u00e1ndar con una plantilla de la capa gratuita (utiliza una instancia <code>db.t4g.micro</code>). Una vez configurado el usuario <code>admin</code> y la contrase\u00f1a <code>adminadmin</code> (al menos debe tener ocho caracteres), debemos configurar la conectividad.</p> Configuraci\u00f3n de la conectividad en RDS <p>Instancias permitidas en AWS Academy</p> <p>Si quer\u00e9is crear bases de datos con m\u00e1quinas m\u00e1s potentes, pod\u00e9is utilizar instancias hasta nivel large, y a ser posible a r\u00e1fagas (instancias t). Dentro de la Configuraci\u00f3n adicional, es importante deshabilitar la monitorizaci\u00f3n mejorada (no tenemos permiso para su uso en AWS Academy).</p> <p>Como vamos a querer acceder a nuestro servidor de MariaDB desde fuera de una VPC de EC2, necesitamos configurar el acceso p\u00fablico. Al hacerlo, no quiere decir que ya sea accesible desde fuera de internet, ya que necesitamos configurar su grupo de seguridad (recordad que funciona a modo de firewall). As\u00ed pues, es recomendable crear un nuevo grupo de seguridad para que permitamos las conexiones del puerto 3306 a nuestra IP.</p> Configuraci\u00f3n de la conectividad en RDS <p>As\u00ed pues, una vez creada (lo cual tarda unos minutos), podremos seleccionar la instancia creada y ver su panel de informaci\u00f3n:</p> Resumen de instancia en RDS <p>As\u00ed pues, si copiamos la informaci\u00f3n del punto de enlace y creamos una conexi\u00f3n en DBeaver, veremos que nos conectamos correctamente (si no hemos creado un nuevo grupo de seguridad, deberemos editar el grupo de seguridad por defecto, y a\u00f1adir una regla de entrada para el protocolo TCP para el puerto 3306, y por ejemplo para todo internet - <code>0.0.0.0/0</code>).</p> Configuraci\u00f3n en DBeaver <p>Una vez conectado, ya procedemos de la misma manera que si tuvi\u00e9ramos la base de datos en un entorno local.</p>"},{"location":"cloud/06datos.html#amazon-aurora","title":"Amazon Aurora","text":"<p>Amazon Aurora es una base de datos relacional compatible con MySQL y PostgreSQL optimizada para la nube. Combina el rendimiento y la disponibilidad de las bases de datos comerciales de alta gama con la simplicidad y la rentabilidad de las bases de datos de c\u00f3digo abierto. Ofrece dos modelos, el cl\u00e1sico basado en instancias y un modelo serverless en el cual se contratan unidades de computaci\u00f3n (ACU).</p> <p>Al estar desarrollado de forma nativa por Amazon se adapta mejor a su infraestructura en coste, rendimiento y alta disponibilidad. Est\u00e1 pensado como un subsistema de almacenamiento distribuido de alto rendimiento, ofreciendo automatizaci\u00f3n de las tareas que requieren mucho tiempo, como el aprovisionamiento, la implementaci\u00f3n de parches, las copias \u200bde seguridad, la recuperaci\u00f3n, la detecci\u00f3n de errores y su reparaci\u00f3n.</p> Alta disponibles con Aurora <p>Aurora replica varias copias de los datos en m\u00faltiples zonas de disponibilidad y realiza copias de seguridad continuas de los datos en S3.</p> <p>Respecto a la seguridad, hay varios niveles disponibles, incluidos el aislamiento de la red con VPC, el cifrado en reposo por medio de claves creadas y controladas con AWS KMS y el cifrado de los datos en tr\u00e1nsito mediante SSL.</p> <p>Respecto al coste, si cogemos el mismo ejemplo anterior de una instancia de Aurora compatible con MySQL con dos procesadores y 8GB de RAM, en este caso, la <code>db.t4g.large</code>, el precio se queda en 106$ mensuales.</p>"},{"location":"cloud/06datos.html#datos-nosql-dynamodb","title":"Datos NoSQL - DynamoDB","text":"<p>DynamoDB (https://aws.amazon.com/es/dynamodb/) es un servicio administrado de base de datos NoSQL clave-valor y documental, r\u00e1pido y flexible para todas las aplicaciones que requieren una latencia uniforme de un solo d\u00edgito de milisegundos a cualquier escala y una capacidad de almacenamiento pr\u00e1cticamente ilimitado.</p> <p>As\u00ed pues, es un almac\u00e9n de claves/valor (similar a Redis y MongoDB a la vez), flexible y sin estructura fija (los elementos pueden tener atributos diferentes), dise\u00f1ado para garantizar un determinado rendimiento as\u00ed como una determinada disponibilidad para cada tabla (en NoSQL suele haber pocas tablas), es decir, se definen elementos por tabla y se paga seg\u00fan lo exigido en cada una.</p>"},{"location":"cloud/06datos.html#componentes-y-particiones","title":"Componentes y particiones","text":"<p>Los componentes principales son:</p> <ul> <li>las tablas: son conjuntos de datos, formada por los elementos.</li> <li>los elementos: grupo de atributos que se puede identificar de forma exclusiva entre todos los dem\u00e1s elementos</li> <li>los atributos: elemento de datos fundamental que no es preciso seguir dividiendo.</li> </ul> <p>DynamoDB soporta dos tipos de claves principales:</p> <ul> <li>La clave de partici\u00f3n es una clave principal simple.</li> <li>La clave de partici\u00f3n y de ordenamiento, tambi\u00e9n conocidas como clave principal compuesta, ya que est\u00e1 formada por dos atributos.</li> </ul> Claves <p>A medida que aumenta el volumen de datos, la clave principal particiona e indexa los datos de la tabla. Podemos recuperar los datos de una tabla de DynamoDB de dos formas distintas, bien por la clave y hacer una consulta directa, o utilizar un escaneo de todos los elementos en busca de aquello que coincida con el par\u00e1metro de b\u00fasqueda.</p> Consultas por clave o escaneo <p>Para aprovechar al m\u00e1ximo las operaciones de consulta, es importante que la clave utilizada identifique de forma un\u00edvoca los elementos de la tabla de DynamoDB. Podemos configurar una clave principal simple basada en un \u00fanico atributo de los valores de los datos con una distribuci\u00f3n uniforme. De forma alternativa, podemos especificar una clave compuesta, que incluye una clave de partici\u00f3n y una clave secundaria.</p> <p>Adem\u00e1s, DynamoDB permite crear \u00edndices para optimizar las consultas que realicemos sobre atributos que no forman parte de la clave de partici\u00f3n u ordenamiento.</p>"},{"location":"cloud/06datos.html#infraestructura","title":"Infraestructura","text":"<p>AWS administra toda la infraestructura subyacente de datos y los almacena de manera redundante en varias instalaciones dentro de una regi\u00f3n, como parte de la arquitectura tolerante a errores.</p> <p>El sistema particiona los datos autom\u00e1ticamente, distribuyendo los datos entre diferentes dispositivos de almacenamiento. No existe ning\u00fan l\u00edmite pr\u00e1ctico respecto de la cantidad de elementos que se pueden almacenar en una tabla. Por ejemplo, algunos clientes tienen tablas de producci\u00f3n con miles de millones de elementos.</p> <p>Todos los datos de DynamoDB se almacenan en unidades SSD, y su lenguaje de consulta simple (PartiQL) permite un rendimiento de las consultas uniforme y de baja latencia. Adem\u00e1s de escalar el almacenamiento, DynamoDB permite aprovisionar el volumen del rendimiento de lectura o escritura que necesita para cada tabla.</p> <p>Tambi\u00e9n facilita el escalado autom\u00e1tico, monitorizando la carga de la tabla e incrementando o disminuyendo el rendimiento aprovisionado de manera autom\u00e1tica. Otras caracter\u00edsticas clave son las tablas globales que permiten generar r\u00e9plicas de manera autom\u00e1tica en las regiones de AWS que elijamos, el cifrado en reposo y la visibilidad del tiempo de vida (TTL) de los elementos.</p>"},{"location":"cloud/06datos.html#costes_1","title":"Costes","text":"<p>Con DynamoDB se cobran las operaciones de lectura, escritura y almacenamiento de datos en sus tablas, junto con las caracter\u00edsticas opcionales que decidamos habilitar. Ofrece dos modos de capacidad con opciones de facturaci\u00f3n:</p> <ul> <li> <p>Bajo demanda: se cobran las operaciones de lectura y escritura de datos realizada en las tablas. No necesitamos especificar el rendimiento de lectura y escritura que espera de nuestras aplicaciones. Apropiado cuando:</p> <ul> <li>Creamos nuevas tablas con cargas de trabajo desconocidas.</li> <li>El tr\u00e1fico de la aplicaci\u00f3n es impredecible.</li> </ul> </li> <li> <p>Aprovisionada: se configura el n\u00famero de operaciones de lectura y escritura por segundo que consideramos que necesitar\u00e1 nuestra aplicaci\u00f3n. Permite usar el escalado autom\u00e1tico para ajustar autom\u00e1ticamente la capacidad de la tabla en funci\u00f3n de la tasa de uso especificada. Apropiado cuando:</p> <ul> <li>El tr\u00e1fico de la aplicaci\u00f3n es predecible.</li> <li>Las aplicaciones tienen un tr\u00e1fico uniforme o aumenta gradualmente.</li> <li>Los requisitos de capacidad se pueden predecir para controlar los costos</li> </ul> </li> </ul> <p>Por ejemplo, una tabla donde especificamos un rendimiento garantizado de 1000 millones lecturas y 1 mill\u00f3n de escrituras al mes, con una coherencia eventual (es decir, que permite desorden de peticiones ) nos costar\u00e1 $67,17 al mes.</p>"},{"location":"cloud/06datos.html#ejemplo-dynamodb","title":"Ejemplo DynamoDB","text":"<p>A continuaci\u00f3n vamos a crear un ejemplo donde tras crear una tabla, la cargaremos con datos para posteriormente realizar alguna consulta.</p> <p>Supongamos que tenemos datos relativos a un cat\u00e1logo de productos, almacenados en el archivo ProductCatalog.json, el cual queremos poder consultar.</p> <p>Si visualizamos el primer registro podemos observar su estructura. Esta estructura es espec\u00edfica de DynamoDB, ya que indica en el primer elemento el nombre de la tabla (en nuestro caso <code>ProductCatalog</code>), y a continuaci\u00f3n el tipo de operaci\u00f3n (<code>PutRequest</code>):</p> <pre><code>{\n\"ProductCatalog\": [\n{\n\"PutRequest\": {\n\"Item\": {\n\"Id\": {\n\"N\": \"101\"\n},\n\"Title\": {\n\"S\": \"Book 101 Title\"\n},\n\"ISBN\": {\n\"S\": \"111-1111111111\"\n},\n\"Authors\": {\n\"L\": [\n{\n\"S\": \"Author1\"\n}\n]\n},\n\"Price\": {\n\"N\": \"2\"\n},\n\"Dimensions\": {\n\"S\": \"8.5 x 11.0 x 0.5\"\n},\n\"PageCount\": {\n\"N\": \"500\"\n},\n\"InPublication\": {\n\"BOOL\": true\n},\n\"ProductCategory\": {\n\"S\": \"Book\"\n}\n}\n}\n},\n</code></pre> <p>Para ello, primero vamos a crear la tabla desde el interfaz web de AWS. Tras seleccionar Amazon DynamoDB, creamos una tabla que llamamos <code>ProductCatalog</code>, cuyo identificador ser\u00e1 <code>Id</code> de tipo n\u00famero. El resto de campos se crear\u00e1n autom\u00e1ticamente al importar los datos.</p> Creando la tabla <p>Tambi\u00e9n pod\u00edamos haber creado la tabla mediante el comando create-table de AWS CLI:</p> <pre><code>aws dynamodb create-table \\\n--table-name ProductCatalog \\\n--attribute-definitions AttributeName=Id,AttributeType=N  \\\n--key-schema AttributeName=Id,KeyType=HASH \\\n--billing-mode PAY_PER_REQUEST\n</code></pre> <p>Para introducir los datos, podemos hacerlo de varias maneras.</p> <ul> <li>Si pulsamos sobra la tabla y luego en elementos podemos rellenar un formulario indicando el tipo de los elementos y su valor.</li> <li> <p>Otra manera m\u00e1s \u00e1gil es mediante AWS CLI (recordad antes configurar las variables de entorno con la informaci\u00f3n de la conexi\u00f3n):</p> <p>El comando batch-write-item permite importar los datos desde un archivo JSON siempre y cuando cumpla con el formato comentado anteriormente.</p> <p>As\u00ed pues, el comando ser\u00eda:</p> <pre><code>aws dynamodb batch-write-item --request-items file://ProductCatalog.json\n</code></pre> <p>Una vez ejecutado tendremos un mensaje de <code>UnprocessedItems: {}</code>.</p> </li> <li> <p>Tambi\u00e9n podemos cargar los datos en S3, y realizar una importaci\u00f3n desde S3, pero el formato del documento es diferente, admitiendo datos en CSV, un formato de JSON multil\u00ednea espec\u00edfico de DynamoDB (compuestos de documentos <code>Item</code>) o un formato propietario como Amazon Ion. As\u00ed pues, primero cargaremos ProductCatalogS3.json en S3, y a continuaci\u00f3n realizamos la importaci\u00f3n.</p> <p> Importaci\u00f3n en DynamoDB desde S3 </p> <p>Tras indicar el archivo, deberemos indicar los datos de creaci\u00f3n de la nueva tabla (es decir, no permite importar datos sobre una tabla ya existente previamente).</p> </li> </ul> <p>Si volvemos a la consola web, tras entrar en la tabla y pulsar en Ver elementos veremos los datos ya introducidos.</p> Ver elementos <p>Si queremos consultar informaci\u00f3n de la tabla mediante el comando describe-table de AWS CLI, ejecutaremos:</p> <pre><code>aws dynamodb describe-table --table-name ProductCatalog\n</code></pre> <p>Si queremos hacer la consulta de la tabla para ver los datos que contiene desde el comando scan de AWS CLI, ejecutaremos:</p> <pre><code>aws dynamodb scan --table-name ProductCatalog\n</code></pre> <p>Y veremos algo similar a:</p> <pre><code>{\n\"Items\": [\n{\n\"Title\": {\n\"S\": \"18-Bike-204\"\n},\n\"Price\": {\n\"N\": \"500\"\n},\n\"Brand\": {\n\"S\": \"Brand-Company C\"\n},\n\"Description\": {\n\"S\": \"205 Description\"\n},\n\"Color\": {\n\"L\": [\n{\n\"S\": \"Red\"\n},\n{\n\"S\": \"Black\"\n}\n]\n},\n\"ProductCategory\": {\n\"S\": \"Bicycle\"\n},\n\"Id\": {\n\"N\": \"205\"\n},\n\"BicycleType\": {\n\"S\": \"Hybrid\"\n</code></pre> <p>Como se puede observar, los datos salen desordenados.</p> <p>Vamos a realizar consultas sobre estos datos haciendo uso de PartiQL. As\u00ed pues, en el men\u00fa de la izquierda, seleccionamos el editor PartiQL.</p> Consultas con PartiQL <p>En el panel de la derecha podremos realizar consultas del tipo:</p> <pre><code>select * from ProductCatalog where Id = 101\nselect Title from ProductCatalog where ProductCategory = 'Book'\nselect * from ProductCatalog where Price &gt;= 300\n</code></pre>"},{"location":"cloud/06datos.html#interaccion-con-python","title":"Interacci\u00f3n con Python","text":""},{"location":"cloud/06datos.html#caso-de-uso-1-cargar-datos-en-dynamodb","title":"Caso de uso 1: Cargar datos en DynamoDB","text":"<p>Vamos a cargar un listado de pel\u00edculas en DynamoDB. El primer paso es elegir las claves de particionado y ordenaci\u00f3n. El archivo datosPeliculas.json contiene el siguiente contenido:</p> <pre><code>[\n{\n\"year\": 2013,\n\"title\": \"Rush\",\n\"info\": {\n\"directors\": [\"Ron Howard\"],\n\"release_date\": \"2013-09-02T00:00:00Z\",\n\"rating\": 8.3,\n\"genres\": [\n\"Action\",\n\"Biography\",\n\"Drama\",\n\"Sport\"\n],\n\"image_url\": \"http://ia.media-imdb.com/images/M/MV5BMTQyMDE0MTY0OV5BMl5BanBnXkFtZTcwMjI2OTI0OQ@@._V1_SX400_.jpg\",\n\"plot\": \"A re-creation of the merciless 1970s rivalry between Formula One rivals James Hunt and Niki Lauda.\",\n\"rank\": 2,\n\"running_time_secs\": 7380,\n\"actors\": [\n\"Daniel Bruhl\",\n\"Chris Hemsworth\",\n\"Olivia Wilde\"\n]\n}\n},\n]\n</code></pre> <p>Como los a\u00f1os de las pel\u00edculas permiten particionar de manera m\u00e1s o menos equilibrada los datos, en la mejor candidata para clave de particionado. Como s\u00ed que habr\u00e1 varias pel\u00edculas en el mismo a\u00f1o, elegimos el t\u00edtulo como clave de ordenaci\u00f3n, provocando que los documentos tengan una clave compuesta.</p> <p>As\u00ed pues, vamos a nombrar nuestra tabla como <code>SeveroPeliculas</code> y ponemos como clave de partici\u00f3n el atributo <code>year</code> de tipo num\u00e9rico, y como clave de ordenaci\u00f3n <code>title</code> de tipo cadena.</p> Creaci\u00f3n de la tabla SeveroPeliculas <p>Una vez creada la tabla, vamos a ver c\u00f3mo podemos cargar los datos. Haciendo uso de la librer\u00eda boto3 vamos a crear el archivo <code>cargarDatosPeliculas.py</code>:</p> cargarDatosPeliculas.py<pre><code>import boto3\nimport json\nimport decimal\ndynamodb = boto3.resource('dynamodb', region_name='us-east-1') # (1)\ntabla = dynamodb.Table('SeveroPeliculas')\nwith open(\"datosPeliculas.json\") as ficheroJSON:\npeliculas = json.load(ficheroJSON, parse_float=decimal.Decimal)\nfor pelicula in peliculas:\nyear = int(pelicula['year'])\ntitle = pelicula['title']\ninfo = pelicula['info']\nprint(\"A\u00f1adida pel\u00edcula:\", year, title)\ntabla.put_item(\nItem={\n'year': year,\n'title': title,\n'info': info,\n}\n)\n</code></pre> <ol> <li>Nos conectamos a la regi\u00f3n e indicamos que vamos a utilizar el servicio de DynamoDB</li> </ol> <p>Si lo ejecutamos desde nuestro ordenador, nos aparecer\u00e1 por la consola cada una de las pel\u00edculas insertadas.</p> <p>Float y boto3</p> <p>Mucho cuidado con boto3 y DynamoDB, ya que los tipos <code>Float</code> no est\u00e1n soportados, y en cambio, hemos de utilizar el tipo <code>Decimal</code>.</p>"},{"location":"cloud/06datos.html#faker","title":"Faker","text":"<p>Si necesitamos escribir muchos datos, es muy \u00fatil emplear una librer\u00eda como Faker para generar datos sint\u00e9ticos.</p> <p>Primero hemos de instalarla mediante pip:</p> <pre><code>pip3 install faker\n</code></pre> <p>Vamos a realizar un ejemplo para mostrar algunos datos aleatorios y comprobar su funcionamiento:</p> C\u00f3digoResultado holaFaker.py<pre><code>from faker import Faker\nfake = Faker()\nfake = Faker('es_ES')   # cambiamos el locale a espa\u00f1ol\nprint(\"Nombre:\", fake.name())\nprint(\"Direcci\u00f3n:\", fake.address())\nprint(\"Nombre de hombre:\", fake.first_name_male())\nprint(\"N\u00famero de tel\u00e9fono:\", fake.phone_number())\nprint(\"Color:\", fake.color_name())\nprint(\"Fecha:\", fake.date())\nprint(\"Email:\", fake.email())\nprint(\"Frase de 10 palabras\", fake.sentence(nb_words=10))\n</code></pre> <pre><code>Nombre: Dani Pla Chico\nDirecci\u00f3n: Cuesta de Emiliano Milla 66\nAlbacete, 83227\nNombre de hombre: Mat\u00edas\nN\u00famero de tel\u00e9fono: +34 818 779 827\nColor: Salm\u00f3n oscuro\nFecha: 1984-09-29\nEmail: btome@example.net\nFrase de 10 palabras Perferendis saepe consequatur saepe sapiente est impedit eaque omnis temporibus excepturi repellat ducimus.\n</code></pre> <p>Los diferentes grupos de datos que genera se agrupan en Providers: de direcci\u00f3n, fechas, relacionados con internet, bancarios, c\u00f3digos de barra, isbn, etc... Se recomienda consultar la documentaci\u00f3n en https://faker.readthedocs.io/en/master/providers.html.</p> <p>Locale ES</p> <p>Al trabajar con el idioma en espa\u00f1ol, puede que algunos m\u00e9todos no funcionen (m\u00e1s que no funcionar, posiblemente tengan otro nombre). Es recomendable comprobar las opciones disponibles en https://faker.readthedocs.io/en/master/locales/es_ES.html</p>"},{"location":"cloud/06datos.html#generando-csv","title":"Generando CSV","text":"<p>Vamos a generar un CSV con datos de 1000 personas. Primero creamos una lista con los encabezados y los escribimos en el fichero, para posteriormente, l\u00ednea a l\u00ednea, generar los datos de cada persona:</p> C\u00f3digoResultado generaCSV.py<pre><code>from faker import Faker\nimport csv\noutput = open('datosFaker.csv', 'w')\nfake = Faker('es_ES')   # cambiamos el locale a espa\u00f1ol\nheader = ['nombre', 'edad', 'calle', 'ciudad',\n'provincia', 'cp', 'longitud', 'latitud']\nmywriter = csv.writer(output)\nmywriter.writerow(header)\nfor r in range(1000):\nmywriter.writerow([fake.name(),\nfake.random_int(min=18, max=80, step=1),\nfake.street_address(),\nfake.city(),\nfake.state(),\nfake.postcode(),\nfake.longitude(),\nfake.latitude()])\noutput.close()\n</code></pre> datosFaker.csv<pre><code>nombre,edad,calle,ciudad,provincia,cp,longitud,latitud\nJenaro Verd\u00fa Suarez,26,Urbanizaci\u00f3n Mohamed Vall\u00e9s 122,Sevilla,Guip\u00fazcoa,73198,2.657719,-69.679293\nEugenio Calzada Revilla,57,Camino Vanesa Amor 36 Piso 9 ,Huesca,\u00c1lava,75590,34.041399,-52.924628\nFlavio del Lumbreras,76,Avenida de Beatriz Amaya 92,Ciudad,Murcia,86420,58.248903,-17.924926\n</code></pre>"},{"location":"cloud/06datos.html#generando-json","title":"Generando JSON","text":"<p>Y a continuaci\u00f3n repetimos el mismo ejemplo, pero ahora generando un documento JSON. La principal diferencia es que primero vamos a rellenar un diccionario con toda la informaci\u00f3n, y luego persistimos el diccionario:</p> C\u00f3digoResultado generaJSON.py<pre><code>from faker import Faker\nimport json\nfake = Faker('es_ES')   # cambiamos el locale a espa\u00f1ol\n# Preparamos los datos\ndatos = {}\ndatos['registros'] = []\nfor x in range(1000):\npersona = {\"datos\": fake.name(),\n\"edad\": fake.random_int(min=18, max=80, step=1),\n\"calle\": fake.street_address(),\n\"ciudad\": fake.city(),\n\"provincia\": fake.state(),\n\"cp\": fake.postcode(),\n\"longitud\": float(fake.longitude()),\n\"latitud\": float(fake.latitude())}\ndatos['registros'].append(persona)\n# Los metemos en el fichero\noutput = open('datosFaker.json', 'w')\njson.dump(datos, output)\n</code></pre> datosFaker.json<pre><code>{\n\"registros\": [\n{\n\"datos\": \"Merche Moreno Roman\",\n\"edad\": 51,\n\"calle\": \"Paseo Amelia Folch 967\",\n\"ciudad\": \"Segovia\",\n\"provincia\": \"M\\u00e1laga\",\n\"cp\": \"71721\",\n\"longitud\": 84.603801,\n\"latitud\": 58.941349\n},\n{\n\"datos\": \"Miguel Abascal Sanz\",\n\"edad\": 21,\n</code></pre>"},{"location":"cloud/06datos.html#caso-de-uso-2-consultar-datos-en-dynamodb","title":"Caso de uso 2 - Consultar datos en DynamoDB","text":"<p>Una vez tenemos nuestra tabla de DynamoDB cargada con datos, llega el momento de recuperar los datos, ya sea un registro en concreto o la posibilidad de realizar una consulta, ya sea por su \u00edndice o su clave de ordenaci\u00f3n (o ambas).</p> <p>En el apartado anterior hemos estudiado que podemos realizar consultas sobre DynamoDB haciendo uso de un subconjunto de SQL conocido como PartiQL. En los siguientes ejemplos vamos a mostrar c\u00f3mo realizar las operaciones v\u00eda el API de DynamoDb y mediante PartiQL.</p> <p>Si queremos recuperar la pel\u00edcula Interstellar de 2014 haremos:</p> Mediante <code>get_item</code>Mediante <code>get_item</code> con excepcionesMediante PartiQL dynamodb_getitem.py<pre><code>import boto3\ndynamodb = boto3.resource('dynamodb', region_name='us-east-1')\ntabla = dynamodb.Table('SeveroPeliculas')\ntitle = \"Interstellar\"\nyear = 2014\nresponse = tabla.get_item(\nKey={\n'year': year,\n'title': title\n},\nProjectionExpression=\"title, info.plot\")\nitem = response['Item']\nprint(item)\n</code></pre> dynamodb_getitem_exc.py<pre><code>import boto3\nfrom botocore.exceptions import ClientError\ndynamodb = boto3.resource('dynamodb', region_name='us-east-1')\ntabla = dynamodb.Table('SeveroPeliculas')\ntitle = \"Interstellar\"\nyear = 2014\n# Recupera una pel\u00edcula\nprint(\"------ Datos de Interstellar\")\ntry:\nresponse = tabla.get_item(\nKey={\n'year': year,\n'title': title\n},\nProjectionExpression=\"title, info.plot\"\n)\nexcept ClientError as e:\nprint(e.response['Error']['Message'])\nelse:\nitem = response['Item']\nprint(item)\n</code></pre> dynamodb_select.py<pre><code>import boto3\nclientDDB = boto3.client('dynamodb', region_name='us-east-1')\n# Recupera una pel\u00edcula con PartiQL\nprint(\"------ Datos de Interstellar mediante PartiQL\")\nresp = clientDDB.execute_statement(\nStatement=\"SELECT title, info.plot FROM SeveroPeliculas WHERE year = 2014 and title='Interstellar'\")\nitem = resp['Items'][0]\nprint(item)\ntitle = \"Interstellar\"\nyear = 2014\n# Recupera una pel\u00edcula con PartiQL con par\u00e1metros indicados mediante ?\nprint(\"------ Datos de Interstellar mediante PartiQL con par\u00e1metros\")\nresp = clientDDB.execute_statement(Statement='SELECT * FROM SeveroPeliculas WHERE year = ? AND title = ?',\nParameters=[{'N': str(year)}, {'S': title}])\nitem = resp['Items'][0]\nprint(item)\n</code></pre> <p>En el caso de las consultas mediante PartiQL haciendo uso de <code>execute_statement</code> conviene destacar que:</p> <ul> <li>Las consultas son case sensitive.</li> <li>Los par\u00e1metros se indican mediante <code>?</code></li> <li>Los contenidos de los par\u00e1metros se indican mediante una lista con un diccionario por cada par\u00e1metro donde la clave es el tipo del par\u00e1metro, y el valor es el dato a pasar (el dato se pasa siempre como un <code>string</code>)</li> <li>Las consultas siempre devuelven un diccionario con una propiedad <code>Items</code> que contiene los resultados devueltos.</li> </ul> <p>Destacar que es diferente la estructura del resultado de realizar una consulta mediante el API de DynamoDB (respeta la estructura definida en la base de datos) o mediante PartiQL (crea un atributo por columna recuperada cuyo valor contiene el tipo del dato):</p> Resultado de <code>get-item</code>Resultado de PartiQL <pre><code>{\n'info': {'plot': 'A group of explorers make use of a newly discovered wormhole to surpass the limitations on human space travel and conquer the vast distances involved in an interstellar voyage.'},\n'title': 'Interstellar'\n}\n</code></pre> <pre><code>{\n'title': {'S': 'Interstellar'},\n'plot': {'S': 'A group of explorers make use of a newly discovered wormhole to surpass the limitations on human space travel and conquer the vast distances involved in an interstellar voyage.'}\n}\n</code></pre> <p>Tambi\u00e9n podemos realizar otro tipo de consultas:</p> Pel\u00edculas de 2016 mediante <code>query</code>Pel\u00edculas cuyo t\u00edtulo est\u00e9 entre la A y la L <pre><code>import boto3\nfrom boto3.dynamodb.conditions import Key\n# Mediante query\ndynamodb = boto3.resource('dynamodb', region_name='us-east-1')\ntabla = dynamodb.Table('SeveroPeliculas')\nprint(\"-----Pel\u00edculas de 2016\")\nresp = tabla.query(KeyConditionExpression=Key('year').eq(2016))\nfor i in resp['Items']:\nprint(i['year'], \":\", i['title'])\n# Mediante PartiQL\nprint(\"-----Pel\u00edculas de 2016 con PartiQL\")\nclientDDB = boto3.client('dynamodb', region_name='us-east-1')\nresp = clientDDB.execute_statement(\nStatement=\"SELECT title, year FROM SeveroPeliculas WHERE year = 2016\")\nfor i in resp['Items']:\nprint(i['year']['N'], \":\", i['title']['S'])\n</code></pre> <pre><code>import boto3\nimport json\nimport decimal\nfrom boto3.dynamodb.conditions import Key\nclass DecimalEncoder(json.JSONEncoder):\ndef default(self, o):\nif isinstance(o, decimal.Decimal):\nif o % 1 &gt; 0:\nreturn float(o)\nelse:\nreturn int(o)\nreturn super(DecimalEncoder, self).default(o)\nanyo = 2016\nletraInicial = \"A\"\nletraFinal = \"F\"\ndynamodb = boto3.resource('dynamodb', region_name='us-east-1')\ntabla = dynamodb.Table('SeveroPeliculas')\nprint(\"-----Pel\u00edculas de 2016 cuyo t\u00edtulo empieza desde A hasta L\")\nresp = tabla.query(\nProjectionExpression=\"#yr, title, info.genres, info.actors[0]\",\n# year es una palabra clave, por tanto necesitamos crear un alias\nExpressionAttributeNames={\"#yr\": \"year\"},\nKeyConditionExpression=Key('year').eq(anyo) &amp; Key('title').between(letraInicial, letraFinal)\n)\nfor i in resp['Items']:\nprint(i)\n# {'info': {'actors': ['Zoe Saldana'], 'genres': ['Action', 'Adventure', 'Fantasy', 'Sci-Fi']}, 'year': Decimal('2016'), 'title': 'Avatar 2'}\n# Transforma los valores num\u00e9ricos de Decimal a Number\nprint(json.dumps(i, cls=DecimalEncoder))\n# {\"info\": {\"actors\": [\"Zoe Saldana\"], \"genres\": [\"Action\", \"Adventure\", \"Fantasy\", \"Sci-Fi\"]}, \"year\": 2016, \"title\": \"Avatar 2\"}\nfor genero in i['info']['genres']:\nprint(genero)\nprint(\"-----Pel\u00edculas de 2016 cuyo t\u00edtulo empieza desde A hasta L con PartiQL\")\nclientDDB = boto3.client('dynamodb', region_name='us-east-1')\nconsulta = 'SELECT year, title, info.genres, info.actors[0] FROM SeveroPeliculas WHERE year = ? AND title between ? and ?'\nresp = clientDDB.execute_statement(Statement=consulta,\nParameters=[{'N': str(anyo)}, {'S': letraInicial}, {'S': letraFinal}])\nfor i in resp['Items']:\nprint(i)\n# [{'year': {'N': '2016'}, 'title': {'S': 'Avatar 2'}, 'actors[0]': {'S': 'Zoe Saldana'}, 'genres': {'L': [{'S': 'Action'}, {'S': 'Adventure'}, {'S': 'Fantasy'}, {'S': 'Sci-Fi'}]}}]\nfor genero in i['genres']['L']:\nprint(genero['S'])\n</code></pre> <p>La clase <code>DecimalEncoder</code> se utiliza para transformar los campos <code>Decimal</code> que utiliza DynamoDB para almacenar contenido num\u00e9rico a tipo entero o flotante seg\u00fan necesite.</p>"},{"location":"cloud/06datos.html#full-scan","title":"Full scan","text":"<p>Cuando en PartiQL no le indicamos en la condici\u00f3n una expresi\u00f3n que busque por una de las claves, se realizar\u00e1 un full scan sobre toda la tabla, lo que puede implicar unos costes inesperados, tanto econ\u00f3micos como a nivel rendimiento.</p> <p>El m\u00e9todo <code>scan</code> lee cada elemento de la tabla y devuelve todos los datos de la tabla. Se le puede pasar una <code>filter_expression</code> opcional para que s\u00f3lo devuelva los elementos que cumplan el criterio. Sin embargo, el filtrado se aplica tras escanear toda la tabla.</p> Ejemplo scanFull scan con PartiQL <pre><code>import boto3\nimport json\nimport decimal\nfrom boto3.dynamodb.conditions import Key\nclass DecimalEncoder(json.JSONEncoder):\ndef default(self, o):\nif isinstance(o, decimal.Decimal):\nif o % 1 &gt; 0:\nreturn float(o)\nelse:\nreturn int(o)\nreturn super(DecimalEncoder, self).default(o)\ndynamodb = boto3.resource('dynamodb', region_name='us-east-1')\ntabla = dynamodb.Table('SeveroPeliculas')\nprint(\"-----Pel\u00edculas de sobresaliente mediante full scan\")\n# Escaneo y filtrado\nfe = Key('info.rating').gte(9)\npe = \"#yr, title, info.rating\"\nean = {\"#yr\": \"year\"}\nresp = tabla.scan(\nFilterExpression=fe,\nProjectionExpression=pe,\nExpressionAttributeNames=ean\n)\nfor i in resp['Items']:\nprint(json.dumps(i, cls=DecimalEncoder))\n</code></pre> <pre><code>import boto3\nfrom boto3.dynamodb.conditions import Key\nprint(\"-----Pel\u00edculas de 2016 con PartiQL\")\nclientDDB = boto3.client('dynamodb', region_name='us-east-1')\nresp = clientDDB.execute_statement(\nStatement=\"SELECT title, year, info.rating FROM SeveroPeliculas WHERE info.rating &gt;= 9\")\nfor i in resp['Items']:\nprint(i['year']['N'], \":\", i['title']['S'])\n</code></pre>"},{"location":"cloud/06datos.html#caso-de-uso-3-de-s3-a-dynamodb","title":"Caso de uso 3 - De S3 a DynamoDB","text":"<p>En la sesi\u00f3n de S3 trabajamos con Python con un dataset de pel\u00edculas, el cual filtramos mediante S3Select y nos quedamos con el t\u00edtulo, la nota media y la trama siempre y cuando hayan recibido al menos 10.000 votos, el cual almacenamos en <code>TMDb_filtered.csv</code>.</p> <p>Una vez creado el fichero en S3, vamos cargar los datos en DynamoDB. Como el dataset no conten\u00eda la fecha de la pel\u00edcula, en nuestro caso le vamos a poner a todas las pel\u00edculas que son del 2022:</p> <pre><code>import boto3\nimport pandas as pd\nfrom decimal import Decimal\n# 1.- Leemos el fichero desde S3 y lo metemos en un DataFrame\ns3c = boto3.client('s3')\nbucketNombre = \"s3severo2122python\"\nficheroNombre = \"TMDb_filtered.csv\"\nresponse = s3c.get_object(Bucket=bucketNombre, Key=ficheroNombre)\nmovies_df = pd.read_csv(response['Body'], delimiter = ',')\n# 2.- Nos conectamos a DynamoDB\ndynamodb = boto3.resource('dynamodb', region_name='us-east-1')\ntabla = dynamodb.Table('SeveroPeliculas')\n# 3.- Lo metemos en DynamoDB mediante un batch\nwith tabla.batch_writer() as batch:\nfor index, fila in movies_df.iterrows():\nItem = {\n'year': 2022,\n'title': str(fila['title']),\n'info': {\n'plot' : fila['overview'],\n'rating' : Decimal(fila['vote_average']).quantize(Decimal('1.00'))\n}\n}\nbatch.put_item(Item=Item)\n</code></pre>"},{"location":"cloud/06datos.html#caso-de-uso-4-desde-rds","title":"Caso de uso 4 - Desde RDS","text":"<p>Preparaci\u00f3n MariaBD</p> <p>Para estos actividades y futuras sesiones, vamos a utilizar una base de datos (retail_db) que contiene informaci\u00f3n sobre un comercio (clientes, productos, pedidos, etc...).</p> <p>Para ello, descargaremos el archivo create_db.sql con las sentencias para crear la base de datos y los datos como instrucciones SQL.</p> <p>Tras ello, bien sea mediante DBeaver o si nos conectamos a MariaDB (<code>mariadb -u iabd -p</code>) desde la misma carpeta que hemos descargado el archivo, ejecutaremos los siguientes comando:</p> <pre><code>create database retail_db;\nuse retail_db;\nsource create_db.sql;\nshow tables;\n</code></pre> <p>Vamos a utilizar la instancia de base de datos iabd que tenemos en RDS con la base de datos <code>retail_db</code>.</p>"},{"location":"cloud/06datos.html#mariadbmysql-y-python","title":"MariaDB/MySQL y Python","text":"<p>Para acceder a la base de datos desde Python necesitamos instalar la librer\u00eda correspondiente:</p> <pre><code>pip3 install mariadb\npip3 install mysql-connector-python\n</code></pre> <p>Todo el c\u00f3digo a continuaci\u00f3n se basa en MariaDB como sistema gestor de base de datos. Si queremos conectarnos, debemos indicar los datos de conexion:</p> <pre><code>import mariadb\nimport sys\ntry:\nconn = mariadb.connect(\nuser=\"admin\",\npassword=\"adminadmin\",\nhost=\"iabd.cllw9xnmy9av.us-east-1.rds.amazonaws.com\",\nport=3306,\ndatabase=\"retail_db\"\n)\nexcept mariadb.Error as e:\nprint(f\"Error conectando a MariaD: {e}\")\nsys.exit(1)\n# Obtenemos el cursor\ncur = conn.cursor()\n</code></pre> <p>Una vez nos hemos conectado y tenemos abierto un cursor, ya podemos hacer consultas y recuperar datos.</p> <p>Por ejemplo, para recuperar toda la informaci\u00f3n de los clientes almacenada en la tabla <code>customers</code>:</p> <pre><code>sql = \"select * from customers\"\ncur.execute(sql)\nresultado = cur.fetchAll()\n# Cerramos el cursor y la conexi\u00f3n\ncur.close()\nconn.close()\n# Mostramos el resultado\nprint(resultado)\n</code></pre>"},{"location":"cloud/06datos.html#de-rds-a-s3","title":"De RDS a S3","text":"<p>Vamos a realizar otro ejemplo sencillo que recupere el nombre, apellido y email de los clientes mediante una consulta que reibe un par\u00e1metro:</p> <pre><code>import mariadb\nimport sys\nimport json\nimport boto3\ntry:\nconn = mariadb.connect(\nuser=\"admin\",\npassword=\"adminadmin\",\nhost=\"iabd.cllw9xnmy9av.us-east-1.rds.amazonaws.com\",\nport=3306,\ndatabase=\"retail_db\")\nexcept mariadb.Error as e:\nprint(f\"Error conectando a MariaDB: {e}\")\nsys.exit(1)\nciudad = \"Brownsville\"\n# Obtenemos el cursor\ncur = conn.cursor()\nsql = \"select customer_fname, customer_lname, customer_zipcode from customers where customer_city=?\"\ncur.execute(sql, (ciudad, ))\n# Generamos un JSON con los datos\nrow_headers=[x[0] for x in cur.description] \nclientes = cur.fetchall()\njson_data=[]\nfor cliente in clientes:\njson_data.append(dict(zip(row_headers,cliente)))\n# Cerramos el cursor y la conexi\u00f3n\ncur.close()\nconn.close()\n# Persistimos el JSON en S3\ns3r = boto3.resource('s3', region_name='us-east-1')\nobject = s3r.Object('s3severo2122python', 'clientesRDS.json')\nobject.put(Body=json.dumps(json_data))\n</code></pre>"},{"location":"cloud/06datos.html#de-rds-a-dynamodb","title":"De RDS a DynamoDB","text":"<p>Para este caso de uso, vamos a crear una nueva tabla en DynamoDB a la que llamaremos <code>SeveroClientes</code> y le pondremos como clave de particionado el campo <code>Id</code> de tipo num\u00e9rico y como clave de ordenamiento el <code>Zip</code> de tipo texto.</p> Creaci\u00f3n de la tabla SeveroClientes <p>Vamos a modificar el ejemplo anterior para que, una vez recuperado los datos de la base de datos, los almacene directamente en DynamoDB:</p> <pre><code>import mariadb\nimport sys\nimport boto3\ntry:\nconn = mariadb.connect(\nuser=\"admin\",\npassword=\"adminadmin\",\nhost=\"iabd.cllw9xnmy9av.us-east-1.rds.amazonaws.com\",\nport=3306,\ndatabase=\"retail_db\"\n)\nexcept mariadb.Error as e:\nprint(f\"Error conectando a MariaDB: {e}\")\nsys.exit(1)\nciudad = \"Brownsville\"\n# Obtenemos el cursor\ncur = conn.cursor()\nsql = \"select customer_id, customer_fname, customer_lname, customer_zipcode from customers where customer_city=?\"\ncur.execute(sql, (ciudad, ))\n# Recorremos el cursor e insertamos en DynamoDB\ndynamodb = boto3.resource('dynamodb', region_name='us-east-1')\ntabla = dynamodb.Table('SeveroClientes')\nwith tabla.batch_writer() as batch:\nfor customer_id, customer_fname, customer_lname, customer_zipcode in cur: \nItem = {\n'Id': customer_id,\n'Zip': customer_zipcode,\n'Nombre': customer_fname,\n'Apellidos': customer_lname,\n}\nbatch.put_item(Item=Item)\n# Cerramos el cursor y la conexi\u00f3n\ncur.close()\nconn.close()\n</code></pre> <p>Bases de datos y Pandas</p> <p>Si est\u00e1s interesado en colocar dentro de Pandas los datos que recuperas desde una base de datos, es muy com\u00fan utilizar SQLAlchemy el cual ofrece una capa por encima de los drivers (adem\u00e1s de ofrecer un framework ORM).</p> <p>Un fragmento de c\u00f3digo que utiliza Pandas y SQLAlchemy ser\u00eda similar a:</p> <pre><code>from sqlalchemy import create_engine\nimport pymysql\nimport pandas as pd\nsqlEngine = create_engine('mysql+pymysql://iabd:@127.0.0.1', pool_recycle=3600)\ndbConnection = sqlEngine.connect()\ndf = pd.read_sql(\"select * from retail_db.customers\", dbConnection);\n</code></pre>"},{"location":"cloud/06datos.html#referencias","title":"Referencias","text":"<ul> <li>Gu\u00eda de usuario de Amazon RDS</li> <li>Gu\u00eda de referencias de Amazon DynamoDB</li> <li>Laboratorios con ejemplos y modelado con Amazon DynamoDB</li> <li>DynamoDB mediante Python</li> <li>Ten Examples of Getting Data from DynamoDB with Python and Boto3</li> <li>DynamoDB Insert: Performance Basics in Python/Boto3</li> </ul>"},{"location":"cloud/06datos.html#actividades","title":"Actividades","text":"<ol> <li> <p>(RA5075.2 / CE5.2a / 1p) Realizar el m\u00f3dulo 8 (Bases de Datos) del curso ACF de AWS.</p> </li> <li> <p>(RA5075.2 / CE5.2a / 1p) Siguiendo el ejemplo de RDS, crea una instancia (<code>instituto</code>) de una base de datos de tipo MariaDB y c\u00e1rgala con los datos de <code>retail_db</code>.</p> <p>A partir de esta instancia, crea una instant\u00e1nea de forma manual. A continuaci\u00f3n, restaura esta instant\u00e1nea en una nueva instancia (por ejemplo, <code>instituto2</code>) de tipo <code>db.t4g.small</code>, y tras conectarte mediante DBeaver, comprueba que tiene los datos ya cargados. Adjunta una captura de pantalla donde se vean las caracter\u00edsticas de las dos instancias.</p> </li> <li> <p>(RA5075.2 / CE5.2a / 1p) Siguiendo el ejemplo de DynamoDB, crea la tabla (<code>ProductCatalog</code>), c\u00e1rgala con los datos del ejemplo y realiza un consulta para obtener las bicicletas h\u00edbridas. Exporta el resultado a CSV.</p> </li> <li> <p>(RA5075.2 / CE5.2a / 1p) Realiza los casos de uso 1 y 2 de interacci\u00f3n desde Python con DynamoDB.</p> </li> </ol>"},{"location":"cloud/07athena.html","title":"AWS Athena","text":"<p>Athena es una herramienta serverless que permite realizar consultas sobre datos los cuales est\u00e1n directamente en S3 y que provienen de fuentes dispares como bases de datos, un flujo de datos, contenido web desestructurado, etc.. Athena almacena metadatos sobre las fuentes de datos, as\u00ed como las consultas para poder reutilizarlas o compartirlas con otros usuarios.</p> <p>En el siguiente supuesto, vamos a crear una aplicaci\u00f3n Athena, definiremos una base de datos, crearemos una tabla con sus columnas y tipos de datos, y ejecutaremos consultas sencillas y compuestas.</p> <p>Los pasos a realizar son:</p> <ol> <li>Seleccionar el data set, identificando en S3 donde est\u00e1n los datos. Athena permite consultar los datos CSV, TSV, JSON, Parquet y formato ORC.</li> <li>Crear la tabla, mediante el asistente de crear tabla o utilizamos la sintaxis DDL de Hive.</li> <li>Consultar los datos, mediante SQL.</li> </ol>"},{"location":"cloud/07athena.html#preparando-athena","title":"Preparando Athena","text":"<p>Antes de empezar con Athena, necesitamos indicar un bucket donde almacenar los resultados de nuestras consultas. As\u00ed pues, vamos a utilizar uno de los buckets que hemos creado en sesiones anteriores.</p> <p>Tras acceder a Athena, en la pesta\u00f1a de Settings del Query Editor, configuramos donde vamos a guardar los resultados:</p> Athena - Configuraci\u00f3n inicial <p>Preparando los datos</p> <p>Los datos que vamos a consultar son los datos de los clientes de la base de datos <code>retail_db</code> que hemos utilizando en la sesi\u00f3n de Hive, los cuales hemos exportado al archivo customers.csv.</p> <p>Para poder leer estos datos, primero hemos de colocarlos en S3. En nuestro caso, hemos decidido crear una carpeta llamada <code>customers</code> dentro del bucket <code>s3severo8a</code>, y dentro de ella, hemos dejado el archivo con los datos:</p> <p> Archivo de customers.csv en S3 </p>"},{"location":"cloud/07athena.html#creando-la-estructura","title":"Creando la estructura","text":"<p>En AWS Glue, o directamente en Athena, vamos a crear una base de datos y una tabla de forma similar a como se hace mediante Hive.</p> <p>A continuaci\u00f3n, entramos al Query editor, y a lado de la secci\u00f3n Tables and views, desplegamos el men\u00fa Create y creamos una tabla a partir de datos S3, indic\u00e1ndole un nombre para la tabla, otro para la base de datos (o elegimos una existente), as\u00ed como la localizaci\u00f3n en S3 de la carpeta donde se encuentren nuestros datos:</p> Athena - Opci\u00f3n para crear la tabla a partir de S3 <p>A continuaci\u00f3n, le indicamos que vamos a cargar los datos en una tabla de tipo Hive en formato CSV, utilizando la coma como separador de campos:</p> Athena - Configuraci\u00f3n del formato <p>Una vez tenemos el formato, debemos indicar la estructura de la tabla. </p> Athena - Definici\u00f3n de las columnas <p>Para ello, podemos a\u00f1adir cada columna de una en una, indicando su nombre y su tipo, o mediante la opci\u00f3n Bulk add columns, y le pegamos el nombre y el tipo de las columnas, que en nuestro caso son:</p> <pre><code>custId INT,\nfName STRING,\nlName STRING,\ncity STRING\n</code></pre> <p>Cuando los hayamos introducido, veremos como se han creado dichas columnas:</p> Athena - Configuraci\u00f3n del formato <p>Finalmente, veremos a modo de resumen una instrucci\u00f3n <code>create table</code> similar a la siguiente y ya podemos pulsar sobre Create table:</p> <pre><code>CREATE EXTERNAL TABLE IF NOT EXISTS `s8a-retail`.`customers` (\n`custid` int,\n`fname` string,\n`lname` string,\n`city` string\n)\nROW FORMAT SERDE 'org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe'\nWITH SERDEPROPERTIES ('field.delim' = ',')\nSTORED AS INPUTFORMAT 'org.apache.hadoop.mapred.TextInputFormat' OUTPUTFORMAT 'org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat'\nLOCATION 's3://s3severo8a/customers/'\nTBLPROPERTIES ('classification' = 'csv');\n</code></pre>"},{"location":"cloud/07athena.html#realizando-consultas","title":"Realizando consultas","text":"<p>Si volvemos a la pantalla de Query Editor, si pinchamos sobre los tres puntos de la tabla <code>customers</code>, podemos hacer un preview de la tabla, y veremos que autom\u00e1ticamente realiza una consulta de tipo <code>select * from customers</code></p> Athena - Realizaci\u00f3n de una consulta"},{"location":"cloud/07athena.html#referencias","title":"Referencias","text":"<ul> <li>Gu\u00eda de usuario de AWS Athena</li> <li>Getting started with AWS Athena</li> </ul>"},{"location":"dataflow/index.html","title":"Flujos de datos","text":""},{"location":"dataflow/index.html#resultados-de-aprendizaje","title":"Resultados de aprendizaje","text":"<ul> <li>RA5074.1 Aplica t\u00e9cnicas de an\u00e1lisis de datos que integran, procesan y analizan la informaci\u00f3n, adaptando e implementando sistemas que las utilicen.  </li> <li>RA5074.3 Gestiona y almacena datos facilitando la b\u00fasqueda de respuestas en grandes conjuntos de datos.  </li> <li>RA5075.1 Gestiona soluciones a problemas propuestos, utilizando sistemas de almacenamiento y herramientas asociadas al centro de datos.  </li> <li>RA5075.2 Gestiona sistemas de almacenamiento y el amplio ecosistema alrededor de ellos facilitando el procesamiento de grandes cantidades de datos sin fallos y de forma r\u00e1pida.  </li> <li>RA5075.3 Genera mecanismos de integridad de los datos, comprobando su mantenimiento en los sistemas de ficheros distribuidos y valorando la sobrecarga que conlleva en el tratamiento de los datos.</li> </ul>"},{"location":"dataflow/index.html#planificacion-20h","title":"Planificaci\u00f3n (20h)","text":"Sesi\u00f3n Fecha Duraci\u00f3n (h) 90.- Nifi I Lunes 6 Mar 2p + 2o 92.- Nifi II Mi\u00e9rcoles 8 Mar 2p + 2o 97.- Kafka I Mi\u00e9rcoles 15 Mar 2p + 2o 99.- Kafka II Lunes 20 Mar 2p + 2o"},{"location":"dataflow/02kafka.html","title":"Kafka","text":""},{"location":"dataflow/02kafka.html#introduccion","title":"Introducci\u00f3n","text":"<p>Apache Kafka es, en pocas palabras, un middleware de mensajer\u00eda entre sistemas heterog\u00e9neos, el cual, mediante un sistema de colas (topics, para ser concreto) facilita la comunicaci\u00f3n as\u00edncrona, desacoplando los flujos de datos de los sistemas que los producen o consumen. Funciona como un broker de mensajes, encargado de enrutar los mensajes entre los clientes de un modo muy r\u00e1pido.</p> <p>Supongamos que tenemos multiples generadores de datos, ya sean servidores web, de bases de datos, un servidor de chat y que todos ellos tienen que almacenar sus datos en m\u00faltiples destinos, como pueden ser logs, m\u00e9tricas de rendimiento y monitorizaci\u00f3n, el carrito de la compra o los fallos ocurridos, lo que puede provocar una serie de dependencias de unos con otros. Para evitarlo, Kafka viene al rescate conectando todos los generadores de datos (productores) a Kafka y a su vez, a todos los consumidores de estos datos.</p> Kafka como middleware/broker de mensajes <p>En concreto, se trata de una plataforma open source distribuida de transmisi\u00f3n de eventos/mensajes en tiempo real con almacenamiento duradero y que proporciona de base un alto rendimiento (capaz de manejar billones de peticiones al d\u00eda, con una latencia inferior a 10ms), tolerancia a fallos, disponibilidad y escalabilidad horizontal (mediante cientos de nodos).</p> <p>Evento / Mensaje</p> <p>Dentro del vocabulario asociado a arquitecturas as\u00edncronas basadas en productor/consumidor o publicador/suscriptor, se utiliza el mensaje para indicar el dato que viaja desde un punto a otro. En Kafka, adem\u00e1s de utilizar el concepto mensaje, se emplea el t\u00e9rmino evento.</p> <p>M\u00e1s del 80% de las 100 compa\u00f1\u00edas m\u00e1s importantes de EEUU utilizan Kafka: Uber, Twitter, Netflix, Spotify, Blizzard, LinkedIn, Spotify, y PayPal procesan cada d\u00eda sus mensajes con Kafka.</p> <p>Como sistema de mensajes, sigue un modelo publicador-suscriptor. Su arquitectura tiene dos directivas claras:</p> <ul> <li>No bloquear los productores (para poder gestionar la back pressure, la cual sucede cuando un publicador produce m\u00e1s elementos de los que un suscriptor puede consumir).</li> <li>Aislar los productores y los consumidores, de manera que los productores y los consumidores no se conocen.</li> </ul> <p>A d\u00eda de hoy, Apache Kafka se utiliza, adem\u00e1s de como un sistema de mensajer\u00eda, para ingestar datos, realizar procesado de datos en streaming y anal\u00edtica de datos en tiempo real, as\u00ed como en arquitectura de microservicios y sistemas IOT.</p> <p>Amazon Kinesis</p> <p>Amazon Kinesis es un producto similar a Apache Kafka pero dentro de la plataforma AWS, por lo que no es un producto open source como tal. Su principal ventaja es la facilidad de escalabilidad a golpe de click e integraci\u00f3n con el resto de servicios que ofrece AWS. Se trata de una herramienta muy utilizada que permite incorporar datos en tiempo real, como v\u00eddeos, audios, registros de aplicaciones, secuencias de clicks de sitios web y datos de sensores IoT para machine learning, anal\u00edtica de datos en streaming, etc...</p>"},{"location":"dataflow/02kafka.html#publicador-suscriptor","title":"Publicador / Suscriptor","text":"<p>Antes de entrar en detalle sobre Kafka, hay que conocer el modelo publicador/suscriptor. Este patr\u00f3n tambi\u00e9n se conoce como publish / subscribe o productor / consumidor.</p> <p>Hay tres elementos que hay que tener realmente claros:</p> <ul> <li>Publicador (publisher / productor / emisor): genera un dato y lo coloca en un topic como un mensaje.</li> <li>topic (tema): almac\u00e9n temporal/duradero que guarda los mensajes funcionando como una cola.</li> <li>Suscriptor (subscriber / consumidor / receptor): recibe el mensaje.</li> </ul> <p>Cabe destacar que un productor no se comunica nunca directamente con un consumidor, siempre lo hace a trav\u00e9s de un topic:</p> Productor - Consumidor"},{"location":"dataflow/02kafka.html#caso-0-hola-kafka","title":"Caso 0: Hola Kafka","text":"<p>Para arrancar Kafka, vamos a utilizar la instalaci\u00f3n que tenemos creada en nuestra m\u00e1quina virtual.</p> <p>Kafka mediante Docker</p> <p>Bitnami tiene una imagen para trabajar con Docker la cual permite probar todos los ejemplos de esta sesi\u00f3n. Para ello, se recomienda seguir los pasos de la p\u00e1gina oficial: https://hub.docker.com/r/bitnami/kafka/</p> <p>El primer paso, una vez dentro de la carpeta de instalaci\u00f3n de Kafka (en nuestro caso <code>/opt/kafka_2.13-3.3.1</code>), es arrancar Zookeeper mediante el comando <code>zookeeper-server-start.sh</code>, el cual se encarga de gestionar la comunicaci\u00f3n entre los diferentes brokers:</p> <pre><code>zookeeper-server-start.sh ./config/zookeeper.properties\n</code></pre> <p>zookeeper.properties</p> <p>Del archivo de configuraci\u00f3n de Zookeeper conviene destacar dos propiedades:</p> <ul> <li><code>clientPort</code>: puerto por defecto (2181)</li> <li><code>dataDir</code>: indica donde est\u00e1 el directorio de datos de Zookeeper (por defecto es <code>tmp/zookeeper</code>, pero si queremos que dicha carpeta no se elimine es mejor que apunte a una ruta propia, por ejemplo <code>/opt/zookeeper-data</code>)</li> </ul> <p>Para comprobar que Zookeeper est\u00e1 arrancado, podemos ejecutar el comando <code>lsof -i :2181</code>, el cual escanea el puerto 2181 donde est\u00e1 corriendo Zookeeper.</p> <p>Una vez comprobado, en un nuevo terminal, arrancamos el servidor de Kafka mediante el comando <code>kafka-server-start.sh</code> (de manera que tenemos corriendo a la vez Zookeeper y Kafka):</p> <pre><code>kafka-server-start.sh ./config/server.properties\n</code></pre> <p>Instalaci\u00f3n de pruebas</p> <p>En nuestra m\u00e1quina virtual, en los archivos de configuraci\u00f3n, hemos puesto que todas las rutas utilicen <code>/tmp</code> para no llenar el disco duro de datos, en concreto la propiedad <code>log.dirs</code>.</p> <p>Por ello, entre cada reinicio de la m\u00e1quina virtual, tendremos que volver a crear los diferentes topics, habiendo perdido los mensajes que no se hubieran consumido.</p>"},{"location":"dataflow/02kafka.html#creando-un-topic","title":"Creando un topic","text":"<p>A continuaci\u00f3n, en un tercer terminal, vamos a crear un topic mediante el comando <code>kafka-topics.sh</code>, utilizando el par\u00e1metro <code>--create</code>:</p> <pre><code>kafka-topics.sh --create --topic iabd-topic --bootstrap-server iabd-virtualbox:9092\n</code></pre> <p>Si quisi\u00e9ramos comprobar los topics que hemos creado, podemos obtener un listado mediante el par\u00e1metro <code>--list</code>:</p> <pre><code>kafka-topics.sh --list --bootstrap-server iabd-virtualbox:9092\n</code></pre> <p>Si queremos obtener la descripci\u00f3n del topic creado con la cantidad de particiones le pasamos el par\u00e1metro <code>--describe</code>:</p> <pre><code>kafka-topics.sh --describe --topic iabd-topic --bootstrap-server iabd-virtualbox:9092\n</code></pre> <p>Obteniendo la siguiente informaci\u00f3n:</p> <pre><code>Topic: iabd-topic       TopicId: ogKnRpOFS7mfOhspLcuB4A PartitionCount: 1       ReplicationFactor: 1      Configs: segment.bytes=1073741824\n        Topic: iabd-topic       Partition: 0    Leader: 0       Replicas: 0     Isr: 0\n</code></pre>"},{"location":"dataflow/02kafka.html#produciendo-mensajes","title":"Produciendo mensajes","text":"<p>Para enviar un mensaje a un topic, ejecutaremos en un cuarto terminal un productor mediante el comando <code>kafka-console-producer.sh</code>. Por defecto, cada l\u00ednea que introduzcamos resultar\u00e1 en un evento separado que escribir\u00e1 un mensaje en el topic (podemos pulsar CTRL+C en cualquier momento para cancelar):</p> <pre><code>kafka-console-producer.sh --topic iabd-topic --bootstrap-server iabd-virtualbox:9092\n</code></pre> <p>As\u00ed pues, escribimos los mensajes que queramos:</p> <pre><code>&gt;Este es un mensaje\n&gt;Y este es otro\n&gt;Y el tercero\n</code></pre>"},{"location":"dataflow/02kafka.html#consumiendo-mensajes","title":"Consumiendo mensajes","text":"<p>Y finalmente, en otro terminal, vamos a consumir los mensajes:</p> <pre><code>kafka-console-consumer.sh --topic iabd-topic --from-beginning --bootstrap-server iabd-virtualbox:9092\n</code></pre> <p>Al ejecutarlo veremos los mensajes que hab\u00edamos introducido antes (ya que hemos indicado la opci\u00f3n <code>--from-beginning</code>). Si ahora volvemos a escribir en el productor, casi instant\u00e1neamente, aparecer\u00e1 en el consumidor el mismo mensaje.</p> <p>Tras esto, paramos todos los procesos que se est\u00e1n ejecutando mediante CTRL+C y hemos finalizado nuestro primer contacto con Kafka.</p>"},{"location":"dataflow/02kafka.html#elementos","title":"Elementos","text":"<p>Dentro de una arquitectura con Kafka, existen m\u00faltiples elementos que interact\u00faan entre s\u00ed.</p>"},{"location":"dataflow/02kafka.html#topic-y-particiones","title":"Topic y Particiones","text":"<p>Un topic (\u00bftema?) es un flujo particular de datos que funciona como una cola almacenando de forma temporal o duradera los datos que se colocan en \u00e9l.</p> <p>Podemos crear tantos topics como queramos y cada uno de ellos tendr\u00e1 un nombre un\u00edvoco.</p> <p>Un topic se divide en particiones, las cuales se numeran, siendo la primera la 0. Al crear un topic podemos indicar la cantidad de particiones inicial, la cual podemos modificar a posteriori (en nuestra m\u00e1quina virtual, en el archivo <code>server.properties</code> tenemos configurado que, por defecto, cada topic tenga una sola partici\u00f3n mediante la propiedad <code>num.partitions=1</code>).</p> <p>Al crear un topic, si queremos indicar la cantidad de particiones, hemos de pasarle el par\u00e1metro <code>--partitions</code> y el n\u00famero de particiones deseadas:</p> <pre><code>kafka-topics.sh --create --topic iabd-topic-p3 --partitions 3 --bootstrap-server iabd-virtualbox:9092\n</code></pre> <p>Cada partici\u00f3n est\u00e1 ordenada, de manera que cada mensaje dentro de una partici\u00f3n tendr\u00e1 un identificador incremental, llamado offset (desplazamiento). Cada partici\u00f3n funciona como un commit log almacenando los mensajes que recibe.</p> Offset dentro de las particiones de un topic <p>Como podemos observar en la imagen, cada partici\u00f3n tiene sus propios offset (el offset 3 de la partici\u00f3n 0 no representa el mismo dato que el offset 3 de la partici\u00f3n 1).</p> <p>Hab\u00edamos comentado que las particiones est\u00e1n ordenadas, pero el orden s\u00f3lo se garantiza dentro de una partici\u00f3n (no entre particiones), es decir, el mensaje 7 de la partici\u00f3n 0 puede haber llegado antes, a la vez, o despu\u00e9s que el mensaje 5 de la partici\u00f3n 1.</p> <p>Los datos de una partici\u00f3n tiene un tiempo de vida limitado (retention period) que indica el tiempo que se mantendr\u00e1n los mensajes antes de eliminarlos. Por defecto es de una semana. Adem\u00e1s, una vez que los datos se escriben en una partici\u00f3n, no se pueden modificar (las mensajes son immutables).</p> <p>Finalmente, por defecto, los datos se asignan de manera aleatoria a una partici\u00f3n. Sin embargo, existe la posibilidad de indicar una clave de particionado.</p> <p>Borrando un topic</p> <p>Para eliminar un topic, le pasaremos el par\u00e1metro <code>--delete</code>:</p> <pre><code>kafka-topics.sh --delete --topic iabd-topic --bootstrap-server iabd-virtualbox:9092\n</code></pre> <p>Al borrar un topic, sus \u00edndices con el hist\u00f3rico no se eliminan, de manera que volver a crear un topic con el mismo nombre es una mala idea ya que podemos obtener datos incongruentes.</p>"},{"location":"dataflow/02kafka.html#brokers","title":"Brokers","text":"<p>Un cl\u00faster de Kafka est\u00e1 compuesto de m\u00faltiples nodos conocidos como Brokers, donde cada broker es un servidor de Kafka. Cada broker se identifica con un id, el cual debe ser un n\u00famero entero.</p> <p>Cada broker contiene un conjunto de particiones, de manera que un broker contiene parte de los datos, nunca los datos completos ya que Kafka es un sistema distribuido. Al conectarse a un broker del cl\u00faster (bootstrap broker), autom\u00e1ticamente nos conectaremos al cl\u00faster entero.</p> <p>Para comenzar se recomienda una arquitectura de 3 brokers, aunque algunos cl\u00fasters lo forman cerca de un centenar de brokers.</p> <p>Por ejemplo, el siguiente gr\u00e1fico muestra un cl\u00faster con tres brokers, de manera que el topic A est\u00e1 dividido en tres particiones, cada una de ellas residiendo en un broker diferente (no hay ninguna relaci\u00f3n entre el n\u00famero de la partici\u00f3n y el nombre del broker), y el topic B est\u00e1 a su vez dividido en dos particiones:</p> Ejemplo de 3 brokers <p>En el caso de haber introducido un nuevo topic con 4 particiones, uno de los brokers contendr\u00eda dos particiones.</p>"},{"location":"dataflow/02kafka.html#factor-de-replicacion","title":"Factor de replicaci\u00f3n","text":"<p>Para soportar la tolerancia a fallos, los topics deben tener un factor de replicaci\u00f3n mayor que uno (normalmente se configura entre 2 y 3).</p> <p>En la siguiente imagen podemos ver como tenemos 3 brokers, y un topic A con dos particiones y un factor de replicaci\u00f3n de 2, de manera que cada partici\u00f3n crea un replica de si misma:</p> Divisiones de un broker en particiones <p>Para crear la configuraci\u00f3n del gr\u00e1fico, debemos indicar el factor de replicaci\u00f3n mediante <code>--replication-factor</code>:</p> <pre><code>kafka-topics.sh --create --topic TopicA --partitions 2 --replication-factor 2 --bootstrap-server iabd-virtualbox:9092\n</code></pre> <p>Si se cayera el broker 102, Kafka podr\u00eda devolver los datos al estar disponibles en los nodos 101 y 103.</p>"},{"location":"dataflow/02kafka.html#replica-lider","title":"R\u00e9plica l\u00edder","text":"<p>Acabamos de ver que cada broker tiene m\u00faltiples particiones, y cada partici\u00f3n tiene m\u00faltiples r\u00e9plicas, de manera que si se cae un nodo/broker, Kafka puede utilizar otro broker para servir los datos.</p> <p>En cualquier instante, una determinada partici\u00f3n tendr\u00e1 una \u00fanica r\u00e9plica que ser\u00e1 la l\u00edder, y esta r\u00e9plica l\u00edder ser\u00e1 la \u00fanica que pueda recibir y servir los datos de una partici\u00f3n. La r\u00e9plica l\u00edder es importante porque todas las lecturas y escrituras siempre van a esta r\u00e9plica. El resto de brokers sincronizar\u00e1n sus datos. En resumen, cada partici\u00f3n tendr\u00e1 un l\u00edder y m\u00faltiples ISR (in-sync replica).</p> R\u00e9plicas de una partici\u00f3n <p>Si se cayera el Broker 101 , entonces la partici\u00f3n 0 del Broker 102 se convertir\u00eda en la l\u00edder. Y cuando vuelva a funcionar el Broker 101, intentar\u00e1 volver a ser la partici\u00f3n l\u00edder.</p>"},{"location":"dataflow/02kafka.html#productores","title":"Productores","text":"<p>Los productores escriben datos en los topics, sabiendo autom\u00e1ticamente el broker y la partici\u00f3n en la cual deben escribir. En el caso de un fallo de un broker, los productores autom\u00e1ticamente se recuperan y se comunican con el broker adecuado.</p> <p>Si el productor env\u00eda los datos sin una clave determinada, Kafka utiliza un algoritmo de Round Robin, de manera que cada mensaje se va alternando entre los diferentes brokers.</p> La carga se balancea entre los brokers <p>Podemos configurar los productores para que reciban un ACK de las escrituras de los datos con los siguientes valores:</p> <ul> <li><code>ack=0</code>: El productor no espera la confirmaci\u00f3n (posible p\u00e9rdida de datos), lo que se traduce en un env\u00edo as\u00edncrono.</li> <li><code>ack=1</code>: El productor espera la confirmaci\u00f3n del l\u00edder (limitaci\u00f3n de la p\u00e9rdida de datos), de manera que los env\u00edos son s\u00edncronos.</li> <li><code>ack=all</code>: El productores espera la confirmaci\u00f3n del l\u00edder y de todas las r\u00e9plicas (sin p\u00e9rdida de datos).</li> </ul>"},{"location":"dataflow/02kafka.html#clave-de-mensaje","title":"Clave de mensaje","text":"<p>Los productores pueden enviar una clave con el mensaje (de tipo cadena, num\u00e9rico, etc...). Cuando la clave no se env\u00eda, ya hemos comentado que los datos se env\u00edan mediante Round Robin (primero Broker 101, luego el 102, el 103, etc... y vuelta al 101).</p> <p>Kafka trabaja con pares clave-valor, de manera que si no indicamos la clave, de considerar\u00e1 por defecto como nula y por tanto, la partici\u00f3n se identifica mediante round robin. Si se env\u00eda la clave, todos los mensajes con la misma clave siempre ir\u00e1n a la misma partici\u00f3n. Por lo tanto, enviaremos una clave cuando necesitemos ordenar los mensajes por un campo espec\u00edfico (por ejemplo, el identificador de una operaci\u00f3n).</p> <p>Para enviar mensajes con la clave, desde el terminal, necesitamos indicar dos propiedades mediante <code>--property</code>:</p> <ul> <li><code>parse.key</code>: si es <code>true</code>, obligatoriamente enviaremos la clave (por defecto es <code>false</code>)</li> <li><code>key.separator</code>: car\u00e1cter para separar la clave del valor, por ejemplo, <code>:</code>, <code>;</code>, ....</li> </ul> <p>As\u00ed pues, podemos enviar mensajes con clave mediante:</p> <pre><code>kafka-console-producer.sh --topic iabd-topic --property \"parse.key=true\" --property \"key.separator=:\" \\\n--bootstrap-server iabd-virtualbox:9092\n</code></pre> <p>Y luego enviar mensajes del estilo:</p> <pre><code>clave1:valor1\nclave2:valor2\nclave1:valor3\ncustomer_id: {\"customer_id\":\"1\", \"customer_fname\": \"Aitor\", \"customer_lname\": \"Medrano\", \"customer_email\": \"a.medrano@edu.gva.es\"}\n</code></pre>"},{"location":"dataflow/02kafka.html#consumidores","title":"Consumidores","text":"<p>Los consumidores obtienen los datos de los topics y las particiones, y saben de qu\u00e9 broker deben leer los datos. Igual que los productores, en el caso de un fallo de un broker, los consumidores autom\u00e1ticamente se recuperan y se comunican con el broker adecuado.</p> <p>Los datos se leen en orden dentro de cada partici\u00f3n, de manera que el consumidor no podr\u00e1 leer, por ejemplo, los datos del offset 6 hasta que no haya le\u00eddo los del offset 5. Adem\u00e1s, un consumidor puede leer de varias particiones (se realiza en paralelo), pero el orden s\u00f3lo se respeta dentro de cada partici\u00f3n, no entre particiones:</p> Los consumidores leen en orden dentro de cada partici\u00f3n"},{"location":"dataflow/02kafka.html#grupo-de-consumidores","title":"Grupo de consumidores","text":"<p>Un consumidor puede pertenecer a un grupo de consumidores, de manera que cada uno de los consumidores del grupo obtendr\u00e1n una parte de los datos, es decir, una partici\u00f3n de un topic.</p> <p>Por ejemplo, tenemos una aplicaci\u00f3n compuesta de dos consumidores, formando un grupo de consumidores. El consumidor 1 lo har\u00e1 de dos particiones, y el consumidor 2 lo har\u00e1 de la tercera partici\u00f3n. Tambi\u00e9n tenemos otra aplicaci\u00f3n compuesta de tres consumidores, de manera que cada consumidor lo har\u00e1 de cada una de las particiones. Finalmente, tenemos un tercer grupo de consumidores formado por un \u00fanico consumidor que leer\u00e1 las tres particiones. En conclusi\u00f3n, cada grupo de consumidores funciona como un \u00fanico consumidor de manera que accede a todas las particiones de un topic.</p> Grupos de consumidores <p>Coordinando los consumidores</p> <p>Los consumidores, por s\u00ed solos, no saben con que partici\u00f3n se deben comunicar. Para ello, se utiliza un GroupCoordinator y un Consumer Coordinator para asignar los consumidores a cada partici\u00f3n. Esta gesti\u00f3n la realiza Kafka.</p> <p>Cabe destacar que los diferentes grupos de consumidores reciben el mismo dato de cada partici\u00f3n, es decir, el consumidor 1 del grupo 1 y el consumidor 1 del grupo 2 reciben la informaci\u00f3n que hab\u00eda en la partici\u00f3n 0. Este caso de uso es muy \u00fatil cuando tenemos dos aplicaciones que queremos que reciban los mismos datos (por ejemplo, uno encargado de realizar machine learning y otro anal\u00edtica de datos).</p> <p>En el caso de tener m\u00e1s consumidores que particiones, algunos consumidores no realizar\u00e1n nada. Este caso de uso es at\u00edpico, ya que lo recomendable es tener tantos consumidores como el mayor n\u00famero de particiones existentes.</p>"},{"location":"dataflow/02kafka.html#probando-los-grupos-de-consumidores","title":"Probando los grupos de consumidores","text":"<p>Vamos a simular el gr\u00e1fico anterior mediante un ejemplo con el terminal. Primero crearemos un topic que contenga tres particiones:</p> <pre><code>kafka-topics.sh --create --topic iabd-topic-group \\\n--bootstrap-server iabd-virtualbox:9092 --partitions 3\n</code></pre> <p>Si comprobamos el estado del topic mediante:</p> <pre><code>kafka-topics.sh --describe --topic iabd-topic-group \\\n--bootstrap-server iabd-virtualbox:9092\n</code></pre> <p>Obtendremos la siguiente informaci\u00f3n:</p> <pre><code>Topic: iabd-topic-group TopicId: p1i3m4fMRximngLjAV5rsA PartitionCount: 3       ReplicationFactor: 1    Configs: segment.bytes=1073741824\n        Topic: iabd-topic-group Partition: 0    Leader: 0       Replicas: 0     Isr: 0\n        Topic: iabd-topic-group Partition: 1    Leader: 0       Replicas: 0     Isr: 0\n        Topic: iabd-topic-group Partition: 2    Leader: 0       Replicas: 0     Isr: 0\n</code></pre> <p>A continuaci\u00f3n, en dos pesta\u00f1as diferentes, vamos a crear dos consumidores que pertenezcan al mismo grupo de consumidores:</p> <pre><code>kafka-console-consumer.sh --topic iabd-topic-group \\\n--group iabd-app1 \\\n--bootstrap-server iabd-virtualbox:9092\n</code></pre> <p>Y finalmente, creamos un nuevo productor sobre el topic:</p> <pre><code>kafka-console-producer.sh --topic iabd-topic-group \\\n--bootstrap-server iabd-virtualbox:9092\n</code></pre> <p>Y si creamos varios mensajes en el productor, veremos c\u00f3mo van llegando de manera alterna a los diferentes consumidores:</p> Ejemplo de grupo de consumidores <p>Autoevaluaci\u00f3n</p> <ul> <li>\u00bfQue suceder\u00e1 se creamos un nuevo consumidor que lo haga del mismo topic pero con un grupo de consumidores diferente (por ejemplo, <code>iabd-app2</code>) y le pedimos que lea los mensajes desde el principio (mediante <code>--from-beginning</code>) ?     Que aparecer\u00e1n todos los mensajes desde el principio.</li> <li>\u00bfY si lo detenemos y volvemos a crear el mismo consumidor (tambi\u00e9n con el grupo de consumidores <code>iabd-app2</code> y los vuelva a leer desde el principio tambi\u00e9n)?     En esta ocasi\u00f3n, ya no recibir\u00e1 ning\u00fan mensaje, ya que el primer consumidor hace commit de la lectura y el segundo al hacerlo desde el mismo grupo de consumidores ya tiene los mensajes previos marcados como le\u00eddos.</li> <li>\u00bfY si detenemos todos los consumidores y seguimos creando mensajes en el productor?     Los mensajes se almacenan en el topic.</li> <li>\u00bfY si arrancamos de nuevo un consumidor sobre el grupo de consumidores <code>iabd-app2</code>?     Que consumir\u00e1 los mensajes que acabamos de crear.</li> </ul> <p>Mediante el comando <code>kafka-consumer-groups.sh</code> podemos obtener sobre los diferentes grupos de consumidores que tenemos creado, as\u00ed como eliminarlos o resetear sus offsets.</p> <p>Por ejemplo, si queremos listar los grupos de consumidores existentes ejecutaremos:</p> <pre><code>kafka-consumer-groups.sh --list \\\n--bootstrap-server iabd-virtualbox:9092\n</code></pre> <p>En cambio, si queremos obtener la informaci\u00f3n de un determinado grupo ejecutaremos:</p> <pre><code>kafka-consumer-groups.sh --describe --group iabd-app1 \\\n--bootstrap-server iabd-virtualbox:9092\n</code></pre> <p>Obteniendo informaci\u00f3n a destacar como:</p> <ul> <li><code>CURRENT-OFFSET</code>: valor actual del offset</li> <li><code>LOG-END-OFFSET</code>: offset del \u00faltimo mensaje de la partici\u00f3n</li> <li><code>LAG</code>: cantidad de mensajes pendientes de leer</li> </ul> <pre><code>GROUP           TOPIC            PARTITION  CURRENT-OFFSET  LOG-END-OFFSET  LAG             CONSUMER-ID                                               HOST            CLIENT-ID\niabd-app1       iabd-topic-group 0          4               4               0               consumer-iabd-app1-1-405b2b39-2252-4e12-ba55-00a579441df2 /127.0.0.1      consumer-iabd-app1-1\niabd-app1       iabd-topic-group 1          2               2               0               consumer-iabd-app1-1-405b2b39-2252-4e12-ba55-00a579441df2 /127.0.0.1      consumer-iabd-app1-1\niabd-app1       iabd-topic-group 2          4               4               0               consumer-iabd-app1-1-8f09bc45-8e8c-46d2-9c9c-cf6bd3a5fdc7 /127.0.0.1      consumer-iabd-app1-1\n</code></pre> <p>Si por ejemplo, con todos los consumidores detenidos, mediante un productor lanzamos 5 mensajes nuevos, estos se quedar\u00e1n en el topic a la espera de ser consumidos, y se habr\u00e1n repartidos entre las diferentes particiones. Si volvemos a lanzar el comando anterior obtendr\u00edamos:</p> <pre><code>Consumer group 'iabd-app1' has no active members.\n\nGROUP           TOPIC            PARTITION  CURRENT-OFFSET  LOG-END-OFFSET  LAG             CONSUMER-ID     HOST            CLIENT-ID\niabd-app1       iabd-topic-group 2          4               5               1               -               -               -\niabd-app1       iabd-topic-group 1          2               4               2               -               -               -\niabd-app1       iabd-topic-group 0          4               6               2               -               -               -\n</code></pre>"},{"location":"dataflow/02kafka.html#offsets-de-consumidor","title":"Offsets de Consumidor","text":"<p>Kafka almacena los offsets por el que va leyendo un grupo de consumidores, a modo de checkpoint, en un topic llamado <code>__consumer_offsets</code>.</p> <p>Cuando un consumidor de un grupo ha procesado los datos que ha le\u00eddo de Kafka, realizar\u00e1 un commit de sus offsets. Si el consumidor se cae, podr\u00e1 volver a leer los mensajes desde el \u00faltimo offset sobre el que se realiz\u00f3 commit.</p> <p>Por ejemplo, supongamos que tenemos un consumidor el cual ha hecho un commit tras el offset 4262. Tras el commit seguimos leyendo los siguientes mensajes: 4263, 4264, 4265 y de repente el consumidor se cae sin haber hecho commit de esos mensajes. Cuando el consumidor vuelva a funcionar, volver\u00e1 a leer los mensajes desde el 4263, asegur\u00e1ndose que no se ha quedado ning\u00fan mensaje sin procesar.</p> Offsets de consumidor <p>El commit de los mensajes est\u00e1 muy relacionado con la sem\u00e1ntica de la entrega. Los consumidores eligen cuando realizar el commit de los offsets:</p> <ul> <li>As most once: se realiza el commit del mensaje tan pronto como se recibe el mensaje. Si falla su procesamiento, el mensaje se perder\u00e1 (y no se volver\u00e1 a leer).</li> <li>At least once (opci\u00f3n m\u00e1s equilibrada): El commit se realiza una vez procesado el mensaje. Este enfoque puede resultar en un procesado duplicado de los mensajes, por lo que hemos de asegurarnos que son idempotentes (el volver a procesar un mensaje no tendr\u00e1 un impacto en el sistema)</li> <li>Exactly once: s\u00f3lo se puede conseguir utilizando flujos de trabajo de Kafka con Kafka mediante el API de Kafka Streams. Si necesitamos la interacci\u00f3n de Kafka con un sistema externo, como una base de datos, se recomienda utilizar un consumidor idempotente que nos asegura que no habr\u00e1 duplicados en la base de datos.</li> </ul>"},{"location":"dataflow/02kafka.html#descubrimiento-de-brokers","title":"Descubrimiento de brokers","text":"<p>Cada broker de Kafka es un bootstrap server, lo que significa que dicho servidor contiene un listado con todos los nodos del cl\u00faster, de manera que al conectarnos a un broker, autom\u00e1ticamente nos conectaremos al cl\u00faster entero.</p> <p>Mediante esta configuraci\u00f3n, cada broker conoce todos los brokers, topics y particiones (metadatos del cl\u00faster).</p> <p>As\u00ed pues, cuando un cliente se conecta a un broker, tambi\u00e9n realiza una petici\u00f3n de los metadatos, y obtiene un listado con todos los brokers. Tras ello, ya puede conectarse a cualquiera de los brokers que necesite:</p> Descubrimiento de brokers"},{"location":"dataflow/02kafka.html#zookeeper","title":"Zookeeper","text":"<p>En la primera sesi\u00f3n de Hadoop ya vimos que ZooKeeper es un servicio para mantener la configuraci\u00f3n, coordinaci\u00f3n y aprovisionamiento de aplicaciones distribuidas dentro del ecosistema de Apache. No s\u00f3lo se utiliza en Hadoop, pero es muy \u00fatil ya que elimina la complejidad de la gesti\u00f3n distribuida de la plataforma.</p> <p>En el caso de Kafka, Zookeeper:</p> <ul> <li>gestiona los brokers (manteniendo una lista de ellos).</li> <li>ayuda en la elecci\u00f3n de la partici\u00f3n l\u00edder</li> <li>env\u00eda notificaciones a Kafka cuando hay alg\u00fan cambio (por ejemplo, se crea un topic, se cae un broker, se recupera un broker, al eliminar un topic, etc...).</li> </ul> <p>Por todo ello, Kafka no puede funcionar sin Zookeeper.</p> <p>En un entorno real, se instalan un n\u00famero impar de servidores Zookeeper (3, 5, 7). Para su gesti\u00f3n, Zookeeper define un l\u00edder (gestiona las escrituras) y el resto de servidores funcionan como r\u00e9plicas de lectura.</p> Kafka y Zookeeper <p>Pese a su dependencia, los productores y consumidores no interact\u00faan nunca con Zookeeper, s\u00f3lo lo hacen con Kafka.</p> <p>Kraft</p> <p>Aunque podemos decir que todav\u00eda no es la opci\u00f3n m\u00e1s recomendable en producci\u00f3n, tambi\u00e9n podemos utilizar una instalaci\u00f3n de Kafka sin Zookeeper haciendo uso de Kraft, el cual ofrece un nuevo protocolo de consenso y evita tener una infraestructura extra para Zookeeper.</p>"},{"location":"dataflow/02kafka.html#en-resumen","title":"En Resumen","text":"<p>Kafka garantiza que...</p> <ul> <li>Los mensajes se a\u00f1aden a una partici\u00f3n/topic en el orden en el que se env\u00edan</li> <li>Los consumidores leen los mensajes en el orden en que se almacenaron en la partici\u00f3n/topic</li> <li>Con un factor de replicaci\u00f3n N, los productores y consumidores pueden soportar que se caigan N-1 brokers.<ul> <li>Por ejemplo, con un factor de replicaci\u00f3n de 3 (el cual es un valor muy apropiado), podemos tener un nodo detenido para mantenimiento y podemos permitirnos que otro de los nodos se caiga de forma inesperada.</li> </ul> </li> <li>Mientras el n\u00famero de particiones de un topic permanezca constante (no se hayan creado nuevas particiones), la misma clave implicar\u00e1 que los mensajes vayan a la misma partici\u00f3n.</li> </ul>"},{"location":"dataflow/02kafka.html#caso-1-kafka-y-python","title":"Caso 1: Kafka y Python","text":"<p>Para poder producir y consumir mensajes desde Python necesitamos instalar la librer\u00eda Kafka-python:</p> <pre><code>pip install kafka-python\n</code></pre>"},{"location":"dataflow/02kafka.html#kafkaconsumer","title":"KafkaConsumer","text":"<p>Vamos a crear un consumidor, mediante un KafkaConsumer, que escuche de nuestro servidor de Kafka:</p> consumer.py<pre><code>from kafka import KafkaConsumer\nfrom json import loads\nconsumer = KafkaConsumer(\n'iabd-topic',\nauto_offset_reset='earliest',\nenable_auto_commit=True,\ngroup_id='iabd-grupo-1',\nvalue_deserializer=lambda m: loads(m.decode('utf-8')),\nbootstrap_servers=['iabd-virtualbox:9092'])\nfor m in consumer:\nprint(m.value)\n</code></pre> <p>Al crear el consumidor, configuramos los siguientes par\u00e1metros:</p> <ul> <li>en el primer par\u00e1metro indicamos el topic desde el que vamos a consumir los mensajes</li> <li><code>bootstrap_servers</code>: listado de brokers de Kafka</li> <li><code>auto_offset_reset</code>: le indica al consumidor desde donde empezar a leer los mensaje si se cae: <code>earliest</code> se mover\u00e1 hasta el mensaje m\u00e1s antiguo y <code>latest</code> al m\u00e1s reciente.</li> <li><code>enable_auto_commit</code>: si <code>True</code>, el offset del consumidor realizar\u00e1 peri\u00f3dicamente commit en segundo plano.</li> <li><code>value_deserializer</code>: m\u00e9todo utilizado para deserializar los datos. En este caso, transforma los datos recibidos en JSON.</li> </ul>"},{"location":"dataflow/02kafka.html#kafkaproducer","title":"KafkaProducer","text":"<p>Y para el productor, mediante un KafkaProducer, vamos a enviar 10 mensajes en formato JSON:</p> producer.py<pre><code>from kafka import KafkaProducer\nfrom json import dumps\nimport time\nproducer = KafkaProducer(\nvalue_serializer=lambda m: dumps(m).encode('utf-8'),\nbootstrap_servers=['iabd-virtualbox:9092'])\nfor i in range(10):\nproducer.send(\"iabd-topic\", value={\"nombre\": \"producer \" + str(i)})\n# Como el env\u00edo es as\u00edncrono, para que no se salga del programa antes de enviar el mensaje, esperamos 1 seg\ntime.sleep(1)\n# producer.flush()\n</code></pre> <p>Tras ejecutar ambos programas en pesta\u00f1as diferentes, en la salida del consumidor recibiremos:</p> <pre><code>{'nombre': 'producer 0'}\n{'nombre': 'producer 1'}\n{'nombre': 'producer 2'}\n{'nombre': 'producer 3'}\n{'nombre': 'producer 4'}\n{'nombre': 'producer 5'}\n{'nombre': 'producer 6'}\n{'nombre': 'producer 7'}\n{'nombre': 'producer 8'}\n{'nombre': 'producer 9'}\n</code></pre>"},{"location":"dataflow/02kafka.html#referencias","title":"Referencias","text":"<ul> <li>Apache Kafka Series - Learn Apache Kafka for Beginners</li> <li>Serie de art\u00edculos de V\u00edctor Madrid sobre Kafka en enmilocalfunciona.io.</li> <li>Distributed Databases: Kafka por Miguel del Tio</li> <li>Kafka Cheatsheet</li> </ul>"},{"location":"dataflow/02kafka.html#actividades","title":"Actividades","text":"<ol> <li>Realiza los casos de uso 0 y 1.</li> </ol>"},{"location":"dataflow/03kafka.html","title":"Kafka II","text":""},{"location":"dataflow/03kafka.html#caso-2-cluster-de-kafka","title":"Caso 2: Cl\u00faster de Kafka","text":"<p>En Kafka hay tres tipos de cl\u00fasters:</p> <ul> <li>Un nodo con un broker</li> <li>Un nodo con muchos brokers</li> <li>Muchos nodos con m\u00faltiples brokers</li> </ul> <p>Para nuestro ejemplo, como s\u00f3lo disponemos de una m\u00e1quina, vamos a crear 3 brokers en un nodo.</p>"},{"location":"dataflow/03kafka.html#creando-brokers","title":"Creando brokers","text":"<p>Para ello, vamos a crear diferentes archivos de configuraci\u00f3n a partir del archivo <code>config/server.properties</code> que utiliz\u00e1bamos para arrancar el servidor.</p> <p>As\u00ed pues, crearemos 3 copias del archivo modificando las propiedades <code>broker.id</code> (identificador del broker), <code>listeners</code> (URL y puerto de escucha del broker) y <code>log.dirs</code> (carpeta donde se guardaran los logs del broker):</p> Broker 101Broker 102Broker 103 server101.properties<pre><code>broker.id=101\nlisteners=PLAINTEXT://:9092  \nlog.dirs=/opt/kafka_2.13-2.8.1/logs/broker_101\nzookeeper.connect=localhost:2181\n</code></pre> server102.properties<pre><code>broker.id=102\nlisteners=PLAINTEXT://:9093  \nlog.dirs=/opt/kafka_2.13-2.8.1/logs/broker_102\nzookeeper.connect=localhost:2181\n</code></pre> server103.properties<pre><code>broker.id=103\nlisteners=PLAINTEXT://:9094\nlog.dirs=/opt/kafka_2.13-2.8.1/logs/broker_103 \nzookeeper.connect=localhost:2181\n</code></pre> <p>Una vez creados los tres archivos, ejecutaremos los siguientes comandos (cada uno en un terminal diferente) para arrancar Zookeeper y cada uno de los brokers:</p> <pre><code>zookeeper-server-start.sh ./config/zookeeper.properties\nkafka-server-start.sh ./config/server101.properties\nkafka-server-start.sh ./config/server102.properties\nkafka-server-start.sh ./config/server103.properties\n</code></pre>"},{"location":"dataflow/03kafka.html#creando-topics","title":"Creando topics","text":"<p>Con cada comando que vayamos a interactuar con Kafka, le vamos a pasar como par\u00e1metro <code>--bootstrap-server iabd-virtualbox:9092</code> para indicarle donde se encuentra uno de los brokers (en versiones antiguas de Kafka se indicaba donde estaba Zookeeper mediante <code>--zookeeper iabd-virtualbox:9092</code>).</p> <p>A la hora de crear un topic, adem\u00e1s de indicarle donde est\u00e1 Zookeeper y el nombre del topic, indicaremos:</p> <ul> <li>la cantidad de particiones con el par\u00e1metro <code>--partitions</code></li> <li>el factor de replicaci\u00f3n con el par\u00e1metro <code>--replication-factor</code></li> </ul> <p>As\u00ed pues, vamos a crear un topic con tres particiones y factor de replicaci\u00f3n 2:</p> <pre><code>kafka-topics.sh --create --topic iabd-topic-3p2r \\\n--bootstrap-server iabd-virtualbox:9092 \\\n--partitions 3 --replication-factor 2\n</code></pre> <p>Si ahora obtenemos la informaci\u00f3n del topic</p> <pre><code>kafka-topics.sh --describe --topic iabd-topic-3p2r \\\n--bootstrap-server iabd-virtualbox:9092\n</code></pre> <p>Podemos observar como cada partici\u00f3n tiene la partici\u00f3n l\u00edder en un broker distinto y en qu\u00e9 brokers se encuentran las r\u00e9plicas:</p> <pre><code>Topic: iabd-topic-3p2r  TopicId: lyrv4qXkS1-c09XAXnIj7w PartitionCount: 3       ReplicationFactor: 2    Configs: segment.bytes=1073741824 \n        Topic: iabd-topic-3p2r  Partition: 0    Leader: 103     Replicas: 103,102       Isr: 103,102 \n        Topic: iabd-topic-3p2r  Partition: 1    Leader: 102     Replicas: 102,101       Isr: 102,101 \n        Topic: iabd-topic-3p2r  Partition: 2    Leader: 101     Replicas: 101,103       Isr: 101,103 \n</code></pre>"},{"location":"dataflow/03kafka.html#produciendo-y-consumiendo","title":"Produciendo y consumiendo","text":"<p>Respecto al c\u00f3digo Python, va a ser el mismo que hemos visto antes pero modificando:</p> <ul> <li>el nombre del topic</li> <li>la lista de boostrap_servers (aunque podr\u00edamos haber dejado \u00fanicamente el nodo principal, ya que Kafka le comunica al cliente el resto de nodos del cl\u00faster, es una buena pr\u00e1ctica por si el nodo al que nos conectamos de manera expl\u00edcita est\u00e1 ca\u00eddo).</li> </ul> ProductorConsumidor producer-cluster.py<pre><code>from kafka import KafkaProducer\nfrom json import dumps\nimport time\nproducer = KafkaProducer(\nvalue_serializer=lambda m: dumps(m).encode('utf-8'),\nbootstrap_servers=['iabd-virtualbox:9092','iabd-virtualbox:9093','iabd-virtualbox:9094'])\nfor i in range(10):\nproducer.send(\"iabd-topic-3p2r\", value={\"nombre\": \"producer \" + str(i)}, key=b\"iabd\")\n# Como el env\u00edo es as\u00edncrono, para que no se salga del programa antes de enviar el mensaje, esperamos 1 seg\ntime.sleep(1)\n</code></pre> <p>En el consumidor, adem\u00e1s hemos modificado la forma de mostrar los mensajes para visualizar m\u00e1s informaci\u00f3n: </p> consumer-cluster.py<pre><code>from kafka import KafkaConsumer\nfrom json import loads\nconsumer = KafkaConsumer(\n'iabd-topic-3p2r',\nauto_offset_reset='earliest',\nenable_auto_commit=True,\ngroup_id='iabd-grupo-1',\nvalue_deserializer=lambda m: loads(m.decode('utf-8')),\nbootstrap_servers=['iabd-virtualbox:9092','iabd-virtualbox:9093','iabd-virtualbox:9094'])\nfor m in consumer:\nprint(f\"P:{m.partition} O:{m.offset} K:{m.key} V:{m.value}\")\n</code></pre> <p>Como ahora tenemos los datos repartidos en dos brokers (por el factor de replicaci\u00f3n) y tres particiones, los datos consumidos no tienen por qu\u00e9 llegar en orden (como es el caso), ya que los productores han enviado los datos de manera aleatoria para repartir la carga:</p> <pre><code>P:1 O:0 K:None V:{'nombre': 'producer 0'}\nP:1 O:1 K:None V:{'nombre': 'producer 3'}\nP:2 O:0 K:None V:{'nombre': 'producer 1'}\nP:2 O:1 K:None V:{'nombre': 'producer 5'}\nP:2 O:2 K:None V:{'nombre': 'producer 6'}\nP:2 O:3 K:None V:{'nombre': 'producer 7'}\nP:2 O:4 K:None V:{'nombre': 'producer 8'}\nP:0 O:0 K:None V:{'nombre': 'producer 2'}\nP:0 O:1 K:None V:{'nombre': 'producer 4'}\nP:0 O:2 K:None V:{'nombre': 'producer 9'}\n</code></pre> <p>Para asegurarnos el orden, debemos enviar los mensajes con una clave de partici\u00f3n con el atributo <code>key</code> del m\u00e9todo <code>send</code>:</p> <pre><code>producer.send(\"iabd-topic-3p2r\",\nvalue={\"nombre\": \"producer \" + str(i)},\nkey=b\"iabd\")\n</code></pre> <p>Si volvemos a ejecutar el productor con esa clave, el resultado s\u00ed que sale ordenado:</p> <pre><code>P:0 O:3 K:b'iabd' V:{'nombre': 'producer 0'}\nP:0 O:4 K:b'iabd' V:{'nombre': 'producer 1'}\nP:0 O:5 K:b'iabd' V:{'nombre': 'producer 2'}\nP:0 O:6 K:b'iabd' V:{'nombre': 'producer 3'}\nP:0 O:7 K:b'iabd' V:{'nombre': 'producer 4'}\nP:0 O:8 K:b'iabd' V:{'nombre': 'producer 5'}\nP:0 O:9 K:b'iabd' V:{'nombre': 'producer 6'}\nP:0 O:10 K:b'iabd' V:{'nombre': 'producer 7'}\nP:0 O:11 K:b'iabd' V:{'nombre': 'producer 8'}\nP:0 O:12 K:b'iabd' V:{'nombre': 'producer 9'}\n</code></pre>"},{"location":"dataflow/03kafka.html#decisiones-de-rendimiento","title":"Decisiones de rendimiento","text":"<p>Aunque podemos modificar la cantidad de particiones y el factor de replicaci\u00f3n una vez creado el cl\u00faster, es mejor hacerlo de la manera correcta durante la creaci\u00f3n ya que tienen un impacto directo en el rendimiento y durabilidad del sistema:</p> <ul> <li>si el n\u00famero de particiones crece con el cl\u00faster ya creado, el orden de las claves no est\u00e1 garantizado.</li> <li>si se incrementa el factor de replicaci\u00f3n durante el ciclo de vida de un topic, estaremos metiendo presi\u00f3n al cl\u00faster, que provocar\u00e1 un decremento inesperado del rendimiento.</li> </ul> <p>Cada partici\u00f3n puede manejar un rendimiento de unos pocos MB/s. Al a\u00f1adir m\u00e1s particiones, obtendremos mejor paralelizaci\u00f3n y por tanto, mejor rendimiento. Adem\u00e1s, podremos ejecutar m\u00e1s consumidores en un grupo. Pero el hecho de a\u00f1adir m\u00e1s brokers al cl\u00faster para que las particiones los aprovechen, provocar\u00e1 que Zookeeper tenga que realizar m\u00e1s elecciones y que Kafka tenga m\u00e1s ficheros abiertos.</p> <p>Gu\u00eda de rendimiento</p> <p>Una propuesta es:</p> <ul> <li>Si nuestro cl\u00faster es peque\u00f1o (menos de 6 brokers), crear el doble de particiones que brokers.</li> <li>Si tenemos un cl\u00faster grande (m\u00e1s de 12 brokers), crear la misma cantidad de particiones que brokers.</li> <li>Ajustar el n\u00famero de consumidores necesarios que necesitamos que se ejecuten en paralelo en los picos de rendimiento.</li> </ul> <p>Independientemente de la decisi\u00f3n que tomemos, hay que realizar pruebas de rendimiento con diferentes configuraciones.</p> <p>Respecto al factor de replicaci\u00f3n, deber\u00eda ser, al menos 2, siendo 3 la cantidad recomendada (es necesario tener al menos 3 brokers) y no sobrepasar de 4. Cuanto mayor sea el factor de replicaci\u00f3n (RF):</p> <ul> <li>El sistema tendr\u00e1 mejor tolerancia a fallos (se pueden caer RF-1 brokers)</li> <li>Pero tendremos mayor replicaci\u00f3n (lo que implicar\u00e1 una mayor latencia si <code>acks=all</code>)</li> <li>Y tambi\u00e9n ocupar\u00e1 m\u00e1s espacio en disco (50% m\u00e1s si RF es 3 en vez de 2).</li> </ul> <p>Respecto al cl\u00faster, se recomienda que un broker no contenga m\u00e1s de 2000-4000 particiones (entre todos los topics de ese broker). Adem\u00e1s, un cl\u00faster de Kafka deber\u00eda tener un m\u00e1ximo de 20.000 particiones entre todos los brokers, ya que si se cayese alg\u00fan nodo, Zookeeper necesitar\u00eda realizar muchas elecciones de l\u00edder.</p>"},{"location":"dataflow/03kafka.html#caso-3-de-twitter-a-elasticsearch-con-python","title":"Caso 3: De Twitter a Elasticsearch con Python","text":"<p>A continuaci\u00f3n vamos a crear un ejemplo completo de flujo de datos mediante Python que nos permita recoger tweets y meterlos dentro de ElasticSearch.</p> <p>Vamos a suponer que ya disponemos de una cuenta de Twitter y que tenemos las credenciales de acceso, las cuales vamos a almacenar en un fichero denominado <code>credential.py</code>:</p> credentials.py<pre><code>API_KEY = 'YOUR_API_KEY'\nAPI_SECRET_KEY = 'YOUR_API_SECRET_KEY'\nACCESS_TOKEN = 'YOUR_ACCESS_TOKEN'\nACCESS_TOKEN_SECRET = 'YOUR_ACCESS_TOKEN_SECRET'\n</code></pre>"},{"location":"dataflow/03kafka.html#tweepy","title":"Tweepy","text":"<p>Para acceder a Twitter desde Python, la librer\u00eda por excelencia es Tweepy, la cual instalaremos mediante:</p> <pre><code>pip install tweepy\n</code></pre> <p>A continuaci\u00f3n, vamos a realizar el proceso de autenticaci\u00f3n en Tweepy y recoger el timeline de mi usuario:</p> timeline.py<pre><code>import credentials\nimport tweepy\n# Nos autenticamos mediante OAuth\nauth = tweepy.OAuthHandler(credentials.API_KEY, credentials.API_SECRET_KEY)\nauth.set_access_token(credentials.ACCESS_TOKEN, credentials.ACCESS_TOKEN_SECRET)\napi = tweepy.API(auth)\nmiTimeline = api.home_timeline()\nfor tweet in miTimeline:\nprint(f'{tweet.user.screen_name}:\\n{tweet.text}\\n{\"*\"*60}')\n</code></pre>"},{"location":"dataflow/03kafka.html#productor-de-tweets","title":"Productor de Tweets","text":"<p>En este caso de uso vamos a buscar los tweets que contengan la palabra bigdata y meterlos en un topic de Kafka. As\u00ed pues, en vez de obtener el timeline de un usuario, realizaremos una b\u00fasqueda mediante la funci\u00f3n <code>search</code> y para cada elemento recuperado, lo enviaremos al productor con toda la informaci\u00f3n (seguimos un planteamiento ELT).</p> <p>Primero creamos el topic:</p> <pre><code>kafka-topics.sh --create --topic iabd-twitter  --bootstrap-server iabd-virtualbox:9092\n</code></pre> <p>Y a continuaci\u00f3n desarrollamos el productor:</p> producerTwitter.py<pre><code>import credentials\nimport tweepy\nfrom kafka import KafkaProducer\nfrom json import dumps\nimport time\n# Creamos el productor de Kafka\nproducer = KafkaProducer(\nvalue_serializer=lambda m: dumps(m).encode('utf-8'),\nbootstrap_servers=['iabd-virtualbox:9092'])\n# Nos autenticamos mediante OAuth en Twitter\nauth = tweepy.OAuthHandler(credentials.API_KEY, credentials.API_SECRET_KEY)\nauth.set_access_token(credentials.ACCESS_TOKEN, credentials.ACCESS_TOKEN_SECRET)\napi = tweepy.API(auth)\n# Cargamos 500 tweets\nid = None\ncantidad = 0\nwhile cantidad &lt;= 500:\ntweets = api.search_tweets(q='bigdata', tweet_mode='extended', max_id=id)\nfor tweet in tweets:\nproducer.send(\"iabd-twitter\", value=tweet._json)\ncantidad += 1\n#  Al final del ciclo le asignamos el id del \u00faltimo tweet\n#  para que en cada ciclo se consulten solo los tweets hasta el m\u00e1s antiguos del ciclo anterior\nid = tweet.id\n# Como el env\u00edo es as\u00edncrono, para que no se salga del programa antes de enviar el \u00faltimo mensaje, esperamos 1 seg\ntime.sleep(1)\n</code></pre>"},{"location":"dataflow/03kafka.html#elasticsearch-desde-python","title":"Elasticsearch desde Python","text":"<p>Para poder acceder a Elasticsearch desde Python necesitamos descargar la librer\u00eda:</p> <pre><code>pip install elasticsearch\n</code></pre> <p>El siguiente fragmento muestra varias operaciones b\u00e1sicas y como las operaciones REST de Elasticsearch se traducen en m\u00e9todos:</p> C\u00f3digo PythonResultado prueba-elasticsearch.py<pre><code>from datetime import datetime\nfrom elasticsearch import Elasticsearch\nes = Elasticsearch(\"http://localhost:9200\")\ndoc1 = {\n'author': 'Aitor Medrano',\n'text': 'Prueba de texto desde Python',\n'timestamp': datetime.now(),\n}\ndoc2 = {\n'author': 'Aitor Medrano',\n'text': 'Y otra #prueba desde @Python',\n'timestamp': datetime.now(),\n}\n# Inserci\u00f3n\nresp = es.index(index=\"prueba\", id=1, document=doc1)\nresp = es.index(index=\"prueba\", id=2, document=doc2)\nprint(resp['result'])\n# Recuperaci\u00f3n\nresp = es.get(index=\"prueba\", id=1)\nprint(resp['_source'])\nes.indices.refresh(index=\"prueba\")\n# B\u00fasqueda\nresp = es.search(index=\"prueba\", query={\"match_all\": {}})\nprint(\"Encontrados %d Hits:\" % resp['hits']['total']['value'])\nfor hit in resp['hits']['hits']:\nprint(\"%(timestamp)s %(author)s: %(text)s\" % hit[\"_source\"])\n</code></pre> <pre><code>    resp = es.index(index=\"prueba\", id=1, document=doc1)\n    resp = es.index(index=\"prueba\", id=2, document=doc2)\nupdated\n    resp = es.get(index=\"prueba\", id=1)\n{'author': 'Aitor Medrano', 'text': 'Prueba de texto desde Python', 'timestamp': '2022-02-25T15:11:43.720820'}\n    es.indices.refresh(index=\"prueba\")\n    resp = es.search(index=\"prueba\", query={\"match_all\": {}})\nEncontrados 2 Hits:\n2022-02-25T15:11:43.720820 Aitor Medrano: Prueba de texto desde Python\n2022-02-25T15:11:43.720826 Aitor Medrano: Y otra #prueba desde @Python\n</code></pre>"},{"location":"dataflow/03kafka.html#consumidor-en-elasticsearch","title":"Consumidor en Elasticsearch","text":"<p>Finalmente, vamos a crear un consumidor que se conecte a Kafka para consumir los mensajes, e introduzca cada uno de los tuits en Elasticsearch:</p> consumerTwitter.py<pre><code>from datetime import datetime\nfrom elasticsearch import Elasticsearch\nfrom kafka import KafkaConsumer\nfrom json import loads\nimport ast\nes = Elasticsearch(\"http://localhost:9200\")\nconsumer = KafkaConsumer(\n'iabd-twitter',\nauto_offset_reset='earliest',\nenable_auto_commit=True,\ngroup_id='iabd-caso3',\nvalue_deserializer=lambda m: loads(m.decode('utf-8')),\nbootstrap_servers=['iabd-virtualbox:9092'])\ncantidad = 1\nfor m in consumer:\ntweet = m.value\n# print(type(tweet))\n# tweet = ast.literal_eval(m.value)\n# print(tweet['user'])\n# doc = {\n#     'user': m.value.user.screen_name,\n#     'text': m.value.full_text,\n#     'created_at': m.value.created_at,\n#     'likes': m.value.favourite_count\n# }\nresp = es.index(index=\"iabd-twitter-es\", id=cantidad, document=tweet)\ncantidad += 1\n# Forzamos que se persistan los cambios\nes.indices.refresh(index=\"iabd-twitter-es\")\n</code></pre> <p>Si accedemos a <code>http://localhost:9200/iabd-twitter-es/_search?pretty</code> podremos ver como Elasticsearch contiene los tuits que hab\u00edamos producido previamente:</p> Resultado de consumir tuits desde Kafka y cargar en Elasticsearch"},{"location":"dataflow/03kafka.html#todo-en-uno-con-nifi","title":"Todo en uno con Nifi","text":"<p>Vamos a realizar un flujo de datos en Nifi para el mismo caso de uso que acabamos de desarrollar. Para ello, vamos a crear dos grupos de procesos para tener los flujos ordenados:</p> Grupos de procesos para E y L <p>En el primer grupo, que hemos denominado Extract Twitter, vamos a realizar la carga desde Twitter (filtrando los mensajes que contengan la palabra bigdata) y los vamos a meter en el topic <code>iabd-twitter</code>.</p> <p>Para ello, conectaremos los siguientes procesadores:</p> <ul> <li>GetTwitter: tras introducir los valores para autenticarnos en Twitter, configuraremos como endpoint que sea de tipo Filter Endpoint y como t\u00e9rmino a filtrar bigdata (no olvides poner las claves de autenticaci\u00f3n).</li> <li>PublishKafka_2_6: en este procesador, adem\u00e1s del topic <code>iabd-twitter</code>, indicaremos que no utilizaremos transacciones (Use Transactions: false), as\u00ed como que intente garantizar la entrega (Delivery Guarantee: Best Effort):</li> </ul> De Twitter a Kafka <p>Del mismo modo, dentro del segundo grupo (Load Elasticsearch), conectaremos los siguientes procesadores:</p> <ul> <li>ConsumerKafka_2_6: donde consumiremos los mensajes del topic <code>iabd-twitter</code> de Kafka, y por ejemplo, como grupo de consumidores le indicaremos que usamos nifi (group id: nifi)</li> <li>PutElasticsearchHttp: como ya hicimos en la sesi\u00f3n de Nifi, indicaremos la URL de Elasticsearch (<code>http://localhost:9200</code>) y que lo almacene en un indice que hemos denominado <code>iabd-twitter-es</code>:</li> </ul> De Kafka a Elasticsearch"},{"location":"dataflow/03kafka.html#kafka-connect","title":"Kafka Connect","text":"<p>Si hacerlo con Nifi ya es un avance respecto a tener que codificarlo con Python, \u00bfqu\u00e9 dir\u00edas si Kafka ofreciera una serie de conectores para las operaciones m\u00e1s comunes?</p> <p>As\u00ed pues, Kafka Connect permite importar/exportar datos desde/hacia Kafka, facilitando la integraci\u00f3n en sistemas existentes mediante alguno del centenar de conectores disponibles.</p> Arquitectura Kafka Connect <p>Los elementos que forman Kafka Connect son:</p> <ul> <li>Conectores fuente (source), para obtener datos desde las fuentes de datos (E en ETL)</li> <li>Conectores destino (sink) para publicar los datos en los almacenes de datos (L en ETL).</li> </ul> <p>Estos conectores facilitan que desarrolladores no expertos puedan trabajar con sus datos en Kafka de forma r\u00e1pida y fiable, de manera que podamos introducir Kafka dentro de nuestros procesos ETL.</p>"},{"location":"dataflow/03kafka.html#hola-kafka-connect","title":"Hola Kafka Connect","text":"<p>Vamos a realizar un ejemplo muy sencillo leyendo datos de una base de datos para meterlos en Kafka.</p> <p>Para ello, utilizaremos la base de datos de retail_db que ya hemos empleado en otras sesiones y vamos a cargar en Kafka los datos de la tabla <code>categories</code>:</p> <pre><code>MariaDB [retail_db]&gt; describe categories;\n+------------------------+-------------+------+-----+---------+----------------+\n| Field                  | Type        | Null | Key | Default | Extra          |\n+------------------------+-------------+------+-----+---------+----------------+\n| category_id            | int(11)     | NO   | PRI | NULL    | auto_increment |\n| category_department_id | int(11)     | NO   |     | NULL    |                |\n| category_name          | varchar(45) | NO   |     | NULL    |                |\n+------------------------+-------------+------+-----+---------+----------------\n</code></pre>"},{"location":"dataflow/03kafka.html#configuracion","title":"Configuraci\u00f3n","text":"<p>Cuando ejecutemos Kafka Connect, le debemos pasar un archivo de configuraci\u00f3n. Para empezar, tenemos <code>config/connect-standalone.properties</code> el cual ya viene rellenado e indica los formatos que utilizar\u00e1n los conversores y otros aspectos:</p> config/connect-standalone.properties<pre><code>bootstrap.servers=localhost:9092\nkey.converter=org.apache.kafka.connect.json.JsonConverter\nvalue.converter=org.apache.kafka.connect.json.JsonConverter\nkey.converter.schemas.enable=true\nvalue.converter.schemas.enable=true\noffset.storage.file.filename=/tmp/connect.offsets\n</code></pre> <p>Los conectores se incluyen en Kafka como plugins. Para ello, primero hemos de indicarle a Kafka donde se encuentran. Para ello, en el archivo de configuraci\u00f3n le indicaremos la siguiente ruta:</p> <pre><code>plugin.path=/opt/kafka_2.13-2.8.1/plugins\n</code></pre>"},{"location":"dataflow/03kafka.html#extrayendo-datos-mediante-kafka-connect","title":"Extrayendo datos mediante Kafka Connect","text":"<p>As\u00ed pues, el primer paso es crear el archivo de configuraci\u00f3n de Kafka Connect con los datos (en nuestro caso lo colocamos en la carpeta <code>config</code>  de la instalaci\u00f3n de Kafka) utilizando un conector fuente de JDBC:</p> retaildb-mariadb-source-connector.properties<pre><code>name=retaildb-mariabd-source-jdbc-autoincrement\nconnector.class=io.confluent.connect.jdbc.JdbcSourceConnector\ntasks.max=1\nconnection.url=jdbc:mysql://localhost/retail_db\nconnection.user=iabd\nconnection.password=iabd\ntable.whitelist=categories\nmode=incrementing\nincrementing.column.name=category_id\ntopic.prefix=iabd-retail_db-\n</code></pre> <p>Antes de ponerlo en marcha, debemos descargar el conector y colocar la carpeta descomprimida dentro de nuestra carpeta de plugins <code>/opt/kafka_2.13-2.8.1/plugins</code> y descargar el driver de MySQL y colocarlos en la carpeta <code>/opt/kafka_2.13-2.8.1/lib</code>.</p> <p>Y a continuaci\u00f3n ya podemos ejecutar Kafka Connect:</p> <pre><code>connect-standalone.sh config/connect-standalone.properties config/retaildb-mariadb-source-connector.properties\n</code></pre> <p>Guava</p> <p>Es posible que salte un error de ejecuci\u00f3n indicando que falta la librer\u00eda Guava la cual pod\u00e9is descargar desde aqu\u00ed y colocar en la carpeta <code>/opt/kafka_2.13-2.8.1/lib</code></p> <p>Si ahora arrancamos un consumidor sobre el topic <code>iabd-retail_db-categories</code>:</p> <pre><code>kafka-console-consumer.sh --topic iabd-retail_db-categories --from-beginning --bootstrap-server iabd-virtualbox:9092\n</code></pre> <p>Veremos que aparecen todos los datos que ten\u00edamos en la tabla en formato JSON (es lo que hemos indicado en el archivo de configuraci\u00f3n de Kafka Connect):</p> <pre><code>{\"schema\":{\n\"type\":\"struct\",\"fields\":[\n{\"type\":\"int32\",\"optional\":false,\"field\":\"category_id\"},\n{\"type\":\"int32\",\"optional\":false,\"field\":\"category_department_id\"},\n{\"type\":\"string\",\"optional\":false,\"field\":\"category_name\"}],\n\"optional\":false,\"name\":\"categories\"},\n\"payload\":{\"category_id\":1,\"category_department_id\":2,\"category_name\":\"Football\"}}\n{\"schema\":{\n\"type\":\"struct\",\"fields\":[\n{\"type\":\"int32\",\"optional\":false,\"field\":\"category_id\"},\n{\"type\":\"int32\",\"optional\":false,\"field\":\"category_department_id\"},\n{\"type\":\"string\",\"optional\":false,\"field\":\"category_name\"}],\n\"optional\":false,\"name\":\"categories\"},\n\"payload\":{\"category_id\":2,\"category_department_id\":2,\"category_name\":\"Soccer\"}}\n...\n</code></pre> <p>Autoevaluaci\u00f3n</p> <p>Vamos a dejar el consumidor y Kafka Connect corriendo. \u00bfQu\u00e9 suceder\u00e1 si inserto un nuevo registro en la base de datos en la tabla <code>categories</code>? Que autom\u00e1ticamente aparecer\u00e1 en nuestro consumidor.</p>"},{"location":"dataflow/03kafka.html#rest-api","title":"REST API","text":"<p>Como Kafka Connect est\u00e1 dise\u00f1ado como un servicio que deber\u00eda correr continuamente, ofrece un API REST para gestionar los conectores. Por defecto est\u00e1 a la escucha el puerto 8083, de manera que si accedemos a http://iabd-virtualbox:8083/ obtendremos informaci\u00f3n sobre la versi\u00f3n que se est\u00e1 ejecutando:</p> <pre><code>{\"version\":\"2.8.1\",\"commit\":\"839b886f9b732b15\",\"kafka_cluster_id\":\"iHa0JUnTSfm85fvFadsylA\"}\n</code></pre> <p>Por ejemplo, si queremos obtener un listado de los conectores realizaremos una petici\u00f3n GET a <code>/connectors</code> mediante <code>http://iabd-virtualbox:8083/connectors</code>:</p> <pre><code>[\"retaildb-mariabd-source-jdbc-autoincrement\"]\n</code></pre> <p>M\u00e1s informaci\u00f3n en https://kafka.apache.org/documentation/#connect_rest</p> <p>Kafka Streams</p> <p>Kafka Streams es la tercera pata del ecosistema de Kafka, y permite procesar y transformar datos dentro de Kafka. Una vez que los datos se almacenan en Kafka como eventos, podemos procesar los datos en nuestras aplicaciones cliente mediante Kafka Streams y sus librer\u00edas desarrolladas en Java y/o Scala, ya que requiere una JVM.</p> <p>En nuestro caso, realizaremos en posteriores sesiones un procesamiento similar de los datos mediante Spark Streaming, permitiendo operaciones con estado y agregaciones, funciones ventana, joins, procesamiento de eventos basados en el tiempo, etc...</p>"},{"location":"dataflow/03kafka.html#kafka-y-el-big-data","title":"Kafka y el Big Data","text":"<p>El siguiente gr\u00e1fico muestra c\u00f3mo Kafka est\u00e1 enfocado principalmente para el tratamiento en streaming, aunque con los conectores de Kafka Connect da soporte para el procesamiento batch:</p> Kafka y Big Data"},{"location":"dataflow/03kafka.html#referencias","title":"Referencias","text":"<ul> <li>Apache Kafka Series - Learn Apache Kafka for Beginners</li> <li>Serie de art\u00edculos de V\u00edctor Madrid sobre Kafka en enmilocalfunciona.io.</li> <li>Distributed Databases: Kafka por Miguel del Tio</li> <li>Introduction to Kafka Connectors</li> <li>Kafka Cheatsheet</li> </ul>"},{"location":"dataflow/03kafka.html#actividades","title":"Actividades","text":"<ol> <li>(opcional) A partir del caso 2, crea un cl\u00faster de Kafka con 4 particiones y 3 nodos. A continuaci\u00f3n, en el productor utiliza Faker para crear 10 personas (almac\u00e9nalas como un diccionario). En el consumidor, muestra los datos de las personas (no es necesario recibirlos ordenados, s\u00f3lo necesitamos que se aproveche al m\u00e1ximo la infraestructura de Kafka).</li> <li>Realiza el caso de uso 3 (De Twitter a ElasticSearch) tanto con Python como con Nifi.</li> <li>(opcional) Repite el caso de uso 2 \u00fanicamente mediante Kafka Connect.  </li> <li>(opcional) Investiga en qu\u00e9 consiste el patr\u00f3n CDC (Change Data Capture) y c\u00f3mo se realiza CDC con Kafka/Kafka Connect y Debezium. \u00bfQu\u00e9 ventajas aportan las soluciones CDC?</li> </ol>"},{"location":"dataflow/04nifi1.html","title":"Nifi","text":"Logo de Apache Nifi <p>Nifi es un proyecto de Apache (desarrollado en Java inicialmente por la NSA, su nombre rinde tributo a los archivos Niagara - NiagaraFiles) que plantea un sistema distribuido dedicado a ingestar y transformar datos mediante un modelo en streaming.</p> <p>Para ello, define un modelo de programaci\u00f3n basado en flujos de datos, donde podemos definir aplicaciones como un conjunto de procesos (cajas negras) que intercambian datos utilizan mensajes, los cuales se env\u00edan entre conexiones predefinidas.</p> <p>Entre sus caracter\u00edsticas principales destacamos:</p> <ul> <li>flujos de datos escalables.</li> <li>m\u00e1s de 300 conectores.</li> <li>procesadores personalizados.</li> <li>ingesta de datos en streaming.</li> <li>usa el paradigma de programaci\u00f3n basado en flujos.</li> <li>define las aplicaciones como grafos de procesos dirigidos (DAG) a trav\u00e9s de conexiones que env\u00edan mensajes.</li> <li>entrega garantizada sin p\u00e9rdida de datos.</li> </ul> <p>Las ventajas de utilizar Nifi son:</p> <p>Linaje del dato</p> <p>En la sesi\u00f3n de Arquitecturas de big data, ya vimos que el linaje de los nos permite conocer las transformaciones que ha sufrido un dato, desde el origen hasta el estado actual, incluyendo las combinaciones con otros datos o el cambio del dato en s\u00ed a lo largo de su ciclo de vida.</p> <ul> <li>aplicaci\u00f3n multiplataforma con licencia Open Source.</li> <li>facilidad de uso mediante un interfaz gr\u00e1fica y web.</li> <li>escalabilidad horizontal mediante un cluster de m\u00e1quinas.</li> <li>evoluci\u00f3n y comunidad.</li> <li>pol\u00edtica de usuarios (LDAP).</li> <li>validador de configuraciones.</li> <li>linaje y procedencia del dato.</li> </ul> <p>Sus casos de uso son:</p> <ul> <li>transferencias de datos entre sistemas, por ejemplo, de JSON a una base de datos, de un FTP a Hadoop, etc..</li> <li>preparar y enriquecer los datos.</li> <li>enrutar datos en funci\u00f3n de caracter\u00edsticas, con diferentes prioridades.</li> <li>conversi\u00f3n de datos entre formatos.</li> </ul> <p>En cambio, no es apropiado para:</p> <ul> <li>procesamiento y operaciones de c\u00f3mputo distribuido.</li> <li>operaciones de streaming complejas con joins o agregaciones.</li> <li>procesamiento complejo de eventos.</li> </ul>"},{"location":"dataflow/04nifi1.html#puesta-en-marcha","title":"Puesta en marcha","text":"<p>Para instalar Nifi, s\u00f3lo hemos de descargar la \u00faltima versi\u00f3n desde https://nifi.apache.org (en nuestro caso hemos descargado la version 1.19.1) y tras descomprimirla, debemos crear unas credenciales de acceso. Para ello, ejecutaremos el comando <code>./nifi.sh set-single-user-credentials &lt;username&gt; &lt;password&gt;</code> indicando el usuario y contrase\u00f1a que queramos.</p> <p>Por ejemplo, nosotros hemos creado el usuario <code>nifi</code>/<code>nifinifinifi</code>:</p> <pre><code>./bin/nifi.sh set-single-user-credentials nifi nifinifinifi\n</code></pre> <p>A continuaci\u00f3n, ya podemos arrancar Nifi ejecutando el comando <code>./nifi.sh start</code> (se ejecutar\u00e1 en background):</p> <pre><code>./bin/nifi.sh start\n</code></pre> <p>Si queremos detenerlo ejecutaremos <code>./bin/nifi.sh stop</code>.</p>"},{"location":"dataflow/04nifi1.html#instalacion-con-aws","title":"Instalaci\u00f3n con AWS","text":"<p>Si quieres trabajar con una m\u00e1quina en AWS has de seguir los siguientes pasos:</p> <ol> <li>Crear una instancia EC2 (se recomienda elegir el tipo <code>t3.large</code>  para tener 8GB RAM), con un grupo de seguridad que permita tanto las conexiones SSH como el puerto 8443.</li> <li>Conectarnos via SSH a la ipPublicaAWS y descargar Nifi: <pre><code>wget https://dlcdn.apache.org/nifi/1.19.1/nifi-1.19.1-bin.zip\nunzip nifi-1.19.1-bin.zip\n</code></pre></li> <li>Tras meternos dentro de la carpeta reci\u00e9n creada, configurar el archivo <code>conf/nifi.properties</code> para permitir el acceso remoto. Para ello, modificaremos las siguientes propiedades: <pre><code>nifi.web.https.host = 0.0.0.0\nnifi.web.proxy.host = &lt;ipPublicaAWS&gt;:8443\n</code></pre></li> <li>Configurar el usuario con las credenciales de acceso <pre><code>./bin/nifi.sh set-single-user-credentials nifi nifinifinifi\n</code></pre></li> <li>Acceder desde un navegador a la direcci\u00f3n https://ipPublicaAWS:8443/nifi</li> </ol>"},{"location":"dataflow/04nifi1.html#instalacion-con-docker","title":"Instalaci\u00f3n con Docker","text":"<p>Si no queremos instalarlo y hacer uso de un contenedor mediante Docker, ejecutaremos el siguiente comando:</p> <pre><code>docker run --name nifi -p 8443:8443 -d -e SINGLE_USER_CREDENTIALS_USERNAME=nifi -e  SINGLE_USER_CREDENTIALS_PASSWORD=nifinifinifi -e NIFI_JVM_HEAP_MAX=2g apache/nifi:latest\n</code></pre> <p>Cluster de Nifi mediante Docker</p> <p>El siguiente art\u00edculo sobre ejecutar Nifi en un cluster utilizando Docker es muy interesante.</p>"},{"location":"dataflow/04nifi1.html#acceso","title":"Acceso","text":"<p>Esperaremos un par de minutos tras arrancar Nifi para acceder al entorno de trabajo. Para ello, introduciremos en el navegador la URL https://localhost:8443/nifi y tras aceptar la alerta de seguridad respecto al certificado veremos un interfaz similar a la siguiente imagen:</p> P\u00e1gina de inicio en Nifi <p>Respecto al interfaz de usuario, cabe destacar cuatro zonas:</p> <ul> <li>Men\u00fa superior: con los iconos grandes (procesadores, puertos de entrada y salida, etc...)</li> <li>Barra de debajo con iconos: indican el estado de la ejecuci\u00f3n (hilos, procesadores en marcha, detenidos, etc..)</li> <li>Cuadro Navigate para hacer zoom</li> <li>Cuadro Operate con las opciones del flujo de trabajo o del recurso seleccionado</li> <li>Zona de trabajo drag&amp;drop.</li> </ul>"},{"location":"dataflow/04nifi1.html#componentes","title":"Componentes","text":""},{"location":"dataflow/04nifi1.html#flowfile","title":"Flowfile","text":"<p>En castellano se conocen como ficheros de flujo o FF: es b\u00e1sicamente el dato, el cual se persiste en disco tras su creaci\u00f3n. Realmente es un puntero al dato en su almacenamiento local, de esta manera se acelera su rendimiento. El Flowfile a a su vez se compone de dos partes:</p> <ul> <li>contenido: el dato en s\u00ed</li> <li>atributos: metadatos en pares de clave/valor</li> </ul>"},{"location":"dataflow/04nifi1.html#procesador","title":"Procesador","text":"<p>Encargado de ejecutar alguna transformaci\u00f3n o regla sobre los datos o el flujo para generar un nuevo Flowfile. La salida de un procesador es un Flowfile que ser\u00e1 la entrada de otro procesador. As\u00ed pues, para implementar un flujo de datos en NiFi, crearemos una secuencia de procesadores que reproduzcan las acciones y transformaciones que queremos realizar sobre sobre los datos.</p> <p>Todos los procesadores se ejecutan en paralelo (mediante diferentes hilos de ejecuci\u00f3n), abstrayendo la complejidad de la programaci\u00f3n concurrente y adem\u00e1s se pueden ejecutar en varios nodos de forma simult\u00e1nea o bien en el nodo primario de un cl\u00faster.</p> <p>Si bien es posible dise\u00f1ar a mano un procesador, por defecto, NiFi ofrece un amplio cat\u00e1logo con m\u00e1s de 300 procesadores, que cubre ampliamente las operaciones m\u00e1s frecuentes que se van a necesitar en un flujo de datos: a\u00f1adir o modificar los atributos del FF, capturar cambios en una base de datos, cambiar de formato el contenido del FF (JSON, CSV, Avro\u2026), extraer el contenido textual de un fichero, extraer el valor de un campo de un fichero JSON a partir de su ruta, extraer cabeceras de un email, consultar a ElasticSearch, geolocalizar una IP, obtener un fichero de una cola Kafka, escribir en un log, unir el contenido de varios FFs, realizar una petici\u00f3n HTTP, transformar un fichero XML, validar un fichero CSV, enviar mensajes a un web socket, etc.</p> <p>Tipos de procesadores</p> <p>Adem\u00e1s de en la documentaci\u00f3n oficial (https://nifi.apache.org/docs.html), puedes consultar informaci\u00f3n extra en https://www.nifi.rocks/apache-nifi-processors/. A grosso modo, los m\u00e1s utilizados son:</p> <ul> <li>Tranformaci\u00f3n de datos: <code>ReplaceText</code>, <code>JoltTransformJSON</code>, <code>CompressContent</code>.</li> <li>Enrutado y mediaci\u00f3n: <code>RouteOnAttribute</code>, <code>RouteOnContent</code></li> <li>Acceso a base de datos: <code>ExecuteSQL</code>, <code>ConvertJSONToSQL</code>, <code>PutSQL</code></li> <li>Extracci\u00f3n de atributos: <code>EvaluateJsonPath</code>, <code>ExtractText</code>, <code>UpdateAttribute</code></li> <li>Interacci\u00f3n con el sistema: <code>ExecuteProcess</code></li> <li>Ingesti\u00f3n de datos: <code>GetFile</code>, <code>GetFTP</code>, <code>GetHTTP</code>, <code>GetHDFS</code></li> <li>Env\u00edo de datos: <code>PutEmail</code>, <code>PutFile</code>, <code>PutFTP</code>, <code>PutKafka</code>, <code>PutMongo</code></li> <li>Divisi\u00f3n y agregaci\u00f3n: <code>SplitText</code>, <code>SplitJson</code>, <code>SplitXml</code>, <code>MergeContent</code></li> <li>HTTP: <code>GetHTTP</code>, <code>ListenHTTP</code>, <code>PostHTTP</code></li> <li>AWS: <code>FetchS3Object</code>, <code>PutS3Object</code>, <code>PutSNS</code>, <code>PutSQS</code></li> </ul>"},{"location":"dataflow/04nifi1.html#conector","title":"Conector","text":"<p>Es una cola dirigida (con un origen y un destino que determinan un sentido) que une diferentes procesadores y contiene los FF que todav\u00eda no se han ejecutado, pudiendo definir diferentes prioridades (por ejemplo, FIFO o LIFO seg\u00fan necesitemos).</p> <p>As\u00ed pues, los conectores van a unir la salida de un procesador con la entrada de otro (o un procesador consigo mismo, por ejemplo, para realizar reintentos sobre una operaci\u00f3n).</p> <p>Las conexiones se caracterizan y nombran por el tipo de puerto de salida del procesador del que nacen. En la mayor\u00eda de los casos nos enfrentaremos a conexiones de tipo success, que recogen el FF que devuelve un procesador cuando ha terminado satisfactoriamente su tarea, o de tipo failure, que conducen el FF en los casos en los que la tarea ha fallado. Tambi\u00e9n podemos crear nuestros propios conectores. Adem\u00e1s, existe la posibilidad de configurar algunos aspectos de la conexi\u00f3n, como el n\u00famero de FF que pueden viajar de forma simult\u00e1nea por ella, la prioridad de salida de los FF que hay en la conexi\u00f3n, o el tiempo que los FF deben permanecer a la espera para ser recogidos por el procesador de destino.</p>"},{"location":"dataflow/04nifi1.html#caso-1-moviendo-datos","title":"Caso 1 - Moviendo datos","text":"<p>Vamos a hacer un peque\u00f1o ejercicio con Nifi para familiarizarnos con el entorno desarrollando un flujo de datos sencillo que mueva un fichero de un directorio a otro.</p> <p>A continuaci\u00f3n detallamos los pasos a realizar:</p> <ol> <li>Seleccionamos un procesador (primer icono grande) y lo arrastramos en nuestra \u00e1rea de trabajo.</li> <li> <p>Nos aparece un dialogo con tres partes diferenciadas:</p> <p> Di\u00e1logo de elecci\u00f3n de procesador </p> <ul> <li>A la izquierda una nube de etiquetas para poder filtrar los procesadores.</li> <li>Arriba a la derecha tenemos un buscador para buscar procesadores por su nombre</li> <li>La parte central con el listado de procesadores, desde donde lo podemos seleccionar.</li> </ul> <p>As\u00ed pues, buscamos el procesador GetFile y lo a\u00f1adimos al flujo, el cual permite recuperar un fichero desde una carpeta.</p> </li> <li> <p>Damos doble click sobre el elemento gr\u00e1fico que representa nuestro procesador, y en la pesta\u00f1a properties indicamos el directorio de entrada de donde tendr\u00e1 que recoger el fichero mediante la propiedad Input Directory. En nuestro caso le pondremos el valor <code>/home/iabd/Documentos/in</code>:</p> </li> </ol> Propiedades de GetFile <pre><code>Antes de cambiar de procesador, en la pesta\u00f1a *Settings*, en la caja *Name* la rellenamos con `ObtenerFichero`.\n</code></pre> <ol> <li>Ahora a\u00f1adimos un nuevo procesador de tipo PutFile, y en las propiedades indicamos el directorio de salida con la propiedad directory a <code>/home/iabd/Documentos/out</code>.</li> <li>Si visualizamos la pesta\u00f1a Settings, una buena pr\u00e1ctica es ponerle nombre a los procesadores. As\u00ed pues, la caja Name la rellenamos con <code>PonerFichero</code>. Si nos centramos en el lado derecho, podemos configurar el comportamiento a seguir si el procesador se ejecuta correctamente (success) o falla (failure). Como vamos a hacer que este procesador sea el paso final, vamos a configurar que autoterminen marcando ambos casos:</li> </ol> Finalizaci\u00f3n de PutFile <p>Terminar las relaciones</p> <p>Si nos olvidamos de autoterminar las relaciones, o tenemos conexiones sin conectar, no podremos iniciar los procesadores implicados. Esto lo tenemos que realizar para todos los procesadores que tengamos en nuestro flujo de datos.</p> <ol> <li>Unimos ambos procesadores creando una conexi\u00f3n. Para ello, tras pulsar sobre el icono de la flecha que aparece al dejar el rat\u00f3n sobre el primer procesador y lo arrastramos hasta el segundo.</li> </ol> Conexi\u00f3n mediante un conector entre procesadores <ol> <li>Antes de arrancar el primer procesador, creamos un peque\u00f1o fichero en el directorio que hemos puesto como entrada:</li> </ol> <pre><code>echo \"Hola IABD!\" &gt; hola-iabd.txt\n</code></pre> <ol> <li> <p>Arrancamos el procesador mediante el bot\u00f3n derecho y la opci\u00f3n Start, y comprobamos que el fichero ya no est\u00e1 en la carpeta <code>in</code>, y que s\u00ed aparece en la cola (Queued 1). Tambi\u00e9n podemos comprobar como tampoco est\u00e1 en la carpeta <code>out</code>.</p> </li> <li> <p>Finalmente, arrancamos el procesador de Poner Fichero, y veremos como la cola se vac\u00eda y el archivo aparece en la carpeta <code>out</code>.</p> </li> </ol> <p>\u00a1Ya hemos creado nuestro primer flujo de datos!</p>"},{"location":"dataflow/04nifi1.html#gestionando-los-errores","title":"Gestionando los errores","text":"<p>\u00bfQu\u00e9 sucede si leemos dos veces un archivo con el mismo nombre? Tal como lo hemos definido en nuestro flujo, s\u00f3lo se guardar\u00e1 la primera copia.</p> <p>Si vamos a la pesta\u00f1a Properties del procesador PonerFichero, podemos cambiar este comportamiento en la propiedad Conflict Resolution Strategy a replace, de esta manera, se guardar\u00e1 el \u00faltimo archivo.</p> Propiedades de PutFile - gesti\u00f3n de conflictos <p>Realmente, en vez de decidir si lo ignora o lo sobreescribe, lo ideal es definir un nuevo flujo que dependa del estado de finalizaci\u00f3n del procesador. De esta manera, podremos almacenar todos los archivos que han llegado con el mismo nombre para su posterior estudio.</p> <p>As\u00ed pues, vamos a quitar la autoterminaci\u00f3n que antes hab\u00edamos puesto al procesador de PonerFichero, para que cuando falle, redirija el flujo a un nuevo procesador PutFile que coloque el archivo en una nueva carpeta (en nuestro caso en <code>/home/iabd/Documentos/conflictos</code>):</p> Flujo failure para los ficheros repetidos <p>Aunque ahora tenemos un mecanismo para almacenar los ficheros que coinciden en nombre, s\u00f3lo nos guardar\u00e1 uno (nos sucede lo mismo que antes, pero ahora s\u00f3lo con los repetidos).</p> <p>As\u00ed pues, necesitamos renombrar los ficheros que vayamos a colocar en la carpeta <code>conflictos</code> para guardar el hist\u00f3rico. Para ello, necesitamos introducir un procesador previo que le cambie el nombre al archivo.</p> <p>Nifi a\u00f1ade la propiedad <code>filename</code> a todos los FF. Esta propiedad la podemos consultar mediante el Nifi Expression Language (Nifi EL) y haciendo uso del procesador UpdateAttribute modificar su valor.</p> <p>As\u00ed pues, vamos a colocar el procesador UpdateAttribute antes de colocar los archivos en la carpeta de <code>conflictos</code>:</p> A\u00f1adimos el procesador UpdateAttribute <p>Hemos decidido a\u00f1adir como prefijo al nombre del archivo la fecha del sistema en formato de milisegundos, de manera que obtendremos archivos similares a <code>1637151536113-fichero.txt</code>. Para ello, a\u00f1adimos un nuevo atributo que llamaremos <code>filename</code> haciendo clic sobre el icono de <code>+</code> que aparece arriba a la derecha y en su valor utilizaremos la expresi\u00f3n <code>${now():toNumber()}-${filename}</code>:</p> A\u00f1adimos el procesador UpdateAttribute"},{"location":"dataflow/04nifi1.html#caso-2-trabajando-con-atributos","title":"Caso 2 - Trabajando con atributos","text":"<p>Cada vez que se generan FF (representa un registro de datos que viaja por el flujo) estos van a tener asignados ciertos atributos por defecto. Entre estos atributos est\u00e1n el UUID o identificador \u00fanico, su timestamp y el tama\u00f1o del fichero. Como ya hemos visto, mediante el uso de procesadores podremos modificar estos o a\u00f1adir nuevos atributos.</p>"},{"location":"dataflow/04nifi1.html#generando-contenido","title":"Generando contenido","text":"<p>Vamos a ver c\u00f3mo hacerlo realizando los siguientes pasos:</p> <ol> <li> <p>Vamos a a\u00f1adir un procesador del tipo <code>GenerateFlowFile</code> (este procesador crea FF con datos aleatorios o contenidos personalizados, lo cual es muy \u00fatil para testear y depurar nuestros flujos de datos).</p> <p>En las opciones del procesador vamos a la pesta\u00f1a de propiedades y completamos los campos:</p> <ul> <li><code>Flow Size: 10 bytes</code></li> <li><code>Batch Size: 1</code> para que nos genere un FF por cada ejecuci\u00f3n</li> <li><code>Data Format: Text</code></li> <li><code>Unique Flowfiles: true</code> e indicamos que los FF van a ser \u00fanicos.</li> </ul> <p> Configuraci\u00f3n del procesador GenerateFlowFile </p> <p>A continuaci\u00f3n, en la configuraci\u00f3n de planificaci\u00f3n (Scheduling) de este procesador vamos a indicar que se ejecute cada 3 segundos (en el campo Run Schedule le ponemos como valor <code>3s</code>).</p> </li> <li> <p>Una vez tenemos listo el generador, vamos a a\u00f1adir el procesador ReplaceText con el que cambiaremos el texto. Tras ello, conectamos ambos procesadores.</p> <p> Conexi\u00f3n con ReplaceText </p> </li> <li> <p>Si nos fijamos, a la izquierda del nombre del procesador, aparece un icono de aviso, el cual nos indica que necesitamos configurar el nuevo procesador, adem\u00e1s de indicarnos que ambas relaciones no est\u00e1n conectadas o que faltan por autocompletar.</p> <p> Avisos que aparecen </p> <p>Para ello, configuramos la estrategia de reemplazo para que lo haga siempre (en el campo Replacement Value seleccionamos Always Replace), y al hacer esto el campo  Search Value se invalida. Adem\u00e1s, en el Replacement Value vamos a indicar simplemente <code>prueba</code>. Finalmente, marcamos para que autotermine la conexi\u00f3n <code>failure</code>.</p> </li> <li> <p>A\u00f1adimos un procesador de tipo LogAttribute para mostrar en el log los atributos del FF, y conectamos el procesador anterior (ReplaceText) a \u00e9ste mediante la relaci\u00f3n <code>success</code>.</p> <p> Log con los atributos </p> </li> <li> <p>Arrancamos el primer procesador y visualizamos la cola para comprobar qu\u00e9 ha generado. Para ello, sobre la cola elegimos la opci\u00f3n list queue para ver su contenido, y tras elegir uno, sobre el icono del ojo, visualizamos su contenido y comprobado que ha generado datos aleatorios:</p> <p> Acceso y visualizaci\u00f3n de la cola </p> </li> <li> <p>Si ejecutamos el siguiente procesador, vemos que saca el FF de la cola anterior y aparecer\u00e1 en la siguiente. Si comprobamos su valor, veremos que ha cambiado el valor original por <code>prueba</code>.</p> <p> Resultado de visualizar la cola tras ReplaceText </p> </li> </ol> <p>Si accedemos al log de la aplicaci\u00f3n (archivo <code>nifi-app.log</code> dentro de la carpeta <code>logs</code>) veremos mensajes similares a:</p> <pre><code>2021-11-17 19:12:37,446 INFO [Timer-Driven Process Thread-2]\no.a.n.processors.standard.LogAttribute LogAttribute\n[id=2f300ff5-017d-1000-9020-2744e67e8d04]\nlogging for flow file StandardFlowFileRecord\n[uuid=f4181825-f996-40c0-9e3c-a78326837d60,claim=StandardContentClaim\n    [resourceClaim=StandardResourceClaim\n        [id=1637174667410-1, container=default, section=1],\n        offset=7953, length=7],\n    offset=0,name=f4181825-f996-40c0-9e3c-a78326837d60,size=7]\n--------------------------------------------------\nStandard FlowFile Attributes\nKey: 'entryDate'\nValue: 'Wed Nov 17 19:12:37 UTC 2021'\nKey: 'lineageStartDate'\nValue: 'Wed Nov 17 19:12:37 UTC 2021'\nKey: 'fileSize'\nValue: '7'\nFlowFile Attribute Map Content\nKey: 'filename'\nValue: 'f4181825-f996-40c0-9e3c-a78326837d60'\nKey: 'path'\nValue: './'\nKey: 'uuid'\nValue: 'f4181825-f996-40c0-9e3c-a78326837d60'\n--------------------------------------------------\n</code></pre>"},{"location":"dataflow/04nifi1.html#anadiendo-un-atributo","title":"A\u00f1adiendo un atributo","text":"<p>Ahora vamos a extraer el contenido del FF a un atributo mediante el procesador ExtractText.</p> <ol> <li> <p>En las propiedades, creamos una nueva propiedad (bot\u00f3n <code>+</code> de la esquina superior derecha) que llamaremos <code>contenido</code>, y en cuyo valor vamos a poner la expresi\u00f3n <code>.*</code> que indica que queremos que coincida con todo.</p> <p> A\u00f1adimos la propiedad contenido a ExtractText </p> </li> <li> <p>Una vez creado, vamos a colocar este procesador entre los dos anteriores (para el segundo con el caso <code>matched</code>, que es cuando ha coincidido con la expresi\u00f3n regular). En la conexi\u00f3n <code>unmatched</code> la marcamos para que autotermine, y comprobamos que no tenemos ning\u00fan advertencia en ning\u00fan procesador.</p> <p> Flujo completo del caso 2 </p> </li> <li> <p>Finalmente, ejecutamos todos los procesadores y comprobamos como en el log aparece el nuevo atributo creado. Tambi\u00e9n podemos acceder a la cola, y en la parte izquierda de cada flujo, en el icono de la <code>i</code>, pulsar y comprobar la pesta\u00f1a Atributes.</p> <p> Comprobaci\u00f3n de los atributos de un FF </p> </li> </ol>"},{"location":"dataflow/04nifi1.html#linaje-de-los-datos","title":"Linaje de los datos","text":"<p>Para comprobar el dato final, es muy \u00fatil utilizar la opci\u00f3n de Data provenance, la cual nos ofrece un linaje de los datos.</p> <p>Linaje de los datos</p> <p>El linaje de los datos describe el origen, movimientos, caracter\u00edsticas y calidad de los datos, aportando visibilidad de punto a punto para incrementar la calidad de los datos. Se puede considerar como el historial de los datos, facilitando la documentaci\u00f3n y gobernanza de los datos.</p> <p>Para ello, sobre el procesador final, con el bot\u00f3n derecho, elegimos la opci\u00f3n View data provenance. Si elegimos uno de los flujos, a la derecha de cada flujo, podemos pulsar sobre el primer icono podremos ver un grafo y un slider que modifica el grafo respecto al instante temporal (en cada uno de los pasos, podemos hacer doble clik y ver la informaci\u00f3n y el contenido del FF en dicho momento exacto):</p> Linaje de los datos"},{"location":"dataflow/04nifi1.html#guardando-los-datos-en-hdfs","title":"Guardando los datos en HDFS","text":"<p>Nifi y Hadoop en m\u00e1quinas separadas</p> <p>Si trabaj\u00e1semos en una m\u00e1quina externa a la instalaci\u00f3n de Hadoop, deberemos copiar ambos archivos (<code>core-site.xml</code> y <code>hdfs-site.xml</code>) desde uno de nuestros nodos Hadoop a la m\u00e1quina donde ejecutamos Nifi.</p> <p>Para colocar los datos en HDFS, necesitamos utilizar el procesador PutHDFS y configurar las propiedades:</p> <ul> <li>Hadoop configuration resources: con la ruta de los archivos de configuraci\u00f3n de Hadoop, en nuestro caso: <code>/opt/hadoop-3.3.1/etc/hadoop/hdfs-site.xml, /opt/hadoop-3.3.1/etc/hadoop/core-site.xml</code></li> <li>Directory: con la carpeta donde queremos almacenar los datos, por ejemplo, <code>/user/iabd/nifi</code></li> </ul> <p>As\u00ed pues, vamos a a\u00f1adir este procesador unido de nuevo con la relaci\u00f3n <code>matched</code> tras la extracci\u00f3n del texto, para que adem\u00e1s de escribir en el log, persista todo el contenido en HDFS.</p> Persistiendo FF en HDFS"},{"location":"dataflow/04nifi1.html#caso-3-filtrado-de-datos","title":"Caso 3 - Filtrado de datos","text":"<p>En este caso, vamos a coger los datos de ventas que ya utilizamos en la sesi\u00f3n de Spark, el cual tiene la siguiente estructura:</p> pdi_sales_small.csv<pre><code>ProductID;Date;Zip;Units;Revenue;Country\n725;1/15/1999;41540          ;1;115.5;Germany\n787;6/6/2002;41540          ;1;314.9;Germany\n788;6/6/2002;41540          ;1;314.9;Germany\n</code></pre> <p>Utilizando Nifi, vamos a crear un nuevo fichero CSV que contenga \u00fanicamente los datos de Francia que han realizado m\u00e1s de una venta.</p> <p>Para ello, tendremos que leer el fichero haciendo uso del procesador GetFile, separar cada fila en un FF mediante SplitRecord, filtrar los datos usando el procesador QueryRecord y finalmente los almacenaremos en disco gracias al procesador PutFile.</p>"},{"location":"dataflow/04nifi1.html#lectura-y-division","title":"Lectura y divisi\u00f3n","text":"<ol> <li>As\u00ed pues, comenzamos leyendo el fichero con el procesador GetFile. En este caso vamos a dejar la opci\u00f3n keep source file a true para que no lo elimine.</li> <li> <p>Mediante el procesador SplitRecord, vamos a separar cada fila del CSV a un FF. Para ello, primero hemos de crear un RecordReader y un RecordWriter para que sepa interactuar con el CSV (Nifi ya tiene varios implementados que podemos utilizar). As\u00ed pues:</p> <ul> <li>En el Record Reader, seleccionamos Create new service, y elegimos CVSReader.</li> <li>A su vez, en el Record Writer elegimos CVSRecordSetWriter.</li> </ul> <p>Para configurar estos servicios, pulsaremos sobre la flecha, y veremos la pantalla de configuraci\u00f3n. Para cada uno de ellos, tendremos otros tres iconos: la rueda para configurar, el rayo para activar/desactivar el servicio y la papelera para eliminarlo. As\u00ed, pues, tras comprobar los valores de CVSReader y CSVSWriter (indicamos el <code>;</code> como separador de campos tanto para la lectura como la escritura de CSV en el campo value separator y marcamos como true que el archivo contiene la primera fila con encabezados (treat first line as header)), pulsamos sobre el rayo para activar ambos servicios.</p> <p> Configuraci\u00f3n y activaci\u00f3n de Split Record </p> <p>Finalmente, en el campo Records per Split le indicamos <code>1</code> para que coloque cada fila en un FF.</p> </li> </ol>"},{"location":"dataflow/04nifi1.html#filtrado-de-ff","title":"Filtrado de FF","text":"<ol> <li> <p>En este paso, mediante el procesador QueryRecord vamos a ejecutar una consulta SQL contra el FF. El resultado del nuevo FF ser\u00e1 el resultado de la consulta. En nuestro caso, como hemos comentado antes, vamos a quedarnos con las ventas de m\u00e1s de una unidad realizadas en Francia.</p> <p>Igual que antes, configuramos los mismos Record Reader y Record Writer. Adem\u00e1s, hemos de poner la propiedad Include Zero Record FlowFiles a false para que no vuelva a enrutar los FF que no cumplan la consulta. Finalmente, a\u00f1adimos una nueva propiedad para indicar la consulta. En nuestro caso la hemos denominado <code>FranciaMayor1</code> y en el contenido ponemos la consulta:</p> <pre><code>select * from Flowfile where Country = 'France' and Units &gt; 1\n</code></pre> <p>campos</p> <p>Tambi\u00e9n podr\u00edamos haber filtrado los campos para recuperar menos contenido con una consulta similar a <code>select ProductID, Date from FlowFile ....</code>. Con este procesador podemos filtrar, hacer agrupaciones, c\u00e1lculos, del mismo modo que lo hacemos con SQL.</p> </li> <li> <p>Finalmente, igual que hicimos en el caso 1, vamos a cambiarle el nombre a cada FF para generar un archivo por cada resultado mediante UpdateAttribute y persistimos los datos con PutFile.</p> </li> </ol> <p>El resultado del flujo de datos ser\u00e1 similar a:</p> Flujo completo del caso 3 <p>\u00bfRealmente no podemos hacerlo mejor?</p> <p>\u00bfHace falta generar tantos FF con los registros que cumplen la consulta? \u00bfNo ser\u00eda mejor fusionarlos en ficheros m\u00e1s grandes? Por ejemplo, despu\u00e9s de hacer la consulta, podemos utilizar un procesador MergeRecord para unir los registros, por ejemplo, cada 10KB de datos (aunque si fuera un ejemplo real, estar\u00edamos hablando de cientos de megas) y acumulando los FF entrantes, por ejemplo, durante un minuto.</p> <p>\u00bfPara qu\u00e9 hemos utilizado el SplitRecord si el procesador QueryRecord puede trabajar con un FF que contiene m\u00e1s de una fila? As\u00ed pues, podemos conectar el procesador GetFile directamente a QueryRecord y obtendr\u00edamos menos FF de resultado, concretamente como mucho por cada fichero que ley\u00e9semos (siempre que tuviera datos que cumplen la condici\u00f3n de la consulta).</p>"},{"location":"dataflow/04nifi1.html#caso-4-fusionar-datos","title":"Caso 4 - Fusionar datos","text":"<p>En esta caso vamos a realizar los siguientes pasos:</p> <ol> <li>Escuchar datos que recibimos de un servidor web.</li> <li>Reconocer si el mensaje contiene la cadena <code>error</code>.</li> <li>Fusionar los mensajes en varios ficheros, dependiendo de si contienen un error.</li> <li>Almacenar el fichero resultante en MongoDB.</li> </ol>"},{"location":"dataflow/04nifi1.html#recibiendo-datos-via-http","title":"Recibiendo datos via HTTP","text":"<ol> <li>Vamos a utilizar el procesador ListenHTTP para escuchar peticiones HTTP. Para ello, lo a\u00f1adimos a nuestro flujo de trabajo y configuramos:</li> </ol> <ul> <li>Listening port (puerto de escucha): <code>8081</code></li> <li>Base Path (endpoint de la petici\u00f3n): <code>iabd</code></li> </ul> <ol> <li>A continuaci\u00f3n, para distinguir entre los diferentes datos de entrada, utilizaremos el procesador RouteOnContent, con el objetivo de separar en dos flujos de datos, los que contienen la cadena <code>error</code> y los que no. Para ello, tras a\u00f1adir el procesador, le conectamos al flujo <code>success</code> que viene de ListenHTTP, y configuramos:</li> </ol> <ul> <li>Cambiamos el Match Requirement (requisito de coincidencia) a: <code>content must contain match</code> (no tienen que coincidir exactamente, sino contener el valor).</li> <li>Y a\u00f1adimos la propiedad <code>textoError</code> con el valor <code>ERROR</code>.</li> </ul> Propiedades de RouteOnContent <p>Para poder probarlo, arrancamos el primer procesador, y desde un terminal, hacemos una petici\u00f3n a:</p> <pre><code>curl --data \"texto de prueba\" http://localhost:8081/iabd\n</code></pre> <p>Si comprobamos la cola, podremos ver como se ha creado un FF cuyo contenido es <code>texto de prueba</code>.</p>"},{"location":"dataflow/04nifi1.html#fusionando-contenido","title":"Fusionando contenido","text":"<p>Si nos fijamos en las propiedades del procesador RouteOnContent, tenemos dos flujos de salida <code>textoError</code> (para los mensajes que contienen el texto <code>ERROR</code>) y <code>unmatched</code> (para los que no).</p> <ol> <li>Vamos a a\u00f1adir el procesador MergeContent, el cual recibe un conjunto de FF y los fusiona en uno a partir de la estrategia de fusi\u00f3n que defina el usuario. Las diferentes opciones incluye agrupando ciertos atributos de forma similar a como se realiza la fase reduce de un algoritmo MapReduce.</li> </ol> <p>As\u00ed pues, vamos a conectar las relaciones <code>textoError</code> y <code>unmatched</code> con MergeContent:</p> Conexi\u00f3n con MergeContent <p>Tras conectar los procesadores, vamos a configurar el procesador MergeContent:</p> <ul> <li>En la pesta\u00f1a de planificaci\u00f3n, vamos a poner que el procesador se ejecuta cada 30 segundos para poder agrupar varios FF.</li> <li> <p>En las propiedades:</p> <ul> <li>Merge Strategy: <code>Bin-Packing Algorithm</code> (se fusionan en grupos).</li> <li>Merge Format: <code>Binary Concatenation</code> (concatena los contenidos de los FF en un \u00fanico FF, otra opci\u00f3n ser\u00eda comprimirlos en un zip)</li> <li>Correlation Attribute Name: <code>RouteOnContent.Route</code> (crea diferentes grupos para <code>textoError</code> y <code>unmatched</code>)</li> <li>Maximum Number of Entries: <code>1000</code> (cantidad m\u00e1xima de elementos por grupo, por si tuvi\u00e9ramos muchas peticiones HTTP)</li> <li>Maximum Bin Age: <code>300s</code> (fuerza que el fichero fusionado salga como muy tarde a los 300s)</li> <li>Delimiter Strategy: <code>Text</code> (para concatenar los fichero utilizando una nueva l\u00ednea como car\u00e1cter delimitador)<ul> <li>Demarcator: al abrir el campo, pulsar Shift/May\u00fas + Intro para poner el car\u00e1cter del salto de l\u00ednea.</li> </ul> </li> </ul> </li> </ul> <p>Para poder probar c\u00f3mo se van creando y agrupando los mensajes, ejecutaremos los siguientes comandos:</p> <pre><code>curl --data \"texto de prueba\" http://localhost:8081/iabd\ncurl --data \"este s\u00ed que tiene ERROR\" http://localhost:8081/iabd\ncurl --data \"vaya ERROR m\u00e1s tonto\" http://localhost:8081/iabd\ncurl --data \"nifi mola mucho\" http://localhost:8081/iabd\n</code></pre> <p>Por ejemplo, si abrimos uno de los flujos podemos ver c\u00f3mo se han agrupado varias peticiones en un \u00fanico FF:</p> Resultado de MergeContent"},{"location":"dataflow/04nifi1.html#guardando-el-resultado-a-mongodb","title":"Guardando el resultado a MongoDB","text":"<p>Para almacenar el resultado de las fusiones anteriores, vamos a guardar los resultados en una colecci\u00f3n de MongoDB.</p> <p>Suponemos que ya tenemos instalado MongoDB en nuestro sistema, como es el caso de nuestra m\u00e1quina virtual (recuerda arrancarlo mediante <code>sudo service mongod start</code>). Si no, podemos lanzarlo mediante Docker:</p> <p>MongoDB + Nifi via Docker</p> <p>Si queremos utilizarlo mediante Docker, necesitamos que MongoDB y Nifi est\u00e9n dentro del mismo contenedor. Para ello, podemos configurarlo mediante el siguiente archivo docker-compose.yml (si tuvieras alguna problema con la imagen de MongoDB y tu procesador, prueba a cambiar la l\u00ednea 15 <code>mongo:latest</code> por <code>mongo:4.4</code>):</p> docker-compose.yml<pre><code>services:\nnifi:\nports:\n- \"8443:8443\"\nimage: apache/nifi:latest\nenvironment:\nSINGLE_USER_CREDENTIALS_USERNAME: nifi\nSINGLE_USER_CREDENTIALS_PASSWORD: nifinifinifi\nNIFI_JVM_HEAP_MAX: 2g\nlinks:\n- mongodb\nmongodb:\nports:\n- \"27017:27017\"\nimage: mongo:latest\n</code></pre> <p>Una vez creado el archivo, construimos el contenedor mediante:</p> <pre><code>docker-compose -p nifimongodb up -d\n</code></pre> <p>Para poder meter los mensajes en MongoDB, vamos a preparar el contenido para que est\u00e9 en formato JSON. Adem\u00e1s del contenido, vamos a crear un atributo con el nombre del enrutador utilizado para posteriormente poder filtrar los mensajes de error.</p> <p>Para poder crear el formato JSON, utilizaremos el procesador AttributesToJSON. As\u00ed pues, previamente necesitamos pasar los mensajes desde el contenido de los FF a los atributos (para ello, igual que en el caso anterior, utilizaremos el procesador ExtracText). A su vez, tambi\u00e9n crearemos un nuevo atributo con el nombre del enrutador mediante el procesador UpdateAttribute.</p> <p>El resultado final ser\u00e1 similar al siguiente flujo:</p> Resultado completo del caso 4 <ol> <li> <p>Utilizamos el procesador ExtracText para pasar el contenido a los atributos. Dentro de las propiedades configuraremos:</p> <ul> <li>Enable DOTALL mode: <code>true</code>, para que incluya los saltos de l\u00ednea como contenido.</li> <li>A\u00f1adimos una nueva propiedad <code>contenido</code>, y como expresi\u00f3n regular introducimos <code>(.*)</code>.</li> </ul> <p>Una vez creado, conectamos MergeContent con ExtractText mediante la conexi\u00f3n merged, y el resto de conexiones las marcamos para que autoterminen.</p> </li> <li> <p>A\u00f1adimos el procesador UpdateAttribute, y dentro de las propiedades, a\u00f1adirmos una nueva propiedad que vamos a llamar <code>estado</code> cuyo valor ser\u00e1 <code>${RouteOnContent.Route}</code>, es decir, le ponemos el mismo que contenga el atributo RouteOnContent.Route.</p> <p> Creando el atributo estado </p> <p>Una vez creado, conectamos ExtractText con UpdateAttribute mediante la conexi\u00f3n matched, y el resto de conexiones las marcamos para que autoterminen.</p> </li> <li> <p>A continuaci\u00f3n, vamos a utilizar el procesador AttributesToJSON para pasar los atributos <code>contenido</code>y <code>estado</code> como contenido de un FF en formato JSON.</p> <p>Para ello, configuramos las propiedades:</p> <ul> <li>Attribute List: <code>contenido,estado</code></li> <li>Destination: <code>flowfile-content</code></li> </ul> <p> Creando el atributo estado </p> <p>Una vez creado, conectamos UpdateAttribute con AttributesToJSON mediante la conexi\u00f3n success, y el resto de conexiones las marcamos para que autoterminen.</p> <p>Si ejecutamos los procesadores anteriores y comprobamos la salida, veremos como se est\u00e1n creando FF cuyo contenido es la petici\u00f3n introducida m\u00e1s el estado:</p> <p> Mensaje JSON creado </p> </li> <li> <p>Finalmente, a\u00f1adimos el procesador PutMongo para introducir el contenido JSON. Las propiedades que hay que configurar son:</p> <ul> <li>Mongo URI: <code>mongodb://localhost</code></li> <li>Mongo Database Name: <code>iabd</code></li> <li>Mongo Collection Name: <code>caso4</code></li> </ul> <p>En nuestro caso, hemos autoterminado la conexi\u00f3n <code>success</code> y reconectado con el mismo procesador la conexi\u00f3n <code>failure</code>.</p> </li> </ol> <p>Si arrancamos el flujo de datos completo, y tras realizar las mismas peticiones de antes:</p> <pre><code>curl --data \"texto de prueba\" http://localhost:8081/iabd\ncurl --data \"este s\u00ed que tiene ERROR\" http://localhost:8081/iabd\ncurl --data \"vaya ERROR m\u00e1s tonto\" http://localhost:8081/iabd\ncurl --data \"nifi mola mucho\" http://localhost:8081/iabd\n</code></pre> <p>S\u00f3lo nos queda entrar a MongoDB y comprobar que nos aparecen los datos:</p> <pre><code>&gt; use iabd\nswitched to db iabd\n&gt; db.caso4.find()\n{ \"_id\" : ObjectId(\"6197cca29c63ec4e825b8232\"), \"contenido\" : \"este s\u00ed que tiene ERROR\\nvaya ERROR m\u00e1s tonto\", \"estado\" : \"textoError\" }\n{ \"_id\" : ObjectId(\"6197cca29c63ec4e825b8233\"), \"contenido\" : \"texto de prueba\\nnifi mola mucho\", \"estado\" : \"unmatched\" }\n</code></pre> <p>Fecha de los mensajes</p> <p>\u00bfY si quisi\u00e9ramos a\u00f1adir una campo fecha con la fecha en la que se genera el mensaje? En el procesador UpdateAttribute podemos a\u00f1adir un nuevo atributo <code>fecha</code> con el valor <code>${now()}</code>, y posteriormente en AttributesToJSON a\u00f1adir\u00edamos dicho a atributo en Attributes list para mostrar los tres campos que queremos.  </p>"},{"location":"dataflow/04nifi1.html#actividades","title":"Actividades","text":"<ol> <li> <p>Realiza los casos de uso del 1 al 3. En la entrega debes adjuntar una captura de pantalla donde se vea el flujo de datos completo con una nota con tu nombre, y adjuntar la definici\u00f3n de cada flujo (sobre el \u00e1rea de trabajo, con el bot\u00f3n derecho, Download flow definition).</p> </li> <li> <p>(opcional) Realiza el caso de uso 4.</p> </li> </ol>"},{"location":"dataflow/04nifi1.html#referencias","title":"Referencias","text":"<ul> <li>Documentaci\u00f3n oficial:<ul> <li>Getting started with Apache Nifi</li> <li>Apache Nifi User Guide</li> <li>Apache Nifi in Depth</li> </ul> </li> <li>Apache Nifi en TutorialsPoint</li> <li>Playlist de Youtube de InsightByte</li> </ul>"},{"location":"dataflow/05nifi2.html","title":"Nifi Avanzado","text":""},{"location":"dataflow/05nifi2.html#grupos","title":"Grupos","text":"<p>En Nifi s\u00f3lo hay un canvas de nivel superior, pero podemos construir tantos flujos l\u00f3gicos como deseemos. Normalmente, para organizar las flujos, se utilizan grupos de procesos, por lo que el canvas de nivel superior puede tener varios grupos de procesos, cada uno de los cuales representa un flujo l\u00f3gico, pero no necesariamente conectados entre s\u00ed.</p> Trabajando con grupos <p>Dentro de los grupos, para indicar como entran los datos se utiliza un Input port, el cual va a definir un puerto de entrada al grupo. Del mismo modo, para indicar c\u00f3mo salen los datos, se utiliza un Output port como puerto de salida para transferir la informaci\u00f3n fuera del grupo.</p> <p>As\u00ed pues, los grupos de procesos nos van a permitir refactorizar nuestros flujos para agruparlos y poder reutilizarlos en otros flujos, o bien mejorar la legibilidad de nuestro flujo de datos.</p> <p>En todo momento podemos ver el nivel en el que nos encontramos en la parte inferior izquierda, con una notaci\u00f3n similar a <code>Nifi Flow &gt;&gt; Subnivel &gt;&gt; Otro Nivel</code>.</p>"},{"location":"dataflow/05nifi2.html#creando-un-grupo","title":"Creando un grupo","text":"<p>Vamos a partir de un ejemplo sencillo de leer un fichero de texto, partirlo en fragmentos y nos saque por el log alguno de sus atributos.</p> <p>Para ello, vamos a conectar un procesador GetFile con un SplitText y finalmente con LogAttribute. El procesador SplitText nos permite dividir cualquier flujo de texto en fragmentos a partir del n\u00famero de l\u00edneas que queramos (pudiendo tener encabezados, ignorar las l\u00edneas en blanco, etc...)</p> Dividimos un archivo en fragmentos <p>Para probarlo, podemos copiar cualquier archivo (ya sea el <code>README</code> o el <code>NOTICE</code>) en la carpeta que hayamos indicado de entrada y comprobar el log.</p> <p>Una vez lo tenemos funcionando, vamos a colocar el procesador SplitText dentro de un grupo. As\u00ed pues, un grupo encapsula la l\u00f3gica de un procesador haci\u00e9ndolo funcionar como una caja negra.</p> <p>Para ello, desde la barra superior arrastramos el icono de Process Group y lo nombramos como grupo.</p> Creaci\u00f3n de un grupo"},{"location":"dataflow/05nifi2.html#puertos","title":"Puertos","text":"<p>Una vez creado, vamos a copiar nuestro procesador SplitText. Pulsamos doble click sobre el grupo y bajaremos un nivel en el canvas para meternos dentro de Grupo. Una vez dentro, vamos a pegar el procesador y a\u00f1adiremos tanto un Input port (al que nombramos como entrada) como un Output port (al que llamamos salida). Una vez creados, los conectamos con el procesador con las mismas conexiones que antes.</p> Grupo con puertos de entrada y salida <p>Ahora salimos del grupo, y conectamos los procesadores del nivel superior con el grupo creado y comprobamos como sigue funcionando.</p> Sustituimos el procesador por el grupo creado"},{"location":"dataflow/05nifi2.html#funnels","title":"Funnels","text":"Funnel <p>Los funnels son un tipo de componente que permite trabajar en paralelo y despu\u00e9s unir los diferentes flujos en un \u00fanico flujo de ejecuci\u00f3n, adem\u00e1s de poder definir su propia prioridad de forma centralizada.</p> <p>Para ello vamos a poner varios GenerateFlowFile (4 en este caso) para mostrar sus datos mediante LogAttribute.</p> Varios procesadores que apuntan a uno <p>Si quisi\u00e9ramos cambiar el procesador de LogAttribute por otro tipo de procesador, deber\u00edamos borrar todas las conexiones y volver a conectarlo todo. Para evitar esto a\u00f1adimos un Funnel que va a centralizar todas las conexiones en un \u00fanico punto.</p> El Funnel agrupa las conexiones"},{"location":"dataflow/05nifi2.html#plantillas","title":"Plantillas","text":"<p>Nifi permite trabajar con plantillas para poder reutilizar flujos de datos, as\u00ed como importar y exportar nuestras plantillas.</p>"},{"location":"dataflow/05nifi2.html#creando-plantillas","title":"Creando plantillas","text":"<p>Crear una plantilla es muy sencillo. Si partimos del ejemplo anterior, mediante shift y el rat\u00f3n, podemos seleccionar todos los elementos que queremos que formen parte de la plantilla.</p> <p>Una vez seleccionado, podemos utilizar el bot\u00f3n derecho o dentro del men\u00fa Operate, y elegir Create Template:</p> Creaci\u00f3n de una plantilla <p>Si queremos descargar una plantilla para usarla en otra instalaci\u00f3n, desde el men\u00fa de la esquina superior derecha, en la opci\u00f3n Templates, podemos consultar las plantillas que tenemos cargadas, y para cada una de ellas, tenemos la opci\u00f3n de descargarlas o eliminarlas.</p> Descargando una plantilla"},{"location":"dataflow/05nifi2.html#cargando-plantillas","title":"Cargando plantillas","text":"<p>En cambio, para cargar una plantilla, desde el propio men\u00fa de Operate, el icono con la plantilla y la flecha hacia arriba, nos permitir\u00e1 elegir un archivo <code>.xml</code> con el c\u00f3digo de la plantilla.</p> <p>Una vez cargada, usaremos el control del menu superior para arrastrarla al \u00e1rea de trabajo.</p> <p>Una de las mayores ventajas es el uso de plantillas ya existentes. Existe una colecci\u00f3n de plantillas mantenida por Cloudera en https://github.com/hortonworks-gallery/nifi-templates. Se recomienda darle un ojo a la hoja de c\u00e1lculo que contiene un resumen de las plantillas compartidas.</p> <p>Otros ejemplos a destacar se encuentran en https://github.com/xmlking/nifi-examples.</p> <p>En nuestro caso, vamos a utilizar la plantilla de CSV-to-JSON, la cual podemos descargar desde https://raw.githubusercontent.com/hortonworks-gallery/nifi-templates/master/templates/csv-to-json-flow.xml.</p> <p>Una vez descargado el archivo xml, lo subimos a Nifi. Tras ello, arrastramos el componente y vemos su resultado:</p> Cargando una plantilla"},{"location":"dataflow/05nifi2.html#caso-5-trabajando-con-conjuntos-de-registros","title":"Caso 5: Trabajando con conjuntos de registros","text":"<p>En los casos anteriores, ya hemos visto que haciendo uso de ExtractText y AttributesToJSON pod\u00edamos crear ficheros JSON a partir de CSV.</p> <p>Nifi ofrece una forma m\u00e1s c\u00f3moda de realizar esto. Haciendo uso de los FF como registros y los procesadores de tipo Record (ya utilizamos alguno en el caso 3, en el que filtr\u00e1bamos mediante una sentencia SQL), vamos a poder trabajar con los datos como un conjunto de registros en vez de hacerlo de forma individual.</p> <p>Estos procesadores hacen que los flujos de construcci\u00f3n para manejar datos sean m\u00e1s sencillos, ya que que podemos construir procesadores que acepten cualquier formato de datos sin tener que preocuparnos por el an\u00e1lisis y la l\u00f3gica de serializaci\u00f3n. Otra gran ventaja de este enfoque es que podemos mantener los FF m\u00e1s grandes, cada uno de los cuales consta de m\u00faltiples registros, lo que resulta en un mejor rendimiento.</p> <p>Tenemos tres componentes a destacar:</p> <ul> <li>De lectura: <code>AvroReader</code>, <code>CsvReader</code>, <code>ParquetReader</code>, <code>JsonPathReader</code>, <code>JsonTreeReader</code>, <code>ScriptedReader</code>, ...</li> <li>De escritura: <code>AvroRecordSetWriter</code>, <code>CsvRecordSetWriter</code>, <code>JsonRecordSetWriter</code>, <code>FreeFormTextRecordSetWriter</code>, <code>ScriptedRecordSetWriter</code>, ...</li> <li>Procesador de registros:<ul> <li><code>ConvertRecord</code>: convierte entre formatos y/o esquemas similares. Por ejemplo, la conversi\u00f3n de CSV a Avro se puede realizar configurando <code>ConvertRecord</code> con un <code>CsvReader</code> y un <code>AvroRecordSetWriter</code>. Adem\u00e1s, la conversi\u00f3n de esquemas entre esquemas similares se puede realizar cuando el esquema de escritura es un subconjunto de los campos del esquema de lectura o si el esquema de escritura tiene campos adicionales con valores propuestos.</li> <li><code>LookupRecord</code>: extrae uno o m\u00e1s campos de un registro y busca un valor para esos campos en un <code>LookupService</code> (ya sea a un fichero CSV, XML, accediendo a una base de datos o un servicio REST, etc...). Estos servicios funcionan como un mapa, de manera que reciben la clave y el servicio devuelve el valor. Puedes consultar m\u00e1s informaci\u00f3n en la serie de art\u00edculos Data flow enrichment with NiFi part: LookupRecord processor y un ejemplo completo en Enriching Records with LookupRecord &amp; REST APIs in NiFi.</li> <li><code>QueryRecord</code>: ejecuta una declaraci\u00f3n SQL contra los registros y escribe los resultados en el contenido del archivo de flujo. Este es el procesador que usamos en el caso 3 de la sesi\u00f3n anterior.</li> <li><code>ConsumeKafkaRecord_N_M</code>: utiliza el Reader de registros configurado para deserializar los datos sin procesar recuperados de Kafka, y luego utiliza el Writer de registros configurado para serializar los registros al contenido del archivo de flujo.</li> <li><code>PublishKafkaRecord_N_M</code>: utiliza el Reader de registros configurado para leer el archivo de flujo entrante como registros, y luego utiliza el Writer de registros configurado para serializar cada registro para publicarlo en Kafka.</li> </ul> </li> </ul>"},{"location":"dataflow/05nifi2.html#convirtiendo-formatos","title":"Convirtiendo formatos","text":"<p>As\u00ed pues, para demostrar su uso vamos a convertir el archivo CSV del caso 3 de la sesi\u00f3n anterior que contiene informaci\u00f3n sobre ventas a formato JSON.</p> <p>Podr\u00edamos utilizar simplemente un GetFile conectado a un ConvertRecord y este a un PutFile. Para que el fichero generado contenga como extensi\u00f3n el formato al que convertimos, antes de serializar los datos, a\u00f1adimos un procesador UpdateAttribute para modificar el nombre del fichero.</p> <p>El flujo de datos resultante ser\u00e1 similar a:</p> Conversi\u00f3n de formato mediante ConvertRecord <p>En concreto, en el caso del ConvertRecord, hemos utilizado los siguientes elementos:</p> Configuraci\u00f3n de ConvertRecord <p>Para el CSVReader, hemos de configurar el separador de campos con el <code>;</code> e indicar que la primera fila contiene un encabezado. Para el JSONRecordSetWriter no hemos configurado nada.</p>"},{"location":"dataflow/05nifi2.html#renombrando-el-destino","title":"Renombrando el destino","text":"<p>Tal como hemos comentado, necesitamos renombrar el fichero de salida. Para ello, necesitamos hacer uso del procesador UpdateAttribute y utilizar el Nifi Expression Language para modificar la propiedad <code>filename</code> y recortar la extensi\u00f3n y concatenar con la nueva mediante la expresi\u00f3n <code>${filename:substringBefore('.csv')}.json</code>:</p> Modificando la extensi\u00f3n de filename"},{"location":"dataflow/05nifi2.html#caso-6-trabajando-con-elasticsearch","title":"Caso 6: Trabajando con Elasticsearch","text":"<p>En bloques anteriores ya hemos trabajado con Elasticsearch. En nuestro caso, tenemos la versi\u00f3n 7.16 descargada en la carpeta <code>/opt/elasticsearch-7.16.0</code> de nuestra m\u00e1quina virtual.</p> <p>Elasticsearch+Nifi via Docker</p> <p>Si queremos utilizarlo mediante Docker, necesitamos que ElasticSearch y Nifi est\u00e9n dentro del mismo contenedor. Para ello, podemos configurarlo mediante el siguiente archivo docker-compose.yml:</p> docker-compose.yml<pre><code>services:\nnifi:\nports:\n- \"8443:8443\"\nimage: apache/nifi:latest\nenvironment:\nSINGLE_USER_CREDENTIALS_USERNAME: nifi\nSINGLE_USER_CREDENTIALS_PASSWORD: nifinifinifi\nlinks:\n- elasticsearch\nelasticsearch:\nports:\n- \"9200:9200\"\n- \"9300:9300\"\nenvironment:\ndiscovery.type: single-node\nimage: docker.elastic.co/elasticsearch/elasticsearch:7.15.2\n</code></pre> <p>Una vez creado el archivo, construimos el contenedor mediante:</p> <pre><code>docker-compose -p nifielasticsearch up -d\n</code></pre> <p>Recordad que necesitamos arrancarla mediante el comando <code>./bin/elasticsearch</code>. Para comprobar que ha ido todo bien, podemos ejecutar la siguiente petici\u00f3n:</p> <pre><code>curl -X GET 'localhost:9200/_cat/health?v=true&amp;pretty'\n</code></pre> <p>El procesador con el que vamos a trabajar es del tipo PutElasticSearchHttp, en el cual vamos a configurar:</p> <ul> <li>Elasticsearch URL: <code>http://localhost:9200</code> (en el caso de usar Docker, deber\u00e1s cambiar <code>localhost</code> por el nombre del servicio: <code>http://elasticsearch:9200</code>)</li> <li>Index: aqu\u00ed vamos a poner como valor la palabra <code>peliculas</code>.</li> <li>marcamos la opci\u00f3n de autoterminar para las conexiones retry y failure.</li> </ul> <p>Una vez creado el procesador, vamos a alimentarlo a partir de los datos de un fichero JSON, mediante el procesador que ya conocemos GetFile. Pod\u00e9is descargar el fichero de pruebas movies.json y colocarlo en la carpeta donde hayamos configurado.</p> Lectura de JSON e inserci\u00f3n en Elasticsearch <p>Una vez ejecutado, para comprobar que se han introducido los datos podemos ejecutar la siguiente petici\u00f3n:</p> <pre><code>curl -X  GET \"localhost:9200/peliculas/_search?pretty\"\n</code></pre> <p>Y veremos c\u00f3mo se han introducido en Elasticsearch:</p> <pre><code>{\n\"took\": 46,\n\"timed_out\": false,\n\"_shards\": {\n\"total\": 1,\n\"successful\": 1,\n\"skipped\": 0,\n\"failed\": 0\n},\n\"hits\": {\n\"total\": {\n\"value\": 1,\n\"relation\": \"eq\"\n},\n\"max_score\": 1,\n\"hits\": [\n{\n\"_index\": \"peliculas\",\n\"_type\": \"_doc\",\n\"_id\": \"FTUyU30BBEE3YF7Zlgn1\",\n\"_score\": 1,\n\"_source\": {\n\"movies\": [\n{\n\"title\": \"The Shawshank Redemption\",\n\"rank\": \"1\",\n\"id\": \"tt0111161\"\n},\n</code></pre> <p>Si nos fijamos bien, realmente solo ha insertado un documento que contiene un array de pel\u00edculas, lo cual no est\u00e1 bien.</p>"},{"location":"dataflow/05nifi2.html#separando-los-datos","title":"Separando los datos","text":"<p>As\u00ed pues, previamente debemos separar el array contenido dentro de <code>movies.json</code> en documentos individuales.</p> <p>Borrar el \u00edndice</p> <p>Recuerda que antes de meter nuevos datos, necesitamos eliminar el \u00edndice de ElasticSearch mediante <code>curl -X DELETE \"localhost:9200/peliculas\"</code>.</p> <p>Para dividir el documento de pel\u00edculas en documentos individuales, necesitamos utilizar el procesador SplitJSON. Lo conectamos entre los dos procesadores anteriores, y le indicamos en la propiedad JSonPath Expression la expresi\u00f3n donde se encuentran las pel\u00edculas: <code>$.movies.*</code></p> Separamos las pel\u00edculas <p>Y ahora si volvemos a consultar el \u00edndice mediante <code>curl -X  GET \"localhost:9200/peliculas/_search?pretty\"</code>, s\u00ed que veremos que ha insertado las cien pel\u00edculas por separado:</p> <pre><code>{\n\"took\" : 5,\n\"timed_out\" : false,\n\"_shards\" : {\n\"total\" : 1,\n\"successful\" : 1,\n\"skipped\" : 0,\n\"failed\" : 0\n},\n\"hits\" : {\n\"total\" : {\n\"value\" : 100,\n\"relation\" : \"eq\"\n},\n\"max_score\" : 1.0,\n\"hits\" : [\n{\n\"_index\" : \"peliculas\",\n\"_type\" : \"_doc\",\n\"_id\" : \"X-uaWH0BesFhA-H6MMxA\",\n\"_score\" : 1.0,\n\"_source\" : {\n\"title\" : \"The Shawshank Redemption\",\n\"rank\" : \"1\",\n\"id\" : \"tt0111161\"\n}\n},\n{\n\"_index\" : \"peliculas\",\n\"_type\" : \"_doc\",\n\"_id\" : \"YOuaWH0BesFhA-H6MMxC\",\n\"_score\" : 1.0,\n\"_source\" : {\n\"title\" : \"The Godfather\",\n\"rank\" : \"2\",\n\"id\" : \"tt0068646\"\n}\n},\n</code></pre>"},{"location":"dataflow/05nifi2.html#caso-7-de-twitter-a-elasticsearchmongodb","title":"Caso 7: de Twitter a Elasticsearch/MongoDB","text":"<p>Para este caso de uso, vamos a recoger datos de Twitter y los vamos a meter tanto en MongoDB como en ElasticSearch a la vez.</p> <p>El primer paso es obtener unas credenciales de desarrollador por parte de Twitter para poder acceder a su API. Para ello, en https://developer.twitter.com/ creamos una cuenta de desarrollador y creamos un proyecto.</p> Claves necesarias para conectar con Twitter <p>Nifi+Elasticsearch+MongDB via Docker</p> <p>Si queremos realizar este caso de uso mediante Docker, necesitamos que ElasticSearch, MongoDB y Nifi est\u00e9n dentro del mismo contenedor. Para ello, podemos configurarlo mediante el siguiente archivo docker-compose.yml:</p> docker-compose.yml<pre><code>services:\nnifi:\nports:\n- \"8443:8443\"\nimage: apache/nifi:latest\nenvironment:\nSINGLE_USER_CREDENTIALS_USERNAME: nifi\nSINGLE_USER_CREDENTIALS_PASSWORD: nifinifinifi\nNIFI_JVM_HEAP_MAX: 2g\nlinks:\n- elasticsearch\n- mongodb\nelasticsearch:\nports:\n- \"9200:9200\"\n- \"9300:9300\"\nenvironment:\ndiscovery.type: single-node\nimage: docker.elastic.co/elasticsearch/elasticsearch:7.15.2\nmongodb:\nports:\n- \"27017:27017\"\nimage: mongo:latest\n</code></pre> <p>Una vez creado el archivo, construimos el contenedor mediante:</p> <pre><code>docker-compose -p nifielasticsearchmongodb up -d\n</code></pre>"},{"location":"dataflow/05nifi2.html#leyendo-tweets","title":"Leyendo tweets","text":"<p>Vamos a recuperar cada 100 segundos los mensajes que contengan la palabra bigdata.</p> <p>Procesador GetTwitter - Twitter Elevated</p> <p>Para poder utilizar el procesador de Nifi GetTwitter es necesario acceder al Twitter API v1.1, la cual solo est\u00e1 disponible para las cuentas con un nivel Elevated. Por ello, en vez de utilizar las credenciales habituales (API Key, API Key Secret, Access Token y Access Token Secret), vamos a realizar el acceso mediante una petici\u00f3n HTTP utilizando un token de validaci\u00f3n, conocido como Bearer Token (lo cual es una mejor pr\u00e1ctica de seguridad).</p> <p>Desde la versi\u00f3n 1.17 de Nifi (disponible desde agosto del 2022), podemos emplear el procesador ConsumeTwitter que ya emplea la versi\u00f3n 2 del API de Twitter, y sustituye al procesador anterior.</p> <p>Para ello, usamos un procesador InvokeHTTP y configuramos los siguientes par\u00e1metros:</p> <ul> <li>En la planificaci\u00f3n, vamos a configurar que se realice una petici\u00f3n cada 100 segundos, configurando Run Schedule a <code>100s</code>.</li> <li>HTTP Method: <code>GET</code></li> <li>Remote URL: <code>https://api.twitter.com/2/tweets/search/recent?query=bigdata&amp;tweet.fields=created_at,lang,public_metrics</code><ul> <li>Mediante el par\u00e1metro <code>query</code> indicamos el t\u00e9rmino a buscar. En nuestro caso, buscamos la palabra <code>bigdata</code>.</li> <li>Mediante el par\u00e1metro <code>tweet.field</code> indicamos los campos a recuperar (por defecto recupera el id y el texto de cada tweet)<ul> <li>Puedes comprobar todos los campos que podemos obtener de los mensajes en https://developer.twitter.com/en/docs/twitter-api/data-dictionary/object-model/tweet</li> </ul> </li> </ul> </li> <li>A\u00f1adimos una propiedad (mediante el icono del signo <code>+</code>) que nombramos como Authorization y le asignamos la palabra Bearer y el token que copiamos desde la administraci\u00f3n de Twitter: <code>Bearer AAAAAAAAAAAAAAAAAAAAAIGNWAEAAAAA...</code></li> </ul> Caso 7: Comprobando la lectura de mensajes de Twitter <p>Tras realizar una petici\u00f3n, obtendremos un FF similar a la siguiente informaci\u00f3n (he dejado s\u00f3lo dos mensajes para facilitar la visualizaci\u00f3n):</p> <pre><code>{\n\"data\":[\n{\n\"id\":\"1468197767885561856\",\n\"text\":\"RT @CatherineAdenle: Machine Learning Algorithms in Python You Must Learn \\n#DataScience #MachineLearning\\n#BigData #Analytics #AI #Tech #Alg\u2026\",\n\"created_at\":\"2021-12-07T12:36:40.000Z\",\n\"public_metrics\":{\n\"retweet_count\":22,\n\"reply_count\":0,\n\"like_count\":0,\n\"quote_count\":0\n},\n\"lang\":\"en\"\n},\n...\n{\n\"id\":\"1468197570925277190\",\n\"text\":\"RT @gp_pulipaka: A Quick Intro to Deep Learning Course! #BigData #Analytics #DataScience #AI #MachineLearning #IoT #IIoT #Python #RStats #T\u2026\",\n\"created_at\":\"2021-12-07T12:35:53.000Z\",\n\"public_metrics\":{\n\"retweet_count\":60,\n\"reply_count\":0,\n\"like_count\":0,\n\"quote_count\":0\n},\n\"lang\":\"en\"\n}\n],\n\"meta\":{\n\"newest_id\":\"1468197767885561856\",\n\"oldest_id\":\"1468197570925277190\",\n\"result_count\":10,\n\"next_token\":\"b26v89c19zqg8o3fpdy8xh0ikrj9fhq1nywqt95oqkxh9\"\n}\n}\n</code></pre> <p>A continuaci\u00f3n, vamos a separar los mensajes en diferentes FF del mismo modo que acabamos de hacer en el ejercicio anterior. As\u00ed pues, a\u00f1adimos el procesador SplitJson y configuramos la divisi\u00f3n de los mensajes mediante expresi\u00f3n con <code>$.data.*</code>.</p>"},{"location":"dataflow/05nifi2.html#evaluando-el-idioma","title":"Evaluando el idioma","text":"<p>Con esta informaci\u00f3n, hemos decidido enviar todos los mensajes que vengan en ingl\u00e9s (<code>\"lang\": \"en\"</code>) a ElasticSearch, y los que vengan en castellano a MongoDB.</p> <p>Mediante el procesador EvaluateJsonPath, vamos a colocar en atributos la siguiente informaci\u00f3n que queremos almacenar, definiendo la propiedad Destination como <code>flow-attribute</code>:</p> <p>Para ello creamos los siguientes atributos con la expresi\u00f3n para acceder al campo JSON asociado:</p> <ul> <li>twitter.id: <code>$.id</code></li> <li>twitter.text: <code>$.text</code></li> <li>twitter.lang: <code>$.lang</code></li> <li>twitter.created_at: <code>$.created_at</code></li> <li>twitter.rt: <code>$.public_metrics.retweet_count</code></li> <li>twitter.likes: <code>$.public_metrics.like_count</code></li> </ul> Caso 7: Creamos atributos con informaci\u00f3n de los tweets <p>A continuaci\u00f3n, conectamos con el procesador RouteOnAttribute.</p> Caso 7: Conexiones para enrutar seg\u00fan el idioma <p>Dentro del procesador RouteOnAttribute, creamos dos propiedas para enrutar los FF seg\u00fan el valor del atributo twitter.lang:</p> <ul> <li>lang-en: <code>${twitter.lang:equals(\"en\")}</code></li> <li>lang-es: <code>${twitter.lang:equals(\"es\")}</code></li> </ul> Caso 7: Enrutamos seg\u00fan el atributo twitter.lang"},{"location":"dataflow/05nifi2.html#guardando-mensajes-en-ingles-en-elasticsearch","title":"Guardando mensajes en ingl\u00e9s en ElasticSearch","text":"<p>Tal como acabamos de hacer, s\u00f3lo tenemos que a\u00f1adir el procesador PutElasticsearchHttp y configurar las siguientes propiedades:</p> <ul> <li>Elasticsearch URL: <code>http://localhost:9200</code> (en el caso de usar Docker, deber\u00e1s cambiar <code>localhost</code> por el nombre del servicio: <code>http://elasticsearch:9200</code>)</li> <li>Index: aqu\u00ed vamos a poner como valor la palabra <code>tweets</code>.</li> <li>marcamos la opci\u00f3n de autoterminar para las conexiones retry y failure.</li> </ul> <p>A continuaci\u00f3n, lo conectamos mediante la conexi\u00f3n <code>lang-en</code> que sale del procesador anterior.</p> <p>Para comprobar que los datos se est\u00e1n insertando correctamente, podemos hacer una petici\u00f3n a:</p> <pre><code>curl -X  GET \"localhost:9200/tweets/_search?pretty\"\n</code></pre>"},{"location":"dataflow/05nifi2.html#guardando-mensajes-en-castellano-en-mongodb","title":"Guardando mensajes en castellano en MongoDB","text":"<p>De forma similar, agregamos el procesador PutMongo y configuramos las siguientes propiedades:</p> <ul> <li>Mongo URI: <code>mongodb://localhost</code> (en el caso de usar Docker, deber\u00e1s cambiar <code>localhost</code> por el nombre del servicio: <code>mongodb://mongodb</code>)</li> <li>Mongo Database Name: <code>iabd</code></li> <li>Mongo Collection Name: <code>tweets</code></li> </ul> <p>Tras ello, lo conectamos mediante la conexi\u00f3n <code>lang-es</code> (y si queremos, tambi\u00e9n podemos a\u00f1adir la conexi\u00f3n <code>unmatched</code> de manera que almacener\u00e1 los tambi\u00e9n los mensajes que no est\u00e9n ni en ingl\u00e9s ni en espa\u00f1ol. Cuando Twitter no reconoce el lenguaje del mensaje, le asigna como lenguaje undetermined mediante el c\u00f3digo <code>und</code>).</p> <p>Para comprobar que los datos se est\u00e1n insertando correctamente, una vez conectados a <code>mongo</code>, podemos realizar la siguiente consulta:</p> <pre><code>use iabd;\ndb.tweets.find();\n</code></pre> <p>As\u00ed pues, el flujo de datos queda tal que as\u00ed:</p> Caso 7: Flujo de datos con ElasticSearch y MongoDB <p>Renombrando id</p> <p>Si queremos que MongoDB utilice el id del tweet como la clave de los documentos en MongoDB y as\u00ed asegurar que no tenemos mensajes repetidos, debemos renombrar el campo a <code>_id</code>. Para ello, podemos utilizar el procesador UpdateAttribute para renombrar <code>twitter.id</code> a <code>_id</code> y luego el procesador AttritubesToJSON para generar la informaci\u00f3n a almacenar.</p> <p>REST API</p> <p>Nifi ofrece un API REST con el cual podemos interactuar de forma similar al interfaz gr\u00e1fico. Teniendo Nifi arrancado, prueba con las siguientes URL: https://localhost:8443/nifi-api/access y https://localhost:8443/nifi-api/flow/about. M\u00e1s informaci\u00f3n en https://nifi.apache.org/docs/nifi-docs/rest-api/index.html</p>"},{"location":"dataflow/05nifi2.html#actividades","title":"Actividades","text":"<ol> <li> <p>Realiza los casos de uso del 5 al 7. En la entrega debes adjuntar una captura de pantalla donde se vea el flujo de datos completo con una nota con tu nombre, y adjuntar la plantilla de cada flujo.</p> </li> <li> <p>(opcional) Modifica el caso 7 para que los tweets que no est\u00e1n ni en castellano ni en ingl\u00e9s se inserten en una base de datos MySQL/MariaDB.</p> <p>Para ello, debes recoger la informaci\u00f3n de los atributos que hemos separado y generar un nuevo JSON con los datos que quieres almacenar (id, text, created_at, rt y likes) mediante el procesador AttributestoJSON. Una vez tengas el JSON, utiliza los procesadores ConvertJSONToSQL y ExecuteSQL para insertar los datos. Antes deber\u00e1s crear la tabla en la base de datos. Tienes un ejemplo parecido en el art\u00edculo Using Apache Nifi to Load Tweets from Twitter API to MemSQL.</p> <p>Adjunta capturas de pantalla de la configuraci\u00f3n de los procesadores que has a\u00f1adido, as\u00ed como de una consulta sobre la base de datos donde aparezcan mensajes insertados y la plantilla del caso de uso completo.</p> </li> </ol>"},{"location":"dataflow/05nifi2.html#referencias","title":"Referencias","text":"<ul> <li>Documentaci\u00f3n oficial:<ul> <li>Getting started with Apache Nifi</li> <li>Apache Nifi User Guide</li> <li>Apache Nifi in Depth</li> </ul> </li> <li>Apache Nifi en TutorialsPoint</li> <li>Playlist de Youtube de InsightByte</li> <li>Libro Data Engineering with Python</li> <li>Art\u00edculo de Futurespace: Flujo de extracci\u00f3n, validaci\u00f3n, transformaci\u00f3n y carga de ficheros (Caso de uso real)</li> </ul>"},{"location":"dataflow/resources/confluent/confluent.html","title":"Confluent","text":"<p>https://docs.confluent.io/platform/current/installation/docker/installation.html?_ga=2.213921236.250893104.1675841323-1286092240.1645715222#install-cp-using-docker</p> <p>https://docs.confluent.io/platform/current/platform-quickstart.html#prerequisites</p>"},{"location":"hadoop/index.html","title":"Ecosistema Hadoop","text":""},{"location":"hadoop/index.html#resultados-de-aprendizaje","title":"Resultados de aprendizaje","text":"<ul> <li>RA5074.3 Gestiona y almacena datos facilitando la b\u00fasqueda de respuestas en grandes conjuntos de datos.</li> <li>RA5075.1 Gestiona soluciones a problemas propuestos, utilizando sistemas de almacenamiento y herramientas asociadas al centro de datos.  </li> <li>RA5075.2 Gestiona sistemas de almacenamiento y el amplio ecosistema alrededor de ellos facilitando el procesamiento de grandes cantidades de datos sin fallos y de forma r\u00e1pida.  </li> <li>RA5075.3 Genera mecanismos de integridad de los datos, comprobando su mantenimiento en los sistemas de ficheros distribuidos y valorando la sobrecarga que conlleva en el tratamiento de los datos.</li> <li>RA5075.4 Realiza el seguimiento de la monitorizaci\u00f3n de un sistema, asegurando la fiabilidad y estabilidad de los servicios que se proveen.</li> </ul>"},{"location":"hadoop/index.html#planificacion-20h","title":"Planificaci\u00f3n (20h)","text":"Sesi\u00f3n Fecha Duraci\u00f3n (h) 36.- Arquitecturas Big Data Mi\u00e9rcoles 23 Nov 1p + 1o 36.- Ingesta de datos Mi\u00e9rcoles 23 Nov 1p + 1o 38.- Hadoop Lunes 28 Nov 2p + 2o 39.- HDFS Mi\u00e9rcoles 30 Nov 1p + 1o 39.- Formatos de datos Mi\u00e9rcoles 30 Nov 1p + 1o 43.- Sqoop / Flume Lunes 5 Dic 2p + 2o 45.- Hive Mi\u00e9rcoles 7 Dic 2p + 2o"},{"location":"hadoop/01arq.html","title":"Arquitecturas Big Data","text":"<p>Ya sabemos en qu\u00e9 consiste Big Data, y que dentro de sus 5V, dos de las m\u00e1s importantes son el volumen y la velocidad. Para cumplir con estas necesidades, necesitamos una infraestructura que dote a nuestras aplicaciones de toda la potencia y robustez necesarias.</p> <p>Una arquitectura de big data se dise\u00f1a para manejar la ingesti\u00f3n, el procesamiento y el an\u00e1lisis de los datos que son demasiado grandes o complejos para un sistema tradicional de base de datos.</p> <p>En esta sesi\u00f3n no vamos a profundizar en ninguna tecnolog\u00eda concreta, ya que el stack de herramientas es muy amplio y en constante crecimiento. A lo largo del curso iremos conociendo las distintas herramientas y aprenderemos c\u00f3mo y cu\u00e1ndo utilizarlas.</p>"},{"location":"hadoop/01arq.html#caracteristicas","title":"Caracter\u00edsticas","text":"<p>Todas las arquitecturas que dise\u00f1emos / utilicemos deben cumplir las siguientes caracter\u00edsticas:</p> <ul> <li>Escalabilidad: permite aumentar f\u00e1cilmente las capacidades de procesamiento y almacenamiento de datos.</li> <li>Tolerancia a fallos: garantiza la disponibilidad del sistema, aunque se produzcan fallos en algunas de las m\u00e1quinas, evitando la p\u00e9rdida de datos.</li> <li>Datos distribuidos: los datos deben estar almacenados entre diferentes m\u00e1quinas evitando as\u00ed el problema de almacenar grandes vol\u00famenes de datos en un \u00fanico nodo central (SPOF).</li> <li>Procesamiento distribuido: el tratamiento de los datos se realiza entre diferentes m\u00e1quinas para mejorar los tiempos de ejecuci\u00f3n y dotar al sistema de escalabilidad.</li> <li>Localidad del dato: los datos a trabajar y los procesos que los tratan deben estar cerca, para evitar las transmisiones por red que a\u00f1aden latencias y aumentan los tiempos de ejecuci\u00f3n.</li> </ul> <p>Antes de conocer las arquitecturas m\u00e1s empleadas, es conveniente tener presente siempre cu\u00e1l es el objetivo que debe cumplir nuestra soluci\u00f3n. Es muy f\u00e1cil caer en la sobreingenier\u00eda y montar una arquitectura con una amalgama de productos que luego son dif\u00edciles de configurar y mantener.</p>"},{"location":"hadoop/01arq.html#tipos-de-arquitecturas","title":"Tipos de arquitecturas","text":"<p>Debido a que las empresas disponen de un volumen de datos cada vez mayor y la necesidad de analizarlos y obtener valor de ellos lo antes posible, surge la necesidad de definir nuevas arquitecturas para cubrir casos de uso distintos a los que hab\u00eda hasta el momento.</p> <p>Las arquitecturas m\u00e1s comunes en estos proyectos son principalmente dos: Lambda y Kappa. La principal diferencia entre ambas son los flujos de tratamiento de datos que intervienen.</p> <p>Un par de conceptos que tenemos que definir antes de ver las caracter\u00edsticas de ambas son el procesamiento batch y el procesamiento en streaming.</p>"},{"location":"hadoop/01arq.html#procesamiento-batch","title":"Procesamiento Batch","text":"<p>Batch hace referencia a un proceso en el que intervienen un conjunto de datos y que tiene un inicio y un fin en el tiempo. Tambi\u00e9n se le conoce como procesamiento por lotes y se ejecuta sin control directo del usuario.</p> <p>Por ejemplo, si tenemos un conjunto de datos muy grande con m\u00faltiples relaciones, puede llevarnos del orden de horas ejecutar las consultas que necesita el cliente, y por tanto, no se pueden ejecutar en tiempo real y necesitan de algoritmos paralelos (como por ejemplo, Map Reduce). En estos casos, los resultados se almacenan en un lugar diferente al de origen para posteriores consultas.</p> <p>Otro ejemplo, si tenemos una aplicaci\u00f3n que muestra el total de casos COVID que hay en cada ciudad, en vez de realizar el c\u00e1lculo sobre el conjunto completo de los datos, podemos realizar una serie de operaciones que hagan esos c\u00e1lculos y los almacenen en tablas temporales (por ejemplo, mediante <code>INSERT ... SELECT</code>), de manera que si queremos volver a realizar la consulta sobre todos los datos, acceder\u00edamos a los datos ya calculados de la tabla temporal. El problema es que este c\u00e1lculo necesita actualizarse, por ejemplo, de manera diaria, y de ah\u00ed que haya que rehacer todas las tablas temporales.</p> <p>Es el procesamiento que se ha realizado desde los inicios del trabajo con datos, tanto a nivel de bases de datos como con Data Warehouses.</p> <p>De la mano del procesamiento batch se ha implantado el ecosistema Hadoop con todas las herramientas que abarcan un proceso ETL (extracci\u00f3n, transformaci\u00f3n y carga de los datos). Estos conceptos los trabajaremos m\u00e1s adelante.</p>"},{"location":"hadoop/01arq.html#procesamiento-en-streaming","title":"Procesamiento en Streaming","text":"<p>Un procesamiento es de tipo streaming cuando est\u00e1 continuamente recibiendo y tratando nueva informaci\u00f3n seg\u00fan va llegando sin tener un fin en lo referente al apartado temporal.</p> <p>Este procesamiento se relaciona con el an\u00e1lisis en tiempo real. Para ello, se utilizan diferentes sistemas basados en el uso de colas de mensajes.</p> <p>No todo es tiempo real</p> <p>No confundir tiempo real con inmediatez. En inform\u00e1tica, un sistema de tiempo real es aquel que responde en un periodo de tiempo finito, normalmente muy peque\u00f1o, pero no tiene por qu\u00e9 ser instant\u00e1neo.</p>"},{"location":"hadoop/01arq.html#arquitectura-lambda","title":"Arquitectura Lambda","text":"<p>Representada mediante la letra griega, apareci\u00f3 en el a\u00f1o 2012 y se atribuye a Nathan Marz.</p> <p>Nathan Marz</p> <p>La defini\u00f3 en base a su experiencia en sistemas de tratamiento de datos distribuidos durante su etapa como empleado en las empresas Backtype y Twitter, y est\u00e1 inspirada en su art\u00edculo How to beat the CAP theorem.</p> <p>Su objetivo era montar un sistema robusto y tolerante a fallos, tanto humanos como de hardware, que fuera linealmente escalable y que permitiese realizar escrituras y lecturas con baja latencia.</p> <p>Todos los datos que llegan al sistema van a ir por dos caminos, uno el lento (capa batch) y otro el r\u00e1pido (capa streaming), que finalmente confluyen en la capa de consultas. As\u00ed pues, se compone de tres capas:</p> <ul> <li> <p>Capa batch: se encarga de gestionar los datos hist\u00f3ricos y recalcular los resultados. De manera espec\u00edfica, la capa batch recibe todos los datos en crudo, los almacena de forma inmutable y los combina con el hist\u00f3rico existente (se a\u00f1aden a los datos existente y los datos previos nunca se sobrescriben) y recalcula los resultados iterando sobre todo el conjunto de datos combinado. Cualquier cambio en un dato se almacena como un nuevo registro, no modifica nada, para as\u00ed poder seguir el linaje de los datos.</p> <p>Linaje de los datos</p> <p>Indica las transformaciones que ha sufrido un dato, desde el origen hasta el estado actual, incluyendo las combinaciones con otros datos o el cambio del dato en s\u00ed a lo largo de su ciclo de vida.</p> <p>As\u00ed pues, este capa opera sobre el conjunto completo y permite que el sistema produzca los resultados m\u00e1s precisos. Sin embargo, esto conlleva un coste de alta latencia debido a los requisitos de tiempo de computaci\u00f3n.</p> </li> <li> <p>Capa de streaming / speed: sirve para ofrecer resultados con muy baja latencia, cercano al tiempo real. Este capa recibe los datos y realiza modificaciones incrementales sobre los resultados de la capa batch. Gracias a los algoritmos incrementales implementados en esta capa, se consigue reducir el coste computacional de manera considerable, a coste de perder algo de precisi\u00f3n.</p> </li> <li>Capa de serving: permite la consulta de los resultados enviados desde las dos capas anteriores, en base a las vistas batch que rellenan las capas anteriores.</li> </ul> <p>Podemos ver un esquema de la arquitectura en el siguiente gr\u00e1fico:</p> Arquitectura Lambda <p>Los datos que fluyen por la capa de velocidad/streaming tienen la restricci\u00f3n de latencia que impone la propia capa para poder procesar los datos todo lo r\u00e1pido que sea posible. Normalmente, este requisito choca con la precisi\u00f3n de los datos. Por ejemplo, en un escenario IoT donde se leen un gran n\u00famero de sensores de temperatura que env\u00edan datos de telemetr\u00eda, la capa de velocidad se puede utilizar para procesar una ventana temporal de los datos que entran (por ejemplo, los diez primeros segundos de cada minuto).</p> <p>Los datos que fluyen por el camino lento, no est\u00e1n sujeto a los mismos requisitos de latencia, lo que permite una mayor precisi\u00f3n computacional sobre grandes conjuntos de datos, que pueden conllevar mucho tiempo de procesamiento.</p> <p>Finalmente, ambos caminos, el lento y el r\u00e1pido, convergen en las aplicaciones anal\u00edticas del cliente. Si el cliente necesita informaci\u00f3n constante (cercana al tiempo real) aunque menos precisa, obtendr\u00e1 los datos del camino r\u00e1pido. Si no, lo har\u00e1 a partir de los datos de la capa batch.</p> <p>Dicho de otro modo, el camino r\u00e1pido tiene los datos de una peque\u00f1a ventana temporal, la cual se puede actualizar con datos m\u00e1s precisos provenientes de la capa batch.</p>"},{"location":"hadoop/01arq.html#paso-a-paso","title":"Paso a paso","text":"Arquitectura Lambda <p>El flujo de trabajo es el siguiente:</p> <ol> <li>La nueva informaci\u00f3n recogida por el sistema se env\u00eda tanto a la capa batch como a la capa de streaming (Speed Layer en la imagen anterior).</li> <li>En la capa batch (Batch Layer) se gestiona la informaci\u00f3n en crudo, es decir, sin modificar. Los datos nuevos se a\u00f1aden a los ya existentes. Seguidamente se hace un tratamiento mediante un proceso batch cuyo resultado ser\u00e1n las Batch Views, que se usar\u00e1n en la capa que sirve los datos para ofrecer la informaci\u00f3n ya transformada al exterior.</li> <li>La capa que sirve los datos (Serving Layer) indexa las Batch Views generadas en el paso anterior de forma que puedan ser consultadas con tiempos de respuesta muy bajos.</li> <li>La capa de streaming compensa la alta latencia de las escrituras que ocurre en la serving layer y solo tiene en cuenta los datos nuevos (incrementos entre los procesos batch y el momento actual).</li> <li>Finalmente, combinando los resultados de las Batch Views y de las vistas en tiempo real (Real-time Views), se construye la respuesta a las consultas realizadas.</li> </ol>"},{"location":"hadoop/01arq.html#arquitectura-kappa","title":"Arquitectura Kappa","text":"<p>El t\u00e9rmino Arquitectura Kappa fue introducido en 2014 por Jay Kreps en su art\u00edculo Questioning the Lambda Architecture. En \u00e9l se\u00f1ala los posibles puntos d\u00e9biles de la arquitectura Lambda y c\u00f3mo solucionarlos mediante una evoluci\u00f3n.</p> <p>Uno de los mayores inconveniente de la arquitectura Lambda es su complejidad. El procesamiento de los datos se realiza en dos caminos diferenciados, lo que conlleva duplicar la l\u00f3gica de computaci\u00f3n y la gesti\u00f3n de la arquitectura de ambos caminos.</p> <p>Lo que se\u00f1ala Jay Kreps en su propuesta es que todos los datos fluyan por un \u00fanico camino, eliminando la capa batch y dejando solamente la capa de streaming. Esta capa, a diferencia de la de tipo batch, no tiene un comienzo ni un fin desde un punto de vista temporal y est\u00e1 continuamente procesando nuevos datos a medida que van llegando.</p> <p>Para conseguir un \u00fanico camino, se sustituyen las fuentes de datos por colas de mensajes (por ejemplo, mediante una herramienta como Apache Kafka), obteniendo flujos de datos que facilitan el acceso en tiempo real, leyendo y transformando los datos de los mensajes en un formato que sea f\u00e1cilmente accesible a los usuarios finales. </p> Arquitectura Kappa <p>Podemos decir que sus cuatro pilares principales son los siguientes:</p> <ol> <li>Todo es un stream: las operaciones batch son un subconjunto de las operaciones de streaming, por lo que todo puede ser tratado como un stream.</li> <li>Los datos de partida no se modifican: los datos se almacenan sin ser transformados, por tanto son inmutables, y las vistas se derivan de ellos. Un estado concreto puede ser recalculado puesto que la informaci\u00f3n de origen no se modifica.</li> <li>Solo existe un flujo de procesamiento: puesto que mantenemos un solo flujo, el c\u00f3digo, el mantenimiento y la actualizaci\u00f3n del sistema se ven reducidos considerablemente.</li> <li>Tenemos la posibilidad de volver a lanzar un procesamiento: se puede modificar un procesamiento concreto y su configuraci\u00f3n para variar los resultados obtenidos partiendo de los mismos datos de entrada.</li> </ol> Arquitectura Kappa <p>Como requisito previo a cumplir, se tiene que garantizar que los eventos se leen y almacenan en el orden en el que se han generado. De esta forma, podremos variar un procesamiento concreto partiendo de una misma versi\u00f3n de los datos.</p>"},{"location":"hadoop/01arq.html#arquitectura-por-capas","title":"Arquitectura por capas","text":"<p>Adem\u00e1s de las dos soluciones que acabamos de conocer, otra forma de dise\u00f1ar las capas de una arquitectura Big Data consiste en separar las diferentes fases del dato en capa diferenciadas.</p> <p>La arquitectura por capas da soporte tanto al procesamiento batch como por streaming. La arquitectura consiste en 6 capas que aseguran un flujo seguro de los datos:</p> Arquitectura por capas (xenonstack.com) <ul> <li>Capa de ingesti\u00f3n: es la primera capa que recoge los datos que provienen de fuentes diversas. Los datos se categorizan y priorizan, facilitando el flujo de \u00e9stos en posteriores capas.</li> <li>Capa de colecci\u00f3n: Centrada en el transporte de los datos desde la ingesta al resto del pipeline de datos. En esta capa los datos se deshacen para facilitar la anal\u00edtica posterior.</li> <li>Capa de procesamiento: Esta es la capa principal. Se procesan los datos recogidos en las capas anteriores (ya sea mediante procesos batch, streaming o modelos h\u00edbridos), y se clasifican para decidir hac\u00eda qu\u00e9 capa se dirige.</li> <li>Capa de almacenamiento: Se centra en decidir donde almacenar de forma eficiente la enorme cantidad de datos. Normalmente en un almac\u00e9n de archivos distribuido, que da pie al concepto de data lake.</li> <li>Capa de consulta: capa donde se realiza el procesado anal\u00edtico, centr\u00e1ndose en obtener valor a partir de los datos.</li> <li>Capa de visualizaci\u00f3n: tambi\u00e9n conocida como capa de presentaci\u00f3n, es con la que interact\u00faan los usuarios.</li> </ul>"},{"location":"hadoop/01arq.html#tecnologias","title":"Tecnolog\u00edas","text":"<p>Por ejemplo, la ingesta de datos hacia las arquitecturas Lambda y Kappa se pueden realizar mediante un sistema de mensajer\u00eda de colas publish/subscribe como Apache Kafka y/o un servicio de flujo de datos como Apache Nifi.</p> <p>El almacenamiento de los datos y modelos lo podemos realizar mediante HDFS o S3. Dentro de una arquitectura Lambda, en el sistema batch, mediante algoritmos MapReduce de Hadoop o consultas Hive podemos generar modelos. Para la capa de streaming (tanto para Lambda como Kappa) se pueden utilizar otras tecnolog\u00edas como Apache Storm, Apache Samza o Spark Streaming para modificar modelos de forma incremental.</p> <p>De forma alternativa, Apache Spark se puede utilizar como plataforma com\u00fan para desarrollar las capas batch y streaming de la arquitectura Lambda. De ah\u00ed su amplia aceptaci\u00f3n y uso a d\u00eda de hoy en la industria, se codifica una vez y se comparte en ambas capas</p> <p>La capa de serving se puede implementar mediante una base de datos NoSQL como pueda ser Apache HBase, MongoDB, Redis o AWS Dynamo DB. Tambi\u00e9n se pueden utilizar motores de consultas como Apache Drill o Presto.</p>"},{"location":"hadoop/01arq.html#principio-scv","title":"Principio SCV","text":"<p>Mientras que el teorema CAP tiene que ver con almacenamiento de datos distribuidos, el principio SCV est\u00e1 relacionado con el procesamiento distribuido de los datos.</p> <p>Es decir, no tiene que ver con la escritura y lectura (consistente o no) de los datos en entornos distribuidos sino con el procesamiento que se realiza sobre ellos dentro de los nodos de un sistema de procesamiento distribuido.</p> <p>De modo similar a lo que ocurr\u00eda con el teorema CAP, el principio SCV establece que un sistema de procesamiento distribuido s\u00f3lo puede soportar como m\u00e1ximo 2 de las siguientes 3 caracter\u00edsticas:</p> <ul> <li>Velocidad (Speed): Se refiere a cu\u00e1nto tardan en procesarse los datos desde el momento en el que son recibidos en el sistema anal\u00edtico. Por lo general se excluye el tiempo que se tarda en capturar los datos, considerando s\u00f3lo lo que se tarda en generar la estad\u00edstica o ejecutar el algoritmo en cuesti\u00f3n. Esta velocidad es m\u00e1s alta si estamos ante un sistema de anal\u00edtica en tiempo real que si se trata de un sistema de anal\u00edtica por lotes (del ingl\u00e9s batch).</li> <li>Consistencia (Consistency): Se refiere en este caso a la precisi\u00f3n de los resultados de la anal\u00edtica (no confundir, por lo tanto, con el significado de la C del teorema CAP). Tal precisi\u00f3n depende de si para la anal\u00edtica se utilizan todos los datos disponibles (precisi\u00f3n alta) o de si por el contrario se emplean t\u00e9cnicas de muestreo para seleccionar s\u00f3lo un subconjunto de los mismos con la intenci\u00f3n de producir resultados (de menor precisi\u00f3n) en un menor tiempo.</li> <li>Volumen (Volume). Se refiere a la cantidad de datos que pueden ser procesados. Hay que tener en cuenta que en entornos de Big Data, el alto volumen de datos es una caracter\u00edsticas siempre presente (una de las 5 Vs).</li> </ul> <p>De igual modo que hicimos al estudiar el teorema CAP, nos fijaremos en una serie de escenarios para mostrar que no podemos conseguir un sistema que cumpla a la vez las 3 caracter\u00edsticas del principio SCV.</p> Principio SCV <ul> <li>Si se requiere velocidad (S) y consistencia (C), no podemos procesar un alto volumen (V) de datos ya que eso aumenta el tiempo de respuesta.</li> <li>Si se requiere consistencia (C) y poder procesar grandes vol\u00famenes de datos (V), no es posible realizar tal procesado a una alta velocidad (S).</li> <li>Si necesitamos procesar un alto volumen de datos (V) a una alta velocidad (S), entonces necesitaremos emplear t\u00e9cnicas de muestreo para seleccionar s\u00f3lo un subconjunto de esos datos, lo cual producir\u00e1 un resultado no consistente (C).</li> </ul>"},{"location":"hadoop/01arq.html#casos-de-uso","title":"Casos de uso","text":"<p>\u00bfQu\u00e9 arquitectura se adapta mejor a los requerimientos que nos traslada el cliente? \u00bfLambda o Kappa? \u00bfCu\u00e1l encaja mejor en nuestro modelo de negocio?.</p> <p>Depende. La arquitectura Lambda es m\u00e1s vers\u00e1til y es capaz de cubrir un mayor n\u00famero de casos, muchos de ellos que requieren incluso procesamiento en tiempo real.</p> <p>Una pregunta que debemos plantearnos es, \u00bfel an\u00e1lisis y el procesamiento (sus algoritmos) que vamos a realizar en las capas batch y streaming es el mismo? En ese caso la opci\u00f3n m\u00e1s acertada ser\u00eda la arquitectura Kappa.</p> <p>Sin embargo, en otras ocasiones necesitaremos acceder a todo el conjunto de datos sin penalizar el rendimiento por lo que la Lambda puede ser m\u00e1s apropiada e incluso m\u00e1s f\u00e1cil de implementar.</p> <p>Tambi\u00e9n nos inclinaremos hacia Lambda si nuestros algoritmos de batch y streaming generan resultados muy distintos, como puede suceder con operaciones de procesamiento pesado o en modelos de Machine Learning. En estos casos, los algoritmos batch se pueden optimizar ya que acceden al dataset hist\u00f3rico completo.</p> <p>El decidir entre Lamba y Kappa al final es una decisi\u00f3n entre favorecer el rendimiento de ejecuci\u00f3n de un proceso batch sobre la simplicidad de compartir c\u00f3digo para ambas capas.</p> <p>Casos reales</p> <p>Un ejemplo real de una arquitectura Kappa ser\u00eda un sistema de geolocalizaci\u00f3n de usuarios por la cercan\u00eda a una antena de telefon\u00eda m\u00f3vil. Cada vez que se aproximase a una antena que le diese cobertura se generar\u00eda un evento. Este evento se procesar\u00eda en la capa de streaming y servir\u00eda para pintar sobre un mapa su desplazamiento respecto a su posici\u00f3n anterior.</p> <p>Un caso de uso real para una arquitectura Lambda podr\u00eda ser un sistema que recomiende pel\u00edculas en funci\u00f3n de los gustos de los usuarios. Por un lado, tendr\u00eda una capa batch encargada de entrenar el modelo e ir mejorando las predicciones; y por otro, una capa streaming capaz de encargarse de las valoraciones en tiempo real.</p> <p>Como lectura recomendable tenemos un par de casos desarrollados por Ericsson que pod\u00e9is leer en https://www.ericsson.com/en/blog/2015/11/data-processing-architectures--lambda-and-kappa-examples</p> <p>Es muy importante siempre tener en mente lo r\u00e1pido que evolucionan los casos de uso que queremos cubrir y el mercado del Big Data, lo que implica la necesidad de adaptarse a ellos lo antes posible, modificando la arquitectura sobre la marcha.</p>"},{"location":"hadoop/01arq.html#buenas-practicas","title":"Buenas pr\u00e1cticas","text":"<ul> <li>En la ingesta de datos: evaluar los tipos de fuentes de datos, no todas las herramientas sirven para cualquier fuente de datos, y en alg\u00fan caso lo mejor es combinar varias herramientas para cubrir todo el abanico.</li> <li>En el procesamiento: analizar si el sistema debe ser streaming o batch. Algunos sistemas que no se definen como puramente streaming, es decir, utilizan lo que denominan micro-batch que suele dar respuesta a problemas que en el uso cotidiano del lenguaje se denomina como streaming.</li> <li>En la monitorizaci\u00f3n: al trabajar con multitud de herramientas es importante utilizar herramienta para controlar, monitorizar y gestionar la arquitectura.</li> <li>Algunas decisiones que debemos tomar a la hora de elegir la arquitectura son:<ul> <li>Enfocar los casos de uso. Cuando tengamos los objetivos claros sabremos qu\u00e9 parte debemos fortalecer en la arquitectura. \u00bfVolumen, variedad, velocidad?</li> <li>Definir la arquitectura: \u00bfbatch o streaming? \u00bfRealmente es necesario que nuestra arquitectura soporte streaming?</li> <li>Evaluar las fuentes de datos: \u00bfC\u00f3mo de heterog\u00e9neas son? \u00bfsoportan las herramientas elegidas todos los tipos de fuentes de datos que se utilizan?</li> </ul> </li> </ul>"},{"location":"hadoop/01arq.html#referencias","title":"Referencias","text":"<ul> <li>Big Data Lambda Architecture - Nathan Marz</li> <li>What Is Lambda Architecture?</li> <li>Arquitectura Lambda vs Arquitectura Kappa</li> <li>Data processing architectures \u2013 Lambda and Kappa</li> <li>Big Data Architecture \u2013 Detailed Explanation</li> </ul>"},{"location":"hadoop/01arq.html#actividades","title":"Actividades","text":"<ol> <li>(RA5075.1 / CE5.1a / 2p) Contesta a las siguientes preguntas justificando tus respuestas:<ol> <li>En una arquitectura Lambda, \u00bfc\u00f3mo consigue la capa de streaming mostrar la m\u00e1s informaci\u00f3n m\u00e1s r\u00e1pida que la de batch? \u00bfA coste de que se consigue la velocidad?</li> <li>Indica las diferencias en cantidad de datos y tiempo entre el procesamiento batch y en streaming.</li> <li>Respecto al procesamiento batch/streaming \u00bfPor qu\u00e9 Spark es una de las herramientas m\u00e1s utilizadas a d\u00eda de hoy?</li> </ol> </li> </ol>"},{"location":"hadoop/02etl.html","title":"Ingesta de Datos","text":""},{"location":"hadoop/02etl.html#introduccion","title":"Introducci\u00f3n","text":"<p>Formalmente, la ingesta de datos es el proceso mediante el cual se introducen datos, desde diferentes fuentes, estructura y/o caracter\u00edsticas dentro de otro sistema de almacenamiento o procesamiento de datos.</p> Ingesta de datos <p>La ingesta de datos es un proceso muy importante porque la productividad de un equipo va directamente ligada a la calidad del proceso de ingesta de datos. Estos procesos deben ser flexibles y \u00e1giles, ya que una vez puesta en marcha, los analistas y cient\u00edficos de datos puedan construir un pipeline de datos para mover los datos a la herramienta con la que trabajen. Entendemos como pipeline de datos un proceso que consume datos desde un punto de origen, los limpia y los escribe en un nuevo destino.</p> <p>Es sin duda, el primer paso que ha de tenerse en cuenta a la hora de dise\u00f1ar una arquitectura Big Data, para lo cual, hay que tener muy claro, no solamente el tipo y fuente de datos, sino cual es el objetivo final y qu\u00e9 se pretende conseguir con ellos. A la hora de dise\u00f1ar un pipeline, se debe empezar desde el problema que negocio quiere solucionar, y retroceder con los datos hasta el origen de los mismos. Por lo tanto, en este punto, hay que realizar un an\u00e1lisis detallado, porque es la base para determinar las tecnolog\u00edas que compondr\u00e1n nuestra arquitectura Big Data.</p> <p>Dada la gran cantidad de datos que disponen las empresas, toda la informaci\u00f3n que generan desde diferentes fuentes se deben integrar en un \u00fanico lugar, al que actualmente se le conoce como data lake, asegur\u00e1ndose que los datos sean compatibles entre s\u00ed. Gestionar tal volumen de datos puede llegar a ser un procedimiento complejo, normalmente dividido en procesos distintos y de relativamente larga duraci\u00f3n.</p>"},{"location":"hadoop/02etl.html#pipeline-de-datos","title":"Pipeline de datos","text":"<p>Un pipeline es una construcci\u00f3n l\u00f3gica que representa un proceso dividido en fases. Los pipelines de datos se caracterizan por definir el conjunto de pasos o fases y las tecnolog\u00edas involucradas en un proceso de movimiento o procesamiento de datos. En su forma m\u00e1s simple, consisten en recoger los datos, almacenarlos y procesarlos, y construir algo \u00fatil con los datos.</p> Pipeline de datos - AWS <p>Las pipelines de datos son necesarios ya que no debemos analizar los datos en los mismos sistemas donde se crean (principalmente para evitar problemas de rendimiento). El proceso de anal\u00edtica es costoso computacionalmente, por lo que se separa para evitar perjudicar el rendimiento del servicio. De esta forma, tenemos sistemas OLTP (sistemas de procesamiento transaccional online, como un CRM), encargados de capturar y crear datos, y de forma separada, sistemas OLAP (sistemas de procesamiento anal\u00edtico, como un Data Warehouse), encargados de analizar los datos.</p>"},{"location":"hadoop/02etl.html#fases-del-pipeline","title":"Fases del pipeline","text":"<p>Los movimientos de datos entre estos sistemas involucran varias fases. Por ejemplo:</p> <ol> <li>Ingesta. Recogemos los datos y los enviamos a un topic de Apache Kafka.</li> <li> <p>Almacenamiento. Kafka act\u00faa aqu\u00ed como un buffer para el siguiente paso.</p> <p> Fases en un pipeline de datos - AWS </p> </li> <li> <p>Procesamiento. Mediante una tecnolog\u00eda de procesamiento, que puede ser streaming o batch, leemos los datos del buffer.</p> </li> <li>An\u00e1lisis y Visualizaci\u00f3n. Por ejemplo, mediante Spark realizamos la anal\u00edtica sobre estos datos (haciendo c\u00e1lculos, filtrados, agrupaciones de datos, etc...). Finalmente, podemos visualizar los resultado obtenidos o almacenarlos en una base de datos NoSQL como Amazon DynamoDB o un sistema de almacenamiento distribuido como Amazon S3.</li> </ol> <p>Antes de realizar el an\u00e1lisis de los datos, va a ser muy normal tener que limpiar o normalizar los datos, ya sea porque las fuentes de datos, al ser distintas, utilicen diferentes codificaciones o nomenclaturas, o bien que haya datos sin rellenar o incorrectos. Conforme los datos avanzan a trav\u00e9s del pipeline, los datos se van a transformar (por ejemplo, poniendo ceros en los campos vac\u00edos, o rellenando los huecos con valores que aporten valor). Estas transformaciones se conocen como Data Wrangling (manipulaci\u00f3n o disputa de datos), termino que engloba las acciones realizadas desde los datos en crudo hasta el estado final en el cual el dato cobra valor y sentido para los usuarios.</p>"},{"location":"hadoop/02etl.html#pipeline-iterativo","title":"Pipeline iterativo","text":"<p>Este proceso de ingesta, almacenamiento, procesamiento y an\u00e1lisis es iterativo. Sobre una hip\u00f3tesis que se nos plantee en negocio, comprobaremos los datos almacenados, y si no disponemos de la informaci\u00f3n necesaria, recogeremos nuevos datos. EStos nuevos datos pasaran por todo el pipeline, integr\u00e1ndose con los datos ya existentes. En la fase de anal\u00edtica, si no obtenemos el resultado esperado, nos tocar\u00e1 volver a la fase de ingesta para obtener o modificar los datos recogidos, y as\u00ed, de forma iterativa, hasta producir el resultado esperado.</p> Desarrollo iterativo de un pipeline de datos - AWS <p>Aunque a menudo se intercambian los t\u00e9rminos de pipeline de datos y ETL, no significan lo mismo. Las ETLs son un caso particular de pipeline de datos que involucran las fases de extracci\u00f3n, transformaci\u00f3n y carga de datos. Las pipelines de datos son cualquier proceso que involucre el movimiento de datos entre sistemas.</p>"},{"location":"hadoop/02etl.html#etl","title":"ETL","text":"<p>Una ETL, entendida como un proceso que lleva la informaci\u00f3n de un punto A a un punto B, puede realizarse mediante diversas herramientas, scripts, Python, etc... Pero cuando nos metemos con Big Data no servir\u00e1 cualquier tipo de herramienta, ya que necesitamos que sean:</p> <ul> <li>Flexibles y soporten formatos variados (JSON, CSV, etc...)</li> <li>Escalables y tolerante a fallos.</li> <li>Dispongan de conectores a m\u00faltiples fuentes y destinos de datos.</li> </ul> <p>Los procesos ETL, siglas de extracci\u00f3n, transformaci\u00f3n y carga (load), permiten a las organizaciones recopilar en un \u00fanico lugar todos los datos de los que pueden disponer. Ya hemos comentado que estos datos provienen de diversas fuentes, por lo que es necesario acceder a ellos, y formatearlos para poder ser capaces de integrarlos. Adem\u00e1s, es muy recomendable asegurar la calidad de los datos y su veracidad, para as\u00ed evitar la creaci\u00f3n de errores en los datos.</p> Extracci\u00f3n, Transformaci\u00f3n y Carga (load) <p>Una vez los datos est\u00e1n unificados en un data lake, otro tipo de herramientas de an\u00e1lisis permitir\u00e1n su estudio para apoyar procesos de negocio.</p> <p>Dada la gran variedad de posibilidades existentes para representar la realidad en un dato, junto con la gran cantidad de datos almacenados en las diferentes fuentes de origen, los procesos ETL consumen una gran cantidad de los recursos asignados a un proyecto.</p>"},{"location":"hadoop/02etl.html#extraccion","title":"Extracci\u00f3n","text":"<p>Encargada de recopilar los datos de los sistemas originales y transportarlos al sistema donde se almacenar\u00e1n, de manera general suele tratarse de un entorno de Data Warehouse o almac\u00e9n de datos. Las fuentes de datos pueden encontrarse en diferentes formatos, desde ficheros planos hasta bases de datos relacionales, pasando por mensajes de redes sociales como Twitter o Reddit.</p> <p>Un paso que forma parte de la extracci\u00f3n es la de analizar que los datos sean veraces, que contiene la informaci\u00f3n que se espera, verificando que siguen el formato que se esperaba. En caso contrario, esos datos se rechazan.</p> <p>La primera caracter\u00edstica deseable de un proceso de extracci\u00f3n es que debe ser un proceso r\u00e1pido, ligero, causar el menor impacto posible, ser transparente para los sistemas operacionales e independiente de las infraestructuras.</p> <p>La segunda caracter\u00edstica es que debe reducir al m\u00ednimo el impacto que se genera en el sistema origen de la informaci\u00f3n. No se puede poner en riesgo el sistema original, generalmente operacional, ni perder ni modificar sus datos; ya que si colapsase esto podr\u00eda afectar el uso normal del sistema y generar p\u00e9rdidas a nivel operacional.</p> <p>As\u00ed pues, la extracci\u00f3n convierte los datos a un formato preparado para iniciar el proceso de transformaci\u00f3n.</p>"},{"location":"hadoop/02etl.html#transformacion","title":"Transformaci\u00f3n","text":"<p>En esta fase se espera realizar los cambios necesarios en los datos de manera que estos tengan el formato y contenido esperado.</p> <p>En concreto, la transformaci\u00f3n puede comprender:</p> <ul> <li>Cambios de codificaci\u00f3n.</li> <li>Eliminar datos duplicados.</li> <li>Cruzar diferentes fuentes de datos para obtener una fuente diferente.</li> <li>Agregar informaci\u00f3n en funci\u00f3n de alguna variable.</li> <li>Tomar parte de los datos para cargarlos.</li> <li>Transformar informaci\u00f3n para generar c\u00f3digos, claves, identificadores\u2026</li> <li>Generar informaci\u00f3n.</li> <li>Estructurar mejor la informaci\u00f3n.</li> <li>Generar indicadores que faciliten el procesamiento y entendimiento.</li> </ul> <p>Respecto a sus caracter\u00edsticas, debe transformar los datos para mejorarlos, incrementar su calidad, integrarlos con otros sistemas, normalizarlos, eliminar duplicidades o ambig\u00fcedades. Adem\u00e1s, no debe crear informaci\u00f3n, duplicar, eliminar informaci\u00f3n relevante, ser err\u00f3nea o impredecible.</p> <p>Una vez transformados, los datos ya estar\u00e1n listos para su carga.</p>"},{"location":"hadoop/02etl.html#carga","title":"Carga","text":"<p>Fase encargada de almacenar los datos en el destino, un data warehouse o en cualquier tipo de base de datos. Por tanto la fase de carga interact\u00faa de manera directa con el sistema destino, y debe adaptarse al mismo con el fin de cargar los datos de manera satisfactoria.</p> <p>La carga debe realizarse buscando minimizar el tiempo de la transacci\u00f3n.</p> <p>Cada BBDD puede tener un sistema ideal de carga basado en:</p> <ul> <li>SQL (Oracle, SQL Server, Redshift, Postgres, Teradata, Greenplum, \u2026)</li> <li>Ficheros (Postgres, Redshift, ...)</li> <li>Cargadores Propios (HDFS, S3, ...)</li> </ul> <p>Para mejorar la carga debemos tener en cuenta la:</p> <ul> <li>Gestiones de \u00edndices</li> <li>Gesti\u00f3n de claves de distribuci\u00f3n y particionado</li> <li>Tama\u00f1o de las transacciones y commit\u2019s</li> </ul>"},{"location":"hadoop/02etl.html#elt","title":"ELT","text":"<p>ELT cambia el orden de las siglas y se basa en extraer, cargar y transformar. Es un t\u00e9cnica de ingesti\u00f3n de datos donde los datos que se obtienen desde m\u00faltiples fuentes se colocan sin transformar directamente en un data lake o almacenamiento de objetos en la nube. Desde ah\u00ed, los datos se pueden transformar dependiendo de los diferentes objetivos de negocio.</p> <p>En principio un proceso ELT necesita menos ingenieros de datos necesarios. Con la separaci\u00f3n de la extracci\u00f3n y la transformaci\u00f3n, ELT permite que los analistas y cient\u00edficos de datos realicen las transformaciones, ya sea con SQL o mediante Python. De esta manera, m\u00e1s departamentos se involucran en obtener y mejorar los datos.</p> <p>Una de las principales razones de que ELT cueste menos de implementar es que permite una mayor generalizaci\u00f3n de la informaci\u00f3n que se almacena. Los ingenieros de datos generan un data lake con los datos obtenidos de las fuentes de datos m\u00e1s populares, dejando que la transformaci\u00f3n la realicen los expertos en el negocio. Esto tambi\u00e9n implica que los datos est\u00e9n disponibles antes, ya que mediante un proceso ETL los datos no est\u00e1n disponibles para los usuarios hasta que se han transformado, lo que suele implicar un largo proceso de trabajo.</p> <p>En resumen, el mercado se est\u00e1 moviendo desde un desarrollo centralizado mediante ETL a uno m\u00e1s orientado a servicios como ELT, que permite automatizar la carga del data lake y la posterior codificaci\u00f3n de los flujos de datos.</p>"},{"location":"hadoop/02etl.html#herramientas-etl","title":"Herramientas ETL","text":"<p>Las caracteristicas de las herramientas ETL son:</p> <ul> <li> <p>Permiten conectividad con diferentes sistemas y tipos de datos</p> <ul> <li>Excel, BBDD transaccionales, XML, ficheros CSV / JSON, Teradata, HDFS, Hive, S3, ...</li> <li>Peticiones HTTP, servicios REST...</li> <li>APIs de aplicaciones de terceros, logs\u2026</li> </ul> </li> <li> <p>Permiten la planificaci\u00f3n mediante batch, eventos o en streaming.</p> </li> <li> <p>Capacidad para transformar los datos:</p> <ul> <li>Transformaciones simples: tipos de datos, cadenas, codificaciones, c\u00e1lculos simples.</li> <li>Transformaciones intermedias: agregaciones, lookups.</li> <li>Transformaciones complejas: algoritmos de IA, segmentaci\u00f3n, integraci\u00f3n de c\u00f3digo de terceros, integraci\u00f3n con otros lenguajes.</li> </ul> </li> <li> <p>Metadatos y gesti\u00f3n de errores</p> <ul> <li>Permiten tener informaci\u00f3n del funcionamiento de todo el proceso</li> <li>Permiten el control de errores y establecer politicas al respecto</li> </ul> </li> </ul> <p>Las soluciones m\u00e1s empleadas son:</p> <ul> <li>Pentaho Data Integration (PDI)</li> <li>Oracle Data Integrator</li> <li>Talend Open Studio</li> <li>Mulesoft</li> <li>Informatica Data Integration</li> </ul> Herramientas ETL"},{"location":"hadoop/02etl.html#la-ingesta-por-dentro","title":"La ingesta por dentro","text":"<p>La ingesta extrae los datos desde la fuente donde se crean o almacenan originalmente y los carga en un destino o zona temporal. Un pipeline de datos sencillo puede que tenga que aplicar uno o m\u00e1s transformaciones ligeras para enriquecer o filtrar los datos antes de escribirlos en un destino, almac\u00e9n de datos o cola de mensajer\u00eda. Se pueden a\u00f1adir nuevos pipelines para transformaciones m\u00e1s complejas como joins, agregaciones u ordenaciones para anal\u00edtica de datos, aplicaciones o sistema de informes.</p> La ingesta de datos - StreamSets <p>Las fuentes m\u00e1s comunes desde las que se obtienen los datos son:</p> <ul> <li>servicios de mensajer\u00eda como Apache Kafka, los cuales han obtenido datos desde fuentes externas, como pueden ser dispositivos IOT o contenido obtenido directamente de las redes sociales.</li> <li>bases de datos relacionales, las cuales se acceden, por ejemplo, mediante JDBC.</li> <li>servicios REST que devuelven los datos en formato JSON.</li> <li>servicios de almacenamiento distribuido como HDFS o S3.</li> </ul> <p>Los destinos donde se almacenan los datos son:</p> <ul> <li>servicios de mensajer\u00eda como Apache Kafka.</li> <li>bases de datos relacionales.</li> <li>bases de datos NoSQL.</li> <li>servicios de almacenamiento distribuido como HDFS o S3.</li> <li>plataformas de datos como Snowflake o Databricks.</li> </ul>"},{"location":"hadoop/02etl.html#batch-vs-streaming","title":"Batch vs Streaming","text":"<p>El movimiento de datos entre los or\u00edgenes y los destinos se puede hacer, tal como vimos en la sesi\u00f3n de Arquitecturas de Big Data, mediante un proceso:</p> <ul> <li>Batch: el proceso se ejecuta de forma peri\u00f3dica (normalmente en intervalos fijos) a partir de unos datos est\u00e1ticos. Muy eficiente para grandes vol\u00famenes de datos, y donde la latencia (del orden de minutos) no es el factor m\u00e1s importante. Algunas de las herramientas utilizadas son Apache Sqoop, trabajos en MapReduce o de Spark jobs, etc...</li> <li>Streaming: tambi\u00e9n conocido como en tiempo real, donde los datos se leen, modifican y cargan tan pronto como llegan a la capa de ingesta (la latencia es cr\u00edtica). Algunas de las herramientas utilizadas son Apache Storm, Spark Streaming, Apache Nifi, Apache Kafka, etc...</li> </ul>"},{"location":"hadoop/02etl.html#arquitectura","title":"Arquitectura","text":"<p>Si nos basamos en la arquitectura por capas, podemos ver como la capa de ingesta es la primera de las capas, la cual recoge los datos que provienen de fuentes diversas. Los datos se categorizan y priorizan, facilitando el flujo de \u00e9stos en posteriores capas:</p> Arquitectura por capas (xenonstack.com) <p>En el primer paso de la ingesta es el paso m\u00e1s pesado, por tiempo y cantidad de recursos necesarios. Es normal realizar la ingesta de flujos de datos desde cientos a miles de fuentes de datos, los cuales se obtiene a velocidades variables y en diferentes formatos.</p> <p>Para ello, es necesario:</p> <ul> <li>Priorizar las fuentes de datos</li> <li>Validar de forma individual cada fichero</li> <li>Enrutar cada elemento a su destino correcto.</li> </ul> <p>Resumiendo, los cuatro par\u00e1metros en los que debemos centrar nuestros esfuerzos son:</p> <ol> <li>Velocidad de los datos: c\u00f3mo fluyen los datos entre m\u00e1quinas, interacci\u00f3n con usuario y redes sociales, si el flujo es continuo o masivo.</li> <li>Tama\u00f1o de los datos: la ingesta de m\u00faltiples fuentes puede incrementarse con el tiempo.</li> <li>Frecuencia de los datos: \u00bfbatch o en streaming?</li> <li>Formato de los datos: estructurado (tablas), desestructurado (im\u00e1genes, audios, v\u00eddeos, ...) o semi-estructurado (JSON).</li> </ol>"},{"location":"hadoop/02etl.html#herramientas-de-ingesta-de-datos","title":"Herramientas de Ingesta de datos","text":"<p>Las herramientas de ingesta de datos para ecosistemas Big Data se clasifican en los siguientes bloques:</p> Herramientas de ingesta de datos <ul> <li>Apache Sqoop: permite la transferencia bidireccional de datos entre Hadoop/Hive/HBase y una bases de datos SQL (datos estructurados). Aunque principalmente se interact\u00faa mediante comandos, proporciona una API Java.</li> <li>Apache Flume: sistema de ingesta de datos semiestructurados o no estructurados sobre HDFS o HBase mediante una arquitectura basada en flujos de datos en streaming.</li> <li>Apache Nifi: herramienta que facilita un interfaz gr\u00e1fico que permite cargar datos de diferentes fuentes (tanto batch como streaming), los pasa por un flujo de procesos (mediante grafos dirigidos) para su tratamiento y transformaci\u00f3n, y los vuelca en otra fuente.</li> <li>Elastic Logstash: Pensada inicialmente para la ingesta de logs en Elasticsearch, admite entradas y salidas de diferentes tipos (incluso AWS).</li> <li>AWS Glue: servicios gestionado para realizar tareas ETL desde la consola de AWS. Facilita el descubrimiento de datos y esquemas. Tambi\u00e9n se utiliza como almacenamiento de servicios como Amazon Athena o AWS Data Pipeline.</li> </ul> <p>Por otro lado existen sistemas de mensajer\u00eda con funciones propias de ingesta, tales como:</p> <ul> <li>Apache Kafka: sistema de intermediaci\u00f3n de mensajes basado en el modelo publicador/suscriptor.</li> <li>RabbitMQ: sistema de colas de mensajes (MQ) que act\u00faa de middleware entre productores y consumidores.</li> <li>Amazon Kinesis: hom\u00f3logo de Kafka para la infraestructura Amazon Web Services.</li> <li>Microsoft Azure Event Hubs: hom\u00f3logo de Kafka para la infraestructura Microsoft Azure.</li> <li>Google Pub/Sub: hom\u00f3logo de Kafka para la infraestructura Google Cloud.</li> </ul>"},{"location":"hadoop/02etl.html#consideraciones","title":"Consideraciones","text":"<p>A la hora de analizar cual ser\u00eda la tecnolog\u00eda y arquitectura adecuada para realizar la ingesta de datos en un sistema Big Data, hemos de tener en cuenta los siguientes factores:</p> <ul> <li>Origen y formato de los datos<ul> <li>\u00bfCu\u00e1l va a ser el origen u or\u00edgenes de los datos?</li> <li>\u00bfProvienen de sistemas externos o internos a nuestra empresa?</li> <li>\u00bfSer\u00e1n datos estructurados o datos sin estructurar?</li> <li>\u00bfCu\u00e1l es el volumen de los datos? Analizar el volumen diario y plantear como ser\u00eda la primera carga de datos.</li> <li>\u00bfExiste la posibilidad de que m\u00e1s adelante se incorporen nuevas fuentes de datos?</li> </ul> </li> <li>Latencia/Disponibilidad<ul> <li>\u00bfC\u00f3mo de importante es la velocidad con la que se deben obtener los datos?</li> <li>Ventana temporal que debe pasar desde que los datos se ingestan hasta que puedan ser utilizables, desde horas/d\u00edas (mediante procesos batch) o ser real-time (mediante streaming)</li> </ul> </li> <li>Actualizaciones<ul> <li>\u00bfLas fuentes de origen se modifican habitualmente?</li> <li>\u00bfPodemos almacenar toda la informaci\u00f3n y guardar un hist\u00f3rico de cambios?</li> <li>\u00bfModificamos la informaci\u00f3n que tenemos? \u00bfmediante updates, o deletes + insert?</li> </ul> </li> <li>Transformaciones<ul> <li>\u00bfSon necesarias durante la ingesta?</li> <li>\u00bfAportan latencia al sistema? \u00bfAfecta al rendimiento?</li> <li>\u00bfTiene consecuencias que la informaci\u00f3n sea transformada y no sea la original?</li> </ul> </li> <li>Destino de los datos<ul> <li>\u00bfSer\u00e1 necesario enviar los datos a m\u00e1s de un destino, por ejemplo, S3 y MongoDB?</li> <li>\u00bfAlmacenaremos los datos con el mismo formato que los ingestamos? \u00bfLos almacenamos en formatos basados en filas (Avro) o columnares (Parquet)?</li> <li>\u00bfC\u00f3mo se van a utilizar los datos en el destino? \u00bfc\u00f3mo ser\u00e1n las consultas? \u00bfes necesario particionar los datos? \u00bfser\u00e1n b\u00fasquedas aleatorias o no? \u00bfUtilizaremos Hive / Pig / Spark?</li> <li>\u00bfQu\u00e9 procesos de transformaci\u00f3n se van a realizar una vez ingestados los datos?</li> <li>\u00bfCual es la frecuencia y actualizaci\u00f3n de los datos origen?</li> </ul> </li> <li>Estudio de los datos<ul> <li>Calidad de los datos \u00bfson fiables? \u00bfexisten duplicados?</li> <li>Respecto a la seguridad de los datos, si tenemos datos sensibles o confidenciales, \u00bflos enmascaramos o decidimos no realizar su ingesta? \u00bfConocemos los requisitos de seguridad de nuestros datos? \u00bfQui\u00e9n tiene que acceder y en qu\u00e9 estado?</li> </ul> </li> </ul>"},{"location":"hadoop/02etl.html#referencias","title":"Referencias","text":"<ul> <li>Ingesta, es m\u00e1s que una mudanza de datos</li> <li>\u00bfQu\u00e9 es ETL?</li> <li>Building Big Data Storage Solutions (Data Lakes) for Maximum Flexibility</li> <li>Data Ingestion, Processing and Big Data Architecture Layers</li> </ul>"},{"location":"hadoop/02etl.html#actividades","title":"Actividades","text":"<ol> <li>(RA5075.1 / CE5.1b / 2p) Contesta a las siguientes preguntas justificando tus repuestas:<ol> <li>\u00bfQu\u00e9 relaci\u00f3n existe entre un pipeline de datos y una ETL?</li> <li>\u00bfEs lo mismo un proceso ETL que ELT? \u00bfCu\u00e1ndo se realiza un ETL y cuando un ELT? Dentro de un contexto Big data, \u00bfCu\u00e1l crees que se utiliza m\u00e1s? \u00bfPor qu\u00e9?</li> <li>Supongamos que somos una empresa que va a sacar un producto al mercado, y queremos medir las reacciones de las comunidades en las redes sociales. Del apartado Consideraciones contesta todas las preguntas planteadas a partir del supuesto planteado.</li> </ol> </li> </ol>"},{"location":"hadoop/03hadoop.html","title":"Hadoop","text":"Logo de Apache Hadoop <p>Si Big Data es la filosof\u00eda de trabajo para grandes vol\u00famenes de datos, Apache Hadoop (http://hadoop.apache.org/) es la tecnolog\u00eda catalizadora. Hadoop puede escalar hasta miles de ordenadores creando un cl\u00faster con un almacenamiento del orden de petabytes de informaci\u00f3n.</p> <p>M\u00e1s que un producto, es un proyecto open source que aglutina una serie de herramientas para el procesamiento distribuido de grandes conjuntos de datos a trav\u00e9s de cl\u00fasters de ordenadores utilizando modelos de programaci\u00f3n sencillos.</p> <p>Sus caracter\u00edsticas son:</p> <ul> <li>Confiable: crea m\u00faltiples copias de los datos de manera autom\u00e1tica y, en caso de fallo, vuelve a desplegar la l\u00f3gica de procesamiento.</li> <li>Tolerante a fallos: tras detectar un fallo aplica una recuperaci\u00f3n autom\u00e1tica. Cuando un componente se recupera, vuelve a formar parte del cl\u00faster. En Hadoop los fallos de hardware se tratan como una regla, no como una excepci\u00f3n.</li> <li>Escalable: los datos y su procesamiento se distribuyen sobre un cl\u00faster de ordenadores (escalado horizontal), desde un \u00fanico servidor a miles de m\u00e1quinas, cada uno ofreciendo computaci\u00f3n y almacenamiento local.</li> <li>Portable: se puede instalar en todo tipos de hardware y sistemas operativos.</li> </ul> <p>En la actualidad se ha impuesto Hadoop v3 (la \u00faltima versi\u00f3n a d\u00eda de hoy es la 3.3.4), aunque todav\u00eda existe mucho c\u00f3digo para Hadoop v2.</p>"},{"location":"hadoop/03hadoop.html#procesamiento-distribuido","title":"Procesamiento distribuido","text":"<p>Hadoop est\u00e1 dise\u00f1ado para ejecutar sistemas de procesamiento en el mismo cl\u00faster que almacena los datos (data local computing). Su filosof\u00eda es almacenar todos los datos en un lugar y procesarlos en el mismo lugar, esto es, mover el procesamiento al almac\u00e9n de datos y no mover los datos al sistema de procesamiento.</p> <p>Esto lo logra mediante un entorno distribuido de datos y procesos. El procesamiento se realiza en paralelo a trav\u00e9s de nodos de datos en un sistema de ficheros distribuidos (HDFS), donde se distingue entre:</p> <ul> <li>Nodos maestros: encargados de los procesos de gesti\u00f3n global, es decir, controlar la ejecuci\u00f3n o el almacenamiento de los trabajos y/o datos. Normalmente se necesitan 3. Su hardware tiene mayores requisitos.</li> <li>Nodos workers: tratan con los datos locales y los procesos de aplicaci\u00f3n. Su n\u00famero depender\u00e1 de las necesidad de nuestros sistemas, pero pueden estar comprendido entre 4 y 10.000. Su hardware es relativamente barato (commodity hardware) mediante servidores X86.</li> <li>Nodos edge: hacen de puente entre el cl\u00faster y la red exterior, y proporcionan interfaces.</li> </ul> Arquitectura hardware de Hadoop <p>Commodity Hardware</p> <p>A veces el concepto hardware commodity suele confundirse con hardware dom\u00e9stico, cuando lo que hace referencia es a hardware no espec\u00edfico, que no tiene unos requerimientos en cuanto a disponibilidad o resiliencia exigentes.</p> <p>El hardware t\u00edpico donde se ejecuta un cluster Hadoop es el siguiente:</p> <ul> <li>Nodos worker: 256 Gb RAM \u2013 12 discos duros de 2-4 TB JBOD (just a bunch of drives) \u2013 2 CPU x 6-8 cores.</li> <li>Nodos master: 256 Gb RAM \u2013 2 discos duros de 2-3 TB en RAID \u2013 2 CPU x 8 cores. En estos nodos es m\u00e1s importante la capacidad de la CPU que la de almacenamiento.</li> <li>Nodos edge: 256 Gb RAM \u2013 2 discos duros de 2-3 TB en RAID \u2013 2 CPU x 8 cores.</li> </ul> <p>Cada vez que a\u00f1adimos un nuevo nodo worker, aumentamos tanto la capacidad como el rendimiento de nuestro sistema.</p>"},{"location":"hadoop/03hadoop.html#componentes-y-ecosistema","title":"Componentes y Ecosistema","text":"<p>El n\u00facleo de Hadoop se compone de:</p> <ul> <li>un conjunto de utilidades comunes (Hadoop Common)</li> <li>un sistema de ficheros distribuidos (Hadoop Distributed File System \u2194 HDFS).</li> <li>un gestor de recursos para el manejo del cl\u00faster y la planificaci\u00f3n de procesos (YARN)</li> <li>un sistema para procesamiento paralelo de grandes conjuntos de datos (MapReduce)</li> </ul> <p>Estos elementos permiten trabajar casi de la misma forma que si tuvi\u00e9ramos un sistema de fichero locales en nuestro ordenador personal, pero realmente los datos est\u00e1n repartidos entre miles de servidores.</p> <p>Las aplicaciones se desarrollan a alto nivel, sin tener constancia de las caracter\u00edsticas de la red. De esta manera, los cient\u00edficos de datos se centran en la anal\u00edtica y no en la programaci\u00f3n distribuida.</p> <p>Sobre este conjunto de herramientas existe un ecosistema \"infinito\" con tecnolog\u00edas que facilitan el acceso, gesti\u00f3n y extensi\u00f3n del propio Hadoop.</p> Ecosistema Hadoop <p>Las m\u00e1s utilizadas son:</p> <ul> <li>Hive: Permite acceder a HDFS como si fuera una Base de datos, ejecutando comandos muy parecido a SQL para recuperar valores (HiveSQL). Simplifica enormemente el desarrollo y la gesti\u00f3n con Hadoop.</li> <li>HBase: Es el sistema de almacenamiento NoSQL basado en columnas para Hadoop.<ul> <li>Es una base de datos de c\u00f3digo abierto, distribuida y escalable para el almacenamiento de Big Data.</li> <li>Escrita en Java, implementa y proporciona capacidades similares sobre Hadoop y HDFS.</li> <li>El objetivo de este proyecto es el de trabajar con grandes tablas, de miles de millones de filas de millones de columnas, sobre un cl\u00faster Hadoop.</li> </ul> </li> <li>Pig: Lenguaje de alto de nivel para analizar grandes vol\u00famenes de datos. Trabaja en paralelo, lo que permite gestionar gran cantidad de informaci\u00f3n. Realmente es un compilador que genera comandos MapReduce, mediante el lenguaje textual denominado Pig Latin.</li> <li>Sqoop: Permite transferir un gran volumen de datos de manera eficiente entre Hadoop y sistemas gestores de base de datos relacionales.</li> <li>Flume: Servicio distribuido y altamente eficiente para distribuir, agregar y recolectar grandes cantidades de informaci\u00f3n. Es \u00fatil para cargar y mover informaci\u00f3n en Hadoop, como ficheros de logs, datos de Twitter/Reddit, etc. Utiliza una arquitectura de tipo streaming con un flujo de datos muy potente y personalizables</li> <li>ZooKeeper: Servicio para mantener la configuraci\u00f3n, coordinaci\u00f3n y aprovisionamiento de aplicaciones distribuidas. No s\u00f3lo se utiliza en Hadoop, pero es muy \u00fatil en esa arquitectura, eliminando la complejidad de la gesti\u00f3n distribuida de la plataforma.</li> <li>Spark: Es un motor muy eficiente de procesamiento de datos a gran escala. Implementa procesamiento en tiempo real al contrario que MapReduce, lo que provoca que sea m\u00e1s r\u00e1pido. Para ello, en vez de almacenar los datos en disco, trabaja de forma masiva en memoria. Puede trabajar de forma aut\u00f3noma, sin necesidad de Hadoop.</li> <li>Ambari: Herramienta utilizada para instalar, configurar, mantener y monitorizar Hadoop.</li> </ul> <p>Si queremos empezar a utilizar Hadoop y todo su ecosistema, disponemos de diversas distribuciones con toda la arquitectura, herramientas y configuraci\u00f3n ya preparadas. Las m\u00e1s rese\u00f1ables son:</p> <ul> <li>Amazon Elastic MapReduce (EMR) de AWS.</li> <li>CDH de Cloudera</li> <li>Azure HDInsight de Microsoft.</li> <li>DataProc de Google.</li> </ul>"},{"location":"hadoop/03hadoop.html#hdfs","title":"HDFS","text":"<p>Es la capa de almacenamiento de Hadoop, y como tal, es un sistema de ficheros distribuido y tolerante a fallos que puede almacenar gran cantidad de datos, escalar de forma incremental y sobrevivir a fallos de hardware sin perder datos. Se basa en el paper que public\u00f3 Google detallando su Google File System en 2003.</p> <p>Es un sistema que reparte los datos entre todos los nodos del cl\u00faster de Hadoop, dividiendo los ficheros en bloques (cada bloque por defecto es de 128MB) y almacenando copias duplicadas a trav\u00e9s de los nodos. Por defecto se replica en 3 nodos distintos (esto se conoce como el factor de replicaci\u00f3n).</p> <p>HDFS asegura que se puedan a\u00f1adir servidores para incrementar el tama\u00f1o de almacenamiento de forma lineal, de manera que al introducir un nuevo nodo, se incrementa tanto la redundancia como la capacidad de almacenamiento.</p> <p>Est\u00e1 planteado para escribir los datos una vez y leerlos muchos veces (WORM / Write Once, Read Many). Las escrituras se pueden realizar a mano, o desde herramientas como Flume y Sqoop, que estudiaremos m\u00e1s adelante.</p> <p>No ofrece buen rendimiento para:</p> <ul> <li>Accesos de baja latencia. Realmente se utiliza para almacenar datos de entrada necesarios para procesos de computaci\u00f3n.</li> <li>Ficheros peque\u00f1os (a menos que se agrupen). Funciona mejor con grandes cantidades de ficheros grandes, es decir, mejor millones de ficheros de 100MB que billones de ficheros de 1MB.</li> <li>M\u00faltiples escritores.</li> <li>Modificaciones arbitrarias de ficheros.</li> </ul> <p>As\u00ed pues, los datos, una vez escritos en HDFS son immutables. Cada fichero de HDFS solo permite a\u00f1adir contenido (append-only). Una vez se ha creado y escrito en \u00e9l, solo podemos a\u00f1adir contenido o eliminarlo. Es decir, a priori, no podemos modificar los datos.</p> <p>HBase / Hive</p> <p>Tanto HBase como Hive ofrecen una capa por encima de HDFS para dar soporte a la modificaci\u00f3n de los datos, como en cualquier base de datos.</p>"},{"location":"hadoop/03hadoop.html#bloques","title":"Bloques","text":"<p>Un bloque es la cantidad m\u00ednima de datos que puede ser le\u00edda o escrita. El tama\u00f1o predeterminado de HDFS son 128 MB, ya que como hemos comentado, Hadoop est\u00e1 pensado para trabajar con ficheros de gran tama\u00f1o.</p> <p>Todos los ficheros est\u00e1n divididos en bloques. Esto quiere decir que si subimos un fichero de 600MB, lo dividir\u00e1 en 5 bloques de 128MB. Estos bloques se distribuyen por todos los nodos de datos del cl\u00faster de Hadoop.</p> <p>Si un fichero de HDFS es menor que el tama\u00f1o de un bloque, es decir, menor de 128MB, ocupar\u00e1 un bloque l\u00f3gico pero en disco \u00fanicamente ocupar\u00e1 el espacio necesario. Es decir, un archivo de 1MB ocupar\u00e1 un bloque de 128MB, pero utilizar\u00e1 1MB en disco.</p> <p>A partir del factor de replicaci\u00f3n, cada bloque se almacena varias veces en m\u00e1quinas distintas. El valor por defecto es 3. Por lo tanto, el archivo de 600MB que ten\u00edamos dividido en 5 bloques de 128MB, si lo replicamos tres veces, lo tendremos repartido en 15 bloques entre todos los nodos del cl\u00faster.</p> Factor de replicaci\u00f3n HDFS <p>Respecto a los permisos de lectura y escritura de los ficheros, sigue la misma filosof\u00eda de asignaci\u00f3n de usuarios y grupos que se realiza en los sistemas Posix. Es una buena pr\u00e1ctica crear una carpeta <code>/user/</code> en el ra\u00edz de HDFS, de forma similar al <code>/home/</code> de Linux.</p> <p>En HDFS se distinguen las siguientes m\u00e1quinas:</p> <ul> <li>Namenode: Act\u00faa como m\u00e1ster y almacena todos los metadatos necesarios para construir el sistema de ficheros a partir de sus bloques. Tiene control sobre d\u00f3nde est\u00e1n todos los bloques.</li> <li>Datanode: Son los esclavos, se limitan a almacenar los bloques que compone cada fichero.</li> <li>Secondary Namenode: Su funci\u00f3n principal es tomar puntos de control de los metadatos del sistema de archivos presentes en namenode.</li> </ul> Arquitectura HDFS <p>En la siguiente sesi\u00f3n profundizaremos en la arquitectura de HDFS y c\u00f3mo funcionan y gestionan los datos tanto el namenode como los datanodes.</p>"},{"location":"hadoop/03hadoop.html#mapreduce","title":"MapReduce","text":"<p>Se trata de un paradigma de programaci\u00f3n funcional en dos fases, la de mapeo y la de reducci\u00f3n, y define el algoritmo que utiliza Hadoop para paralelizar las tareas. Un algoritmo MapReduce divide los datos, los procesa en paralelo, los reordena, combina y agrega de vuelta los resultados mediante un formato clave/valor.</p> <p>Sin embargo, este algoritmo no casa bien con el an\u00e1lisis interactivo o programas iterativos, ya que persiste los datos en disco entre cada uno de los pasos del mismo, lo que con grandes datasets conlleva una penalizaci\u00f3n en el rendimiento.</p> <p>Un job de MapReduce se compone de m\u00faltiples tareas MapReduce, donde la salida de una tarea es la entrada de la siguiente.</p> <p>El siguiente gr\u00e1fico muestra un ejemplo de una empresa que fabrica juguetes de colores. Cuando un cliente compra un juguete desde la p\u00e1gina web, el pedido se almacena como un fichero en Hadoop con los colores de los juguetes adquiridos. Para averiguar cuantas unidades de cada color debe preparar la f\u00e1brica, se emplea un algoritmo MapReduce para contar los colores:</p> <p></p> <p>Como sugiere el nombre, el proceso se divide principalmente en dos fases:</p> <ul> <li>Fase de mapeo (Map) \u2014 Los documentos se parten en pares de clave/valor. Hasta que no se reduzca, podemos tener muchos duplicados.</li> <li>Fase de reducci\u00f3n (Reduce) \u2014 Es en cierta medida similar a un \"group by\" de SQL. Las ocurrencias similares se agrupan, y dependiendo de la funci\u00f3n de reducci\u00f3n, se puede crear un resultado diferente. En nuestro ejemplo queremos contar los colores, y eso es lo que devuelve nuestra funci\u00f3n.</li> </ul> <p>Realmente, es un proceso m\u00e1s complicado:</p> <p></p> <ol> <li>Lectura desde HDFS de los ficheros de entrada como pares clave/valor.</li> <li>Pasar cada l\u00ednea de forma separada al mapeador, teniendo tantos mapeadores como bloques de datos tengamos.</li> <li>El mapeador parsea los colores (claves) de cada fichero y produce un nuevo fichero para cada color con el n\u00famero de ocurrencias encontradas (valor), es decir, mapea una clave (color) con un valor (n\u00famero de ocurrencias).</li> <li>Para facilitar la agregaci\u00f3n, se ordenan y/o barajan los datos a partir de la clave.</li> <li>La fase de reducci\u00f3n suma las ocurrencias de cada color y genera un fichero por clave con el total de cada color.</li> <li>Las claves se unen en un \u00fanico fichero de salida que se persiste en HDFS.</li> </ol> <p>No es oro todo lo que reluce</p> <p>Hadoop facilita el trabajo con grandes vol\u00famenes de datos, pero montar un cl\u00faster funcional no es una cosa trivial. Existen gestores de cl\u00fasters que hacen las cosas un poco menos inc\u00f3modas (como son Apache Ambari o Apache Mesos), aunque la tendencia es utilizar una soluci\u00f3n cloud que nos evita toda la instalaci\u00f3n y configuraci\u00f3n.</p> <p>Tal como comentamos al inicio, uno de los puntos d\u00e9biles de Hadoop es el trabajo con algoritmos iterativos, los cuales son fundamentales en la parte de IA. La soluci\u00f3n es el uso de Spark (que estudiaremos pr\u00f3ximamente), que mejora el rendimiento por una orden de magnitud.</p>"},{"location":"hadoop/03hadoop.html#yarn","title":"YARN","text":"<p>Yet Another Resource Negotiator es un distribuidor de datos y gestor de recursos distribuidos. Forma parte de Hadoop desde la versi\u00f3n 2, y abstrae la gesti\u00f3n de recursos de los procesos MapReduce lo que implica una asignaci\u00f3n de recursos m\u00e1s efectiva. YARN soporta varios frameworks de procesamiento distribuido, como MapReduce v2, Tez, Impala, Spark, etc..</p> YARN y Hadoop <p>El objetivo principal de YARN es separar en dos servicios las funcionalidades de gesti\u00f3n de recursos de la monitorizaci\u00f3n/planificaci\u00f3n de tareas. Por un lado, un gestor de los procesos que se ejecutan en el cl\u00faster, que permite coordinar diferentes aplicaciones, asignar recursos y prioridades, permitir su convivencia, etc. Y por otro lado, las aplicaciones, que pueden desarrollarse utilizando un marco de ejecuci\u00f3n m\u00e1s ligero, no atado a un modelo estricto sobre c\u00f3mo ejecutarse, lo que da m\u00e1s libertad para poder desarrollar las aplicaciones.</p>"},{"location":"hadoop/03hadoop.html#componentes","title":"Componentes","text":"<p>Se divide en tres componentes principales: un Resource Manager, m\u00faltiples Node Manager y varios ApplicationMaster.</p> <p>La idea es tener un Resource Manager por cl\u00faster y un Application Master por aplicaci\u00f3n, considerando una aplicaci\u00f3n tanto un \u00fanico job como un conjunto de jobs c\u00edclicos.</p> Componentes en YARN <p>El Resource Manager y el Node Manager componen el framework de computaci\u00f3n de datos. En concreto, el ResourceManager controla el arranque de la aplicaci\u00f3n, siendo la autoridad que orquesta los recursos entre todas las aplicaciones del sistema. A su vez, tendremos tantos NodeManager como datanodes tenga nuestro cl\u00faster, siendo responsables de gestionar y monitorizar los recursos de cada nodo (CPU, memoria, disco y red) y reportar estos datos al Resource Manager.</p> <p>El Application Master es una librer\u00eda espec\u00edfica encargada de negociar los recursos con el ResourceManager y de trabajar con los Node Manager para ejecutar y monitorizar las tareas.</p> <p>Finalmente, en nuestro cl\u00faster, tendremos corriendo un Job History Server encargado de archivar los fichero de log de los jobs. Aunque es un proceso opcional, se recomienda su uso para monitorizar los jobs ejecutados.</p>"},{"location":"hadoop/03hadoop.html#resource-manager","title":"Resource Manager","text":"<p>El Resource Manager mantiene un listado de los Node Manager activos y de sus recursos disponibles. Dicho de otro modo, es el equivalente al Namenode de HDFS.</p> <p>Cuando un cliente quiere ejecutar una aplicaci\u00f3n en YARN, se comunica con el ResourceManager, que ser\u00e1 el encargado de asignarle los recursos en base a las pol\u00edticas de prioridad asignadas y los recursos disponibles, distribuir la aplicaci\u00f3n (el ejecutable) por los diferentes nodos worker que realizar\u00e1n la ejecuci\u00f3n, controlar la ejecuci\u00f3n para detectar si ha habido una ca\u00edda de una de las tareas, para relanzarla en otro nodo, y liberar los recursos una vez la ejecuci\u00f3n haya finalizado.</p> <p>El gestor de recursos, a su vez, se divide en dos componentes:</p> <ul> <li>El Scheduler o planificador es el encargado de gestionar la distribuci\u00f3n de los recursos del cl\u00faster de YARN. Adem\u00e1s, las aplicaciones usan los recursos que el Resource Manager les ha proporcionado en funci\u00f3n de sus criterios de planificaci\u00f3n. Este planificador no monitoriza el estado de ninguna aplicaci\u00f3n ni les ofrece garant\u00edas de ejecuci\u00f3n, ni recuperaci\u00f3n por fallos de la aplicaci\u00f3n o el hardware, s\u00f3lo planifica. Este componente realiza su planificaci\u00f3n a partir de los requisitos de recursos necesarios por las aplicaciones (CPU, memoria, disco y red).</li> <li>Applications Manager: responsable de aceptar las peticiones de trabajos, negociar el contenedor con los recursos necesarios en el que ejecutar la Application Master y proporcionar reinicios de los trabajos en caso de que fuera necesario debido a errores.</li> </ul>"},{"location":"hadoop/03hadoop.html#node-manager","title":"Node Manager","text":"<p>El servicio NodeManager se ejecuta en cada nodo worker y realiza las siguientes funciones:</p> <ul> <li>Monitoriza y proporciona informaci\u00f3n sobre el consumo de recursos (CPU/memoria) por parte de los contenedores al ResourceManager.</li> <li>Env\u00eda mensajes para notificar al ResourceManager su actividad (no est\u00e1 ca\u00eddo) as\u00ed como la informaci\u00f3n sobre su estado a nivel de recursos.</li> <li>Supervisa el ciclo de vida de los contenedores de aplicaciones.</li> <li>Supervisa la ejecuci\u00f3n de las distintas tareas en contenedores y termina aquellas tareas que se han quedado bloqueadas.</li> <li>Almacena un log (fichero en HDFS) con todas las operaciones que se realizan en el nodo.</li> <li>Lanza procesos ApplicationMaster, que coordinan los trabajos para cada aplicaci\u00f3n.</li> </ul> <p>Contenedores</p> <p>Es la unidad m\u00ednima de recursos de ejecuci\u00f3n para las aplicaciones, y que representa una cantidad espec\u00edfica de memoria, n\u00facleos de procesamiento (cores) y otros recursos (disco, red), para procesar las aplicaciones. Por ejemplo, un contenedor puede representar 4 gigabytes de memoria y 1 n\u00facleo de procesamiento.</p> <p>Todas las tareas de las aplicaciones YARN se ejecutan en contenedores. Cada trabajo puede contener m\u00faltiples tareas y cada una de las tareas se ejecuta en su propio contenedor. Cuando una tarea va a arrancar, YARN le asigna un contenedor, y cuando la tarea termina, el contenedor se elimina y sus recursos se asignan a otras tareas.</p> <p> Contenedores en NodeManager </p> <p>La cantidad de tareas y, por lo tanto, la cantidad de aplicaciones de YARN que puede ejecutar en cualquier momento, est\u00e1 limitada por la cantidad de contenedores que tiene un cl\u00faster. Por ejemplo, en un cl\u00faster de 20 nodos, con 256 GB de RAM y 12 cores por nodo, si se le ha asignado a YARN toda la capacidad existente, habr\u00e1 un total de 5 TB de RAM y 240 cores disponibles. Si se ha definido un tama\u00f1o de contenedor de 32 gigabytes, habr\u00e1 un m\u00e1ximo de 160 contenedores disponibles, es decir, se podr\u00e1n ejecutar como m\u00e1ximo 160 tareas de forma concurrente.</p> <p>Los contenedores YARN tienen una asignaci\u00f3n de recursos (CPU, memoria, disco y red) fija de un host del cl\u00faster y el Node Manager es el encargado de monitorizar esta asignaci\u00f3n. Si un proceso sobrepasase los recursos asignados, por ejemplo, ser\u00eda el encargado de detenerlo. Adem\u00e1s, mapean las variables de entorno necesarias, las dependencias y los servicios necesarios para crear los procesos.</p> <p>Los NodeManager, al igual que los Datanodes en HDFS, son tolerantes a fallos, por lo que en caso de ca\u00edda de alguno de ellos, el ResourceManager detectar\u00e1 que no funciona y redirigir\u00e1 la ejecuci\u00f3n de las aplicaciones al resto de nodos activos.</p>"},{"location":"hadoop/03hadoop.html#application-master","title":"Application Master","text":"<p>El Application Master es el responsable de negociar los recursos apropiados con el Resource Manager y monitorizar su estado y su progreso. Tambi\u00e9n coordina la ejecuci\u00f3n de todas las tareas en las que puede dividirse su aplicaci\u00f3n.</p> <p>Existe un proceso ApplicationMaster por aplicaci\u00f3n, y se ejecuta en uno de los nodos worker, para garantizar la escalabilidad de YARN, ya que si se ejecutaran todos los ApplicationMaster en el nodo maestro, junto con el ResourceManager, \u00e9ste ser\u00eda un cuello de botella para poder escalar o poder lanzar un gran n\u00famero de aplicaciones sobre el cl\u00faster.</p> <p>Asimismo, a diferencia del ResourceManager y los NodeManager, el ApplicationMaster es espec\u00edfico para una aplicaci\u00f3n por lo que, cuando la aplicaci\u00f3n finaliza, el proceso ApplicationMaster termina. En el caso de los servicios ResourceManager y NodeManager, siempre se est\u00e1n ejecutando aunque no haya aplicaciones activas en el cl\u00faster. Cada vez que se inicia una nueva aplicaci\u00f3n, ResourceManager asigna un contenedor que ejecuta ApplicationMaster en uno de los nodos del cl\u00faster.</p>"},{"location":"hadoop/03hadoop.html#funcionamiento","title":"Funcionamiento","text":"<p>Podemos ver la secuencia de trabajo y colaboraci\u00f3n de estos componentes en el siguiente gr\u00e1fico:</p> Secuencia de trabajo YARN <ol> <li>El cliente env\u00eda una aplicaci\u00f3n YARN.</li> <li>Resource Manager reserva los recursos en un contenedor para su ejecuci\u00f3n.</li> <li>El Application Manager se registra con el Resource Manager y pide los recursos necesarios.</li> <li>El Application Manager notifica al Node Manager la ejecuci\u00f3n de los contenedores. Se ejecuta la aplicaci\u00f3n YARN en el/los contenedor/es correspondiente.</li> <li>El Application Master monitoriza la ejecuci\u00f3n y reporta el estado al Resource Manager y al Application Manager.</li> <li>Al terminar la ejecuci\u00f3n, el Application Manager lo notifica al Resource Manager.</li> </ol> <p>YARN soporta la reserva de recursos mediante el Reservation System, un componente que permite a los usuarios especificar un perfil de recurso y restricciones temporales (deadlines) y posteriormente reservar recursos para asegurar la ejecuci\u00f3n predecibles de las tareas importantes. Este sistema registra los recursos a lo largo del tiempo, realiza control de admisi\u00f3n para las reservas, e informa din\u00e1micamente al planificador para asegurarse que se produce la reserva.</p> <p>Para conseguir una alta escalabilidad (del orden de miles de nodos), YARN ofrece el concepto de Federaci\u00f3n. Esta funcionalidad permite conectar varios cl\u00fasteres YARN y hacerlos visibles como un cl\u00faster \u00fanico. De esta forma puede ejecutar trabajos muy pesados y distribuidos.</p> <p>Hadoop v1</p> <p>MapReduce en hadoop-2.x mantiene la compatibilidad del API con versiones previas (hadoop-1.x). De esta manera, todo los jobs de MapReduce funcionan perfectamente con YARN s\u00f3lo recompilando el c\u00f3digo.</p> <p>En Hadoop v1 los componentes encargados de realizar el procesamiento eran el JobTracker (situado en el namenode) y los TaskTracker (situados en los datanodes).</p>"},{"location":"hadoop/03hadoop.html#instalacion","title":"Instalaci\u00f3n","text":"<p>Para trabajar en esta y las siguientes sesiones, vamos a utilizar la m\u00e1quina virtual que tenemos compartida en Aules. A partir de la OVA de VirtualBox, podr\u00e1s entrar con el usuario iabd y la contrase\u00f1a iabd.</p> <p>Si quieres instalar el software del curso, se recomienda crear una m\u00e1quina virtual con cualquier distribuci\u00f3n Linux. En mi caso, yo lo he probado en la versi\u00f3n Lubuntu 20.04 LTS y la versi\u00f3n 3.3.1 de Hadoop. Puedes seguir las instrucciones del art\u00edculo C\u00f3mo instalar y configurar Hadoop en Ubuntu 20.04 LTS.</p> <p>Para trabajar en local tenemos montada una soluci\u00f3n que se conoce como pseudo-distribuida, porque es al mismo tiempo maestro y esclavo. En el mundo real o si utilizamos una soluci\u00f3n cloud tendremos un nodo maestro y m\u00faltiples nodos esclavos.</p>"},{"location":"hadoop/03hadoop.html#configuracion","title":"Configuraci\u00f3n","text":"<p>Los archivos que vamos a revisar a continuaci\u00f3n se encuentran dentro de la carpeta <code>$HADOOP_HOME/etc/hadoop</code>.</p> <p>El archivo que contiene la configuraci\u00f3n general del cl\u00faster es el archivo <code>core-site.xml</code>. En \u00e9l se configura cual ser\u00e1 el sistema de ficheros, que normalmente ser\u00e1 <code>hdfs</code>, indicando el dominio del nodo que ser\u00e1 el maestro de datos (namenode) de la arquitectura. Por ejemplo, su contenido ser\u00e1 similar al siguiente:</p> core-site.xml<pre><code>&lt;configuration&gt;\n&lt;property&gt;\n&lt;name&gt;fs.defaultFS&lt;/name&gt;\n&lt;value&gt;hdfs://iabd-virtualbox:9000&lt;/value&gt;\n&lt;/property&gt;\n&lt;/configuration&gt;\n</code></pre> <p>El siguiente paso es configurar el archivo <code>hdfs-site.xml</code> donde se indica tanto el factor de replicaci\u00f3n como la ruta donde se almacenan tanto los metadatos (namenode) como los datos en s\u00ed (datanode):</p> hdfs-site.xml<pre><code>&lt;configuration&gt;\n&lt;property&gt;\n&lt;name&gt;dfs.replication&lt;/name&gt;\n&lt;value&gt;1&lt;/value&gt;\n&lt;/property&gt;\n&lt;property&gt;\n&lt;name&gt;dfs.namenode.name.dir&lt;/name&gt;\n&lt;value&gt;/opt/hadoop-data/hdfs/namenode&lt;/value&gt;\n&lt;/property&gt;\n&lt;property&gt;\n&lt;name&gt;dfs.datanode.data.dir&lt;/name&gt;\n&lt;value&gt;/opt/hadoop-data/hdfs/datanode&lt;/value&gt;\n&lt;/property&gt;\n&lt;/configuration&gt;\n</code></pre> <p>Recuerda</p> <p>Si tuvi\u00e9semos un cl\u00faster, en el nodo maestro s\u00f3lo configurar\u00edamos la ruta del namenode y en cada uno de los nodos esclavos, \u00fanicamente la ruta del datanode.</p> <p>Para configurar YARN, primero editaremos el archivo <code>yarn-site.xml</code> para indicar quien va a ser el nodo maestro, as\u00ed como el manejador y la gesti\u00f3n para hacer el MapReduce:</p> yarn-site.xml<pre><code>&lt;configuration&gt;\n&lt;property&gt;\n&lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt;\n&lt;value&gt;iabd-virtualbox&lt;/value&gt;\n&lt;/property&gt;\n&lt;property&gt;\n&lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;\n&lt;value&gt;mapreduce_shuffle&lt;/value&gt;\n&lt;/property&gt;\n&lt;property&gt;\n&lt;name&gt;yarn.nodemanager.aux-services.mapreduce_shuffle.class&lt;/name&gt;\n&lt;value&gt;org.apache.hadoop.mapred.ShuffleHandler&lt;/value&gt;\n&lt;/property&gt;\n&lt;/configuration&gt;\n</code></pre> <p>Y finalmente el archivo <code>mapred-site.xml</code> para indicar que utilice YARN como framework MapReduce:</p> <pre><code>&lt;configuration&gt;\n&lt;property&gt;\n&lt;name&gt;mapreduce.framework.name&lt;/name&gt;\n&lt;value&gt;yarn&lt;/value&gt;\n&lt;/property&gt;\n&lt;/configuration&gt;\n</code></pre> <p>Hadoop en Docker</p> <p>Si no quieres (o puedes) ejecutar la m\u00e1quina virtual, bien puedes utilizar un servicio en la nube como AWS EMR (que veremos en la pr\u00f3xima sesi\u00f3n), o lanzar un contenedor Docker. La red contiene m\u00faltiples im\u00e1genes ya creadas, tanto con el core como con los servicios ya configurados. Para esta sesi\u00f3n y la siguiente, con una imagen sencilla como la que podemos crear desde https://www.section.io/engineering-education/set-up-containerize-and-test-a-single-hadoop-cluster-using-docker-and-docker-compose/ es suficiente.</p>"},{"location":"hadoop/03hadoop.html#puesta-en-marcha","title":"Puesta en marcha","text":"Arrancando HDFS <p>Para arrancar Hadoop/HDFS, hemos de ejecutar el comando <code>start-dfs.sh</code>. Al finalizar, veremos que ha arrancado el namenode, los datanodes, y el secondary namenode.</p> <p>Si en cualquier momento queremos comprobar el estado de los servicios y procesos en ejecuci\u00f3n, tenemos el comando <code>jps</code>.</p> <p>Si accedemos a <code>http://iabd-virtualbox:9870/</code> podremos visualizar su interfaz web.</p> Interfaz Web de Hadoop Arrancando YARN <p>Para arrancar YARN utilizaremos el comando <code>start-yarn.sh</code> para lanzar el Resource Manager y el Node Manager:</p> <p>Y a su vez, YARN tambi\u00e9n ofrece un interfaz web para obtener informaci\u00f3n relativa a los jobs ejecutados. Nos conectaremos con el nombre del nodo principal y el puerto <code>8088</code>. En nuestro caso lo hemos realizado a <code>http://iabd-virtualbox:8088</code> obteniendo la siguiente p\u00e1gina:</p> Interfaz Web de YARN"},{"location":"hadoop/03hadoop.html#hola-mundo","title":"Hola Mundo","text":"<p>El primer ejemplo que se realiza como Hola Mundo en Hadoop suele ser una aplicaci\u00f3n que cuente las ocurrencias de cada palabra que aparece en un documento de texto.</p> <p>En nuestro caso, vamos a contar las palabras del libro de El Quijote, el cual podemos descargar desde https://gist.github.com/jsdario/6d6c69398cb0c73111e49f1218960f79.</p> <p>Una vez arrancado Hadoop y YARN, vamos a colocar el libro dentro de HDFS (estos comandos los estudiaremos en profundidad en la siguiente sesi\u00f3n):</p> <pre><code>hdfs dfs -put el_quijote.txt /user/iabd/\n</code></pre> <p>Hadoop tiene una serie de ejemplos ya implementados para demostrar el uso de MapReduce en la carpeta <code>$HADOOP_HOME/share/hadoop/mapreduce</code>. As\u00ed pues, podemos ejecutar el programa <code>wordcount</code> de la siguiente manera:</p> Comando HadoopComando Yarn <pre><code>hadoop jar $HADOOP_HOME/share/hadoop/mapreduce/hadoop-mapreduce-examples-3.3.1.jar \\\nwordcount /user/iabd/el_quijote.txt /user/iabd/salidaWC\n</code></pre> <pre><code>yarn jar $HADOOP_HOME/share/hadoop/mapreduce/hadoop-mapreduce-examples-3.3.1.jar \\\nwordcount /user/iabd/el_quijote.txt /user/iabd/salidaWC\n</code></pre> <p>Si nos fijamos en la salida del comando podremos ver una traza del proceso MapReduce:</p> <pre><code>2022-11-28 09:24:02,763 INFO client.DefaultNoHARMFailoverProxyProvider: Connecting to ResourceManager at iabd-virtualbox/127.0.1.1:8032\n2022-11-28 09:24:03,580 INFO mapreduce.JobResourceUploader: Disabling Erasure Coding for path: /tmp/hadoop-yarn/staging/iabd/.staging/job_1669623168732_0001\n2022-11-28 09:24:04,473 INFO input.FileInputFormat: Total input files to process : 1\n2022-11-28 09:24:04,623 INFO mapreduce.JobSubmitter: number of splits:1\n2022-11-28 09:24:05,313 INFO mapreduce.JobSubmitter: Submitting tokens for job: job_1669623168732_0001\n2022-11-28 09:24:05,313 INFO mapreduce.JobSubmitter: Executing with tokens: []\n2022-11-28 09:24:05,820 INFO conf.Configuration: resource-types.xml not found\n2022-11-28 09:24:05,821 INFO resource.ResourceUtils: Unable to find 'resource-types.xml'.\n2022-11-28 09:24:06,483 INFO impl.YarnClientImpl: Submitted application application_1669623168732_0001\n2022-11-28 09:24:06,644 INFO mapreduce.Job: The url to track the job: http://iabd-virtualbox:8088/proxy/application_1669623168732_0001/\n2022-11-28 09:24:06,645 INFO mapreduce.Job: Running job: job_1669623168732_0001\n2022-11-28 09:24:20,124 INFO mapreduce.Job: Job job_1669623168732_0001 running in uber mode : false\n2022-11-28 09:24:20,126 INFO mapreduce.Job:  map 0% reduce 0%\n2022-11-28 09:24:28,406 INFO mapreduce.Job:  map 100% reduce 0%\n2022-11-28 09:24:35,623 INFO mapreduce.Job:  map 100% reduce 100%\n2022-11-28 09:24:36,687 INFO mapreduce.Job: Job job_1669623168732_0001 completed successfully\n</code></pre> <p>Podemos observar como se crea un job que se env\u00eda a YARN, el cual ejecuta el proceso MapReduce, el cual tarda alrededor de 40 segundos. A continuaci\u00f3n aparecen estad\u00edsticas del proceso:</p> <pre><code>2022-11-28 09:24:36,824 INFO mapreduce.Job: Counters: 54\nFile System Counters\n                FILE: Number of bytes read=347063\nFILE: Number of bytes written=1241507\nFILE: Number of read operations=0\nFILE: Number of large read operations=0\nFILE: Number of write operations=0\nHDFS: Number of bytes read=1060376\nHDFS: Number of bytes written=257233\nHDFS: Number of read operations=8\nHDFS: Number of large read operations=0\nHDFS: Number of write operations=2\nHDFS: Number of bytes read erasure-coded=0\nJob Counters Launched map tasks=1\nLaunched reduce tasks=1\nData-local map tasks=1\nTotal time spent by all maps in occupied slots (ms)=6848\nTotal time spent by all reduces in occupied slots (ms)=4005\nTotal time spent by all map tasks (ms)=6848\nTotal time spent by all reduce tasks (ms)=4005\nTotal vcore-milliseconds taken by all map tasks=6848\nTotal vcore-milliseconds taken by all reduce tasks=4005\nTotal megabyte-milliseconds taken by all map tasks=7012352\nTotal megabyte-milliseconds taken by all reduce tasks=4101120\nMap-Reduce Framework\n                Map input records=2186\nMap output records=187018\nMap output bytes=1808330\nMap output materialized bytes=347063\nInput split bytes=117\nCombine input records=187018\nCombine output records=22938\nReduce input groups=22938\nReduce shuffle bytes=347063\nReduce input records=22938\nReduce output records=22938\nSpilled Records=45876\nShuffled Maps =1\nFailed Shuffles=0\nMerged Map outputs=1\nGC time elapsed (ms)=1173\nCPU time spent (ms)=4890\nPhysical memory (bytes) snapshot=751063040\nVirtual memory (bytes) snapshot=5099941888\nTotal committed heap usage (bytes)=675282944\nPeak Map Physical memory (bytes)=520818688\nPeak Map Virtual memory (bytes)=2548346880\nPeak Reduce Physical memory (bytes)=230244352\nPeak Reduce Virtual memory (bytes)=2551595008\nShuffle Errors\n                BAD_ID=0\nCONNECTION=0\nIO_ERROR=0\nWRONG_LENGTH=0\nWRONG_MAP=0\nWRONG_REDUCE=0\nFile Input Format Counters Bytes Read=1060259\nFile Output Format Counters Bytes Written=257233\n</code></pre> <p>Para poder obtener toda la informaci\u00f3n de un job necesitamos arrancar el Job History Server:</p> <pre><code>mapred --daemon start historyserver\n</code></pre> <p>De manera que si accedemos a la URL que se visualiza en el log, podremos ver de forma gr\u00e1fica la informaci\u00f3n obtenida:</p> Resultado del History Server <p>Si accedemos al interfaz gr\u00e1fico de HDFS (http://iabd-virtualbox:9870/explorer.html#/user/iabd/salidaWC), podremos ver c\u00f3mo se ha creado la carpeta <code>salidaWC</code> y dentro contiene dos archivos:</p> <ul> <li><code>_SUCCESS</code>: indica que el job de MapReduce se ha ejecutado correctamente</li> <li><code>part-r-00000</code>: bloque de datos con el resultado</li> </ul> Contenido HDFS de salidaWC <p>Autoevaluaci\u00f3n</p> <p>\u00bfQu\u00e9 comando HDFS utilizar\u00edas para obtener el contenido de la carpeta <code>/user/iabd/salidaWC</code>? 1 \u00bfY para obtener el contenido del archivo generado? 2</p>"},{"location":"hadoop/03hadoop.html#mapreduce-en-python","title":"MapReduce en Python","text":"<p>El API de MapReduce est\u00e1 escrito en Java, pero mediante Hadoop Streaming podemos utilizar MapReduce con cualquier lenguaje compatible con el sistema de tuber\u00edas Unix (<code>|</code>).</p> <p>Para entender c\u00f3mo funciona, vamos a reproducir el ejemplo anterior mediante Python.</p>"},{"location":"hadoop/03hadoop.html#mapper","title":"Mapper","text":"<p>Primero creamos el mapeador, el cual se encarga de parsear l\u00ednea a l\u00ednea el fragmento de documento que reciba, y va a generar una nueva salida con todas las palabras de manera que cada nueva l\u00ednea la compongan una tupla formada por la palabra, un tabulador y el n\u00famero 1 (hay una ocurrencia de dicha palabra)</p> mapper.py<pre><code>#!/usr/bin/python3\nimport sys \nfor linea in sys.stdin: \n# eliminamos los espacios de delante y de detr\u00e1s\nlinea = linea.strip() \n# dividimos la l\u00ednea en palabras\npalabras = linea.split() \n# creamos tuplas de (palabra, 1)\nfor palabra in palabras: \nprint(palabra, \"\\t1\")\n</code></pre> <p>Si queremos probar el mapper, podr\u00edamos ejecutar el siguiente comando:</p> <pre><code>cat el_quijote.txt | python3 mapper.py\n</code></pre> <p>Obteniendo un resultado similar a:</p> <pre><code>...\ngritos  1\nal      1\ncielo   1\nalli\u0301    1\nse      1\nrenovaron       1\nlas     1\nmaldiciones     1\n...\n</code></pre>"},{"location":"hadoop/03hadoop.html#reducer","title":"Reducer","text":"<p>A continuaci\u00f3n, en el reducer vamos a recibir la salida del mapper y parsearemos la cadena para separar la palabra del contador.</p> <p>Para llevar la cuenta de las palabras, vamos a meterlas dentro de un diccionario para incrementar las ocurrencias encontradas.</p> <p>Cuidado con la memoria</p> <p>En un caso real, hemos de evitar almacenar todos los datos que recibimos en memoria, ya que es posible que al trabajar con big data no quepa en la RAM de cada datanode. Para ello, se recomienda el uso de la librer\u00eda itertools, por ejemplo, utilizando la funci\u00f3n <code>groupby()</code>.</p> <p>Finalmente, volvemos a crear tuplas de palabra, tabulador y cantidad de ocurrencias.</p> reducer.py<pre><code>#!/usr/bin/python3 \nimport sys\n# inicializamos el diccionario\ndictPalabras = {}\nfor linea in sys.stdin:\n# quitamos espacios de sobra\nlinea = linea.strip()\n# parseamos la entrada de mapper.py\npalabra, cuenta = linea.split('\\t', 1)\n# convertimos cuenta de string a int\ntry:\ncuenta = int(cuenta)\nexcept ValueError:\n# cuenta no era un numero, descartamos la linea\ncontinue\ntry:\ndictPalabras[palabra] += cuenta\nexcept:\ndictPalabras[palabra] = cuenta\nfor palabra in dictPalabras.keys():\nprint(palabra, \"\\t\", dictPalabras[palabra])\n</code></pre> <p>Para probar el  proceso completo, ejecutaremos el siguiente comando:</p> <pre><code>cat el_quijote.txt | python3 mapper.py | python3 reducer.py &gt; salida.tsv\n</code></pre> <p>Si abrimos el fichero, podemos ver el resultado:</p> salida.tsv<pre><code>don         1072\nquijote     812\nde          9035\nla          5014\nmancha      50\nmiguel      3\ncervantes   3\n...\n</code></pre>"},{"location":"hadoop/03hadoop.html#hadoop-streaming","title":"Hadoop Streaming","text":"<p>Una vez comprobados que los algoritmos de mapeo y reducci\u00f3n funcionan, vamos a procesarlos dentro de Hadoop para aprovechar la computaci\u00f3n distribuida.</p> <p>Para ello, haremos uso de Hadoop Streaming, el cual permite ejecutar jobs Map/Reduce con cualquier script (y por ende, codificados en cualquier lenguaje de programaci\u00f3n) que pueda leer de la entrada est\u00e1ndar (stdin) y escribir a la salida est\u00e1ndar (stdout). De este manera, Hadoop Streaming env\u00eda los datos en crudo al mapper v\u00eda stdin y tras procesarlos, se los pasa al reducer v\u00eda stdout.</p> <p>La sintaxis para ejecutar los jobs es:</p> <pre><code>mapred streaming \\\n    -input miCarpetaEntradaHDFS \\\n    -output miCarpetaSalidaHDFS \\\n    -mapper scriptMapper \\\n    -reducer scriptReducer\n</code></pre> <p>Versiones 1.x</p> <p>En versiones m\u00e1s antiguas de Hadoop, en vez de utilizar el comando <code>mapred</code>, se utiliza el comando <code>hadoop jar rutaDeHadoopStreaming.jar &lt;par\u00e1metros&gt;</code>, siendo normalmente la ruta del jar <code>$HADOOP_HOME/share/hadoop/tools/lib</code>.</p> <p>As\u00ed pues, en nuestro caso ejecutar\u00edamos el siguiente comando si tuvi\u00e9semos los archivos (tanto los datos como los scripts) dentro de HDFS:</p> <pre><code>mapred streaming \\\n-input el_quijote.txt \\\n-output salidaPy \\\n-mapper mapper.py \\\n-reducer reducer.py\n</code></pre> <p>Permisos de ejecuci\u00f3n</p> <p>Recuerda darle permisos de ejecuci\u00f3n a ambos scripts (<code>chmod u+x mapper.py</code> y <code>chmod u+x reducer.py</code>) para que Hadoop Streaming los pueda ejecutar</p> <p>Como queremos usar los archivos que tenemos en local, debemos indicar cada uno de los elementos mediante el par\u00e1metro <code>-file</code>:</p> <pre><code>mapred streaming \\\n-input el_quijote.txt \\\n-output salidaPy \\\n-mapper mapper.py -file mapper.py \\\n-reducer reducer.py -file reducer.py </code></pre> <p>Una vez finalizado el job, podemos comprobar c\u00f3mo se han generado el resultado en HDFS mediante:</p> <pre><code>hdfs dfs -head /user/iabd/salidaPy/part-00000\n</code></pre>"},{"location":"hadoop/03hadoop.html#referencias","title":"Referencias","text":"<ul> <li>Documentaci\u00f3n de Apache Hadoop.</li> <li>Hadoop: The definitive Guide, 4th Ed - de Tom White - O'Reilly</li> <li>Art\u00edculo de Hadoop por dentro.</li> <li>Tutorial de Hadoop de Tutorialspoint.</li> </ul>"},{"location":"hadoop/03hadoop.html#actividades","title":"Actividades","text":"<p>Para los siguientes ejercicios, copia el comando y/o haz una captura de pantalla donde se muestre el resultado de cada acci\u00f3n.</p> <ol> <li> <p>(RA5075.2 / CE5.2b / 1p) Sobre Hadoop, ejecuta el siguiente comando y explica qu\u00e9 sucede:</p> <pre><code>yarn jar $HADOOP_HOME/share/hadoop/mapreduce/hadoop-mapreduce-examples-3.3.1.jar pi 16 32\n</code></pre> </li> <li> <p>(RA5075.2 / CE5.2b / 2p) Vuelve a contar las palabras que tiene El Quijote, pero haciendo usos de los scripts Python, teniendo en cuenta que el proceso de mapeo va a limpiar las palabras de signos ortogr\u00e1ficos (quitar puntos, comas, par\u00e9ntesis) y en el reducer vamos a considerar que las palabras en may\u00fasculas y min\u00fasculas son la misma palabra.</p> <ul> <li>Tip: para la limpieza, puedes utilizar el m\u00e9todo de <code>string</code> <code>translate</code> de manera que elimine las <code>string.punctuation</code>.</li> </ul> </li> <li> <p>(RA5075.4 / CE5.4a / 1p) Entra en Hadoop UI y en YARN, y visualiza los procesos que se han ejecutado en las actividades 1 y 2.</p> </li> </ol> <ol> <li> <p><code>hdfs dfs -ls /user/iabd/salidaWC</code> \u21a9</p> </li> <li> <p><code>hdfs dfs -cat /user/iabd/salidaWC/part-r-00000</code> \u21a9</p> </li> </ol>"},{"location":"hadoop/04formatos.html","title":"Formatos de datos en Big Data","text":"<p>En la primera unidad de trabajo ya vimos una peque\u00f1a introducci\u00f3n a los diferentes formatos de datos.</p> <p>Las propiedades que ha de tener un formato de datos son:</p> <ul> <li>independiente del lenguaje</li> <li>expresivo, con soporte para estructuras complejas y anidadas</li> <li>eficiente, r\u00e1pido y reducido</li> <li>din\u00e1mico, de manera que los programas puedan procesar y definir nuevos tipos de datos.</li> <li>formato de fichero standalone y que permita dividirlo y comprimirlo.</li> </ul> <p>Para que Hadoop/Spark o cualquier herramienta de anal\u00edtica de datos pueda procesar documentos, es imprescindible que el formato del fichero permita su divisi\u00f3n en fragmentos (splittable in chunks).</p> <p>Si los clasificamos respecto al formato de almacenamiento tenemos:</p> <ul> <li>texto (m\u00e1s lentos, ocupan m\u00e1s pero son m\u00e1s expresivos y permiten su interoperabilidad): CSV, XML, JSON, etc...</li> <li>binarios (mejor rendimiento, ocupan menos, menos expresivos): Avro, Parquet, ORC, etc...</li> </ul> <p>Si comparamos los formatos m\u00e1s empleados a partir de las propiedades descritas tenemos:</p> Caracter\u00edstica CSV XML / JSON SequenceFile Avro Independencia del lenguaje Expresivo Eficiente Din\u00e1mico Standalone Divisible <p>Las ventajas de elegir el formato correcto son:</p> <ul> <li>Mayor rendimiento en la lectura y/o escritura</li> <li>Ficheros troceables (splittables)</li> <li>Soporte para esquemas que evolucionan</li> <li>Soporte para compresi\u00f3n de los datos (por ejemplo, mediante Snappy).</li> </ul>"},{"location":"hadoop/04formatos.html#filas-vs-columnas","title":"Filas vs Columnas","text":"<p>Los formatos con los que estamos m\u00e1s familiarizados, como son CSV o JSON, se basan en filas, donde cada registro se almacena en una fila o documento. Estos formatos son m\u00e1s lentos en ciertas consultas y su almacenamiento no es \u00f3ptimo.</p> <p>En un formato basado en columnas, cada fila almacena toda la informaci\u00f3n de una columna. Al basarse en columnas, ofrece mejor rendimiento para consultas de determinadas columnas y/o agregaciones, y el almacenamiento es m\u00e1s \u00f3ptimo (como todos los datos de una columna son del mismo tipo, la compresi\u00f3n es mayor).</p> <p>Supongamos que tenemos los siguientes datos:</p> Ejemplo de tabla <p>Dependiendo del almacenamiento en filas o columnas tendr\u00edamos la siguiente representaci\u00f3n:</p> Comparaci\u00f3n filas y columnas <p>En un formato columnar los datos del mismo tipo se agrupan, lo que mejora el rendimiento de acceso y reduce el tama\u00f1o:</p> Comparaci\u00f3n filas y columnas <p>El art\u00edculo Apache Parquet: How to be a hero with the open-source columnar data format compara un formato basado en filas, como CSV, con uno basado en columnas como Parquet, en base al tiempo y el coste de su lectura en AWS (por ejemplo, AWS Athena cobra 5$ por cada TB escaneado):</p> Comparaci\u00f3n CSV y Parquet <p>En la tabla podemos observar como 1TB de un fichero CSV en texto plano pasa a ocupar s\u00f3lo 130GB mediante Parquet, lo que provoca que las posteriores consultas tarden menos y, en consecuencia, cuesten menos.</p> <p>En la siguiente tabla comparamos un fichero CSV compuesto de cuatro columnas almacenado en S3 mediante tres formatos:</p> Comparaci\u00f3n filas y columnas <p>Queda claro que la elecci\u00f3n del formato de los datos y la posibilidad de elegir el formato dependiendo de sus futuros casos de uso puede conllevar un importante ahorro en tiempo y costes.</p>"},{"location":"hadoop/04formatos.html#avro","title":"Avro","text":"Logo de Apache Avro <p>Apache Avro es un formato de almacenamiento basado en filas para Hadoop, utilizado para la serializaci\u00f3n de datos, ya que es m\u00e1s r\u00e1pido y ocupa menos espacio que JSON, debido a que la serializaci\u00f3n de los datos se realiza en un formato binario compacto.</p> <p>Tiene soporte para la compresi\u00f3n de bloques y es un formato que permite la divisi\u00f3n de los datos (splittable).</p>"},{"location":"hadoop/04formatos.html#formato","title":"Formato","text":"<p>El formato Avro se basa en el uso de esquemas, los cuales definen los tipos de datos y protocolos mediante JSON. Cuando los datos <code>.avro</code> son le\u00eddos siempre est\u00e1 presente el esquema con el que han sido escritos.</p> Formato de un archivo Avro <p>Cada fichero Avro almacena el esquema en la cabecera del fichero y luego est\u00e1n los datos en formato binario.</p> <p>Los esquemas se componen de tipos primitivos (<code>null</code>, <code>boolean</code>, <code>int</code>, <code>long</code>, <code>float</code>, <code>double</code>, <code>bytes</code>, y <code>string</code>) y compuestos (<code>record</code>, <code>enum</code>, <code>array</code>, <code>map</code>, <code>union</code>, y <code>fixed</code>).</p> <p>Un ejemplo de esquema podr\u00eda ser:</p> empleado.avsc<pre><code>{\n\"type\" : \"record\",\n\"namespace\" : \"SeveroOchoa\",\n\"name\" : \"Empleado\",\n\"fields\" : [\n{ \"name\" : \"Nombre\" , \"type\" : \"string\" },\n{ \"name\" : \"Altura\" , \"type\" : \"float\" }\n{ \"name\" : \"Edad\" , \"type\" : \"int\" }\n]\n}\n</code></pre>"},{"location":"hadoop/04formatos.html#avro-y-python","title":"Avro y Python","text":"<p>Para poder serializar y deserializar documentos Avro mediante Python, previamente debemos instalar la librer\u00eda <code>avro</code>:</p> <pre><code>pip install avro-python3\n# o si utilizamos Anaconda\nconda install -c conda-forge avro-python3\n</code></pre> <p>Vamos a realizar un ejemplo donde primero leemos un esquema de un archivo Avro, y con dicho esquema, escribiremos nuevos datos en un fichero. A continuaci\u00f3n, abrimos el fichero escrito y leemos y mostramos los datos:</p> C\u00f3digo PythonResultadoGoogle Colab <pre><code>import avro\nimport copy\nimport json\nfrom avro.datafile import DataFileReader, DataFileWriter\nfrom avro.io import DatumReader, DatumWriter\n# abrimos el fichero en modo binario y leemos el esquema\nschema = avro.schema.parse(open(\"empleado.avsc\", \"rb\").read())\n# escribimos un fichero a partir del esquema le\u00eddo\nwith open('empleados.avro', 'wb') as f:\nwriter = DataFileWriter(f, DatumWriter(), schema)\nwriter.append({\"nombre\": \"Carlos\", \"altura\": 180, \"edad\": 44})\nwriter.append({\"nombre\": \"Juan\", \"altura\": 175})\nwriter.close()\n# abrimos el archivo creado, lo leemos y mostramos l\u00ednea a l\u00ednea\nwith open(\"empleados.avro\", \"rb\") as f:\nreader = DataFileReader(f, DatumReader())\n# copiamos los metadatos del fichero le\u00eddo\nmetadata = copy.deepcopy(reader.meta)\n# obtenemos el schema del fichero le\u00eddo\nschemaFromFile = json.loads(metadata['avro.schema'])\n# recuperamos los empleados\nempleados = [empleado for empleado in reader]\nreader.close()\nprint(f'Schema de empleado.avsc:\\n {schema}')\nprint(f'Schema del fichero empleados.avro:\\n {schemaFromFile}')\nprint(f'Empleados:\\n {empleados}')\n</code></pre> <pre><code>Schema de empleado.avsc:\n{\"type\": \"record\", \"name\": \"empleado\", \"namespace\": \"SeveroOchoa\", \"fields\": [{\"type\": \"string\", \"name\": \"nombre\"}, {\"type\": \"int\", \"name\": \"altura\"}, {\"type\": [\"null\", \"int\"], \"name\": \"edad\", \"default\": null}]}\nSchema del fichero empleados.avro:\n{'type': 'record', 'name': 'empleado', 'namespace': 'SeveroOchoa', 'fields': [{'type': 'string', 'name': 'nombre'}, {'type': 'int', 'name': 'altura'}, {'type': ['null', 'int'], 'name': 'edad', 'default': None}]}\nEmpleados:\n[{'nombre': 'Carlos', 'altura': 180, 'edad': 44}, {'nombre': 'Juan', 'altura': 175, 'edad': None}]\n</code></pre> <p>Accede al cuaderno en Google Colab y adjunta el archivo del empleado.avsc.</p>"},{"location":"hadoop/04formatos.html#fastavro","title":"Fastavro","text":"<p>Para trabajar con Avro y grandes vol\u00famenes de datos, es mejor utilizar la librer\u00eda Fastavro (https://github.com/fastavro/fastavro) la cual ofrece un rendimiento mayor (en vez de estar codificada en Python puro, tiene algunos fragmentos realizados mediante Cython).</p> <p>Primero, hemos de instalar la librer\u00eda:</p> <pre><code>pip install fastavro\n# o si utilizamos Anaconda\nconda install -c conda-forge fastavro\n</code></pre> <p>Como pod\u00e9is observar a continuaci\u00f3n, hemos repetido el ejemplo y el c\u00f3digo es muy similar:</p> C\u00f3digo PythonResultadoGoogle Colab <pre><code>import fastavro\nimport copy\nimport json\nfrom fastavro import reader\n# abrimos el fichero en modo binario y leemos el esquema\nwith open(\"empleado.avsc\", \"rb\") as f:\nschemaJSON = json.load(f)\nschemaDict = fastavro.parse_schema(schemaJSON)\nempleados = [{\"nombre\": \"Carlos\", \"altura\": 180, \"edad\": 44},\n{\"nombre\": \"Juan\", \"altura\": 175}]\n# escribimos un fichero a partir del esquema le\u00eddo\nwith open('empleadosf.avro', 'wb') as f:\nfastavro.writer(f, schemaDict, empleados)\n# abrimos el archivo creado, lo leemos y mostramos l\u00ednea a l\u00ednea\nwith open(\"empleadosf.avro\", \"rb\") as f:\nreader = fastavro.reader(f)\n# copiamos los metadatos del fichero le\u00eddo\nmetadata = copy.deepcopy(reader.metadata)\n# obtenemos el schema del fichero le\u00eddo\nschemaReader = copy.deepcopy(reader.writer_schema)\nschemaFromFile = json.loads(metadata['avro.schema'])\n# recuperamos los empleados\nempleados = [empleado for empleado in reader]\nprint(f'Schema de empleado.avsc:\\n {schemaDict}')\nprint(f'Schema del fichero empleadosf.avro:\\n {schemaFromFile}')\nprint(f'Empleados:\\n {empleados}')\n</code></pre> <pre><code>Schema de empleado.avsc:\n{'type': 'record', 'name': 'SeveroOchoa.empleado', 'fields': [{'name': 'nombre', 'type': 'string'}, {'name': 'altura', 'type': 'int'}, {'default': None, 'name': 'edad', 'type': ['null', 'int']}], '__fastavro_parsed': True, '__named_schemas': {'SeveroOchoa.empleado': {'type': 'record', 'name': 'SeveroOchoa.empleado', 'fields': [{'name': 'nombre', 'type': 'string'}, {'name': 'altura', 'type': 'int'}, {'default': None, 'name': 'edad', 'type': ['null', 'int']}]}}}\nSchema del fichero empleadosf.avro:\n{'type': 'record', 'name': 'SeveroOchoa.empleado', 'fields': [{'name': 'nombre', 'type': 'string'}, {'name': 'altura', 'type': 'int'}, {'default': None, 'name': 'edad', 'type': ['null', 'int']}]}\nEmpleados:\n[{'nombre': 'Carlos', 'altura': 180, 'edad': 44}, {'nombre': 'Juan', 'altura': 175, 'edad': None}]\n</code></pre> <p>Accede al cuaderno en Google Colab y adjunta el archivo del empleado.avsc.</p>"},{"location":"hadoop/04formatos.html#fastavro-y-pandas","title":"Fastavro y Pandas","text":"<p>Finalmente, vamos a realizar un \u00faltimo ejemplo con las dos librer\u00edas m\u00e1s utilizadas.</p> <p>Vamos a leer un fichero CSV de ventas mediante Pandas, y tras limpiar los datos y quedarnos \u00fanicamente con las ventas de Alemania, almacenaremos el resultado del procesamiento en Avro.</p> Acceso LocalGoogle Colab <pre><code>import pandas as pd\nfrom fastavro import writer, parse_schema\n# Leemos el csv mediante pandas\ndf = pd.read_csv('pdi_sales.csv',sep=';')\n# Limpiamos los datos (strip a los c\u00f3digos postales) y nos quedamos con Alemania\ndf['Zip'] = df['Zip'].str.strip()\nfiltro = df.Country==\"Germany\"\ndf = df[filtro]\n# 1. Definimos el esquema\nschema = {\n'name': 'Sales',\n'namespace' : 'SeveroOchoa',\n'type': 'record',\n'fields': [\n{'name': 'ProductID', 'type': 'int'},\n{'name': 'Date', 'type': 'string'},\n{'name': 'Zip', 'type': 'string'},\n{'name': 'Units', 'type': 'int'},\n{'name': 'Revenue', 'type': 'float'},\n{'name': 'Country', 'type': 'string'}\n]\n}\nschemaParseado = parse_schema(schema)\n# 2. Convertimos el Dataframe a una lista de diccionarios\nrecords = df.to_dict('records')\n# 3. Persistimos en un fichero avro\nwith open('sales.avro', 'wb') as f:\nwriter(f, schemaParseado, records)\n</code></pre> <p>Accede al cuaderno en Google Colab y adjunta el archivo de ventas pdi_sales.csv.</p> <p>Acceso HDFS</p> <p>Tambi\u00e9n podemos conectarnos a HDFS para leer y persistir datos en formato Avro:</p> <pre><code>import pandas as pd\nfrom fastavro import parse_schema\nfrom hdfs import InsecureClient\nfrom hdfs.ext.avro import AvroWriter\nfrom hdfs.ext.dataframe import write_dataframe\n# 1. Nos conectamos a HDFS\nHDFS_HOSTNAME = 'iabd-virtualbox'\nHDFSCLI_PORT = 9870\nHDFSCLI_CONNECTION_STRING = f'http://{HDFS_HOSTNAME}:{HDFSCLI_PORT}'\nhdfs_client = InsecureClient(HDFSCLI_CONNECTION_STRING)\n# 2. Leemos el Dataframe\nwith hdfs_client.read('/user/iabd/pdi_sales.csv') as reader:\ndf = pd.read_csv(reader,sep=';')\n# Limpiamos los datos (strip a los c\u00f3digos postales) y nos quedamos con Alemania\ndf['Zip'] = df['Zip'].str.strip()\nfiltro = df.Country==\"Germany\"\ndf = df[filtro]\n# 3. Definimos el esquema\nschema = {\n'name': 'Sales',\n'namespace' : 'SeveroOchoa',\n'type': 'record',\n'fields': [\n{'name': 'ProductID', 'type': 'int'},\n{'name': 'Date', 'type': 'string'},\n{'name': 'Zip', 'type': 'string'},\n{'name': 'Units', 'type': 'int'},\n{'name': 'Revenue', 'type': 'float'},\n{'name': 'Country', 'type': 'string'}\n]\n}\nschemaParseado = parse_schema(schema)\n# 4a. Persistimos en un fichero avro dentro de HDFS mediante la extension AvroWriter de hdfs\nwith AvroWriter(hdfs_client, '/user/iabd/sales.avro', schemaParseado) as writer:\nrecords = df.to_dict('records') # diccionario\nfor record in records:\nwriter.write(record)\n# 4b. O directamente persistimos el Dataframe mediante la extension write_dataframe de hdfs\nwrite_dataframe(hdfs_client, '/user/iabd/sales2.avro', df)  # infiere el esquema\nwrite_dataframe(hdfs_client, '/user/iabd/sales3.avro', df, schema=schemaParseado)\n</code></pre> <p>Para el acceso HDFS hemos utilizados las extensiones Fastavro y Pandas de la librer\u00eda HDFS que veremos en posteriores sesiones.</p>"},{"location":"hadoop/04formatos.html#comprimiendo-los-datos","title":"Comprimiendo los datos","text":"<p>\u00bfY s\u00ed comprimimos los datos para ocupen menos espacio en nuestro cl\u00faster y por tanto, nos cuesten menos dinero?</p> <p>Fastavro soporta dos tipos de compresi\u00f3n: gzip (mediante el algoritmo <code>deflate</code>) y <code>snappy</code>. Snappy es una biblioteca de compresi\u00f3n y descompresi\u00f3n de datos de gran rendimiento que se utiliza con frecuencia en proyectos Big Data, la cual hemos de instalar previamente mediante <code>pip install python-snappy</code>.</p> <p>Para indicar el tipo de compresi\u00f3n, \u00fanicamente hemos de a\u00f1adir un par\u00e1metros extra con el algoritmo de compresi\u00f3n en la funci\u00f3n/constructor de persistencia:</p> Fastavro y gzipAvroWriter y snappywrite_dataframe y snappy <pre><code>writer(f, schemaParseado, records, 'deflate')\n</code></pre> <pre><code>with AvroWriter(hdfs_client, '/user/iabd/sales.avro', schemaParseado, 'snappy') as writer:\n</code></pre> <pre><code>write_dataframe(hdfs_client, '/user/iabd/sales3.avro', df, schema=schemaParseado, codec='snappy')\n</code></pre> <p>Comparando algoritmos de compresi\u00f3n</p> <p>Respecto a la compresi\u00f3n, sobre un fichero de 100GB, podemos considerar media si ronda los 50GB y alta si baja a los 40GB.</p> Algoritmo Velocidad Compresi\u00f3n Gzip Media Media Bzip2 Lenta Alta Snappy Alta Media <p>M\u00e1s que un tema de espacio, necesitamos que los procesos sean eficientes y por eso priman los algoritmos que son m\u00e1s r\u00e1pidos. Si te interesa el tema, es muy interesante el art\u00edculo Data Compression in Hadoop.</p> <p>Por ejemplo, si realizamos el ejemplo de Fast Avro y Pandas con acceso local obtenemos los siguientes tama\u00f1os:</p> <ul> <li>Sin compresi\u00f3n: 6,9 MiB</li> <li>Gzip: 1,9 MiB</li> <li>Snappy: 2,8 MiB</li> </ul>"},{"location":"hadoop/04formatos.html#parquet","title":"Parquet","text":"Logo de Apache Parquet <p>Apache Parquet es un formato de almacenamiento basado en columnas para Hadoop, con soporte para todos los frameworks de procesamiento de datos, as\u00ed como lenguajes de programaci\u00f3n. De la misma forma que Avro, se trata de un formato de datos auto-descriptivo, de manera que embebe el esquema o estructura de los datos con los propios datos en s\u00ed. Parquet es id\u00f3neo para analizar datasets que contienen muchas columnas, es decir, para lecturas de grandes cargas de trabajo.</p> <p>Tiene un ratio de compresi\u00f3n muy alto (mediante Snappy ronda el 75%), y adem\u00e1s, solo se recorren las columnas necesarias en cada lectura, lo que reduce las operaciones de disco de entrada/salida.</p>"},{"location":"hadoop/04formatos.html#formato_1","title":"Formato","text":"Formato de un archivo Parquet <p>Cada fichero Parquet almacena los datos en binario organizados en grupos de filas. Para cada grupo de filas (row group), los valores de los datos se organizan en columnas, lo que facilita la compresi\u00f3n a nivel de columna.</p> <p>La columna de metadatos de un fichero Parquet se almacena al final del fichero, lo que permite que las escrituras sean r\u00e1pidas con una \u00fanica pasada. Los metadatos pueden incluir informaci\u00f3n como los tipos de datos, esquemas de codificaci\u00f3n/compresi\u00f3n, estad\u00edsticas, nombre de los elementos, etc...</p>"},{"location":"hadoop/04formatos.html#parquet-y-python","title":"Parquet y Python","text":"<p>Para interactuar con el formato Parquet mediante Python, la librer\u00eda m\u00e1s utilizada es la que ofrece Apache Arrow, en concreto la librer\u00eda PyArrow.</p> <p>As\u00ed pues, la instalamos mediante pip:</p> <pre><code>pip install pyarrow\n</code></pre> <p>Apache Arrow usa un tipo de estructura denominada tabla para almacenar los datos bidimensional (ser\u00eda muy similar a un Dataframe de Pandas). La documentaci\u00f3n de PyArrow dispone de un libro de recetas con ejemplos con c\u00f3digo para los diferentes casos de uso que se nos puedan plantear.</p> <p>Vamos a simular el mismo ejemplo que hemos realizado previamente mediante Avro, y vamos a crear un fichero en formato JSON con empleados, y tras persistirlo en formato Parquet, lo vamos a recuperar:</p> Empleados en columnasEmpleados en Filas dict-parquet.py<pre><code>import pyarrow.parquet as pq\nimport pyarrow as pa\n# 1.- Definimos el esquema\nschema = pa.schema([ ('nombre', pa.string()),\n('altura', pa.int32()),\n('edad', pa.int32())  ])\n# 2.- Almacenamos los empleados por columnas\nempleados = {\"nombre\": [\"Carlos\", \"Juan\"],\n\"altura\": [180, 44],\n\"edad\": [None, 34]}\n# 3.- Creamos una tabla Arrow y la persistimos mediante Parquet\ntabla = pa.Table.from_pydict(empleados, schema)\npq.write_table(tabla, 'empleados.parquet')\n# 4.- Leemos el fichero generado\ntable2 = pq.read_table('empleados.parquet')\nschemaFromFile = table2.schema\nprint(f'Schema del fichero empleados.parquet:\\n{schemaFromFile}\\n')\nprint(f'Tabla de Empleados:\\n{table2}')\n</code></pre> <p>Para que pyarrow pueda leer los empleados como documentos JSON, a d\u00eda de hoy s\u00f3lo puede hacerlo leyendo documentos individuales almacenados en fichero:</p> <p>Por lo tanto, creamos el fichero <code>empleados.json</code> con la siguiente informaci\u00f3n:</p> empleados.json<pre><code>{ \"nombre\": \"Carlos\", \"altura\": 180, \"edad\": 44 }\n{ \"nombre\": \"Juan\", \"altura\": 175 }\n</code></pre> <p>De manera que podemos leer los datos JSON y persistirlos en Parquet del siguiente modo:</p> json-parquet.py<pre><code>import pyarrow.parquet as pq\nimport pyarrow as pa\nfrom pyarrow import json\n# 1.- Definimos el esquema\nschema = pa.schema([ ('nombre', pa.string()),\n('altura', pa.int32()),\n('edad', pa.int32())  ])\n# 2.- Leemos los empleados\ntabla = json.read_json(\"empleados.json\")\n# 3.- Persistimos la tabla en Parquet\npq.write_table(tabla, 'empleados-json.parquet')\n# 4.- Leemos el fichero generado\ntable2 = pq.read_table('empleados-json.parquet')\nschemaFromFile = table2.schema\nprint(f'Schema del fichero empleados-json.parquet:\\n{schemaFromFile}\\n')\nprint(f'Tabla de Empleados:\\n{table2}')\n</code></pre> <p>En ambos casos obtendr\u00edamos algo similar a:</p> <pre><code>Schema del fichero empleados.parquet:\nnombre: string\naltura: int32\nedad: int32\n\nTabla de Empleados:\npyarrow.Table\nnombre: string\naltura: int32\nedad: int32\n----\nnombre: [[\"Carlos\",\"Juan\"]]\naltura: [[180,44]]\nedad: [[null,34]]\n</code></pre>"},{"location":"hadoop/04formatos.html#parquet-y-pandas","title":"Parquet y Pandas","text":"<p>En el caso del uso de Pandas el c\u00f3digo todav\u00eda se simplifica m\u00e1s.</p> <p>Un fragmento de c\u00f3digo muy sencillo y que nos puede ser muy \u00fatil es c\u00f3mo leer un archivo en formato Parquet y pasarlo a Pandas:</p> <pre><code>import pyarrow.parquet as pq\ntrips = pq.read_table('archivo.parquet')\ntrips = trips.to_pandas()\n</code></pre> <p>Si reproducimos el mismo ejemplo que hemos realizado con Avro tenemos que los Dataframes ofrecen el m\u00e9todo <code>to_parquet</code> para exportar a un fichero Parquet:</p> csv-parquet.py<pre><code>import pandas as pd\ndf = pd.read_csv('pdi_sales.csv',sep=';')\ndf['Zip'] = df['Zip'].str.strip()\nfiltro = df.Country==\"Germany\"\ndf = df[filtro]\n# A partir de un DataFrame, persistimos los datos\ndf.to_parquet('sales.parquet')\n</code></pre> <p>Parquet y HDFS</p> <p>Si quisi\u00e9ramos almacenar el archivo directamente en HDFS, necesitamos indicarle a Pandas la direcci\u00f3n del sistema de archivos que tenemos configurado en <code>core-site.xml</code>:</p> core-site.ml<pre><code>&lt;property&gt;\n&lt;name&gt;fs.defaultFS&lt;/name&gt;\n&lt;value&gt;hdfs://iabd-virtualbox:9000&lt;/value&gt;\n&lt;/property&gt;\n</code></pre> <p>As\u00ed pues, \u00fanicamente necesitamos modificar el nombre del archivo donde serializamos los datos a Parquet:</p> <pre><code>df.to_parquet('hdfs://iabd-virtualbox:9000/sales.parquet')\n</code></pre>"},{"location":"hadoop/04formatos.html#orc","title":"ORC","text":"Formato de un archivo ORC <p>Apache ORC es un formato de datos columnar optimizado para la lectura, escritura y procesamiento de datos en Hive. ORC tiene una tasa de compresi\u00f3n alta (utiliza zlib), y al basarse en Hive, soporta sus tipos de datos simples (datetime, decimal, etc...) y los tipos complejos (como struct, list, map y union), siendo totalmente compatible con HiveQL.</p> <p>Los fichero ORC se componen de tiras de datos (stripes), donde cada tira contiene un \u00edndice, los datos de la fila y un pie (con estad\u00edsticas como la cantidad, m\u00e1ximos y m\u00ednimos y la suma de cada columna convenientemente cacheadas)</p>"},{"location":"hadoop/04formatos.html#orc-y-python","title":"ORC y Python","text":"<p>Para crear archivos ORC y leerlos, volvemos a necesitar la librer\u00eda PyArrow.</p> <p>As\u00ed pues, para la escritura de datos, por ejemplo, desde un Dataframe, har\u00edamos:</p> <pre><code>import pandas as pd\nimport pyarrow as pa\nimport pyarrow.orc as orc\ndf = pd.read_csv('pdi_sales.csv',sep=';')\n# Limpiamos los datos (strip a los c\u00f3digos postales) y nos quedamos con Alemania\ndf['Zip'] = df['Zip'].str.strip()\nfiltro = df.Country==\"Germany\"\ndf = df[filtro]\ntable = pa.Table.from_pandas(df, preserve_index=False)\norc.write_table(table, 'pdi_sales.orc')\n</code></pre> <p>Y si queremos leer, la propia librer\u00eda de Pandas tiene su m\u00e9todo <code>read_orc</code>:</p> <pre><code>df_orc = pd.read_orc('pdi_sales.orc')\n</code></pre> <p>to_orc</p> <p>Desde Pandas 1.5, a partir de un DataFrame, podemos persistir los datos mediante el m\u00e9todo <code>to_orc</code>. El problema lo tienen Google Colab o Kaggle, que todav\u00eda no dan soporta a esa versi\u00f3n.</p>"},{"location":"hadoop/04formatos.html#comparando-formatos","title":"Comparando formatos","text":"<p>Acabamos de ver que cada uno de los formatos tiene sus puntos fuertes.</p> <p>Los formatos basados en filas ofrecen un rendimiento mayor en las escrituras que en las lecturas, ya que a\u00f1adir nuevos registros en m\u00e1s sencillo. Si s\u00f3lo vamos a hacer consultas sobre un subconjunto de las columnas, entonces un formato columnas se comportar\u00e1 mejor, ya que no necesita recuperar los registros enteros (cosa que s\u00ed hacen los formatos basados en filas).</p> <p>Respecto a la compresi\u00f3n, entendiendo que ofrece una ventaja a la hora de almacenar y transmitir la informaci\u00f3n, es \u00fatil cuando trabajamos con un gran volumen de datos. Los formatos basado en columnas ofrecen un mejor rendimiento ya que todos los datos del mismo tipo se almacenan de forma contigua lo que permite una mayor eficiencia en la compresi\u00f3n (adem\u00e1s, cada tipo de columna tiene su propia codificaci\u00f3n).</p> <p>Respecto a la evoluci\u00f3n del esquema, con operaciones como a\u00f1adir o eliminar columnas o cambiar su nombre, la mejor decisi\u00f3n es decantarse por Avro. Adem\u00e1s, al tener el esquema en JSON facilita su gesti\u00f3n y permite que tengan m\u00e1s de un esquema.</p> <p>Si nuestros documentos tienen una estructura compleja compuesta por columnas anidadas y normalmente realizamos consultas sobre un subconjunto de las subcolumnas, la elecci\u00f3n deber\u00eda ser Parquet, por la estructura que utiliza.</p> <p>Finalmente, recordar que ORC est\u00e1 especialmente enfocado a su uso con Hive, mientras que Spark tiene un amplio soporte para Parquet y que si trabajamos con Kafka, Avro es una buena elecci\u00f3n.</p> Comparativa de formatos <p>Si comparamos los tama\u00f1os de los archivos respecto al formato de datos empleado con \u00fanicamente las ventas de Alemania tendr\u00edamos:</p> <ul> <li><code>ger_sales.csv</code>: 9,7 MiB</li> <li><code>ger_sales.avro</code>: 6,9 MiB<ul> <li><code>ger_sales-gzip.avro</code>: 1,9 MiB</li> <li><code>ger_sales-snappy.avro</code>:  2,8 MiB</li> </ul> </li> <li><code>ger_sales.parquet</code>: 2,3 MiB<ul> <li><code>ger_sales-gzip.parquet</code>: 1,6 MiB</li> <li><code>ger_sales-snappy.parquet</code>: 2,3 MiB</li> </ul> </li> <li><code>ger_sales.orc</code>: 6,98 MiB</li> </ul>"},{"location":"hadoop/04formatos.html#referencias","title":"Referencias","text":"<ul> <li>Introduction to Big Data Formats</li> <li>Handling Avro files in Python</li> <li>Big Data File Formats Demystified</li> </ul>"},{"location":"hadoop/04formatos.html#actividades","title":"Actividades","text":"<ol> <li> <p>(RA5075.1 / CE5.1c / 1p) Mediante Python y utilizando Kaggle, crea un notebook a partir de los datos del dataset de retrasos en los vuelos y a partir de uno de los ficheros (el que m\u00e1s te guste) transforma los datos y persiste los siguientes archivos:</p> <ul> <li><code>air&lt;anyo&gt;.parquet</code>: el archivo csv en formato Parquet.</li> <li><code>air&lt;anyo&gt;.orc</code>: el archivo csv en formato ORC.</li> <li><code>air&lt;anyo&gt;_small.avro</code>: la fecha (FL_DATE), el identificador de la aerol\u00ednea (OP_CARRIER) y el retraso de cada vuelo (DEP_DELAY) en formato Avro</li> <li><code>air&lt;anyo&gt;_small.parquet</code>: con los mismos atributos pero en Parquet.</li> </ul> <p>Adjunta una captura del cuaderno, anota los tama\u00f1os de los ficheros creados y el tiempo necesario para su creaci\u00f3n, y finalmente, comparte el notebook con el usuario Aitor Medrano de Kaggle.</p> </li> </ol>"},{"location":"hadoop/04hdfs.html","title":"HDFS","text":""},{"location":"hadoop/04hdfs.html#namenodes-y-datanodes","title":"Namenodes y Datanodes","text":"<p>En la sesi\u00f3n anterior ya vimos una peque\u00f1a introducci\u00f3n a la arquitectura de HDFS.</p> Arquitectura HDFS <p>Vamos a profundizar en sus elementos.</p>"},{"location":"hadoop/04hdfs.html#namenode","title":"Namenode","text":"<p>Tal como hemos comentado, existen dos tipos de nodos. El principal se conoce como Namenode:</p> <ul> <li>Solo existe uno, y hace de servidor principal.</li> <li>Nodo al que se tienen que conectar los clientes para realizar las lecturas / escrituras.</li> <li>Mantiene el \u00e1rbol del sistema de archivos (espacio de nombre) y los metadatos para todos los ficheros y directorios en el \u00e1rbol, de manera que sabe en qu\u00e9 nodo del cl\u00faster est\u00e1 cada bloque de informaci\u00f3n (mapa de bloques)</li> <li>Los metadatos se almacenan tanto en memoria (para acelerar su uso) como en disco a la vez, por lo que es un nodo que requiere de mucha memoria RAM.</li> <li>Los bloques nunca pasan por el NameNode, se transfieren entre DataNodes y/o el cliente. Es decir, el Namenode no es responsable de almacenar o transferir los datos.</li> <li>Si se cae, no hay acceso a HDFS, por lo que es cr\u00edtico el mantenimiento de copias de seguridad.</li> </ul> <p>El segundo tipo es el Secondary Namenode:</p> <ul> <li>Su funci\u00f3n principal es guardar una copia de FsImage y EditLog:<ul> <li>FsImage: instant\u00e1nea de los metadatos del sistema de archivos.</li> <li>EditLog: registro de transacciones que contiene los registros de cada cambio (deltas) que se produce en los metadatos del sistema de archivos.</li> </ul> </li> <li>No se trata de un nodo de respaldo</li> <li>Por lo general se ejecuta en una m\u00e1quina distinta</li> </ul> <p>Adem\u00e1s de distribuir los bloques entre distintos nodos de datos, tambi\u00e9n los replica (con un factor de replicaci\u00f3n igual a tres, los replicar\u00eda en 3 nodos diferentes, 2 en el mismo rack y 1 en otro diferente) para evitar p\u00e9rdidas de informaci\u00f3n si alguno de los nodos falla.</p> <p>Cuando una aplicaci\u00f3n cliente necesita leer o modificar un bloque de datos, el Namenode le indica en qu\u00e9 nodo se localiza esa informaci\u00f3n. Tambi\u00e9n se asegura de que los nodos no est\u00e9n ca\u00eddos y que la informaci\u00f3n est\u00e9 replicada, para asegurar su disponibilidad a\u00fan en estos casos.</p> <p>Para hacernos una idea, independientemente del cloud, Facebook utiliza un cl\u00faster de 1100 m\u00e1quinas, con 8800 nodos y cerca de 12 PB de almacenamiento.</p>"},{"location":"hadoop/04hdfs.html#datanode","title":"Datanode","text":"<ul> <li>De este tipo de nodo habr\u00e1 m\u00e1s de uno en cada cl\u00faster. Por cada Namenode podemos tener miles de Datanodes</li> <li>Almacena y lee bloques de datos.</li> <li>Recuperado por Namenode clientes.</li> <li>Reportan al Namenode la lista de bloques que est\u00e1n almacenando.</li> <li>Pueden ir en distintos discos.</li> <li>Guarda un checksum del bloque.</li> </ul> Relaci\u00f3n entre Namenodes y Datanodes HDFS"},{"location":"hadoop/04hdfs.html#procesos-de-lectura","title":"Procesos de lectura","text":"<p>Vamos a revisar como fluyen los datos en un proceso de lectura entre el cliente y HDFS a partir de la siguiente imagen:</p> Proceso de lectura <ol> <li>El cliente abre el fichero que quiere leer mediante el m\u00e9todo <code>open()</code> del sistema de archivos distribuido.</li> <li>\u00c9ste llama al namenode mediante una RPC (llamada a procedimiento remoto) el cual le indica la localizaci\u00f3n del primer bloque del fichero. Para cada bloque, el namenode devuelve la direcci\u00f3n de los datanodes que tienen una copia de ese bloque. Adem\u00e1s, los datanodes se ordenan respecto a su proximidad con el cliente (depende de la topolog\u00eda de la red y despliegue en datacenter/rack/nodo). Si el cliente en s\u00ed es un datanode, la lectura la realizar\u00e1 desde su propio sistema local.</li> <li>El sistema de ficheros distribuido devuelve al cliente un FSDataInputStream (un flujo de entrada que soporta la b\u00fasqueda de ficheros), sobre el cual se invoca la lectura mediante el m\u00e9todo <code>read()</code>. Este flujo, que contiene las direcciones de los datanodes para los primeros bloques del fichero, conecta con el datanode m\u00e1s cercano para la lectura del primer bloque.</li> <li>Los datos se leen desde el datanode con llamadas al m\u00e9todo <code>read()</code>. Cuando se haya le\u00eddo el bloque completo, el flujo de entrada cerrar\u00e1 la conexi\u00f3n con el datanode actual y buscar\u00e1 el mejor datanode para el siguiente bloque.</li> <li>Se repite el paso anterior (siempre de manera transparente para el cliente, el cual solo est\u00e1 leyendo datos desde un flujo de datos continuo).</li> <li>Cuando el cliente finaliza la lectura, cierra la conexi\u00f3n con el flujo de datos.</li> </ol> <p>Durante la lectura, si el flujo encuentra un error al comunicarse con un datanode (o un error de checksum), intentar\u00e1 el proceso con el siguiente nodo m\u00e1s cercano (adem\u00e1s, recordar\u00e1 los nodos que han fallado para no realizar reintentos en futuros bloques y/o informar\u00e1 de los bloque corruptos al namenode)</p> <p>Namenode sin datos</p> <p>Recordad que los datos nunca pasan por el namenode. El cliente que realiza la conexi\u00f3n con HDFS es el que hace las operaciones de lectura/escritura directamente con los datanodes. Este dise\u00f1o permite que HDFS escale de manera adecuada, ya que el tr\u00e1fico de los clientes se esparce por todos los datanodes de nuestro cl\u00faster.</p>"},{"location":"hadoop/04hdfs.html#proceso-de-escritura","title":"Proceso de escritura","text":"<p>El proceso de escritura en HDFS sigue un planteamiento similar. Vamos a analizar la creaci\u00f3n, escritura y cierre de un archivo con la siguiente imagen:</p> Proceso de escritura <ol> <li>El cliente crea el fichero mediante la llamada al m\u00e9todo <code>create()</code> del DistributedFileSystem.</li> <li>Este realiza una llamada RPC al namenode para crear el fichero en el sistema de ficheros del namenode, sin ning\u00fan bloque asociado a \u00e9l. El namenode realiza varias comprobaciones para asegurar que el fichero no existe previamente y que el usuario tiene los permisos necesarios para su creaci\u00f3n. Tras ello, el namenode determina la forma en que va a dividir los datos en bloques y qu\u00e9 datanodes utilizar\u00e1 para almacenar los bloques.</li> <li>El DistributedFileSystem devuelve un FSDataOutputStream  el cual gestiona la comunicaci\u00f3n con los datanodes y el namenode para que el cliente comience a escribir los datos de cada bloque en el namenode apropiado.</li> <li>Conforme el cliente escribe los datos, el flujo obtiene del namenode una lista de datanodes candidatos para almacenar las r\u00e9plicas. La lista de nodos forman un pipeline, de manera que si el factor de replicaci\u00f3n es 3, habr\u00e1 3 nodos en el pipeline. El flujo env\u00eda los paquete al primer datanode del pipeline, el cual almacena cada paquete y los reenv\u00eda al segundo datanode del pipeline. Y as\u00ed sucesivamente con el resto de nodos del pipeline.</li> <li>Cuando todos los nodos han confirmado la recepci\u00f3n y almacenamiento de los paquetes, env\u00eda un paquete de confirmaci\u00f3n al flujo.</li> <li>Cuando el cliente finaliza con la escritura de los datos, cierra el flujo mediante el m\u00e9todo <code>close()</code> el cual libera los paquetes restantes al pipeline de datanodes y queda a la espera de recibir las confirmaciones. Una vez confirmado, le indica al namenode que la escritura se ha completado, informando de los bloques finales que conforman el fichero (puede que hayan cambiado respecto al paso 2 si ha habido alg\u00fan error de escritura).</li> </ol>"},{"location":"hadoop/04hdfs.html#hdfs-por-dentro","title":"HDFS por dentro","text":"<p>HDFS utiliza de un conjunto de ficheros que gestionan los cambios que se producen en el cl\u00faster.</p> <p>Primero entramos en <code>$HADOOP_HOME/etc/hadoop</code> y averiguamos la carpeta de datos que tenemos configurada en <code>hdfs-site.xml</code> para el namenode:</p> hdfs-site.xml<pre><code>&lt;property&gt;\n&lt;name&gt;dfs.name.dir&lt;/name&gt;\n&lt;value&gt;file:///opt/hadoop-data/hdfs/namenode&lt;/value&gt;\n&lt;/property&gt;\n</code></pre> <p>Desde nuestro sistema de archivos, accedemos a dicha carpeta y vemos que existe una carpeta <code>current</code> que contendr\u00e1 un conjunto de ficheros cuyos prefijos son:</p> <ul> <li><code>edits_000NNN</code>: hist\u00f3rico de cambios que se van produciendo.</li> <li><code>edits_inprogress_NNN</code>: cambios actuales en memoria que no se han persistido.</li> <li><code>fsimagen_000NNN</code>: snapshot en el tiempo del sistema de ficheros.</li> </ul> HDFS por dentro <p>Al arrancar HDFS se carga en memoria el \u00faltimo fichero <code>fsimage</code> disponible junto con los <code>edits</code> que no han sido procesados. Mediante el secondary namenode, cuando se llena un bloque, se ir\u00e1n sincronizando los cambios que se producen en <code>edits_inprogress</code> creando un nuevo <code>fsimage</code> y un nuevo <code>edits</code>.</p> <p>As\u00ed pues, cada vez que se reinicie el namenode, se realizar\u00e1 el merge de los archivos <code>fsimage</code> y <code>edits log</code>.</p>"},{"location":"hadoop/04hdfs.html#trabajando-con-hdfs","title":"Trabajando con HDFS","text":"<p>Para interactuar con el almacenamiento desde un terminal, se utiliza el comando <code>hdfs</code>. Este comando admite un segundo par\u00e1metro con diferentes opciones.</p> <p>Antes la duda, es recomendable consultar la documentaci\u00f3n oficial</p> <pre><code>hdfs comando\n</code></pre> <p>hadoop fs</p> <p> HDFS DFS </p> <p><code>hadoop fs</code> se relaciona con un sistema de archivos gen\u00e9rico que puede apuntar a cualquier sistema de archivos como local, HDFS, FTP, S3, etc. En versiones anteriores se utilizaba el comando <code>hadoop dfs</code> para acceder a HDFS, pero ya quedado obsoleto en favor de <code>hdfs dfs</code>.</p> <p>En el caso concreto de interactuar con el sistema de ficheros de Hadoop se utiliza el comando <code>dfs</code>, el cual requiere de otro argumento (empezando con un guion) el cual ser\u00e1 uno de los comandos Linux para interactuar con el shell. Pod\u00e9is consultar la lista de comandos en la documentaci\u00f3n oficial.</p> <pre><code>hdfs dfs -comandosLinux\n</code></pre> <p>Por ejemplo, para mostrar todos los archivos que tenemos en el ra\u00edz har\u00edamos:</p> <pre><code>hdfs dfs -ls\n</code></pre> <p>Los comandos m\u00e1s utilizados son:</p> <ul> <li><code>put</code> (o <code>copyFromLocal</code>): Coloca un archivo dentro de HDFS</li> <li><code>get</code> (o <code>copyToLocal</code>): Recupera un archivo de HDFS y lo lleva a nuestro sistema host.</li> <li><code>cat</code> / <code>text</code> / <code>head</code> / <code>tail</code>: Visualiza el contenido de un archivo.</li> <li><code>mkdir</code> / <code>rmdir</code>: Crea / borra una carpeta.</li> <li><code>count</code>: Cuenta el n\u00famero de elementos (n\u00famero de carpetas, ficheros, tama\u00f1o y ruta).</li> <li><code>cp</code> / <code>mv</code> / <code>rm</code>: Copia / mueve-renombra / elimina un archivo.</li> </ul> <p>Durante la realizaci\u00f3n de los ejercicios, es muy com\u00fan necesitar eliminar una carpeta y todo los archivo que contiene. Para ello, podemos hacer un borrado recursivo:</p> <pre><code>hdfs dfs -rm -r /user/iabd/datos\n</code></pre> <p>Autoevaluaci\u00f3n</p> <p>\u00bfSabes qu\u00e9 realiza cada uno de los siguientes comandos?</p> <pre><code>hdfs dfs -mkdir /user/iabd/datos\nhdfs dfs -put ejemplo.txt /user/iabd/datos/\nhdfs dfs -put ejemplo.txt /user/iabd/datos/ejemploRenombrado.txt\nhdfs dfs -ls datos\nhdfs dfs -count datos\nhdfs dfs -mv datos/ejemploRenombrado.txt /user/iabd/datos/otroNombre.json\nhdfs dfs -get /datos/otroNombre.json /tmp\n</code></pre> <p>CRC</p> <p>Cuando recuperamos un archivo desde HDFS podemos indicarle que genere un fichero con el checksum CRC, y as\u00ed poder comprobar la fiabilidad de los datos transmitidos.</p> <pre><code>hdfs dfs -get -crc /user/iabd/archivo archivoLocal\n</code></pre>"},{"location":"hadoop/04hdfs.html#bloques","title":"Bloques","text":"<p>A continuaci\u00f3n vamos a ver c\u00f3mo trabaja internamente HDFS con los bloques. Para el siguiente ejemplo, vamos a trabajar con un archivo que ocupe m\u00e1s de un bloque, como pueden ser los datos de 25 millones de pel\u00edculas. Una vez descargado y descomprimido, colocaremos el archivo <code>ratings.csv</code> dentro de HDFS.</p> <p>Comenzaremos creando un directorio dentro de HDFS llamado <code>prueba-hdfs</code>:</p> <pre><code>hdfs dfs -mkdir /user/iabd/prueba-hdfs\n</code></pre> <p>Una vez creado subimos el archivo con las calificaciones de las pel\u00edculas:</p> <pre><code>hdfs dfs -put ratings.csv  /user/iabd/prueba-hdfs\n</code></pre> <p>Si queremos saber cuantos bloques ha creado y cuanto ocupa cada uno de ellos, por ejemplo, podemos utilizar la utilidad <code>fsck</code> que permite comprobar la salud del sistema de archivos. Si le pasamos las opciones <code>-files</code> y <code>-blocks</code> nos mostrar\u00e1 informaci\u00f3n tanto de los archivos como de los bloques contenidos:</p> <pre><code>iabd@iabd-virtualbox:$ hdfs fsck /user/iabd/prueba-hdfs -files -blocks\nConnecting to namenode via http://iabd-virtualbox:9870/fsck?ugi=iabd&amp;files=1&amp;blocks=1&amp;path=%2Fuser%2Fiabd%2Fprueba-hdfs\nFSCK started by iabd (auth:SIMPLE) from /127.0.0.1 for path /user/iabd/prueba-hdfs at Sun Jan 22 18:11:45 CET 2023\n/user/iabd/prueba-hdfs &lt;dir&gt;\n/user/iabd/prueba-hdfs/ratings.csv 678260987 bytes, replicated: replication=1, 6 block(s):  OK\n0. BP-481169443-127.0.1.1-1639217848073:blk_1073750565_9750 len=134217728 Live_repl=1\n1. BP-481169443-127.0.1.1-1639217848073:blk_1073750566_9751 len=134217728 Live_repl=1\n2. BP-481169443-127.0.1.1-1639217848073:blk_1073750567_9752 len=134217728 Live_repl=1\n3. BP-481169443-127.0.1.1-1639217848073:blk_1073750568_9753 len=134217728 Live_repl=1\n4. BP-481169443-127.0.1.1-1639217848073:blk_1073750569_9754 len=134217728 Live_repl=1\n5. BP-481169443-127.0.1.1-1639217848073:blk_1073750570_9755 len=7172347 Live_repl=1\nStatus: HEALTHY\n Number of data-nodes:  1\nNumber of racks:               1\nTotal dirs:                    1\nTotal symlinks:                0\n...\n</code></pre> <p>Si queremos utilizar el interfaz gr\u00e1fico de Hadoop (http://iabd-virtualbox:9870/explorer.html#/), tras localizar el archivo, obtenemos el Block Pool ID del block information:</p> Identificador de bloque <p>Si desplegamos el combo de block information, podremos ver c\u00f3mo ha partido el archivo CSV en 6 bloques (650 MB aproximadamente que ocupa el fichero CSV / 128 del tama\u00f1o del bloque).</p> Bloques del archivo <p>As\u00ed pues, con el c\u00f3digo del Block Pool Id, podemos confirmar que debe existir el directorio <code>current</code> del datanode donde almacena la informaci\u00f3n nuestro servidor (en `/opt/hadoop-data/):</p> <pre><code>iabd@iabd-virtualbox:~$ ls /opt/hadoop-data/hdfs/datanode/current\nBP-481169443-127.0.1.1-1639217848073  VERSION\n</code></pre> <p>El valor que aparece coincide con el que hemos recuperado tanto en la imagen como mediante <code>fsck</code>.</p> <p>Dentro de este subdirectorio existe otro <code>finalized</code>, donde Hadoop ir\u00e1 creando una estructura de subdirectorios <code>subdir</code> donde albergar\u00e1 los bloques de datos:</p> <pre><code>iabd@iabd-virtualbox:~$ ls /opt/hadoop-data/hdfs/datanode/current/BP-481169443-127.0.1.1-1639217848073/current/finalized/subdir0\ntotal 172\ndrwxrwxr-x 2 iabd iabd 20480 dic 22  2021 subdir0\ndrwxrwxr-x 2 iabd iabd 20480 dic 22  2021 subdir1\ndrwxrwxr-x 2 iabd iabd 20480 dic 22  2021 subdir2\n...\n</code></pre> <p>Una vez en este nivel, vamos a buscar el archivo que coincide con el block id poni\u00e9ndole como prefijo <code>blk_</code>:</p> <pre><code>iabd@iabd-virtualbox:~$ cd /opt/hadoop-data/hdfs/datanode/current/BP-481169443-127.0.1.1-1639217848073/current/finalized/subdir0\niabd@iabd-virtualbox:/opt/hadoop-data/hdfs/datanode/current/BP-481169443-127.0.1.1-1639217848073/current/finalized/subdir0$ \\\n&gt; find -name blk_1073750565\n</code></pre> <p>En mi caso devuelve <code>./subdir2/blk_1073750565</code>. De manera que ya podemos comprobar como el inicio del documento se encuentra en dicho archivo:</p> <pre><code>iabd@iabd-virtualbox:/opt/hadoop-data/hdfs/datanode/current/BP-481169443-127.0.1.1-1639217848073/current/finalized/subdir0$ \\\n&gt; cd subdir2\niabd@iabd-virtualbox:/opt/hadoop-data/hdfs/datanode/current/BP-481169443-127.0.1.1-1639217848073/current/finalized/subdir0/subdir9$ \\\n&gt; head blk_1073750565\nuserId,movieId,rating,timestamp\n1,296,5.0,1147880044\n1,306,3.5,1147868817\n1,307,5.0,1147868828\n1,665,5.0,1147878820\n1,899,3.5,1147868510\n1,1088,4.0,1147868495\n1,1175,3.5,1147868826\n1,1217,3.5,1147878326\n1,1237,5.0,1147868839\n</code></pre>"},{"location":"hadoop/04hdfs.html#administracion","title":"Administraci\u00f3n","text":"<p>Algunas de las opciones m\u00e1s \u00fatiles para administrar HDFS son:</p> <ul> <li><code>hdfs dfsadmin -report</code>: Realiza un resumen del sistema HDFS, similar al que aparece en el interfaz web, donde podemos comprobar el estado de los diferentes nodos.</li> <li><code>hdfs fsck</code>: como acabamos de ver, comprueba el estado del sistema de ficheros. Si queremos comprobar el estado de un determinado directorio, lo indicamos mediante un segundo par\u00e1metro: <code>hdfs fsck /datos/prueba</code></li> <li><code>hdfs dfsadmin -printTopology</code>: Muestra la topolog\u00eda, identificando los nodos que tenemos y al rack al que pertenece cada nodo.</li> <li><code>hdfs dfsadmin -listOpenFiles</code>: Comprueba si hay alg\u00fan fichero abierto.</li> <li><code>hdfs dfsadmin -safemode enter</code>: Pone el sistema en modo seguro, el cual evita la modificaci\u00f3n de los recursos del sistema de archivos.</li> <li><code>hdfs dfsadmin -safemode leave</code>: Sale del modo seguro.</li> </ul>"},{"location":"hadoop/04hdfs.html#snapshots","title":"Snapshots","text":"<p>Mediante las snapshots podemos crear una instant\u00e1nea que almacena c\u00f3mo est\u00e1 en un determinado momento nuestro sistema de ficheros, a modo de copia de seguridad de los datos, para en un futuro poder realizar una recuperaci\u00f3n.</p> <p>El primer paso es activar el uso de snapshots, mediante el comando de administraci\u00f3n indicando sobre qu\u00e9 carpeta vamos a habilitar su uso:</p> <pre><code>hdfs dfsadmin -allowSnapshot /user/iabd/datos\n</code></pre> <p>El siguiente paso es crear una snapshot, para ello se indica tanto la carpeta como un nombre para la captura (es un comando que se realiza sobre el sistema de archivos):</p> <pre><code>hdfs dfs -createSnapshot /user/iabd/datos snapshot1\n</code></pre> <p>Esta captura se crear\u00e1 dentro de una carpeta oculta dentro de la ruta indicada (en nuestro caso crear\u00e1 la carpeta  <code>/user/iabd/datos/.snapshot/snapshot1/</code> la cual contendr\u00e1 la informaci\u00f3n de la instant\u00e1nea).</p> <p>A continuaci\u00f3n, vamos a borrar uno de los archivo creados anteriormente y comprobar que ya no existe:</p> <pre><code>hdfs dfs -rm /user/iabd/datos/ejemplo.txt\nhdfs dfs -ls /user/iabd/datos\n</code></pre> <p>Para comprobar el funcionamiento de los snapshots, vamos a recuperar el archivo desde la captura creada anteriormente.</p> <pre><code>hdfs dfs -cp \\\n/user/iabd/datos/.snapshot/snapshot1/ejemplo.txt \\\n/user/iabd/datos\n</code></pre> <p>Si queremos saber que carpetas soportan las instant\u00e1neas:</p> <pre><code>hdfs lsSnapshottableDir\n</code></pre> <p>Finalmente, si queremos deshabilitar las snapshots de una determinada carpeta, primero hemos de eliminarlas y luego deshabilitarlas:</p> <pre><code>hdfs dfs -deleteSnapshot /user/iabd/datos snapshot1\nhdfs dfsadmin -disallowSnapshot /user/iabd/datos\n</code></pre>"},{"location":"hadoop/04hdfs.html#hdfs-ui","title":"HDFS UI","text":"<p>En la sesi\u00f3n anterior ya vimos que pod\u00edamos acceder al interfaz gr\u00e1fico de Hadoop (http://iabd-virtualbox:9870/explorer.html#/) y navegar por las carpetas de HDFS.</p> <p>Si intentamos crear una carpeta o eliminar alg\u00fan archivo recibimos un mensaje del tipo Permission denied: user=dr.who, access=WRITE, inode=\"/\":iabd:supergroup:drwxr-xr-x. Por defecto, los recursos via web los crea el usuario dr.who.</p> Error al crear un directorio mediante Hadoop UI <p>Si queremos habilitar los permisos para que desde este IU podamos crear/modificar/eliminar recursos, podemos cambiar permisos a la carpeta:</p> <pre><code>hdfs dfs -mkdir /user/iabd/pruebas\nhdfs dfs -chmod 777 /user/iabd/pruebas </code></pre> <p>Si ahora accedemos al interfaz, s\u00ed que podremos trabajar con la carpeta <code>pruebas</code> via web, teniendo en cuenta que las operaciones las realiza el usuario <code>dr.who</code> que pertenece al grupo <code>supergroup</code>.</p> <p>Otra posibilidad es modificar el archivo de configuraci\u00f3n <code>core-site.xml</code> y a\u00f1adir una propiedad para modificar el usuario est\u00e1tico:</p> core-site.xml<pre><code>&lt;property&gt;\n&lt;name&gt;hadoop.http.staticuser.user&lt;/name&gt;\n&lt;value&gt;iabd&lt;/value&gt;\n&lt;/property&gt;\n</code></pre> <p>Tras reiniciar Hadoop, ya podremos crear los recursos como el usuario <code>iabd</code>.</p>"},{"location":"hadoop/04hdfs.html#hdfs-y-python","title":"HDFS y Python","text":"<p>Para el acceso mediante Python a HDFS podemos utilizar la librer\u00eda HdfsCLI.</p> <p>Primero hemos de instalarla mediante <code>pip</code>:</p> <pre><code>pip install hdfs\n</code></pre> <p>Vamos a ver un sencillo ejemplo de lectura y escritura en HDFS:</p> <pre><code>from hdfs import InsecureClient\n# Datos de conexi\u00f3n\nHDFS_HOSTNAME = 'iabd-virtualbox'\nHDFSCLI_PORT = 9870\nHDFSCLI_CONNECTION_STRING = f'http://{HDFS_HOSTNAME}:{HDFSCLI_PORT}'\n# En nuestro caso, al no usar Kerberos, creamos una conexi\u00f3n no segura\nhdfs_client = InsecureClient(HDFSCLI_CONNECTION_STRING)\n# Leemos el fichero de 'El quijote' que tenemos en HDFS\nfichero = '/user/iabd/el_quijote.txt'\nwith hdfs_client.read(fichero) as reader:\ntexto = reader.read()\nprint(texto)\n# Creamos una cadena con formato CSV y la almacenamos en HDFS\ndatos=\"nombre,apellidos\\nAitor,Medrano\\nPedro,Casas\"\nhdfs_client.write(\"/user/iabd/datos.csv\", datos)\n</code></pre> <p>Otra librer\u00eda que podemos utilizar es Snakebite, la cual fue creada por Spotify para interactuar con HDFS (aunque a d\u00eda de hoy ya no se mantiene), y utiliza protobuf como protocolo de comunicaci\u00f3n, lo cual incrementa su rendimiento.</p> <p>Tras instalarla (es necesario instalar la versi\u00f3n para Python3 y downgradear la librer\u00eda protobuf):</p> <pre><code>pip install snakebite-py3\npip install protobuf==3.20.*\n</code></pre> <p>Ya podemos repetir parte del ejemplo anterior (ya que Snakebite no permite escribir en HDFS):</p> <pre><code>from snakebite.client import Client\nsb_client = Client('iabd-virtualbox', 9000)\n# Mostramos el contenido de /user/iabd\nfor x in sb_client.ls(['/user/iabd']):\nprint(x)\n# Leemos el fichero de 'El quijote' que tenemos en HDFS\nfichero = '/user/iabd/el_quijote.txt'\nfor linea in sb_client.text([fichero]):\nprint(linea)\n</code></pre> <p>En el mundo real, los formatos de los archivos normalmente ser\u00e1n Avro y/o Parquet, y el acceso lo realizaremos en gran medida mediante la librer\u00eda de Pandas.</p> <p>Otras librer\u00edas</p> <p>Python ofrece muchas m\u00e1s librer\u00edas para trabajar con Hadoop y HDFS:</p> <ul> <li>mrjob: permite ejecutar tareas MapReduce y ejecutarlas en diferentes plataformas, ya sea en local, un cluster Hadoop, AWS EMR, etc..</li> <li>Pydoop: tambi\u00e9n permite escribir aplicaciones MapReduce, as\u00ed como ofrece una api para HDFS y trabaja de forma transparente con el formato Avro.</li> </ul>"},{"location":"hadoop/04hdfs.html#hue","title":"Hue","text":"<p>Hue (Hadoop User Experience) es una interfaz gr\u00e1fica de c\u00f3digo abierto basada en web para su uso con Apache Hadoop. Hue act\u00faa como front-end para las aplicaciones que se ejecutan en el cl\u00faster, lo que permite interactuar con las aplicaciones mediante una interfaz m\u00e1s amigable que el interfaz de comandos.</p> <p>En nuestra m\u00e1quina virtual ya lo tenemos instalado y configurado para que funcione con HDFS y Hive.</p> <p>La ruta de instalaci\u00f3n es <code>/opt/hue-4.10.0</code> y desde all\u00ed, arrancaremos Hue:</p> <pre><code>./build/env/bin/hue runserver\n</code></pre> <p>Docker</p> <p>Si queremos ejecutarlo desde Docker, la propia Hue dispone de una imagen oficial, la cual podemos lanzar mediante:</p> <pre><code>docker run -it -p 8888:8888 gethue/hue:latest\n</code></pre> <p>Para su configuraci\u00f3n se recomienda consultar la documentaci\u00f3n oficial de la imagen.</p> <p>Tras arrancarlo, nos dirigimos a <code>http://127.0.0.1:8000/</code>y visualizaremos el formulario de entrada, el cual entraremos con el usuario <code>iabd</code> y la contrase\u00f1a <code>iabd</code>:</p> Login en Hue <p>Una vez dentro, por ejemplo, podemos visualizar e interactuar con HDFS:</p> HDFS en Hue"},{"location":"hadoop/04hdfs.html#referencias","title":"Referencias","text":"<ul> <li>Documentaci\u00f3n de Apache Hadoop.</li> <li>Hadoop: The definitive Guide, 4th Ed - de Tom White - O'Reilly</li> <li>HDFS Commands, HDFS Permissions and HDFS Storage</li> <li>Introduction to Data Serialization in Apache Hadoop</li> <li>Handling Avro files in Python</li> <li>Native Hadoop file system (HDFS) connectivity in Python</li> </ul>"},{"location":"hadoop/04hdfs.html#actividades","title":"Actividades","text":"<p>Para los siguientes ejercicios, copia el comando y/o haz una captura de pantalla donde se muestre el resultado de cada acci\u00f3n.</p> <ol> <li> <p>(RA5075.3 / CE5.3a / 0.5p) Explica paso a paso el proceso de lectura (indicando qu\u00e9 bloques y los datanodes empleados) que realiza HDFS si queremos leer el archivo <code>/logs/101213.log</code>:</p> <p> Proceso de lectura HDFS </p> </li> <li> <p>(RA5075.3 / CE5.3a y CE5.3c / 0.5p) En este ejercicio vamos a practicar los comandos b\u00e1sicos de HDFS. Una vez arrancado Hadoop:</p> <ol> <li>Crea la carpeta <code>/user/iabd/ejercicios</code>.</li> <li>Sube el archivo <code>el_quijote.txt</code> a la carpeta creada.</li> <li>Crea una copia en HDFS y ll\u00e1mala <code>el_quijote2.txt</code>.</li> <li>Recupera el principio del fichero <code>el_quijote2.txt</code>.</li> <li>Renombra <code>el_quijote2.txt</code> a <code>el_quijote_copia.txt</code>.</li> <li>Descarga en local <code>el_quijote_copia.txt</code> con su c\u00f3digo CRC.</li> <li>Adjunta una captura desde el interfaz web donde se vean ambos archivos.</li> <li>Vuelve al terminal y elimina la carpeta con los archivos contenidos mediante un \u00fanico comando.</li> </ol> </li> <li> <p>(RA5075.4 / CE5.4e y CE5.4f / 1p) Vamos a practicar los comandos de gesti\u00f3n de instant\u00e1neas y administraci\u00f3n de HDFS. Para ello:</p> <ol> <li>Crea la carpeta <code>/user/iabd/snaps</code>.</li> <li>Habilita las snapshots sobre la carpeta creada.</li> <li>Sube el archivo <code>el_quijote.txt</code> a la carpeta creada.</li> <li>Crea una copia en HDFS y ll\u00e1mala <code>el_quijote_snapshot.txt</code>.</li> <li>Crea una instant\u00e1nea de la carpeta llamada <code>ss1</code>.</li> <li>Elimina ambos ficheros del quijote.</li> <li>Comprueba que la carpeta est\u00e1 vac\u00eda.</li> <li>Recupera desde <code>ss1</code> el archivo <code>el_quijote.txt</code>.</li> <li>Crea una nueva instant\u00e1nea de la carpeta llamada <code>ss2</code>.</li> <li>Muestra el contenido de la carpeta <code>/user/iabd/snaps</code> as\u00ed como de sus snapshots.</li> </ol> </li> <li> <p>(RA5075.4 / CE5.4e y CE5.4f / 1p) HDFS por dentro</p> <ol> <li>Accede al archivo de configuraci\u00f3n <code>hdfs-site.xml</code> y averigua la carpeta donde se almacena el namenode.</li> <li>Muestra los archivos que contiene la carpeta <code>current</code> dentro del namenode</li> <li>Comprueba el id del archivo <code>VERSION</code>.</li> <li>En los siguientes pasos vamos a realizar un checkpoint manual para sincronizar el sistema de ficheros. Para ello entramos en modo safe con el comando <code>hdfs dfsadmin -safemode enter</code>, de manera que impedamos que se trabaje con el sistema de ficheros mientras lanzamos el checkpoint.</li> <li>Comprueba mediante el interfaz gr\u00e1fico que el modo seguro est\u00e1 activo (Safe mode is ON).</li> <li>Ahora realiza el checkpoint con el comando <code>hdfs dfsadmin -saveNamespace</code></li> <li>Vuelve a entrar al modo normal (saliendo del modo seguro mediante <code>hdfs dfsadmin -safemode leave</code>)</li> <li>Accede a la carpeta del namenode y comprueba que los fsimage del namenode son iguales.</li> </ol> </li> </ol>"},{"location":"hadoop/05flume.html","title":"Sqoop / Flume","text":"<p>Las dos herramientas principales utilizadas para importar/exportar datos en HDFS son Sqoop y Flume, las cuales vamos a estudiar a continuaci\u00f3n.</p>"},{"location":"hadoop/05flume.html#sqoop","title":"Sqoop","text":"Logo de Apache Sqoop <p>Apache Sqoop (https://sqoop.apache.org) es una herramienta dise\u00f1ada para transferir de forma eficiente datos crudos entre un cluster de Hadoop y un almacenamiento estructurado, como una base de datos relacional.</p> <p>Sin continuidad</p> <p>Desde Junio de 2021, el proyecto Sqoop ha dejado de mantenerse como proyecto de Apache y forma parte del \u00e1tico. A\u00fan as\u00ed, creemos conveniente conocer su uso en el estado actual. Gran parte de las funcionalidad que ofrece Sqoop se pueden realizar mediante Nifi o Spark.</p> <p>Un caso t\u00edpico de uso es el de cargar los datos en un data lake  (ya sea en HDFS o en S3) con datos que importaremos desde una base de datos relacional, como MariaDB o PostgreSQL.</p> <p>Sqoop utiliza una arquitectura basada en conectores, con soporte para plugins que ofrecen la conectividad a los sistemas externos, como pueden ser Oracle o SqlServer. Internamente, Sqoop utiliza los algoritmos MapReduce para importar y exportar los datos.</p> <p>Por defecto, todos los trabajos Sqoop ejecutan cuatro mapas de trabajo, de manera que los datos se dividen en cuatro nodos de Hadoop.</p> <p>Instalaci\u00f3n</p> <p>Aunque en la m\u00e1quina virtual con la que trabajamos ya tenemos tanto Hadoop como Sqoop instalados, podemos descargar la \u00faltima versi\u00f3n desde http://archive.apache.org/dist/sqoop/1.4.7/sqoop-1.4.7.bin__hadoop-2.6.0.tar.gz.</p> <p>Se recomienda seguir las instrucciones resumidas que tenemos en https://www.tutorialspoint.com/sqoop/sqoop_installation.htm o las de https://riptutorial.com/sqoop.</p> <p>Un par de aspectos que hemos tenido que modificar en nuestra m\u00e1quina virtual son:</p> <ul> <li>Copiar el driver de MySQL en <code>$SQOOP_HOME/lib</code></li> <li>Copiar la librer\u00eda commons-langs-2.6 en <code>$SQOOP_HOME/lib</code></li> </ul> <p>Una vez configurado, podemos comprobar que funciona, por ejemplo, consultando las bases de datos que tenemos en MariaDB (aparecen mensajes de warning por no tener instalados/configurados algunos productos) mediante <code>sqoop list-databases</code>:</p> <pre><code>sqoop list-databases --connect jdbc:mysql://localhost --username=iabd --password=iabd\n</code></pre>"},{"location":"hadoop/05flume.html#importando-datos","title":"Importando datos","text":"<p>La sintaxis b\u00e1sica de Sqoop para importar datos en HDFS es mediante el comando <code>sqoop import</code>:</p> <pre><code>sqoop import --connect jdbc:mysql://host/nombredb --table &lt;nombreTabla&gt; \\\n--username &lt;usuarioMariaDB&gt; --password &lt;passwordMariaDB&gt; -m 2\n</code></pre> <p>El \u00fanico par\u00e1metro que conviene explicar es <code>-m 2</code>, el cual est\u00e1 indicando que utilice dos mappers en paralelo para importar los datos. Si no le indicamos este par\u00e1metro, como hemos comentado antes, Sqoop siempre utilizar\u00e1 cuatro mappers.</p> <p>La importaci\u00f3n se realiza en dos pasos:</p> <ol> <li>Sqoop escanea la base de datos y colecta los metadatos de la tabla a importar. Con esos datos, env\u00eda un job y transfiere los datos reales utilizando los metadatos necesarios.</li> <li>De forma paralela, cada uno de los mappers se encarga de cargar en HDFS una parte proporcional de los datos.</li> </ol> Arquitectura de trabajo de Sqoop <p>Los datos importados se almacenan en carpetas de HDFS, pudiendo especificar otras carpetas, as\u00ed como los caracteres separadores o de terminaci\u00f3n de registro. Adem\u00e1s, podemos utilizar diferentes formatos, como son Avro, ORC, Parquet, ficheros secuenciales o de tipo texto, para almacenar los datos en HDFS.</p>"},{"location":"hadoop/05flume.html#caso-1-importando-datos-desde-mariadb","title":"Caso 1 - Importando datos desde MariaDB","text":"<p>En el siguiente caso de uso vamos a importar datos que tenemos en una base de datos de MariaDB a HDFS.</p> <p>Sqoop y las zonas horarias</p> <p>Cuando se lanza Sqoop captura los timestamps de nuestra base de datos origen y las convierte a la hora del sistema servidor por lo que tenemos que especificar en nuestra base de datos la zona horaria.</p> <p>Para realizar estos ajustes simplemente editamos el fichero <code>mysqld.cnf</code> que se encuentra en <code>/etc/mysql/my.cnf/</code> y a\u00f1adimos la siguiente propiedad para asignarle nuestra zona horaria:</p> <pre><code>[mariabd]\ndefault_time_zone = 'Europe/Madrid'\n</code></pre> <p>Primero, vamos a preparar nuestro entorno. Una vez conectados a MariaDB, creamos una base de datos que contenga una tabla con informaci\u00f3n sobre profesores:</p> <pre><code>create database sqoopCaso1;\nuse sqoopCaso1;\nCREATE TABLE profesores(\nid MEDIUMINT NOT NULL AUTO_INCREMENT,\nnombre CHAR(30) NOT NULL,\nedad INTEGER(30),\nmateria CHAR(30),\nPRIMARY KEY (id) );\n</code></pre> <p>Insertamos datos en la tabla <code>profesores:</code></p> <pre><code>INSERT INTO profesores (nombre, edad, materia) VALUES (\"Carlos\", 24, \"Matem\u00e1ticas\"),\n(\"Pedro\", 32, \"Ingl\u00e9s\"), (\"Juan\", 35, \"Tecnolog\u00eda\"), (\"Jose\", 48, \"Matem\u00e1ticas\"),\n(\"Paula\", 24, \"Inform\u00e1tica\"), (\"Susana\", 32, \"Inform\u00e1tica\"), (\"Lorena\", 54, \"Inform\u00e1tica\");\n</code></pre> <p>A continuaci\u00f3n, arrancamos HDFS y YARN:</p> <pre><code>start-dfs.sh\nstart-yarn.sh\n</code></pre> <p>Con el comando <code>sqoop list-tables</code> listamos todas las tablas de la base de datos <code>sqoopCaso1</code>:</p> <pre><code>sqoop list-tables --connect jdbc:mysql://localhost/sqoopCaso1 --username=iabd --password=iabd\n</code></pre> <p>Y finalmente importamos los datos mediante el comando <code>sqoop import</code>:</p> Comando con explicacionesComando copiable <pre><code>sqoop import --connect jdbc:mysql://localhost/sqoopCaso1 \\ # (1)!\n--username=iabd --password=iabd \\ # (2)!\n--table=profesores --driver=com.mysql.jdbc.Driver \\ # (3)!\n--target-dir=/user/iabd/sqoop/profesores_hdfs \\ # (4)!\n--fields-terminated-by=',' --lines-terminated-by '\\n' # (5)!\n</code></pre> <ol> <li>Indicamos que vamos a importar datos desde un conexi\u00f3n JDBC, donde se indica el SGBD (<code>mysql</code>), el host (<code>localhost</code>) y el nombre de la base de datos (<code>sqoopCaso1</code>).</li> <li>Se configura tanto el usuario como la contrase\u00f1a del usuario (<code>iabd</code> / <code>iabd</code>) que se conecta a la base de datos.</li> <li>Indicamos la tabla que vamos a leer (<code>profesores</code>) y el driver que utilizamos.</li> <li>Configuramos el destino HDFS donde se van a importar los datos.</li> <li>Indicamos el separador de los campos y el car\u00e1cter para separar las l\u00edneas.</li> </ol> <pre><code>sqoop import --connect jdbc:mysql://localhost/sqoopCaso1 \\\n--username=iabd --password=iabd \\\n--table=profesores --driver=com.mysql.jdbc.Driver \\\n--target-dir=/user/iabd/sqoop/profesores_hdfs \\\n--fields-terminated-by=',' --lines-terminated-by '\\n'\n</code></pre> <p>Si queremos que en el caso de que ya exista la carpeta de destino la borre previamente, a\u00f1adiremos la opci\u00f3n <code>--delete-target-dir</code>.</p> <p>Unhealthy node</p> <p>Nuestra m\u00e1quina virtual tiene el espacio limitado, y es probable que en alg\u00fan momento se llene el disco. Adem\u00e1s de eliminar archivos no necesarios, una opci\u00f3n es configurar YARN mediante el archivo <code>yarn-site.xml</code> y configurar las siguientes propiedades para ser m\u00e1s permisivos con la falta de espacio:</p> <pre><code>&lt;property&gt;\n&lt;name&gt;yarn.nodemanager.disk-health-checker.min-healthy-disks&lt;/name&gt;\n&lt;value&gt;0.0&lt;/value&gt;\n&lt;/property&gt;\n&lt;property&gt;\n&lt;name&gt;yarn.nodemanager.disk-health-checker.max-disk-utilization-per-disk-percentage&lt;/name&gt;\n&lt;value&gt;100.0&lt;/value&gt;\n&lt;/property&gt;\n</code></pre> <p>El resultado que aparece en consola es:</p> <pre><code>2021-12-14 17:19:04,684 INFO sqoop.Sqoop: Running Sqoop version: 1.4.7\n2021-12-14 17:19:04,806 WARN tool.BaseSqoopTool: Setting your password on the command-line is insecure. Consider using -P instead.\n2021-12-14 17:19:05,057 WARN sqoop.ConnFactory: Parameter --driver is set to an explicit driver however appropriate connection manager is not being set (via --connection-manager). Sqoop is going to fall back to org.apache.sqoop.manager.GenericJdbcManager. Please specify explicitly which connection manager should be used next time.\n2021-12-14 17:19:05,087 INFO manager.SqlManager: Using default fetchSize of 1000\n2021-12-14 17:19:05,087 INFO tool.CodeGenTool: Beginning code generation\n2021-12-14 17:19:05,793 INFO manager.SqlManager: Executing SQL statement: SELECT t.* FROM profesores AS t WHERE 1=0\n2021-12-14 17:19:05,798 INFO manager.SqlManager: Executing SQL statement: SELECT t.* FROM profesores AS t WHERE 1=0\n2021-12-14 17:19:05,877 INFO orm.CompilationManager: HADOOP_MAPRED_HOME is /opt/hadoop-3.3.1\nNote: /tmp/sqoop-iabd/compile/585dc8a5a92b80ebbd22c9f597dd1928/profesores.java uses or overrides a deprecated API.\nNote: Recompile with -Xlint:deprecation for details.\n2021-12-14 17:19:12,153 INFO orm.CompilationManager: Writing jar file: /tmp/sqoop-iabd/compile/585dc8a5a92b80ebbd22c9f597dd1928/profesores.jar\n2021-12-14 17:19:12,235 INFO mapreduce.ImportJobBase: Beginning import of profesores\n2021-12-14 17:19:12,240 INFO Configuration.deprecation: mapred.job.tracker is deprecated. Instead, use mapreduce.jobtracker.address\n2021-12-14 17:19:12,706 INFO Configuration.deprecation: mapred.jar is deprecated. Instead, use mapreduce.job.jar\n2021-12-14 17:19:12,714 INFO manager.SqlManager: Executing SQL statement: SELECT t.* FROM profesores AS t WHERE 1=0\n2021-12-14 17:19:14,330 INFO Configuration.deprecation: mapred.map.tasks is deprecated. Instead, use mapreduce.job.maps\n2021-12-14 17:19:14,608 INFO client.DefaultNoHARMFailoverProxyProvider: Connecting to ResourceManager at iabd-virtualbox/127.0.1.1:8032\n2021-12-14 17:19:16,112 INFO mapreduce.JobResourceUploader: Disabling Erasure Coding for path: /tmp/hadoop-yarn/staging/iabd/.staging/job_1639498733738_0001\n2021-12-14 17:19:22,016 INFO db.DBInputFormat: Using read commited transaction isolation\n2021-12-14 17:19:22,018 INFO db.DataDrivenDBInputFormat: BoundingValsQuery: SELECT MIN(id), MAX(id) FROM profesores\n2021-12-14 17:19:22,022 INFO db.IntegerSplitter: Split size: 1; Num splits: 4 from: 1 to: 7\n2021-12-14 17:19:22,214 INFO mapreduce.JobSubmitter: number of splits:4\n2021-12-14 17:19:22,707 INFO mapreduce.JobSubmitter: Submitting tokens for job: job_1639498733738_0001\n2021-12-14 17:19:22,707 INFO mapreduce.JobSubmitter: Executing with tokens: []\n2021-12-14 17:19:23,390 INFO conf.Configuration: resource-types.xml not found\n2021-12-14 17:19:23,391 INFO resource.ResourceUtils: Unable to find 'resource-types.xml'.\n2021-12-14 17:19:24,073 INFO impl.YarnClientImpl: Submitted application application_1639498733738_0001\n2021-12-14 17:19:24,300 INFO mapreduce.Job: The url to track the job: http://iabd-virtualbox:8088/proxy/application_1639498733738_0001/\n2021-12-14 17:19:24,303 INFO mapreduce.Job: Running job: job_1639498733738_0001\n2021-12-14 17:19:44,015 INFO mapreduce.Job: Job job_1639498733738_0001 running in uber mode : false\n2021-12-14 17:19:44,017 INFO mapreduce.Job:  map 0% reduce 0%\n2021-12-14 17:20:21,680 INFO mapreduce.Job:  map 50% reduce 0%\n2021-12-14 17:20:23,707 INFO mapreduce.Job:  map 100% reduce 0%\n2021-12-14 17:20:24,736 INFO mapreduce.Job: Job job_1639498733738_0001 completed successfully\n2021-12-14 17:20:24,960 INFO mapreduce.Job: Counters: 34\n        File System Counters\n                FILE: Number of bytes read=0\n                FILE: Number of bytes written=1125124\n                FILE: Number of read operations=0\n                FILE: Number of large read operations=0\n                FILE: Number of write operations=0\n                HDFS: Number of bytes read=377\n                HDFS: Number of bytes written=163\n                HDFS: Number of read operations=24\n                HDFS: Number of large read operations=0\n                HDFS: Number of write operations=8\n                HDFS: Number of bytes read erasure-coded=0\n        Job Counters \n                Killed map tasks=1\n                Launched map tasks=4\n                Other local map tasks=4\n                Total time spent by all maps in occupied slots (ms)=139377\n                Total time spent by all reduces in occupied slots (ms)=0\n                Total time spent by all map tasks (ms)=139377\n                Total vcore-milliseconds taken by all map tasks=139377\n                Total megabyte-milliseconds taken by all map tasks=142722048\n        Map-Reduce Framework\n                Map input records=7\n                Map output records=7\n                Input split bytes=377\n                Spilled Records=0\n                Failed Shuffles=0\n                Merged Map outputs=0\n                GC time elapsed (ms)=1218\n                CPU time spent (ms)=5350\n                Physical memory (bytes) snapshot=560439296\n                Virtual memory (bytes) snapshot=10029588480\n                Total committed heap usage (bytes)=349175808\n                Peak Map Physical memory (bytes)=142544896\n                Peak Map Virtual memory (bytes)=2507415552\n        File Input Format Counters \n                Bytes Read=0\n        File Output Format Counters \n                Bytes Written=163\n2021-12-14 17:20:24,979 INFO mapreduce.ImportJobBase: Transferred 163 bytes in 70,589 seconds (2,3091 bytes/sec)\n2021-12-14 17:20:24,986 INFO mapreduce.ImportJobBase: Retrieved 7 records.\n</code></pre> <p>Vamos a repasar la salida del log para entender el proceso:</p> <ul> <li>En la l\u00ednea 5 vemos como se lanza el generador de c\u00f3digo.</li> <li>En las l\u00edneas 6, 7 y 15 vemos como ejecuta la consulta para obtener todos los metadatos de la tabla de profesores.</li> <li>En la l\u00ednea 20 obtiene los valores m\u00ednimo y m\u00e1ximo para calcular como dividir los datos.</li> <li>De las l\u00edneas 29 a la 34 se ejecuta el proceso MapReduce, donde realmente recupera los datos.</li> <li>En el resto se puede observar un resumen estad\u00edstico.</li> </ul>"},{"location":"hadoop/05flume.html#monitorizando-sqoop","title":"Monitorizando Sqoop","text":"<p>Si accedemos al interfaz gr\u00e1fico de YARN (en <code>http://iabd-virtualbox:8088/cluster</code>) podemos ver c\u00f3mo aparece el proceso como realizado:</p> Estado de YARN tras la importaci\u00f3n <p>Si accedemos al interfaz gr\u00e1fico de Hadoop (recuerda que puedes acceder a \u00e9l mediante <code>http://iabd-virtualbox:9870</code>) podremos comprobar en el directorio <code>/user/iabd/sqoop</code> que ha creado el directorio que hemos especificado junto con los siguientes archivos:</p> Contenido de /user/iabd/sqoop/profesores_hdfs <p>Si entramos a ver los datos, podemos visualizar el contenido del primer fragmento que contiene los primeros datos de la tabla:</p> Contenido de part-m-0000 <p>Import\u00e1ndolo todo</p> <p>Si queremos importar todas las tablas de una base de datos, podemos emplear el comando <code>sqoop import-all-tables</code>, en el cual ya no indicamos la tabla a importar, sino la carpeta (<code>warehouse-dir</code>) donde crear\u00e1 una carpeta por cada tabla que encuentra en la base de datos:</p> <pre><code>sqoop import-all-tables --connect jdbc:mysql://localhost/mi_bd \\\n--username=iabd --password=iabd \\\n--driver=com.mysql.jdbc.Driver \\\n--warehouse-dir=/user/iabd/sqoop \\\n--fields-terminated-by=',' --lines-terminated-by '\\n'\n</code></pre>"},{"location":"hadoop/05flume.html#caso-2-exportando-datos-a-mariadb","title":"Caso 2 - Exportando datos a MariaDB","text":"<p>Tabla no existente</p> <p>Si la tabla no existe previamente, recibiremos un error.</p> <p>Ahora vamos a hacer el paso contrario, desde HDFS vamos a exportar los ficheros a otra tabla mediante el comando <code>sqoop export</code>. As\u00ed pues, primero vamos a crear la nueva tabla en una nueva base de datos (aunque pod\u00edamos haber reutilizado la base de datos):</p> <pre><code>create database sqoopCaso2;\nuse sqoopCaso2;\nCREATE TABLE profesores2(\nid MEDIUMINT NOT NULL AUTO_INCREMENT,\nnombre CHAR(30) NOT NULL,\nedad INTEGER(30),\nmateria CHAR(30),\nPRIMARY KEY (id) );\n</code></pre> <p>Para exportar los datos de HDFS y cargarlos en esta nueva tabla lanzamos la siguiente orden:</p> <pre><code>sqoop export --connect jdbc:mysql://localhost/sqoopCaso2 \\\n--username=iabd --password=iabd \\\n--table=profesores2 --export-dir=/user/iabd/sqoop/profesores_hdfs\n</code></pre> <p>Si quisi\u00e9ramos exportar los datos sobre la misma tabla del caso de uso anterior, nos dar\u00eda error ya que tendr\u00edamos registros duplicados por la clave primaria. Para evitar el error, podemos indicarle una clave de actualizaci\u00f3n mediante <code>--update-key</code>, de manera que en el caso de que el registro ya existiese, modificara sus datos, realizando actualizaciones de datos en vez de inserciones. Si queremos que su comportamiento sea el de un upsert, le a\u00f1adiremos la opci\u00f3n <code>--update-mode allowinsert</code>:</p> <pre><code>sqoop export --connect jdbc:mysql://localhost/sqoopCaso1 \\\n--username=iabd --password=iabd \\\n--table=profesores --export-dir=/user/iabd/sqoop/profesores_hdfs \\\n--update-key id --update-mode allowinsert\n</code></pre>"},{"location":"hadoop/05flume.html#formatos-avro-y-parquet","title":"Formatos Avro y Parquet","text":"<p>Sqoop permite trabajar con diferentes formatos, tanto Avro como Parquet.</p> <p>Avro es un formato de almacenamiento basado en filas para Hadoop que se usa ampliamente como formato de serializaci\u00f3n. Recuerda que Avro almacena la estructura en formato JSON y los datos en binario.</p> <p>Parquet a su vez es un formato de almacenamiento binario basado en columnas que puede almacenar estructuras de datos anidados.</p> <p>Avro y Hadoop</p> <p>Para que funcione la serializaci\u00f3n con Avro hay que copiar el fichero <code>.jar</code> que viene en el directorio de <code>Sqoop</code> para Avro como librer\u00eda de Hadoop, mediante el siguiente comando:</p> <pre><code>cp $SQOOP_HOME/lib/avro-1.8.1.jar $HADOOP_HOME/share/hadoop/common/lib/\nrm $HADOOP_HOME/share/hadoop/common/lib/avro-1.7.7.jar\n</code></pre> <p>En nuestra m\u00e1quina virtual este paso ya est\u00e1 realizado.</p> <p>Para importar los datos en formato Avro, a\u00f1adiremos la opci\u00f3n <code>--as-avrodatafile</code>:</p> <pre><code>sqoop import --connect jdbc:mysql://localhost/sqoopCaso1    \\\n--username=iabd --password=iabd \\\n--table=profesores --driver=com.mysql.jdbc.Driver   \\\n--target-dir=/user/iabd/sqoop/profesores_avro --as-avrodatafile\n</code></pre> <p>Si en vez de Avro, queremos importar los datos en formato Parquet cambiamos el \u00faltimo par\u00e1metro por <code>--as-parquetfile</code>:</p> <pre><code>sqoop import --connect jdbc:mysql://localhost/sqoopCaso1    \\\n--username=iabd --password=iabd \\\n--table=profesores --driver=com.mysql.jdbc.Driver   \\\n--target-dir=/user/iabd/sqoop/profesores_parquet --as-parquetfile\n</code></pre> <p>Si queremos comprobar los archivos, podemos acceder via HDFS y la opci\u00f3n <code>-ls</code>:</p> <pre><code>hdfs dfs -ls /user/iabd/sqoop/profesores_avro\n</code></pre> <p>Obteniendo:</p> <pre><code>Found 5 items\n-rw-r--r--   1 iabd supergroup          0 2021-12-14 17:56 /user/iabd/sqoop/profesores_avro/_SUCCESS\n-rw-r--r--   1 iabd supergroup        568 2021-12-14 17:56 /user/iabd/sqoop/profesores_avro/part-m-00000.avro\n-rw-r--r--   1 iabd supergroup        569 2021-12-14 17:56 /user/iabd/sqoop/profesores_avro/part-m-00001.avro\n-rw-r--r--   1 iabd supergroup        547 2021-12-14 17:56 /user/iabd/sqoop/profesores_avro/part-m-00002.avro\n-rw-r--r--   1 iabd supergroup        574 2021-12-14 17:56 /user/iabd/sqoop/profesores_avro/part-m-00003.avro\n</code></pre> <p>Si queremos ver el contenido de una de las partes, utilizamos la opci\u00f3n <code>-text</code>:</p> <pre><code>hdfs dfs -text /user/iabd/sqoop/profesores_avro/part-m-00000.avro\n</code></pre> <p>Obteniendo el esquema y los datos en formato Avro:</p> <pre><code>{\"id\":{\"int\":1},\"nombre\":{\"string\":\"Carlos\"},\"edad\":{\"int\":24},\"materia\":{\"string\":\"Matem\u00e1ticas\"}}\n{\"id\":{\"int\":2},\"nombre\":{\"string\":\"Pedro\"},\"edad\":{\"int\":32},\"materia\":{\"string\":\"Ingl\u00e9s\"}}\n</code></pre> <p>Autoevaluaci\u00f3n</p> <p>\u00bfQu\u00e9 sucede si ejecutamos el comando <code>hdfs dfs -tail /user/iabd/sqoop/profesores_avro/part-m-00000.avro</code>? \u00bfPor qu\u00e9 aparece contenido en binario?</p> <p>En el caso de ficheros Parquet, primero listamos los archivos generados:</p> <pre><code>hdfs dfs -ls /user/iabd/sqoop/profesores_parquet\n</code></pre> <p>Obteniendo:</p> <pre><code>Found 6 items\ndrwxr-xr-x   - iabd supergroup          0 2021-12-15 16:13 /user/iabd/sqoop/profesores_parquet/.metadata\ndrwxr-xr-x   - iabd supergroup          0 2021-12-15 16:14 /user/iabd/sqoop/profesores_parquet/.signals\n-rw-r--r--   1 iabd supergroup       1094 2021-12-15 16:14 /user/iabd/sqoop/profesores_parquet/12205ee4-6e63-4c0d-8e64-751882d60179.parquet\n-rw-r--r--   1 iabd supergroup       1114 2021-12-15 16:14 /user/iabd/sqoop/profesores_parquet/1e12aaad-98c6-4508-9c41-e1599e698385.parquet\n-rw-r--r--   1 iabd supergroup       1097 2021-12-15 16:14 /user/iabd/sqoop/profesores_parquet/6a803503-f3e0-4f2a-8546-a337f7f90e73.parquet\n-rw-r--r--   1 iabd supergroup       1073 2021-12-15 16:14 /user/iabd/sqoop/profesores_parquet/eda459b2-1da4-4790-b649-0f2f8b83ab06.parquet\n</code></pre> <p>Podemos usar las <code>parquet-tools</code> para ver su contenido. Si la instalamos mediante <code>pip3 install parquet-tools</code> podremos acceder a ficheros locales y almacenados en S3. Si queremos acceder de forma remota via HDFS, podemos descargar la versi\u00f3n Java y utilizarla mediante <code>hadoop</code> (aunque da problemas entre las versiones de Sqoop y Parquet):</p> <pre><code>hadoop jar parquet-tools-1.11.2.jar head -n5 hdfs://iabd-virtualbox:9000/user/iabd/sqoop/profesores_parquet/12205ee4-6e63-4c0d-8e64-751882d60179.parquet\n</code></pre> <p>Si queremos obtener informaci\u00f3n sobre los documentos, usaremos la opci\u00f3n <code>meta</code>:</p> <pre><code>hadoop jar parquet-tools-1.11.2.jar meta hdfs://iabd-virtualbox:9000/user/iabd/sqoop/profesores_parquet/12205ee4-6e63-4c0d-8e64-751882d60179.parquet\n</code></pre> <p>M\u00e1s informaci\u00f3n sobre parquet-tools en https://pypi.org/project/parquet-tools/.</p>"},{"location":"hadoop/05flume.html#trabajando-con-datos-comprimidos","title":"Trabajando con datos comprimidos","text":"<p>En un principio, vamos a trabajar siempre con los datos sin comprimir. Cuando tengamos datos que vamos a utilizar durante mucho tiempo (del orden de varios a\u00f1os) es cuando nos plantearemos comprimir los datos.</p> <p>Por defecto, podemos comprimir mediante el formato gzip utilizando el par\u00e1metro <code>--compress</code>:</p> <pre><code>sqoop import --connect jdbc:mysql://localhost/sqoopCaso1 \\\n--username=iabd --password=iabd \\\n--table=profesores --driver=com.mysql.jdbc.Driver \\\n--target-dir=/user/iabd/sqoop/profesores_gzip \\\n--compress\n</code></pre> <p>Si en cambio queremos comprimirlo con formato bzip2, hemos de a\u00f1adir tambi\u00e9n el par\u00e1metro <code>--compression-codec bzip2</code>:</p> <pre><code>sqoop import --connect jdbc:mysql://localhost/sqoopCaso1 \\\n--username=iabd --password=iabd \\\n--table=profesores --driver=com.mysql.jdbc.Driver \\\n--target-dir=/user/iabd/sqoop/profesores_bzip \\\n--compress --compression-codec bzip2\n</code></pre> <p>Snappy es una biblioteca de compresi\u00f3n y descompresi\u00f3n de datos de gran rendimiento que se utiliza con frecuencia en proyectos Big Data. As\u00ed pues, para utilizarlo lo indicaremos mediante el codec <code>snappy</code>:</p> <pre><code>sqoop import --connect jdbc:mysql://localhost/sqoopCaso1 \\\n--username=iabd --password=iabd \\\n--table=profesores --driver=com.mysql.jdbc.Driver \\\n--target-dir=/user/iabd/sqoop/profesores_snappy \\\n--compress --compression-codec snappy\n</code></pre>"},{"location":"hadoop/05flume.html#importando-con-filtros","title":"Importando con filtros","text":"<p>Adem\u00e1s de poder importar todos los datos de una tabla, podemos filtrar los datos. Por ejemplo, podemos indicar mediante la opci\u00f3n <code>--where</code> el filtro a ejecutar en la consulta:</p> <pre><code>sqoop import --connect jdbc:mysql://localhost/sqoopCaso1 \\\n--username=iabd --password=iabd \\\n--table=profesores --driver=com.mysql.jdbc.Driver \\\n--target-dir=/user/iabd/sqoop/profesores_materia_info \\\n--where \"materia='Inform\u00e1tica'\"\n</code></pre> <p>Tambi\u00e9n podemos restringir las columnas que queremos recuperar mediante la opci\u00f3n <code>--columns</code>:</p> <pre><code>sqoop import --connect jdbc:mysql://localhost/sqoopCaso1 \\\n--username=iabd --password=iabd \\\n--table=profesores --driver=com.mysql.jdbc.Driver \\\n--target-dir=/user/iabd/sqoop/profesores_cols \\\n--columns \"nombre,materia\"\n</code></pre> <p>Finalmente, podemos especificar una consulta con clave de particionado (en este caso, ya no indicamos el nombre de la tabla):</p> <pre><code>sqoop import --connect jdbc:mysql://localhost/sqoopCaso1 \\\n--username=iabd --password=iabd \\\n--driver=com.mysql.jdbc.Driver \\\n--target-dir=/user/iabd/sqoop/profesores_query \\\n--query \"select * from profesores where edad &gt; 40 AND \\$CONDITIONS\" \\\n--split-by \"id\"\n</code></pre> <p>En la consulta, hemos de a\u00f1adir el token <code>\\$CONDITIONS</code>, el cual Sqoop sustituir\u00e1 por la columna por la que los mappers realizan el particionado.</p>"},{"location":"hadoop/05flume.html#importacion-incremental","title":"Importaci\u00f3n incremental","text":"<p>Si utilizamos procesos batch, es muy com\u00fan realizar importaciones incrementales tras una carga de datos. Para ello, utilizaremos las opciones <code>--incremental append</code> junto con la columna a comprobar mediante <code>--check-column</code> y el \u00faltimo registro cargado mediante <code>--last-value</code>:</p> <pre><code>sqoop import --connect jdbc:mysql://localhost/sqoopCaso1 \\\n--username=iabd --password=iabd \\\n--table=profesores --driver=com.mysql.jdbc.Driver \\\n--target-dir=/user/iabd/sqoop/profesores_inc \\\n--incremental append \\\n--check-column id \\\n--last-value 4\n</code></pre> <p>Despu\u00e9s de ejecutarlo, si vemos la informaci\u00f3n que nos devuelve, en las \u00faltimas l\u00edneas, podemos copiar los par\u00e1metros que tenemos que utilizar para posteriores importaciones.</p> <pre><code>...\n2021-12-15 19:10:59,348 INFO tool.ImportTool: Incremental import complete! To run another incremental import of all data following this import, supply the following arguments:\n2021-12-15 19:10:59,348 INFO tool.ImportTool:  --incremental append\n2021-12-15 19:10:59,348 INFO tool.ImportTool:   --check-column id\n2021-12-15 19:10:59,348 INFO tool.ImportTool:   --last-value 7\n2021-12-15 19:10:59,349 INFO tool.ImportTool: (Consider saving this with 'sqoop job --create')\n</code></pre>"},{"location":"hadoop/05flume.html#trabajando-con-hive","title":"Trabajando con Hive","text":"<p>Podemos importar los datos en HDFS para que luego puedan ser consultables desde Hive. Para ello hemos de utilizar el par\u00e1metro <code>--hive-import</code> e indicar el nombre de la base de datos mediante <code>--hive-database</code> as\u00ed como la opci\u00f3n de <code>--create-hive-table</code> para que cree la tabla indicada en el par\u00e1metro <code>hive-table</code>.</p> <p>Es importante destacar que ya no ponemos destino con <code>target-dir</code>:</p> <pre><code>sqoop import --connect jdbc:mysql://localhost/sqoopCaso1 \\\n--username=iabd --password=iabd \\\n--table=profesores --driver=com.mysql.jdbc.Driver \\\n--hive-import --hive-database default \\\n--create-hive-table --hive-table profesores_mariadb\n</code></pre> <p>Para comprobar el resultado, dentro de Hive ejecutaremos el comando:</p> <pre><code>describe formatted profesores_mariadb\n</code></pre> <p>Para exportar los datos, de forma similar haremos:</p> <pre><code>sqoop export --connect jdbc:mysql://localhost/sqoopCaso2 \\\n--username=iabd --password=iabd \\\n--table=profesores2 --driver=com.mysql.jdbc.Driver \\\n--h-catalog-table profesores_mariadb\n</code></pre>"},{"location":"hadoop/05flume.html#flume","title":"Flume","text":"Logo de Apache Flume <p>All\u00e1 por el a\u00f1o 2010 Cloudera present\u00f3 Flume que posteriormente pas\u00f3 a formar parte de Apache (https://flume.apache.org/) como un software para tratamiento e ingesta de datos masivo, facilitando crear desarrollos complejos que permiten el tratamiento de datos en streaming. Inicialmente se dise\u00f1\u00f3 para recolectar ficheros de log de una granja de servidores web y mover los eventos almacenados en esos ficheros a HDFS para su posterior procesamiento.</p> <p>Flume funciona como un buffer entre los productores de datos y el destino final. Al utilizar un buffer, evitamos que un productor sature a un consumidor, sin necesidad de preocuparnos de que alg\u00fan destino est\u00e9 inalcanzable o inoperable (por ejemplo, en el caso de que haya ca\u00eddo HDFS), etc...</p> <p>Instalaci\u00f3n</p> <p>Aunque en la m\u00e1quina virtual con la que trabajamos tambi\u00e9n tenemos instalado Flume, podemos descargar la \u00faltima versi\u00f3n desde https://dlcdn.apache.org/flume/1.11.0/apache-flume-1.11.0-bin.tar.gz.</p> <p>A nivel de configuraci\u00f3n s\u00f3lo hemos definido la variable de entorno <code>$FLUME_HOME</code> que apunta a <code>/opt/flume-1.11.0</code>.</p> <p>Algunas de sus caracter\u00edsticas son:</p> <ul> <li>Dise\u00f1o flexible basado en flujos de datos de transmisi\u00f3n.</li> <li>Resistente a fallos y robusto con m\u00faltiples conmutaciones por error y  mecanismos de recuperaci\u00f3n.</li> <li>Lleva datos desde origen a destino: incluidos HDFS y HBase.</li> </ul>"},{"location":"hadoop/05flume.html#arquitectura","title":"Arquitectura","text":"<p>Su arquitectura es sencilla, y se basa en el uso de agentes que se dividen en tres componentes, los cuales podemos configurar:</p> <ul> <li>Source (fuente): Fuente de origen de los datos, ya sea Twitter, Kafka, una petici\u00f3n Http, etc... Las fuentes son un componente activo que recibe datos desde otra aplicaci\u00f3n que produce datos (aunque tambi\u00e9n existen fuentes que pueden producir datos por s\u00ed mismos, cuyo objetivo es poder probar ciertos flujos de datos). Las fuentes puedes escuchar uno o m\u00e1s puertos de red para recibir o leer datos del sistema de archivos. Cada fuente debe conectar a al menos un canal. Una fuente puede escribir en varios canales, replicando los eventos a todos o algunos canales en base a alg\u00fan criterio.</li> <li>Channel (canal): la v\u00eda por donde se tratar\u00e1n los datos. Un canal es un componente pasivo que almacena los datos como un buffer. Se comportan como colas, donde las fuentes publican y los sumideros consumen los datos. M\u00faltiples fuentes pueden escribir de forma segura en el mismo canal, y m\u00faltiples sumideros pueden leer desde el mismo canal. Sin embargo, cada sumidero s\u00f3lo puede leer de un \u00fanico canal. Si m\u00faltiples sumideros leen del mismo canal, s\u00f3lo uno de ellos leer\u00e1 el dato.</li> <li>Sink (sumidero): persistencia/movimiento de los datos, a ficheros / base de datos. Toma eventos del canal de manera continua leyendo y eliminando los eventos. A continuaci\u00f3n, los transmite hacia el siguiente componente, ya sea a HDFS, Hive, etc... Una vez los datos han llegado al siguiente destino, el sumidero informa al canal mediante un commit transaccional para que elimine dichos eventos del canal.</li> </ul> Arquitectura Flume - imagen extra\u00edda de https://www.diegocalvo.es/flume/ <p>Es muy recomendable acceder a la gu\u00eda de usuario oficial para consultar todas las fuentes de datos, canales y sumideros disponibles en la actualidad. A continuaci\u00f3n se nombran algunos de los m\u00e1s destacados:</p> Sources Channels Sinks Avro Source Memory Channel HDFS Sink Thrift Source JDBC Channel Hive Sink Exec Source Kafka Channel Logger Sink JMS Source File Channel Avro Sink Spooling Directory Source Spillable Memory Channel Thrift Sink Twitter 1% firehose Source Pseudo Transaction Channel Kafka Sink Kafka Source File Roll Sink NetCat Source Null Sink Sequence Generator Source HBaseSink Syslog Sources AsyncHBaseSink HTTP Source MorphlineSolrSink Multiport Syslog TCP Source ElasticSearchSink Syslog UDP Source Kite Dataset Sink <p>Una instalaci\u00f3n de Flume consiste en una colecci\u00f3n de agentes conectados los cuales se ejecutan en una arquitectura distribuida. Los agentes del borde del sistema (situados, por ejemplo, en los mismos servidores web que generan los datos) recogen los datos y los reenv\u00edan a los agentes responsables de agregar y ordenar los datos en el destino final.</p> <p>Flume se complica cuando queremos utilizarlo para obtener datos de manera paralela (o multiplexada) y/o necesitamos crear nuestros propios sumideros o interceptores. Pero por lo general, su uso es sencillo y se trata de una herramienta muy recomendada como ayuda/alternativa a herramientas como Pentaho.</p>"},{"location":"hadoop/05flume.html#agentes","title":"Agentes","text":"<p>Un agente es la unidad m\u00e1s sencilla con la que trabaja Flume, permitiendo conectar un agente Flume a uno o m\u00e1s agentes, encanden\u00e1ndolos. Adem\u00e1s, un agente puede recibir datos de uno o m\u00e1s agentes. Conectando m\u00faltiples agentes entre s\u00ed podemos crear un flujo de datos para mover datos de un lugar a otro, de aplicaciones que producen datos a HDFS, HBase o donde necesitemos.</p> <p>Para lanzar un tarea en Flume, debemos definir un agente, el cual funciona como un contenedor para alojar subcomponentes que permiten mover los datos.</p> <p>Estos agentes tienen cuatro partes bien diferenciadas asociadas a la arquitectura de Flume. En la primera parte, definiremos los componente del agente (sources, channels y sinks), y luego, para cada uno de ellos, configuraremos sus propiedades:</p> <ul> <li><code>sources</code>: responsables de colocar los eventos/datos en el agente</li> <li><code>channels</code>: buffer que almacena los eventos/datos recibidos por los sources hasta que un sink lo saca para enviarlo al siguiente destino.</li> <li><code>sinks</code>: responsable de sacar los eventos/datos del agente y reenviarlo al siguiente agente (HDFS, HBase, etc...)</li> </ul>"},{"location":"hadoop/05flume.html#evento","title":"Evento","text":"<p>El evento es la unidad m\u00e1s peque\u00f1a del procesamiento de eventos de Flume. Cuando Flume lee una fuente de datos, envuelve una fila de datos (es decir, encuentra los saltos de l\u00ednea) en un evento.</p> <p>Un evento es una estructura de datos que se compone de dos partes:</p> <ul> <li>Encabezado (header), se utiliza principalmente para registrar informaci\u00f3n mediante un mapa en forma de clave y valor. No transfieren datos, pero contienen informaci\u00f3n util para el enrutado y gesti\u00f3n de la prioridad o importancia de los mensajes.</li> <li>Cuerpo (payload): array de bytes que almacena los datos reales.</li> </ul>"},{"location":"hadoop/05flume.html#probando-flume","title":"Probando Flume","text":"<p>Por ejemplo, vamos a crear un agente el cual llamaremos <code>ExecLoggerAgent</code> el cual va a ejecutar un comando y mostrar\u00e1 el resultado por el log de Flume, utilizando como canal la memoria.</p> <p>Para ello, creamos la configuraci\u00f3n del agente en el fichero <code>agente.conf</code> (todas las propiedades comenzar\u00e1n con el nombre del agente):</p> agente.conf<pre><code># Nombramos los componentes del agente\nExecLoggerAgent.sources = Exec\nExecLoggerAgent.channels = MemChannel\nExecLoggerAgent.sinks = LoggerSink\n# Describimos el tipo de origen\nExecLoggerAgent.sources.Exec.type = exec\nExecLoggerAgent.sources.Exec.command = ls /home/iabd/\n# Describimos el destino\nExecLoggerAgent.sinks.LoggerSink.type = logger\n# Describimos la configuraci\u00f3n del canal\nExecLoggerAgent.channels.MemChannel.type = memory\nExecLoggerAgent.channels.MemChannel.capacity = 1000\nExecLoggerAgent.channels.MemChannel.transactionCapacity = 100\n# Unimos el origen y el destino a trav\u00e9s del canal\nExecLoggerAgent.sources.Exec.channels = MemChannel\nExecLoggerAgent.sinks.LoggerSink.channel = MemChannel\n</code></pre> <p>A continuaci\u00f3n ya podemos lanzar Flume con el agente mediante el comando (la opci\u00f3n <code>-n</code> sirve para indicar el nombre del agente, y con <code>-f</code> indicamos el nombre del archivo de configuraci\u00f3n):</p> <pre><code>flume-ng agent --name ExecLoggerAgent --conf ./conf/ --conf-file conf/agente.conf </code></pre> <p>Tras su ejecuci\u00f3n, si consultamos el fichero <code>flume.log</code> podremos ver c\u00f3mo ha creado primero el canal del agente <code>MemChannel</code>, as\u00ed como la instancia de la fuente <code>Exec</code> y el sumidero <code>LoggerSink</code> y los conecta:</p> <pre><code>21 ene 2023 19:28:25,006 INFO  [main] (org.apache.flume.conf.FlumeConfiguration$AgentConfiguration.addComponentConfig:1203)  - Processing:LoggerSink\n21 ene 2023 19:28:25,014 INFO  [main] (org.apache.flume.conf.FlumeConfiguration$AgentConfiguration.addComponentConfig:1203)  - Processing:MemChannel\n...\n21 ene 2023 19:28:25,041 INFO  [main] (org.apache.flume.node.AbstractConfigurationProvider.loadChannels:154)  - Creating channels\n21 ene 2023 19:28:25,049 INFO  [main] (org.apache.flume.channel.DefaultChannelFactory.create:42)  - Creating instance of channel MemChannel type memory\n21 ene 2023 19:28:25,054 INFO  [main] (org.apache.flume.node.AbstractConfigurationProvider.loadChannels:208)  - Created channel MemChannel\n21 ene 2023 19:28:25,055 INFO  [main] (org.apache.flume.source.DefaultSourceFactory.create:41)  - Creating instance of source Exec, type exec\n21 ene 2023 19:28:25,113 INFO  [main] (org.apache.flume.sink.DefaultSinkFactory.create:42)  - Creating instance of sink: LoggerSink, type: logger\n21 ene 2023 19:28:25,127 INFO  [main] (org.apache.flume.node.AbstractConfigurationProvider.getConfiguration:123)  - Channel MemChannel connected to [Exec, LoggerSink]\n</code></pre> <p>A continuaci\u00f3n, inicializa los componentes y los arranca:</p> <pre><code>21 ene 2023 19:28:25,128 INFO  [main] (org.apache.flume.node.Application.initializeAllComponents:177)  - Initializing components\n21 ene 2023 19:28:25,173 INFO  [main] (org.apache.flume.node.Application.startAllComponents:207)  -\n    Starting new configuration:{\n        sourceRunners:{Exec=EventDrivenSourceRunner: { source:org.apache.flume.source.ExecSource{name:Exec,state:IDLE} }}\n        sinkRunners:{LoggerSink=SinkRunner: { policy:org.apache.flume.sink.DefaultSinkProcessor@4b7dc788 counterGroup:{ name:null counters:{} } }}\n        channels:{MemChannel=org.apache.flume.channel.MemoryChannel{name: MemChannel}} }\n21 ene 2023 19:28:25,174 INFO  [main] (org.apache.flume.node.Application.startAllComponents:214)  - Starting Channel MemChannel\n21 ene 2023 19:28:25,188 INFO  [main] (org.apache.flume.node.Application.startAllComponents:229)  - Waiting for channel: MemChannel to start. Sleeping for 500 ms\n21 ene 2023 19:28:25,190 INFO  [lifecycleSupervisor-1-0] (org.apache.flume.instrumentation.MonitoredCounterGroup.register:119)  - Monitored counter group for type: CHANNEL, name: MemChannel: Successfully registered new MBean.\n21 ene 2023 19:28:25,190 INFO  [lifecycleSupervisor-1-0] (org.apache.flume.instrumentation.MonitoredCounterGroup.start:95)  - Component type: CHANNEL, name: MemChannel started\n21 ene 2023 19:28:25,692 INFO  [main] (org.apache.flume.node.Application.startAllComponents:241)  - Starting Sink LoggerSink\n21 ene 2023 19:28:25,714 INFO  [main] (org.apache.flume.node.Application.startAllComponents:252)  - Starting Source Exec\n</code></pre> <p>Una vez arrancados, podemos ver c\u00f3mo ha ejecutado el comando <code>ls /home/iabd/</code> y mediante el <code>LoggerSink</code>, muestra cada uno de los archivos de la carpeta en un evento, donde podemos ver que tiene la cabecera vac\u00eda <code>headers:{}</code>, luego los datos en una representaci\u00f3n en hexadecimal y por \u00faltimo el nombre del archivo/carpeta:</p> <pre><code>21 ene 2023 19:28:25,716 INFO  [lifecycleSupervisor-1-2] (org.apache.flume.source.ExecSource.start:170)  -\n    Exec source starting with command: ls /home/iabd/\n21 ene 2023 19:28:25,722 INFO  [lifecycleSupervisor-1-2] (org.apache.flume.instrumentation.MonitoredCounterGroup.register:119)  -\n    Monitored counter group for type: SOURCE, name: Exec: Successfully registered new MBean.\n21 ene 2023 19:28:25,729 INFO  [lifecycleSupervisor-1-2] (org.apache.flume.instrumentation.MonitoredCounterGroup.start:95)  -\n    Component type: SOURCE, name: Exec started\n21 ene 2023 19:28:25,892 INFO  [SinkRunner-PollingRunner-DefaultSinkProcessor] (org.apache.flume.sink.LoggerSink.process:95)  -\n    Event: { headers:{} body: 64 61 74 6F 73                                  datos }\n21 ene 2023 19:28:25,893 INFO  [SinkRunner-PollingRunner-DefaultSinkProcessor] (org.apache.flume.sink.LoggerSink.process:95)  -\n    Event: { headers:{} body: 44 65 73 63 61 72 67 61 73                      Descargas }\n21 ene 2023 19:28:25,893 INFO  [pool-3-thread-1] (org.apache.flume.source.ExecSource$ExecRunnable.run:379)  - \n    Command [ls /home/iabd/] exited with 0\n21 ene 2023 19:28:25,900 INFO  [SinkRunner-PollingRunner-DefaultSinkProcessor] (org.apache.flume.sink.LoggerSink.process:95)  - \n    Event: { headers:{} body: 44 65 73 6B 74 6F 70                            Desktop }\n21 ene 2023 19:28:25,905 INFO  [SinkRunner-PollingRunner-DefaultSinkProcessor] (org.apache.flume.sink.LoggerSink.process:95)  - \n    Event: { headers:{} body: 44 6F 63 75 6D 65 6E 74 6F 73                   Documentos }\n21 ene 2023 19:28:25,906 INFO  [SinkRunner-PollingRunner-DefaultSinkProcessor] (org.apache.flume.sink.LoggerSink.process:95)  - \n    Event: { headers:{} body: 66 6C 75 6D 65                                  flume }\n21 ene 2023 19:28:25,908 INFO  [SinkRunner-PollingRunner-DefaultSinkProcessor] (org.apache.flume.sink.LoggerSink.process:95)  - \n    Event: { headers:{} body: 49 6D C3 A1 67 65 6E 65 73                      Im..genes }\n...\n</code></pre>"},{"location":"hadoop/05flume.html#configurando-un-agente","title":"Configurando un agente","text":"<p>Si te has fijado en el ejemplo anterior, los ficheros de configuraci\u00f3n de los agentes siguen el mismo formato. Para definir un flujo dentro de un agente, necesitamos enlazar las fuentes y los sumideros con un canal. Para ello, listaremos las fuentes, sumideros y canales del agente, y entonces apuntaremos la fuente y el sumidero a un canal.</p> <p>As\u00ed pues, el formato ser\u00e1 similar al siguiente archivo:</p> <pre><code># Listamos las fuentes, sumideros y canales\n&lt;Agent&gt;.sources = &lt;Source&gt;\n&lt;Agent&gt;.sinks = &lt;Sink&gt;\n&lt;Agent&gt;.channels = &lt;Channel1&gt; &lt;Channel2&gt;\n# Configuramos los canales de la fuente\n&lt;Agent&gt;.sources.&lt;Source&gt;.channels = &lt;Channel1&gt; &lt;Channel2&gt; ...\n# Configuramos el canal para el sumidero\n&lt;Agent&gt;.sinks.&lt;Sink&gt;.channel = &lt;Channel1&gt;\n</code></pre> <p>channel y channels</p> <p>Destacar que una fuente tiene una propiedad <code>channels</code>(en plural), pero un sumidero tiene la propiedad <code>channel</code> (en singular). Esto se debe a que una fuente puede alimentar m\u00e1s de un canal (fan out), pero un sumidero s\u00f3lo puede obtener datos de un \u00fanico canal. Tambi\u00e9n es posible que un canal alimente a varios sumideros.</p> <p>En resumen, siguen una relaci\u00f3n 1 - N - 1, de manera que una fuente puede indicar m\u00faltiples canales, pero un sumidero s\u00f3lo puede indicar un \u00fanico canal.</p> <p>Adem\u00e1s de definir el flujo, es necesario configurar las propiedades de cada fuente, sumidero y canal. Para elo se sigue la misma nomenclatura donde fijamos el tipo de componente (mediante la propiedad <code>type</code>) y el resto de propiedades espec\u00edficas de cada componente:</p> <pre><code># Propiedades de las fuentes\n&lt;Agent&gt;.sources.&lt;Source&gt;.&lt;someProperty&gt; = &lt;someValue&gt;\n# Propiedades de los canales\n&lt;Agent&gt;.channel.&lt;Channel&gt;.&lt;someProperty&gt; = &lt;someValue&gt;\n# Propiedades de los sumideros\n&lt;Agent&gt;.sources.&lt;Sink&gt;.&lt;someProperty&gt; = &lt;someValue&gt;\n</code></pre> <p>Para cada tipo de fuente, canal y sumidero es recomendable revisar la documentaci\u00f3n para validar todas las propiedades disponibles.</p>"},{"location":"hadoop/05flume.html#caso-3a-almacenando-en-hdfs","title":"Caso 3a - Almacenando en HDFS","text":"<p>En este caso de uso vamos generar datos de forma secuencial y los vamos a ingestar en HDFS.</p> <p>Una buena pr\u00e1ctica es colocar los archivos de configuraci\u00f3n dentro de <code>$FLUME_HOME/conf</code>. As\u00ed pues, vamos a crear el agente <code>SeqGenAgent</code> y almacenar la configuraci\u00f3n en el fichero <code>seqgen.conf</code>:</p> seqgen.conf<pre><code># Nombramos a los componentes del agente\nSeqGenAgent.sources = SeqSource\nSeqGenAgent.channels = MemChannel\nSeqGenAgent.sinks = HDFS\n# Describimos el tipo de origen\nSeqGenAgent.sources.SeqSource.type = seq\n# Describimos el destino\nSeqGenAgent.sinks.HDFS.type = hdfs\nSeqGenAgent.sinks.HDFS.hdfs.path = hdfs://iabd-virtualbox:9000/user/iabd/flume/seqgen_data/\nSeqGenAgent.sinks.HDFS.hdfs.filePrefix = flume-caso3-seqgen\nSeqGenAgent.sinks.HDFS.hdfs.rollInterval = 0\nSeqGenAgent.sinks.HDFS.hdfs.rollCount = 1000\nSeqGenAgent.sinks.HDFS.hdfs.fileType = DataStream\n# Describimos la configuraci\u00f3n del canal\nSeqGenAgent.channels.MemChannel.type = memory\nSeqGenAgent.channels.MemChannel.capacity = 1000\nSeqGenAgent.channels.MemChannel.transactionCapacity = 100\n# Unimos el origen y el destino a trav\u00e9s del canal\nSeqGenAgent.sources.SeqSource.channels = MemChannel\nSeqGenAgent.sinks.HDFS.channel = MemChannel\n</code></pre> <p>Arrancamos Hadoop</p> <p>Antes de lanzar el agente Flume, recuerda que debes arrancar tanto Hadoop como YARN, por ejemplo, mediante el comando <code>start-all.sh</code>.</p> <p>Ejecutamos el siguiente comando desde <code>$FLUME_HOME</code> y a los pocos segundo lo paramos mediante <code>CTRL + C</code> para que detenga la generaci\u00f3n de n\u00fameros, ya que si no seguir\u00e1 generando archivos en HDFS:</p> <pre><code>./bin/flume-ng agent --conf ./conf/ --conf-file conf/seqgen.conf \\\n--name SeqGenAgent \\\n-Dflume.root.logger=INFO,console\n</code></pre> <p>Vaciando HDFS</p> <p>Si queremos eliminar los ficheros generados en HDFS, recuerda que puedes realizar un borrado recursivo mediante el comando:</p> <pre><code>hdfs dfs -rm -r /user/iabd/flume\n</code></pre> <p>Si comprobamos por ejemplo el contenido de la carpeta (<code>hdfs dfs -ls /user/iabd/flume/seqgen_data</code>) veremos que se han generado m\u00faltiples archivos:</p> <pre><code>Found 10 items\n-rw-r--r--   1 iabd supergroup       1402 2021-12-22 16:42 /user/iabd/flume/seqgen_data/flume-caso3-seqgen.1640187740933\n-rw-r--r--   1 iabd supergroup       1368 2021-12-22 16:42 /user/iabd/flume/seqgen_data/flume-caso3-seqgen.1640187740934\n-rw-r--r--   1 iabd supergroup       1350 2021-12-22 16:42 /user/iabd/flume/seqgen_data/flume-caso3-seqgen.1640187740935\n-rw-r--r--   1 iabd supergroup       1280 2021-12-22 16:42 /user/iabd/flume/seqgen_data/flume-caso3-seqgen.1640187740936\n-rw-r--r--   1 iabd supergroup       1280 2021-12-22 16:42 /user/iabd/flume/seqgen_data/flume-caso3-seqgen.1640187740937\n-rw-r--r--   1 iabd supergroup       1280 2021-12-22 16:42 /user/iabd/flume/seqgen_data/flume-caso3-seqgen.1640187740938\n-rw-r--r--   1 iabd supergroup       1280 2021-12-22 16:42 /user/iabd/flume/seqgen_data/flume-caso3-seqgen.1640187740939\n-rw-r--r--   1 iabd supergroup       1280 2021-12-22 16:42 /user/iabd/flume/seqgen_data/flume-caso3-seqgen.1640187740940\n-rw-r--r--   1 iabd supergroup       1280 2021-12-22 16:42 /user/iabd/flume/seqgen_data/flume-caso3-seqgen.1640187740941\n-rw-r--r--   1 iabd supergroup       1280 2021-12-22 16:42 /user/iabd/flume/seqgen_data/flume-caso3-seqgen.1640187740942\n</code></pre> <p>Y si comprobamos el contenido del primero (<code>hdfs dfs -cat /user/iabd/flume/seqgen_data/flume-caso3-seqgen.1640187740933</code>) veremos como contiene la secuencia generada:</p> <pre><code>0\n1\n2\n3\n...\n</code></pre>"},{"location":"hadoop/05flume.html#caso-3b-de-netcat-a-hdfs","title":"Caso 3b - De Netcat a HDFS","text":"<p>Ahora vamos a crear otro ejemplo de generaci\u00f3n de informaci\u00f3n, pero esta vez, en vez de utilizar la memoria del servidor como canal, vamos a utilizar el sistema de archivos. Adem\u00e1s, para generar la informaci\u00f3n nos basamos en una fuente Netcat, en la cual debemos especificar un puerto de escucha. Mediante esta fuente, Flume quedar\u00e1 a la escucha en dicho puerto y recibir\u00e1 cada l\u00ednea introducida como un evento individual que transferir\u00e1 al canal especificado.</p> <p>En este caso, vamos a utilizar un canal de tipo fichero para hacer los eventos durables, de manera que si se cayese Flume a mitad de una operaci\u00f3n, no se perder\u00edan los datos, y al volver a funcionar, el agente finalizar\u00e1 la ingesta.</p> <p>En el mismo directorio <code>$FLUME_HOME\\conf</code>, creamos un nuevo fichero con el nombre <code>netcat.conf</code> y creamos otro agente que se va a encargar de generar informaci\u00f3n:</p> netcat.conf<pre><code># Nombramos a los componentes del agente\nNetcatAgent.sources = Netcat\nNetcatAgent.channels = FileChannel\nNetcatAgent.sinks = HdfsSink\n# Describimos el origen netcat en localhost:44444\nNetcatAgent.sources.Netcat.type = netcat\nNetcatAgent.sources.Netcat.bind = localhost\nNetcatAgent.sources.Netcat.port = 44444\nNetcatAgent.sources.Netcat.channels = FileChannel\n# Describimos el destino en HDFS\nNetcatAgent.sinks.HdfsSink.type = hdfs\nNetcatAgent.sinks.HdfsSink.hdfs.path = hdfs://iabd-virtualbox:9000/user/iabd/flume/net_data/\nNetcatAgent.sinks.HdfsSink.hdfs.writeFormat = Text\nNetcatAgent.sinks.HdfsSink.hdfs.fileType = DataStream\nNetcatAgent.sinks.HdfsSink.channel = FileChannel\n# Unimos el origen y el destino a trav\u00e9s del canal de fichero\nNetcatAgent.channels.FileChannel.type = file\nNetcatAgent.channels.FileChannel.dataDir = /home/iabd/flume/data\nNetcatAgent.channels.FileChannel.checkpointDir = /home/iabd/flume/checkpoint\n</code></pre> <p>Eventos, ficheros y HDFS</p> <p>Al trabajar con HDFS, el fichero se mantendr\u00e1 abierto durante un tiempo (normalmente 30 segundos, lo podemos configurar mediante la propiedad <code>hdfs.rollInterval</code>), hasta que llegue a un determinado tama\u00f1o (por defecto 1024b, configurado <code>hdfs.rollSize</code>) o que haya escrito un determinado n\u00famero de eventos (por defecto 10, configurado mediante <code>hdfs.rollCount</code>).</p> <p>Mientras est\u00e1 abierto, se renombrar\u00e1 con el prefijo <code>_</code> y el sufijo <code>.tmp</code>. Al finalizar alguno de los criterios, volver\u00e1 a su nombre original y se cierra el fichero. </p> <p>Los nuevos eventos se escribir\u00e1n en un nuevo fichero.</p> <p>Lanzamos al agente:</p> <pre><code>./bin/flume-ng agent --conf ./conf/ --conf-file ./conf/netcat.conf \\\n--name NetcatAgent \\\n-Dflume.root.logger=INFO,console\n</code></pre> <p>En una nueva pesta\u00f1a introducimos el siguiente comando y escribimos</p> <pre><code>curl telnet://localhost:44444\n</code></pre> <p>Una vez conectados, escribimos varias frases con saltos de l\u00ednea. Por cada vez que pulsamos Enter, nos aparecer\u00e1 un <code>OK</code>.</p> <pre><code>Probando Netcat\nOK\nEsto parece que funciona m\u00e1s o menos\nOK\n</code></pre> <p>A continuaci\u00f3n, nos vamos al navegador web de HDFS (http://iabd-virtualbox:9870/explorer.html#/user/iabd/flume/net_data) y comprobamos que se ha creado el fichero:</p> Resultado del flujo Netcat-HDFS"},{"location":"hadoop/05flume.html#caso-4-flujos-encadenados","title":"Caso 4 - Flujos encadenados","text":"<p>Es muy com\u00fan definir un pipeline de flujos encadenados, uniendo la salida de un agente a la entrada de otro. Para ello, utilizaremos como enlace un sink-source de tipo Avro. Este dise\u00f1o tambi\u00e9n se conoce como flujo Multi-hop:</p> Encadenando flujos <p>En este caso, vamos a crear un primer agente (<code>NetcatAvroAgent</code>) que ingeste datos desde Netcat y los coloque en un sink de tipo Avro. Para ello, creamos el agente <code>netcat-avro.conf</code>:</p> netcat-avro.conf<pre><code># Nombramos a los componentes del agente\nNetcatAvroAgent.sources = Netcat\nNetcatAvroAgent.channels = FileChannel\nNetcatAvroAgent.sinks = AvroSink\n# Describimos el origen netcat en localhost:44444\nNetcatAvroAgent.sources.Netcat.type = netcat\nNetcatAvroAgent.sources.Netcat.bind = localhost\nNetcatAvroAgent.sources.Netcat.port = 44444\n# Describimos el destino como Avro en localhost:10003\nNetcatAvroAgent.sinks.AvroSink.type = avro\nNetcatAvroAgent.sinks.AvroSink.hostname = localhost\nNetcatAvroAgent.sinks.AvroSink.port = 10003\n# Unimos el origen y el destino a trav\u00e9s del canal de fichero\nNetcatAvroAgent.sources.Netcat.channels = FileChannel\nNetcatAvroAgent.sinks.AvroSink.channel = FileChannel\nNetcatAvroAgent.channels.FileChannel.type = file\nNetcatAvroAgent.channels.FileChannel.dataDir = /home/iabd/flume/data\nNetcatAvroAgent.channels.FileChannel.checkpointDir = /home/iabd/flume/checkpoint\n</code></pre> <p>A continuaci\u00f3n, creamos un segundo agente (<code>AvroHdfsAgent</code>) que utilice como fuente Avro capturando los datos desde el mismo host y puerto que el sink anterior, y que almacene los eventos recibidos en HDFS. Para ello, creamos el agente <code>avro-hdfs.conf</code>:</p> avro-hdfs.conf<pre><code># Nombramos a los componentes del agente\nAvroHdfsAgent.sources = AvroSource\nAvroHdfsAgent.channels = MemChannel\nAvroHdfsAgent.sinks = HdfsSink\n# Describimos el origen como Avro en localhost:10003\nAvroHdfsAgent.sources.AvroSource.type = avro\nAvroHdfsAgent.sources.AvroSource.bind = localhost\nAvroHdfsAgent.sources.AvroSource.port = 10003\n# Describimos el destino HDFS \nAvroHdfsAgent.sinks.HdfsSink.type = hdfs\nAvroHdfsAgent.sinks.HdfsSink.hdfs.path = /user/iabd/flume/avro_data/\nAvroHdfsAgent.sinks.HdfsSink.hdfs.fileType = DataStream\nAvroHdfsAgent.sinks.HdfsSink.hdfs.writeFormat = Text\n# Unimos el origen y el destino\nAvroHdfsAgent.sources.AvroSource.channels = MemChannel\nAvroHdfsAgent.sinks.HdfsSink.channel = MemChannel\nAvroHdfsAgent.channels.MemChannel.type = memory\n</code></pre> <p>Primero lanzamos este \u00faltimo agente, para que Flume quede a la espera de mensajes Avro en <code>localhost:10003</code>:</p> <pre><code>./bin/flume-ng agent --conf ./conf/ --conf-file ./conf/avro-hdfs.conf \\\n--name AvroHdfsAgent \\\n-Dflume.root.logger=INFO,console\n</code></pre> <p>Una vez ha arrancado, en nueva pesta\u00f1a, lanzamos el primer agente:</p> <pre><code>./bin/flume-ng agent --conf ./conf/ --conf-file ./conf/netcat-avro.conf \\\n--name NetcatAvroAgent \\\n-Dflume.root.logger=INFO,console\n</code></pre> <p>Finalmente, en otro terminal, escribimos mensajes Netcat accediendo a <code>curl telnet://localhost:44444</code>. Si acced\u00e9is a la carpeta <code>/user/iabd/flume/avro_data</code> en HDFS podremos comprobar c\u00f3mo se van creando archivos que agrupan los mensajes enviados.</p>"},{"location":"hadoop/05flume.html#caso-5-flujo-multi-agente","title":"Caso 5 - Flujo multi-agente","text":"<p>Para demostrar como varios agentes pueden conectarse entre s\u00ed, vamos a realizar un caso de uso donde leeremos informaci\u00f3n de tres fuentes distintas: una fuente de Netcat con un canal basado en ficheros, otra que realice spooling de una carpeta (vigila una carpeta y cuando haya alg\u00fan archivo, lo ingesta y lo renombra a\u00f1adi\u00e9ndole el sufijo <code>COMPLETED</code>) utilizando un canal en memoria y un tercero que ejecute un comando utilizando tambi\u00e9n un canal en memoria.</p> <p>Como agente de consolidaci\u00f3n que una la informaci\u00f3n de las tres fuentes de datos, vamos a reutilizar el agente AvroHdfsAgent que hemos creado en el caso de uso anterior.</p> Consolidando flujos <p>Para ello, vamos a definir los agentes en  siguiente fichero de configuraci\u00f3n <code>multiagent-avro.conf</code>):</p> multiagent-avro.conf<pre><code># Nombramos las tres fuentes con sus tres sumideros\nMultiAgent.sources = Netcat Spooldir Exec\nMultiAgent.channels = FileChannel MemChannel1 MemChannel2\nMultiAgent.sinks = AvroSink1 AvroSink2 AvroSink3\n# Describimos el primer agente\nMultiAgent.sources.Netcat.type = netcat\nMultiAgent.sources.Netcat.bind = localhost\nMultiAgent.sources.Netcat.port = 10004\n# Describimos el segundo agente\nMultiAgent.sources.Spooldir.type = spooldir\nMultiAgent.sources.Spooldir.spoolDir = /home/iabd/flume/spoolDir\n# Describimos el tercer agente\nMultiAgent.sources.Exec.type = exec\nMultiAgent.sources.Exec.command = cat /home/iabd/datos/empleados.txt\n# Describimos los tres destinos como Avro en localhost:10003\nMultiAgent.sinks.AvroSink1.type = avro\nMultiAgent.sinks.AvroSink1.hostname = localhost\nMultiAgent.sinks.AvroSink1.port = 10003\nMultiAgent.sinks.AvroSink2.type = avro\nMultiAgent.sinks.AvroSink2.hostname = localhost\nMultiAgent.sinks.AvroSink2.port = 10003\nMultiAgent.sinks.AvroSink3.type = avro\nMultiAgent.sinks.AvroSink3.hostname = localhost\nMultiAgent.sinks.AvroSink3.port = 10003\n# Describimos los canales\nMultiAgent.channels.FileChannel.type = file\nMultiAgent.channels.FileChannel.dataDir = /home/iabd/flume/data\nMultiAgent.channels.FileChannel.checkpointDir = /home/iabd/flume/checkpoint\nMultiAgent.channels.MemChannel1.type = memory\nMultiAgent.channels.MemChannel2.type = memory\n# Unimos los or\u00edgenes y destinos\nMultiAgent.sources.Netcat.channels = FileChannel\nMultiAgent.sources.Spooldir.channels = MemChannel1\nMultiAgent.sources.Exec.channels = MemChannel2\nMultiAgent.sinks.AvroSink1.channel = FileChannel\nMultiAgent.sinks.AvroSink2.channel = MemChannel1\nMultiAgent.sinks.AvroSink3.channel = MemChannel2\n</code></pre> <p>Preparaci\u00f3n</p> <p>Antes de arrancar los agentes, aseg\u00farate de tener creada la carpeta <code>/home/iabd/flume/spoolDir</code> y disponible el recurso <code>/home/iabd/datos/empleados.txt</code>.</p> <p>Igual que en el caso de uso anterior, primero lanzamos el agente consolidador para que Flume quede a la espera de mensajes Avro en <code>localhost:10003</code>:</p> <pre><code>./bin/flume-ng agent --conf ./conf/ --conf-file ./conf/avro-hdfs.conf \\\n--name AvroHdfsAgent \\\n-Dflume.root.logger=INFO,console\n</code></pre> <p>Una vez ha arrancado, en una nueva pesta\u00f1a, lanzamos el multi agente:</p> <pre><code>./bin/flume-ng agent --conf ./conf/ --conf-file ./conf/multiagent-avro.conf \\\n--name MultiAgent \\\n-Dflume.root.logger=INFO,console\n</code></pre> <p>Interceptores</p> <p>Podemos utilizar interceptores para modificar o borrar eventos al vuelo a partir del timestamp, nombre del host, uuid, etc... incluso mediante el uso de una expresi\u00f3n regular. Si quieres profundizar en el tema, el siguiente art\u00edculo detalla los diferentes tipos y configuraciones: https://data-flair.training/blogs/flume-interceptors/</p> <p>En este caso, para poder probarlo, adem\u00e1s de enviar comandos Netstat en <code>curl telnet://localhost:10004</code>, prueba a colocar un archivo de texto (por ejemplo, un documento CSV) en <code>/home/iabd/flume/spoolDir</code>.</p>"},{"location":"hadoop/05flume.html#referencias","title":"Referencias","text":"<ul> <li>P\u00e1gina oficial de Sqoop</li> <li>Sqoop User Guide</li> <li>Sqoop Tutorial en Tutorialspoint</li> <li>Apache Sqoop Cookbook, de Kathleen Ting, Jarek Jarcec Cecho</li> <li>P\u00e1gina oficial de Flume</li> <li>Flume User Guide</li> </ul>"},{"location":"hadoop/05flume.html#actividades","title":"Actividades","text":"<p>Preparaci\u00f3n MariaBD</p> <p>Para estos actividades y futuras sesiones, vamos a utilizar una base de datos (retail_db) que contiene informaci\u00f3n sobre un comercio (clientes, productos, pedidos, etc...).</p> <p>Para ello, descargaremos el archivo create_db.sql con las sentencias para crear la base de datos y los datos como instrucciones SQL.</p> <p>Tras ello, si nos conectamos a MariaDB (<code>mariadb -u iabd -p</code>) desde la misma carpeta que hemos descargado el archivo, ejecutaremos los siguientes comando:</p> <pre><code>create database retail_db;\nuse retail_db;\nsource create_db.sql;\nshow tables;\n</code></pre> <ol> <li> <p>(RA5074.3 / CE4.3a y CE4.3b / 1p) Haciendo uso de Sqoop y la base de datos retail_db, importa:</p> <ol> <li> <p>Todos los pedidos de la tabla <code>orders</code> cuyo campo <code>order_status</code> sea <code>COMPLETE</code>.</p> <p>Coloca los datos en <code>user/iabd/sqoop/orders/datos_parquet</code> en formato Parquet, utilizando el tabulador como delimitador de campos y utilizando la compresi\u00f3n Snappy. Deber\u00e1s recuperar 22.899 (\u00bfo 22.902?) registros.</p> </li> <li> <p>Todos los clientes de la tabla <code>customers</code> cuyo campo <code>state</code> sea <code>CA</code>.</p> <p>Coloca los datos en <code>user/iabd/sqoop/customers/datos_avro</code> en formato Avro,  utilizando la compresi\u00f3n bzip2. Deber\u00e1s recuperar las columnas <code>customer_id, customer_fname, customer_lname, customer_state</code>. El resultado contendr\u00e1 2012 registros.</p> </li> </ol> </li> <li> <p>(RA5074.3 / CE4.3a y CE4.3b / 2p) Mediante Flume, realiza los caso de uso 3, 4 y 5.</p> </li> <li> <p>(RA5074.3 / CE4.3a, CE4.3b y CE4.3c / 1p) Haciendo uso de Flume, recupera informaci\u00f3n de Twitter y almac\u00e9nala en HDFS. Para ello, utiliza el Twitter 1% Firehouse source y el HDFS sink.</p> <p>Para ello, necesitar\u00e9is las claves de desarrollo de Twitter. Adjunta una captura de pantalla donde se visualice el contenido de uno de los bloques de HDFS.</p> <p>Cuidado con el espacio de almacenamiento</p> <p>Una vez lances el agente, p\u00e1ralo a los tres segundos para no llenar de datos HDFS.</p> <p>Cloudera tiene su propia librer\u00eda para acceder a Twitter donde podemos configurar qu\u00e9 mensajes descargar. Puedes consultar un ejemplo completo aqu\u00ed.</p> </li> </ol>"},{"location":"hadoop/06hive.html","title":"Hive","text":"<p>Apache Hive (https://hive.apache.org/) es una tecnolog\u00eda distribuida dise\u00f1ada y construida sobre un cl\u00faster de Hadoop. Permite leer, escribir y gestionar grandes datasets (con escala de petabytes) que residen en HDFS haciendo uso de un lenguaje dialecto de SQL, conocido como HiveSQL, lo que simplifica mucho el desarrollo y la gesti\u00f3n de Hadoop.</p> Logo de Apache Hive <p>El proyecto lo inici\u00f3 Facebook para conseguir que la interacci\u00f3n con Hadoop fuera similar a la que se realiza con un datawarehouse tradicional. La tecnolog\u00eda Hadoop es altamente escalable, aunque hay que destacar su dificultad de uso y que est\u00e1 orientado \u00fanicamente a operaciones batch, con lo que no soporta el acceso aleatorio ni est\u00e1 optimizado para ficheros peque\u00f1os.</p>"},{"location":"hadoop/06hive.html#hive-y-hadoop","title":"Hive y Hadoop","text":"<p>Si volvemos a ver como casa Hive dentro del ecosistema de Hadoop, Hive es una fachada construida sobre Hadoop que permite acceder a los datos almacenados en HDFS de forma muy sencilla sin necesidad de conocer Java, Map Reduce u otras tecnolog\u00edas.</p> <p>Aunque en principio estaba dise\u00f1ado para el procesamiento batch, ahora se integra con frameworks en streaming como Tez y Spark.</p> Ecosistema Hadoop"},{"location":"hadoop/06hive.html#caracteristicas","title":"Caracter\u00edsticas","text":"<p>Hive impone una estructura sobre los datos almacenados en HDFS. Esta estructura se conoce como Schema, y Hive la almacena en su propia base de datos (metastore). Gracias a ella, optimiza de forma autom\u00e1tica el plan de ejecuci\u00f3n y usa particionado de tablas en determinadas consultas. Tambi\u00e9n soporta diferentes formatos de ficheros, codificaciones y fuentes de datos como HBase.</p> <p>Para interactuar con Hive utilizaremos HiveQL, el cual es un dialecto de SQL (recuerda que SQL no es sensible a las may\u00fasculas, excepto en la comparaci\u00f3n de cadenas).</p> <p>Hive ampl\u00eda el paradigma de SQL incluyendo formatos de serializaci\u00f3n. Tambi\u00e9n podemos personalizar el procesamiento de consultas creando un esquema de tabla acorde con nuestros datos, pero sin tocar los datos. Aunque SQL solo es compatible con tipos de valor primitivos (como fechas, n\u00fameros y cadenas), los valores de las tablas de Hive son elementos estructurados, por ejemplo, objetos JSON o cualquier tipo de datos definido por el usuario o cualquier funci\u00f3n escrita en Java.</p> <p>Una consulta t\u00edpica en Hive se ejecuta en varios datanodes en paralelo, con varios trabajos MapReduce asociados. Estas operaciones son de tipo batch, por lo que la latencia es m\u00e1s alta que en otros tipos de bases de datos. Adem\u00e1s, hay que considerar el retardo producido por la inicializaci\u00f3n de los trabajos, sobre todo en el caso de consultar peque\u00f1os datasets.</p>"},{"location":"hadoop/06hive.html#ventajas","title":"Ventajas","text":"<p>Las ventajas de utilizar Hive son:</p> <ul> <li>Reduce la complejidad de la programaci\u00f3n MapReduce al usar HiveQL como lenguaje de consulta.</li> <li>Est\u00e1 orientado a aplicaciones de tipo Data Warehouse, con datos est\u00e1ticos, poco cambiantes y sin requisitos de tiempos de respuesta r\u00e1pidos.</li> <li>Permite a los usuarios despreocuparse de en qu\u00e9 formato y d\u00f3nde se almacenan los datos.</li> <li>Incorpora Beeline: una herramienta por l\u00ednea de comandos para realizar consultas con HiveQL.</li> </ul> <p>En cambio, Hive no es la mejor opci\u00f3n para consultas en tiempo real o de tipo transaccional. Adem\u00e1s, no est\u00e1 dise\u00f1ado para usarse con actualizaciones de valores al nivel de registro, y el soporte de SQL es limitado.</p>"},{"location":"hadoop/06hive.html#alternativas","title":"Alternativas","text":"<p>Una de las alternativas m\u00e1s populares es Apache Impala, originalmente creado por Cloudera, el cual utiliza un demonio dedicado en cada datanode del cl\u00faster, de manera que hay un coordinador que reenv\u00eda a cada datanode la consulta a realizar y luego se encarga de unir los datos en el resultado final. Impala utiliza el metastore de Hive y soporta la mayor\u00eda de construcciones de Hive, con lo que la migraci\u00f3n de un sistema a otro es sencilla.</p> <p>En lugar de utilizar MapReduce, aprovecha un motor de procesamiento masivo en paralelo (MPP) como el que existe en los sistemas gestores de bases de datos relacionales (RDBMS). Esta arquitectura hace que Impala sea adecuado para an\u00e1lisis interactivos y de baja latencia.</p> <p>Otras alternativas open source son :</p> <ul> <li>Presto de Facebook y Apache Drill, con arquitecturas muy similares a Impala.</li> <li>Spark SQL: utiliza Spark como motor de ejecuci\u00f3n y permite utilizar consultas SQL embebidas. La estudiaremos en sesiones futuras.</li> </ul> <p>Pig</p> <p>Apache Pig es una herramienta que abstrae el acceso a MapReduce de forma similar a como lo realiza Hive, pero en vez de SQL, utiliza su propio lenguaje de scripting (PigLatin) para expresar los flujos de datos. Actualmente ha perdido uso en detrimento de Hive/Impala y de Spark.</p> <p>Ten\u00e9is una peque\u00f1a introducci\u00f3n en https://www.analyticsvidhya.com/blog/2021/08/an-introduction-to-apache-pig-for-absolute-beginners/.</p>"},{"location":"hadoop/06hive.html#componentes","title":"Componentes","text":"<p>A continuaci\u00f3n podemos ver un gr\u00e1fico que relaciona los diferentes componentes de Hive y define su arquitectura:</p> Arquitectura de Apache Hive"},{"location":"hadoop/06hive.html#hive-server","title":"Hive Server","text":"<p>HiveServer 2 (HS2) es la \u00faltima versi\u00f3n del servicio. Se compone de una interfaz que permite a clientes externos ejecutar consultas contra Apache Hive y obtener los resultados. Est\u00e1 basado en Thrift RPC y soporta clientes concurrentes. Para arrancar el servidor, ejecutaremos el comando <code>hiveserver2</code>, el cual quedar\u00e1 a la escucha en el puerto <code>10000</code>.</p> <pre><code>iabd@iabd-virtualbox:~$ hiveserver2\n2023-01-20 09:39:51: Starting HiveServer2\nSLF4J: Class path contains multiple SLF4J bindings.\nSLF4J: ...\nHive Session ID = 9e39b0c8-45a6-46ca-bfb0-6e320c85f989\n</code></pre> <p>A este servidor nos conectaremos mediante la herramienta Beeline (Beeline CLI).</p>"},{"location":"hadoop/06hive.html#hive-metastore","title":"Hive Metastore","text":"<p>Es el repositorio central para los metadatos de Hive, y se almacena en una base de datos relacional como MySQL, PostgreSQL o Apache Derby (embebida). Mantiene los metadatos, las tablas y sus tipos mediante Hive DDL (Data Definition Language). Adem\u00e1s, el sistema se puede configurar para que tambi\u00e9n almacene estad\u00edsticas de las operaciones y registros de autorizaci\u00f3n para optimizar las consultas.</p> <p>En las \u00faltimas versiones de Hive, este componente se puede desplegar de forma remota e independiente, para no compartir la misma JVM con HiveServer. Dentro del metastore podemos encontrar el Hive Catalog (HCatalog), que permite acceder a sus metadatos, actuando como una API. Al poder desplegarse de forma aislada e independiente, permite que otras aplicaciones hagan uso del schema sin tener que desplegar el motor de consultas de Hive. En la sesi\u00f3n de Spark Catalog, veremos c\u00f3mo desde una herramienta externa a Hive, se accede y utilizan los metadatos almacenados.</p> <p>As\u00ed pues, al Metastore podremos acceder mediante HiveCLI, o a trav\u00e9s del Hive Server mediante una conexi\u00f3n remota mediante Beeline.</p>"},{"location":"hadoop/06hive.html#beeline","title":"Beeline","text":"<p>Hive incorpora Beeline, el cual act\u00faa como un cliente basado en JDBC para hacer consultas por l\u00ednea de comandos contra el Hive Server, sin necesitar las dependencias de Hive, mediante el comando <code>beeline</code>:</p> <pre><code>iabd@iabd-virtualbox:~$ beeline\nSLF4J: Class path contains multiple SLF4J bindings.\nSLF4J: ...\nBeeline version 3.1.2 by Apache Hive\nbeeline&gt; </code></pre> <p>Por otro lado, tambi\u00e9n podemos utilizar Hive CLI, un cliente basado en Apache Thrift, que usa los mismos drivers que Hive.</p> <p>Apache Tez y Spark</p> <p>Hive 3 deja de soportar MapReduce. Apache Tez lo reemplaza como el motor de ejecuci\u00f3n por defecto, de manera que mejora el rendimiento y se ejecuta sobre Hadoop Yarn, que encola y planifica los trabajos en el cl\u00faster. Adem\u00e1s de Tez, Hive tambi\u00e9n puede utilizar Apache Spark como motor de ejecuci\u00f3n.</p> <p>Para indicar que queremos ejecutar Tez como motor de ejecuci\u00f3n, ejecutar\u00edamos el siguiente comando:</p> <pre><code>SET hive.execution.engine=tez;\n</code></pre> <p>En nuestro caso no tenemos Tez instalado en la m\u00e1quina virtual, quedando fuera del alcance del presente curso.</p> <p>Conviene distinguir que Spark SQL no tiene nada que ver con utilizar el motor de ejecuci\u00f3n de Spark dentro de Hive. Al utilizar el motor de Hive, podemos hacer un uso completo de las caracter\u00edsticas de Hive, mientras que Spark SQL es un motor diferente que ofrece una alta compatibilidad con Hive, pero tiene sus particularidades.</p>"},{"location":"hadoop/06hive.html#tipos-de-datos","title":"Tipos de datos","text":"<p>Los tipos de datos que podemos emplear en Hive son muy similares a los que se utilizan en el DDL de SQL. Los tipos simples m\u00e1s comunes son <code>STRING</code> e <code>INT</code>, aunque podemos utilizar otros tipos como <code>TINYINT</code>, <code>BIGINT</code>, <code>DOUBLE</code>, <code>DATE</code>, <code>TIMESTAMP</code>, etc...</p> <p>Para realizar una conversi\u00f3n explicita de tipos, por ejemplo de un tipo texto a uno num\u00e9rico, hay que utilizar la funci\u00f3n <code>CAST</code>:</p> <pre><code>select CAST('1' as INT) from tablaPruebas;\n</code></pre> <p>Respecto a los tipos compuestos, tenemos tres tipos:</p> <ul> <li>arrays mediante el tipo <code>ARRAY</code>, para agrupar elementos del mismo tipo: <code>[\"manzana\", \"pera\", \"naranja]</code>.</li> <li>mapas mediante el tipo <code>MAP</code>, para definir parejas de clave-valor: <code>{1: \"manzana\", 2: \"pera\"}</code></li> <li>estructuras mediante el tipo <code>STRUCT</code>, para definir estructuras con propiedades: <code>{\"fruta\": \"manzana\", \"cantidad\": 1, \"tipo\": \"postre\"}</code>.</li> </ul>"},{"location":"hadoop/06hive.html#instalacion-y-configuracion","title":"Instalaci\u00f3n y configuraci\u00f3n","text":"<p>M\u00e1quina virtual</p> <p>Los siguientes pasos no son necesarios ya que nuestra m\u00e1quina virtual ya tiene Hive instalado y configurado correctamente. Si quieres hacer tu propia instalaci\u00f3n sigue los siguientes pasos de la documentaci\u00f3n oficial.</p> <p>Una vez instalado vamos a configurarlo. Para ello, debemos crear los ficheros de configuraci\u00f3n a partir de las plantilla que ofrece Hive. Para ello, desde la carpeta <code>$HIVE_HOME/conf</code>, ejecutaremos los siguientes comandos:</p> <pre><code>cp hive-default.xml.template hive-site.xml\ncp hive-env.sh.template hive-env.sh\ncp hive-exec-log4j2.properties.template hive-exec-log4j2.properties\ncp hive-log4j2.properties.template hive-log4j2.properties\n</code></pre> <p>Modificamos el fichero <code>hive.env.sh</code> para incluir dos variables de entorno con las rutas de Hadoop y la configuraci\u00f3n de Hive</p> hive.env.sh<pre><code>export HADOOP_HOME=/opt/hadoop-3.3.1\nexport HIVE_CONF_DIR=/opt/hive-3.1.2/conf\n</code></pre> <p>Para que funcione la ingesta de datos en Hive mediante Sqoop, necesitamos a\u00f1adir una librer\u00eda a Sqoop:</p> <pre><code>cp $HIVE_HOME/lib/hive-common-3.1.2.jar $SQOOP_HOME/lib\n</code></pre> <p>Y configuramos las variables de entorno de nuestro path para exportar las rutas de Hive y del metastore:</p> ~/.bashrc<pre><code>export HIVE_HOME=/opt/hive-3.1.2\nexport HIVE_CONF_DIR=$HIVE_HOME/conf\nexport HCAT_HOME=$HIVE_HOME/hcatalog\n</code></pre> <p>A continuaci\u00f3n, preparamos HDFS para crear la estructura de archivos:</p> <pre><code>hdfs dfs -mkdir /tmp\nhdfs dfs -mkdir -p /user/hive/warehouse\nhdfs dfs -chmod g+w /tmp\nhdfs dfs -chmod g+w /user/hive/warehouse\n</code></pre> <p>Para el metastore, como en nuestra m\u00e1quina virtual tenemos un servidor de MariaDB corriendo, vamos a reutilizarlo. La mayor\u00eda de ejemplos que hay en internet y la diferente bibliograf\u00eda, utilizan DerbyDB como almac\u00e9n (ya que no requiere una instalaci\u00f3n extra). As\u00ed pues, creamos el almac\u00e9n mediante:</p> <pre><code>schematool -dbType mysql -initSchema\n</code></pre> <p>Modificamos el fichero de configuraci\u00f3n <code>hive-site.xml</code> y configuramos :</p> hive-site.xml<pre><code>&lt;!-- nuevas propiedades --&gt;\n&lt;property&gt;\n&lt;name&gt;system:java.io.tmpdir&lt;/name&gt;\n&lt;value&gt;/tmp/hive/java&lt;/value&gt;\n&lt;/property&gt;\n&lt;property&gt;\n&lt;name&gt;system:user.name&lt;/name&gt;\n&lt;value&gt;${user.name}&lt;/value&gt;\n&lt;/property&gt;\n&lt;property&gt;\n&lt;name&gt;datanucleus.schema.autoCreateAll&lt;/name&gt;\n&lt;value&gt;true&lt;/value&gt;\n&lt;/property&gt;\n&lt;!-- propiedades existentes a modificar --&gt;\n&lt;property&gt;\n&lt;name&gt;javax.jdo.option.ConnectionURL&lt;/name&gt;\n&lt;value&gt;jdbc:mysql://localhost:3306/hive?createDatabaseIfNotExist=true&lt;/value&gt;\n&lt;/property&gt;\n&lt;property&gt;\n&lt;name&gt;javax.jdo.option.ConnectionDriverName&lt;/name&gt;\n&lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt;\n&lt;/property&gt;\n&lt;property&gt;\n&lt;name&gt;javax.jdo.option.ConnectionUserName&lt;/name&gt;\n&lt;value&gt;iabd&lt;/value&gt;\n&lt;/property&gt;\n&lt;property&gt;\n&lt;name&gt;javax.jdo.option.ConnectionPassword&lt;/name&gt;\n&lt;value&gt;iabd&lt;/value&gt;\n&lt;/property&gt;\n</code></pre>"},{"location":"hadoop/06hive.html#hola-mundo","title":"Hola Mundo","text":"<p>Si entramos a nuestro <code>$HIVE_HOME</code> podemos comprobar con tenemos las siguientes herramientas:</p> <ul> <li><code>hive</code>: Herramienta cliente</li> <li><code>beeline</code>: Otra herramienta cliente</li> <li><code>hiserver2</code>: Nos permite arrancar el servidor de Hive</li> <li><code>schematool</code>: Nos permite trabajar contra la base de datos de metadatos (Metastore)</li> </ul> <p>Una vez arrancado Hadoop y YARN, vamos a arrancar Hive mediante el cliente local:</p> <pre><code>hive\n</code></pre> <p>Y una vez dentro, podemos comprobar las bases de datos existentes para ver que todo se configur\u00f3 correctamente</p> <pre><code>show databases;\n</code></pre> <p>Si quisi\u00e9ramos ejecutar un script, podemos hacerlo desde el propio comando <code>hive</code> con la opci\u00f3n <code>-f</code>:</p> <pre><code>hive -f script.sql\n</code></pre> <p>Adem\u00e1s, tenemos la opci\u00f3n de pasar una consulta desde la propia l\u00ednea de comandos mediante la opci\u00f3n <code>-e</code>. Supongamos que queremos recuperar los datos de la tabla <code>categories</code> de la base de datos <code>iabd</code> har\u00edamos:</p> <pre><code>hive -e 'select * from iabd.categories'\n</code></pre>"},{"location":"hadoop/06hive.html#acceso-remoto","title":"Acceso remoto","text":"<p>HiveServer2 (desde Hive 0.11) tiene su propio cliente conocido como Beeline. En entornos reales, el cliente Hive est\u00e1 en desuso a favor de Beeline, por la falta de m\u00faltiples usuarios, seguridad y otras caracter\u00edsticas de HiveServer2.</p> <p>Arrancamos HiveServer2 (lo har\u00e1 en el puerto <code>10000</code>) y Beeline en dos pesta\u00f1as diferentes mediante los comandos <code>hiveserver2</code> y <code>beeline</code>. Una vez dentro de Beeline, tras esperar unos segundos a que HiveServer2 haya arrancando completamente, nos conectamos al servidor:</p> <pre><code>!connect jdbc:hive2://iabd-virtualbox:10000\n</code></pre> <p>Al conectarnos, tras introducir <code>iabd</code> como usuario y contrase\u00f1a, obtendremos un interfaz similar al siguiente:</p> <pre><code>Beeline version 3.1.2 by Apache Hive\nbeeline&gt; !connect jdbc:hive2://iabd-virtualbox:10000\nConnecting to jdbc:hive2://iabd-virtualbox:10000\nEnter username for jdbc:hive2://iabd-virtualbox:10000: iabd\nEnter password for jdbc:hive2://iabd-virtualbox:10000: ****\nConnected to: Apache Hive (version 3.1.2)\nDriver: Hive JDBC (version 3.1.2)\nTransaction isolation: TRANSACTION_REPEATABLE_READ\n0: jdbc:hive2://iabd-virtualbox:10000&gt;\n</code></pre> <p>Dentro de Beeline, en cualquier momento podemos ejecutar el comando <code>help</code> que nos mostrar\u00e1 todos los comandos disponibles. Si nos fijamos, adem\u00e1s de las comandos del cliente hive, tenemos los comandos beeline que empiezan por el s\u00edmbolo de exclamaci\u00f3n <code>!</code>:</p> <pre><code>0: jdbc:hive2://iabd-virtualbox:10000&gt; help\n!addlocaldriverjar  Add driver jar file in the beeline client side.\n!addlocaldrivername Add driver name that needs to be supported in the beeline\n                    client side.\n!all                Execute the specified SQL against all the current connections\n!autocommit         Set autocommit mode on or off\n!batch              Start or execute a batch of statements\n...\n</code></pre> <p>Otra forma de trabajar, para arrancar en el mismo proceso Beeline y HiveServer2 para pruebas/desarrollo y tener una experiencia similar al cliente Hive accediendo de forma local, podemos ejecutar el siguiente comando donde indicamos tanto el usuario (<code>-n</code>) como la contrase\u00f1a (<code>-p</code>):</p> <pre><code>beeline -u jdbc:hive2://iabd-virtualbox:10000 -n iabd -p iabd\n</code></pre> <p>Mediante la interfaz gr\u00e1fica de Hive Server UI a la cual podemos acceder mediante http://localhost:10002 podemos monitorizar los procesos ejecutados por HiveServer2:</p> Monitorizaci\u00f3n mediante Hive Server UI"},{"location":"hadoop/06hive.html#caso-de-uso-1-creacion-y-borrado-de-tablas","title":"Caso de uso 1: Creaci\u00f3n y borrado de tablas","text":"<p>Para este caso de uso, vamos a utilizar la base de datos <code>retail_db</code> que ya utilizamos en las actividades de la sesi\u00f3n anterior.</p> <p>Para empezar, vamos a cargar en HDFS los datos de los clientes que contiene la tabla <code>customer</code>. Mediante Sqoop, ejecutamos el siguiente comando:</p> <pre><code>sqoop import --connect \"jdbc:mysql://localhost/retail_db\" \\\n--username iabd --password iabd \\\n--table customers --target-dir /user/iabd/hive/customer \\\n--fields-terminated-by '|' --delete-target-dir \\\n--columns \"customer_id,customer_fname,customer_lname,customer_city\"\n</code></pre> <p>Si comprobamos el contenido en HDFS, veremos c\u00f3mo se han cargado los datos:</p> <pre><code>hdfs dfs -head /user/iabd/hive/customer/part-m-00000\n# 1|Richard|Hernandez|Brownsville\n# 2|Mary|Barrett|Littleton\n# 3|Ann|Smith|Caguas\n# 4|Mary|Jones|San Marcos\n...\n</code></pre> <p>A continuaci\u00f3n, tras habernos conectado con el cliente <code>hive</code> o mediante <code>beeline</code>, creamos una base de datos llamada <code>iabd</code>:</p> <pre><code>create database if not exists iabd;\n</code></pre> <p>Nos conectamos a la base de datos que acabamos de crear:</p> <pre><code>use iabd;\n</code></pre> <p>default</p> <p>Si olvidamos el comando <code>use</code>, se utilizar\u00e1 la base de datos <code>default</code>, la cual reside en <code>/user/hive/warehouse</code> como ra\u00edz en HDFS.</p> <p>A continuaci\u00f3n, vamos a crear una tabla que almacene el identificador, nombre, apellido y ciudad de los clientes (como puedes observar, la sintaxis es similar a SQL):</p> <pre><code>CREATE TABLE customers\n(\ncustId INT,\nfName STRING,\nlName STRING,\ncity STRING\n)\nROW FORMAT DELIMITED  -- (1)!\nFIELDS TERMINATED BY '|'  -- (2)!\nSTORED AS TEXTFILE  -- (3)!\nLOCATION '/user/iabd/hive/customer';  -- (4)!\n</code></pre> <ol> <li>Indica el formato de cada fila como delimitado (con un salto del l\u00ednea)</li> <li>Los campos est\u00e1n separados por el car\u00e1cter <code>|</code> (es el mismo que hab\u00edamos indicado en Sqoop)</li> <li>El contenido est\u00e1 almacenado en HDFS en formato texto</li> <li>Ruta de HDFS donde se encuentran los datos</li> </ol> <p>Y ya podemos realizar algunas consultas:</p> <pre><code>select * from customers limit 5;\nselect count(*) from customers;\n</code></pre> <p>Utilizando Hue</p> <p>Si no queremos conectarnos mediante Beeline, siempre podemos utilizar Hue como un entorno m\u00e1s amigable. Recuerda que para acceder desde la m\u00e1quina virtual necesitas arrancarlo previamente mediante <code>/opt/hue-4.10.0/build/env/bin/hue runserver</code>.</p> <p>Una vez dentro, podemos realizar las consultas u operaciones de creaci\u00f3n de tablas, etc...</p> <p> Consultas Hive desde Hue </p> <p>En ocasiones necesitamos almacenar la salida de una consulta Hive en una nueva tabla. Las definiciones de las columnas de la nueva tabla se deriva de las columnas recuperadas en la consulta. Para ello, usaremos el comando create table-as select:</p> <pre><code>CREATE TABLE customers_new as SELECT * from customers;\n</code></pre> <p>En el caso de que la consulta falle por alg\u00fan motivo, la tabla no se crear\u00eda.</p> <p>Otra posibilidad es crear una tabla con la misma estructura que otra ya existente (pero sin datos):</p> <pre><code>CREATE TABLE customers2 LIKE customers;\n</code></pre> <p>En cualquier momento podemos obtener informaci\u00f3n de la tabla:</p> <pre><code>describe customers_new;\ndescribe formatted customers_new;\n</code></pre> <p>Si empleamos la forma larga, obtendremos mucha m\u00e1s informaci\u00f3n. Por ejemplo, si nos fijamos, vemos que la localizaci\u00f3n de la nueva tabla ya no es <code>/user/iabd/hive/customer</code> sino <code>hdfs://iabd-virtualbox:9000/user/hive/warehouse/iabd.db/customers_new</code>. Esto se debe a que en vez de crear una tabla enlazada a un recurso de HDFS ya existente, ha creado una copia de los datos en el propio almac\u00e9n de Hive (hemos pasado de una tabla externa a una interna).</p> <p>Igual que las creamos, las podemos eliminar:</p> <pre><code>drop table customers_new;\ndrop table customers2;\n</code></pre> <p>Si ejecutamos el comando <code>!tables</code> (o <code>show tables</code> en el cliente <code>hive</code>) veremos que ya no aparecen dichas tablas.</p> <p>En el caso de que queramos eliminar una base de datos, de la misma manera que en SQL, ejecutar\u00edamos el comando <code>drop database iabd</code>. Si nuestra base de datos contiene tablas y las queremos borrar igualmente, entonces necesitamos un borrado en cascada mediante <code>drop database iabd cascade</code>.</p>"},{"location":"hadoop/06hive.html#caso-de-uso-2-insertando-datos","title":"Caso de uso 2: Insertando datos","text":"<p>Para insertar datos en las tablas de Hive podemos hacerlo de varias formas:</p> <ul> <li>Cargando los datos mediante sentencias <code>LOAD DATA</code>.</li> <li>Insertando los datos mediante sentencias <code>INSERT</code>.</li> <li>Cargando los datos directamente mediante Sqoop o alguna herramienta similar.</li> </ul>"},{"location":"hadoop/06hive.html#cargando-datos","title":"Cargando datos","text":"<p>Para cargar datos se utiliza la sentencia <code>LOAD DATA</code>. Si quisi\u00e9ramos volver a cargar los datos desde HDFS utilizaremos:</p> <pre><code>LOAD DATA INPATH '/user/iabd/hive/customer'\noverwrite into table customers;\n</code></pre> <p>Si en cambio vamos a cargar los datos desde un archivo local a nuestro sistema de archivos a\u00f1adiremos <code>LOCAL</code>:</p> <pre><code>LOAD DATA LOCAL INPATH '/home/iabd/datos'\noverwrite into table customers;\n</code></pre>"},{"location":"hadoop/06hive.html#insertando-datos","title":"Insertando datos","text":"<p>Aunque podemos insertar datos de forma at\u00f3mica (es decir, registro a registro mediante <code>INSERT INTO [TABLE] ... VALUES</code>), realmente las inserciones que se realizan en Hive se hacen a partir de los datos de otras tablas mediante el comando insert-select a modo de ETL:</p> <pre><code>INSERT INTO destino\nSELECT col1, col2 FROM fuente;\nINSERT OVERWRITE destino\nSELECT col1, col2 FROM fuente;\n</code></pre> <p>Mediante la opci\u00f3n <code>OVERWRITE</code>, en cada ejecuci\u00f3n se vac\u00eda la tabla y se vuelve a rellenar. Si no lo indicamos o utilizamos <code>INTO</code>, los datos se a\u00f1adir\u00edan a los ya existentes.</p> <p>Por ejemplo, vamos a crear una nueva tabla de clientes, pero la vamos a almacenar en formato Parquet:</p> <pre><code>CREATE TABLE customersp\n(\ncustId INT,\nfName STRING,\nlName STRING,\ncity STRING\n)\nSTORED AS PARQUET;\n</code></pre> <p>Y a continuaci\u00f3n la cargamos con los datos de la tabla <code>customers</code>:</p> <pre><code>INSERT INTO customersp SELECT * FROM customers;\n</code></pre> <p>Rendimiento</p> <p>Prueba a realizar una consulta que cuente la cantidad de clientes en cada una de las tablas \u00bfCu\u00e1l tarda menos? \u00bfPor qu\u00e9?</p> <p>Si necesitamos insertar datos en m\u00faltiples tablas a la vez lo haremos mediante el comando from-insert, ya que ofrece un mejor rendimiento al s\u00f3lo necesitar un escaneado de los datos:</p> <pre><code>FROM fuente\nINSERT OVERWRITE TABLE destino1\nSELECT col1, col2\nINSERT OVERWRITE TABLE destino2\nSELECT col1, col3\n</code></pre> <p>Por ejemplo, vamos a crear un par de tablas con la misma estructura de clientes, pero para almacenar los clientes de determinadas ciudades:</p> <pre><code>CREATE TABLE customers_brooklyn LIKE customers;\nCREATE TABLE customers_caguas LIKE customers;\n</code></pre> <p>Y a continuaci\u00f3n rellenamos ambas tablas con sus clientes;</p> <pre><code>FROM customers\nINSERT OVERWRITE TABLE customers_brooklyn\nSELECT custId, fName, lName, city WHERE city = \"Brooklyn\"\nINSERT OVERWRITE TABLE customers_caguas\nSELECT custId, fName, lName, city WHERE city = \"Caguas\";\n</code></pre>"},{"location":"hadoop/06hive.html#modificando-datos","title":"Modificando datos","text":"<p>Acabamos de a\u00f1adir datos, y en teor\u00eda podemos realizar operaciones <code>UPDATE</code> y <code>DELETE</code> sobre las filas de una tabla.</p> <p>HDFS no se dise\u00f1\u00f3 pensando en las modificaciones de archivos, con lo que los cambios resultantes de las inserciones, modificaciones y borrados se almacenan en archivos delta. Por cada transacci\u00f3n, se crea un conjunto de archivo delta que altera la tabla (o partici\u00f3n). Los ficheros delta se fusionan peri\u00f3dicamente con los ficheros base de las tablas mediante jobs MapReduce que el metastore ejecuta en background.</p> <p>Para poder modificar o borrar los datos, Hive necesita trabajar en un contexto transaccional, por lo que necesitamos activar las siguientes variables:</p> <pre><code>set hive.support.concurrency=true;\nset hive.enforce.bucketing=true;\nset hive.exec.dynamic.partition.mode=nonstrict;\nset hive.txn.manager=org.apache.hadoop.hive.ql.lockmgr.DbTxnManager;\n</code></pre> <p>Una vez configurado, hemos de crear las tablas con el formato ORC y organizar los datos mediante buckets (los estudiaremos m\u00e1s adelante en esta misma sesi\u00f3n). Por ejemplo, volvemos a crear la tabla de clientes:</p> <pre><code>CREATE TABLE customerstx\n(\ncustId INT,\nfName STRING,\nlName STRING,\ncity STRING\n)\nCLUSTERED BY (custId) INTO 4 BUCKETS\nSTORED AS ORC\nTBLPROPERTIES ('transactional' = 'true');\n</code></pre> <p>Una vez creada la tabla, la vamos a cargar con los datos de los clientes:</p> <pre><code>INSERT INTO customerstx\nSELECT * FROM customers;\n</code></pre> <p>Un par de minutos despu\u00e9s, con los datos datos ya cargados, ya podemos cambiar el nombre de la ciudad <code>Caguas</code> por <code>Elche</code>:</p> <pre><code>UPDATE customerstx SET city=\"Elche\" WHERE city=\"Caguas\";\n</code></pre>"},{"location":"hadoop/06hive.html#ingestando-datos","title":"Ingestando datos","text":"<p>Tal como vimos en la sesi\u00f3n anterior, podemos ingestar los datos en Hive haciendo uso de Sqoop (tambi\u00e9n lo podemos hacer con Flume o Nifi).</p> <p>Por ejemplo, vamos a ingestar los datos de la tabla <code>orders</code> de la base de datos MariaDB que tenemos instalada en nuestra m\u00e1quina virtual. En el comando de Sqoop le indicamos que dentro de Hive lo ingeste en la base de datos <code>iabd</code> y que cree una tabla llamada <code>orders</code>:</p> <pre><code>sqoop import --connect jdbc:mysql://localhost/retail_db \\\n--username=iabd --password=iabd \\\n--table=orders --driver=com.mysql.jdbc.Driver \\\n--hive-import --hive-database iabd \\\n--create-hive-table --hive-table orders\n</code></pre> <p>Una vez realizada la ingesta, podemos comprobar que los datos est\u00e1n dentro de Hive (en una tabla interna/gestionada):</p> <pre><code>hdfs dfs -ls /user/hive/warehouse/iabd.db/orders\n</code></pre> <p>Y si entramos a <code>hive</code>, podemos consultar sus datos:</p> <pre><code>select * from orders limit 10;\n</code></pre>"},{"location":"hadoop/06hive.html#extrayendo-datos-insertados","title":"Extrayendo datos insertados","text":"<p>Combinando los comandos de HQL y HDFS podemos extraer datos a ficheros locales o remotos:</p> <pre><code># A\u00f1adiendo contenido local\nhive -e \"use iabd; select * from customers\" &gt;&gt; prueba1\n# Sobrescribiendo contenido local\nhive -e \"use iabd; select * from customers\" &gt; prueba2\n# A\u00f1adiendo contenido HDFS\nhive -e \"use iabd; select * from customers\" | hdfs dfs --appendToFile /tmp/prueba3\n# Sobrescribiendo contenido\nhive -e \"use iabd; select * from customers\" | hdfs dfs --put -f /tmp/prueba4\n</code></pre> <p>Si indicamos la propiedad <code>set hive.cli.print.header=true</code> antes de la consulta, tambi\u00e9n nos mostrar\u00e1 el encabezado de las columnas. Esto puede ser \u00fatil si queremos generar un csv con el resultado de una consulta:</p> <pre><code>hive -e 'use iabd; set hive.cli.print.header=true; select * from customers' | \\\nsed 's/[\\t]/,/g' &gt; fichero.csv\n</code></pre> <p>\u00bfY usar INSERT LOCAL?</p> <p>Mediante <code>INSERT LOCAL DIRECTORY</code> podemos escribir el resultado de una consulta en nuestro sistema de archivos, fuera de HDFS. El problema es que si hay muchos datos crear\u00e1 m\u00faltiples ficheros y necesitaremos concatenarlos para tener un \u00fanico resultado:</p> <pre><code>insert overwrite local directory '/home/iabd/datos'\nrow format delimited\nfields terminated by ','\nselect * from customers;\n</code></pre>"},{"location":"hadoop/06hive.html#caso-de-uso-3-consultas-con-join","title":"Caso de uso 3: Consultas con join","text":"<p>En este caso de uso vamos a trabajar con los datos de clientes y pedidos que hemos cargado en los dos casos anteriores, tanto en <code>customers</code> como en <code>orders</code>.</p> <p>Si queremos relacionar los datos de ambas tablas, tenemos que hacer un join entre la clave ajena de <code>orders</code> (<code>order_customer_id</code>) y la clave primaria de <code>customers</code> (<code>custid</code>):</p> <pre><code>hive&gt; describe customers;\nOK\ncustid                  int                                         fname                   string                                      lname                   string                                      city                    string                                      Time taken: 0.426 seconds, Fetched: 4 row(s)\nhive&gt; describe orders;\nOK\norder_id                int                                         order_date              string                                      order_customer_id       int                                         order_status            string                                      Time taken: 0.276 seconds, Fetched: 4 row(s)\n</code></pre> <p>Para ello, para obtener la ciudad de cada pedido podemos ejecutar la consulta:</p> <pre><code>select o.order_id, o.order_date, c.city\nfrom orders o join customers c\non (o.order_customer_id=c.custid);\n</code></pre>"},{"location":"hadoop/06hive.html#outer-join","title":"Outer join","text":"<p>De la misma manera que en cualquier SGBD, podemos realizar un outer join, tanto left como right o full.</p> <p>Por ejemplo, vamos a obtener para cada cliente, cuantos pedidos ha realizado:</p> <pre><code>select c.custid, count(order_id)\nfrom customers c join orders o\non (c.custid=o.order_customer_id)\ngroup by c.custid\norder by count(order_id) desc;\n</code></pre> <p>Si queremos que salgan todos los clientes, independientemente de que tengan pedidos, deberemos realizar un left outer join:</p> <pre><code>select c.custid, count(order_id)\nfrom customers c left outer join orders o\non (c.custid=o.order_customer_id)\ngroup by c.custid\norder by count(order_id) desc;\n</code></pre>"},{"location":"hadoop/06hive.html#semi-joins","title":"Semi-joins","text":"<p>Si quisi\u00e9ramos obtener las ciudades de los clientes que han realizado pedidos podr\u00edamos realizar la siguiente consulta:</p> <pre><code>select distinct c.city from customers c\nwhere c.custid in (\nselect order_customer_id\nfrom orders);\n</code></pre> <p>Mediante un semi-join podemos obtener el mismo resultado:</p> <pre><code>select distinct city\nfrom customers c\nleft semi join orders o on\n(c.custid=o.order_customer_id)\n</code></pre> <p>Hay que tener en cuenta la restricci\u00f3n que las columnas de la tabla de la derecha s\u00f3lo pueden aparecer en la clausula <code>on</code>, nunca en la expresi\u00f3n <code>select</code>.</p>"},{"location":"hadoop/06hive.html#map-joins","title":"Map joins","text":"<p>Consideramos la consulta inicial de join:</p> <pre><code>select o.order_id, o.order_date, c.city\nfrom orders o join customers c\non (o.order_customer_id=c.custid);\n</code></pre> <p>Si una tabla es suficientemente peque\u00f1a para caber en memoria, tal como nos ocurre con nuestros datos, Hive puede cargarla en memoria para realizar el join en cada uno de los mappers. Esto se conoce como un map join.</p> <p>El job que ejecuta la consulta no tiene reducers, con lo que esta consulta no funcionar\u00e1 para un right o right outer join, ya que la ausencias de coincidencias s\u00f3lo se puede detectar en los pasos de agregaci\u00f3n (reduce).</p> <p>En el caso de utilizar map joins con tablas organizadas en buckets, la sintaxis es la misma, s\u00f3lo siendo necesario activarlo mediante la propiedad <code>hive.optimize.bucketmapjoin</code>:</p> <pre><code>SET hive.optimize.bucketmapjoin=true;\n</code></pre>"},{"location":"hadoop/06hive.html#comandos","title":"Comandos","text":"<p>Mediante los casos de uso realizados hasta ahora, hemos podido observar c\u00f3mo para interactuar con Hive se utilizan comandos similares a SQL.</p> <p>Es conveniente consultar la siguiente cheatsheet: http://hortonworks.com/wp-content/uploads/2016/05/Hortonworks.CheatSheet.SQLtoHive.pdf</p> <p>Adem\u00e1s Hive viene con un conjunto de funciones predefinidas para tratamiento de cadenas, fechas, funciones estad\u00edsticas, condicionales, etc... las cuales puedes consultar en la documentaci\u00f3n oficial.</p> <p>Mediante el comando <code>show functions</code> podemos obtener una lista de las funciones. Si queremos m\u00e1s informaci\u00f3n sobre una determinada funci\u00f3n utilizaremos el comando <code>describe function nombreFuncion</code>:</p> <pre><code>hive&gt; describe function length;\nlength(str | binary) - Returns the length of str or number of bytes in binary data\n</code></pre>"},{"location":"hadoop/06hive.html#caso-de-uso-4-tabla-interna","title":"Caso de uso 4: Tabla interna","text":"<p>Hive permite crear tablas de dos tipos:</p> <ul> <li>tabla interna o gestionada: Hive gestiona la estructura y el almacenamiento de los datos. Para ello, crea los datos en HDFS. Al borrar la tabla de Hive, se borra la informaci\u00f3n de HDFS.</li> <li>tabla externa: Hive define la estructura de los datos en el metastore, pero los datos ya residen previamente en HDFS. Al borrar la tabla de Hive, no se eliminan los datos de HDFS. Se emplea cuando compartimos datos almacenados en HDFS entre diferentes herramientas.</li> </ul> <p>En este caso de uso, vamos a centrarnos en una tabla interna.</p> <p>Supongamos el siguiente fichero con datos de empleados:</p> empleados.txt<pre><code>Michael|Montreal,Toronto|Male,30|DB:80|Product:Developer\u0004Lead\nWill|Montreal|Male,35|Perl:85|Product:Lead,Test:Lead\nShelley|New York|Female,27|Python:80|Test:Lead,COE:Architect\nLucy|Vancouver|Female,57|Sales:89,HR:94|Sales:Lead\n</code></pre> <p>Podemos observar como se utiliza <code>|</code> como separador de campos. Analizando los datos, vemos que tenemos los siguientes campos:</p> <ul> <li>Nombre</li> <li>Centros de trabajo (array con las ciudades)</li> <li>Sexo y edad</li> <li>Destreza y puntuaci\u00f3n</li> <li>Departamento y cargo</li> </ul> <p>Creamos la siguiente tabla interna en Hive mediante el siguiente comando:</p> <pre><code>CREATE TABLE IF NOT EXISTS empleados_interna\n(\nname string,\nwork_place ARRAY&lt;string&gt;,\nsex_age STRUCT&lt;sex:string,age:int&gt;,\nskills_score MAP&lt;string,int&gt;,\ndepart_title MAP&lt;string,ARRAY&lt;string&gt;&gt;\n) COMMENT 'Esto es una tabla interna'\nROW FORMAT DELIMITED\nFIELDS TERMINATED BY '|'\nCOLLECTION ITEMS TERMINATED BY ','\nMAP KEYS TERMINATED BY ':';\n</code></pre> <p>La sintaxis es muy similar a SQL, destacando las siguientes opciones:</p> <ul> <li><code>ROW FORMAT DELIMITED</code>: cada registro ocupa una l\u00ednea</li> <li><code>FIELDS TERMINATED BY '|'</code>: define el <code>|</code> como separador de campos</li> <li><code>COLLECTION ITEMS TERMINATED BY ','</code>: define la coma como separador de los arrays / estructuras</li> <li><code>MAP KEYS TERMINATED BY ':'</code>: define los dos puntos como separador utilizado en los mapas.</li> </ul> <p>Si queremos comprobar la estructura de la tabla mediante el comando <code>show create table empleados_interna</code> veremos las opciones que hemos indicado:</p> <pre><code>+----------------------------------------------------+\n|                   createtab_stmt                   |\n+----------------------------------------------------+\n| CREATE TABLE `empleados_interna`(                  |\n|   `name` string,                                   |\n|   `work_place` array&lt;string&gt;,                      |\n|   `sex_age` struct&lt;sex:string,age:int&gt;,            |\n|   `skills_score` map&lt;string,int&gt;,                  |\n|   `depart_title` map&lt;string,array&lt;string&gt;&gt;)        |\n| COMMENT 'Esto es una tabla interna'                |\n| ROW FORMAT SERDE                                   |\n|   'org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe'  |\n| WITH SERDEPROPERTIES (                             |\n|   'collection.delim'=',',                          |\n|   'field.delim'='|',                               |\n|   'mapkey.delim'=':',                              |\n|   'serialization.format'='|')                      |\n| STORED AS INPUTFORMAT                              |\n|   'org.apache.hadoop.mapred.TextInputFormat'       |\n| OUTPUTFORMAT                                       |\n|   'org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat' |\n| LOCATION                                           |\n|   'hdfs://iabd-virtualbox:9000/user/hive/warehouse/iabd.db/empleados_interna' |\n| TBLPROPERTIES (                                    |\n|   'bucketing_version'='2',                         |\n|   'transient_lastDdlTime'='1647432129')            |\n+----------------------------------------------------+\n</code></pre> <p>Formato de las tablas</p> <p>Si queremos indicarle el formato a las tablas, mediante <code>STORED AS</code> podemos indicar formatos:</p> <ul> <li>basados en filas, como <code>TEXTFILE</code>, <code>JSONFILE</code>, <code>AVRO</code> o en formato de secuencia mediante <code>SEQUENCEFILE</code>.</li> <li>basados en columnas, como <code>PARQUET</code> o <code>ORC</code>.</li> </ul> <p>A continuaci\u00f3n, vamos a cargar los datos del fichero empleados.txt, el cual colocaremos en nuestra carpeta de Descargas:</p> <pre><code>LOAD DATA LOCAL INPATH '/home/iabd/Descargas/empleados.txt' OVERWRITE INTO TABLE empleados_interna;\n</code></pre> <p>Comprobamos que los datos se han cargado correctamente:</p> <pre><code>select * from empleados_interna;\n</code></pre> <p>Y obtenemos:</p> <pre><code>+-------------------------+-------------------------------+----------------------------+---------------------------------+----------------------------------------+\n| empleados_interna.name  | empleados_interna.work_place  | empleados_interna.sex_age  | empleados_interna.skills_score  |     empleados_interna.depart_title     |\n+-------------------------+-------------------------------+----------------------------+---------------------------------+----------------------------------------+\n| Michael                 | [\"Montreal\",\"Toronto\"]        | {\"sex\":\"Male\",\"age\":30}    | {\"DB\":80}                       | {\"Product\":[\"Developer\",\"Lead\"]}       |\n| Will                    | [\"Montreal\"]                  | {\"sex\":\"Male\",\"age\":35}    | {\"Perl\":85}                     | {\"Product\":[\"Lead\"],\"Test\":[\"Lead\"]}   |\n| Shelley                 | [\"New York\"]                  | {\"sex\":\"Female\",\"age\":27}  | {\"Python\":80}                   | {\"Test\":[\"Lead\"],\"COE\":[\"Architect\"]}  |\n| Lucy                    | [\"Vancouver\"]                 | {\"sex\":\"Female\",\"age\":57}  | {\"Sales\":89,\"HR\":94}            | {\"Sales\":[\"Lead\"]}                     |\n+-------------------------+-------------------------------+----------------------------+---------------------------------+----------------------------------------+\n</code></pre> <p>Y si nos abrimos otra pesta\u00f1a, mediante HDFS, comprobamos que tenemos los datos:</p> <pre><code>hdfs dfs -ls /user/hive/warehouse/curso.db/empleados_interna\nhdfs dfs -cat /user/hive/warehouse/curso.db/empleados_interna/empleados.txt\n</code></pre> <p>Y obtenemos:</p> <pre><code>Michael|Montreal,Toronto|Male,30|DB:80|Product:DeveloperLead\nWill|Montreal|Male,35|Perl:85|Product:Lead,Test:Lead\nShelley|New York|Female,27|Python:80|Test:Lead,COE:Architect\nLucy|Vancouver|Female,57|Sales:89,HR:94|Sales:Lead\n</code></pre>"},{"location":"hadoop/06hive.html#consultando-datos-compuestos","title":"Consultando datos compuestos","text":"<p>Si nos fijamos bien en la tabla, tenemos tres columnas con diferentes datos compuestos.</p> <ul> <li><code>work_place</code>, con un <code>ARRAY&lt;string&gt;</code></li> <li><code>sex_age</code> con una <code>STRUCT&lt;sex:string,age:int&gt;</code></li> <li><code>skills_score</code> con un <code>MAP&lt;string,int&gt;</code>,</li> <li><code>depart_title</code> con un <code>MAP&lt;STRING,ARRAY&lt;STRING&gt;&gt;</code></li> </ul> <p>Si queremos obtener los datos del array, podemos realizar las siguientes consultas:</p> Todos los elementosElementos individualesCantidad de elementosExplode array <p>Todos los lugares de trabajo:</p> <pre><code>select name, work_place from empleados_interna;\n</code></pre> <p>Resultado:</p> <pre><code>+----------+-------------------------+\n|   name   |       work_place        |\n+----------+-------------------------+\n| Michael  | [\"Montreal\",\"Toronto\"]  |\n| Will     | [\"Montreal\"]            |\n| Shelley  | [\"New York\"]            |\n| Lucy     | [\"Vancouver\"]           |\n+----------+-------------------------+\n</code></pre> <p>Utilizamos la notaci\u00f3n de array para mostrar los dos primeros puestos de trabajo:</p> <pre><code>select work_place[0] as lugar1, work_place[1] as lugar2\nfrom empleados_interna;\n</code></pre> <p>Resultado:</p> <pre><code>+------------+----------+\n|   lugar1   |  lugar2  |\n+------------+----------+\n| Montreal   | Toronto  |\n| Montreal   | NULL     |\n| New York   | NULL     |\n| Vancouver  | NULL     |\n+------------+----------+\n</code></pre> <p>Mediante la funci\u00f3n <code>size</code> obtenemos la cantidad de lugares de trabajo:</p> <pre><code>select size(work_place) as cantLugares\nfrom empleados_interna;\n</code></pre> <p>Resultado:</p> <pre><code>+--------------+\n| cantlugares  |\n+--------------+\n| 2            |\n| 1            |\n| 1            |\n| 1            |\n+--------------+\n</code></pre> <p>Para obtener los empleados y lugares de trabajo mostrados uno por fila, hemos de realizar un explode sobre el array:</p> <pre><code>select name, lugar\nfrom empleados_interna\nlateral view explode (work_place) e2 as lugar;\n</code></pre> <p>Para ello hemos creado una vista lateral y con la funci\u00f3n <code>explode</code> desenrollamos el array. Resultado:</p> <pre><code>+----------+------------+\n|   name   |   lugar    |\n+----------+------------+\n| Michael  | Montreal   |\n| Michael  | Toronto    |\n| Will     | Montreal   |\n| Shelley  | New York   |\n| Lucy     | Vancouver  |\n+----------+------------+\n</code></pre> <p>En el caso de la estructura con el sexo y la edad podemos realizar las siguientes consultas</p> Todos los elementosElementos individuales <p>Todas las estructuras de sexo/edad:</p> <pre><code>select sex_age from empleados_interna;\n</code></pre> <p>Resultado:</p> <pre><code>+----------------------------+\n|          sex_age           |\n+----------------------------+\n| {\"sex\":\"Male\",\"age\":30}    |\n| {\"sex\":\"Male\",\"age\":35}    |\n| {\"sex\":\"Female\",\"age\":27}  |\n| {\"sex\":\"Female\",\"age\":57}  |\n+----------------------------+\n</code></pre> <p>Utilizando la notaci\u00f3n <code>.</code> podemos obtener el sexo y edad por separado</p> <pre><code>select sex_age.sex as sexo, sex_age.age as edad\nfrom empleados_interna;\n</code></pre> <p>Resultado:</p> <pre><code>+---------+-------+\n|  sexo   | edad  |\n+---------+-------+\n| Male    | 30    |\n| Male    | 35    |\n| Female  | 27    |\n| Female  | 57    |\n+---------+-------+\n</code></pre> <p>Respecto al mapa con las habilidades y sus puntuaciones:</p> Todos los elementosElementos individualesClaves y valores <p>Todas las habilidades como un mapa:</p> <pre><code>select skills_score from empleados_interna;\n</code></pre> <p>Resultado:</p> <pre><code>+-----------------------+\n|     skills_score      |\n+-----------------------+\n| {\"DB\":80}             |\n| {\"Perl\":85}           |\n| {\"Python\":80}         |\n| {\"Sales\":89,\"HR\":94}  |\n+-----------------------+\n</code></pre> <p>Utilizando la notaci\u00f3n array con claves, obtenemos el nombre y puntuaci\u00f3n de las habilidades:</p> <pre><code>select name, skills_score[\"DB\"] as db,\nskills_score[\"Perl\"] as perl,\nskills_score[\"Python\"] as python,\nskills_score[\"Sales\"] as ventas,\nskills_score[\"HR\"] as hr\nfrom empleados_interna;\n</code></pre> <p>Resultado:</p> <pre><code>+----------+-------+-------+---------+---------+-------+\n|   name   |  db   | perl  | python  | ventas  |  hr   |\n+----------+-------+-------+---------+---------+-------+\n| Michael  | 80    | NULL  | NULL    | NULL    | NULL  |\n| Will     | NULL  | 85    | NULL    | NULL    | NULL  |\n| Shelley  | NULL  | NULL  | 80      | NULL    | NULL  |\n| Lucy     | NULL  | NULL  | NULL    | 89      | 94    |\n+----------+-------+-------+---------+---------+-------+\n</code></pre> <p>Claves y valores de las habilidades:</p> <pre><code>select name, map_keys(skills_score) as claves,\nmap_values(skills_score) as valores\nfrom empleados_interna;\n</code></pre> <p>Resultado:</p> <pre><code>+----------+-----------------+----------+\n|   name   |     claves      | valores  |\n+----------+-----------------+----------+\n| Michael  | [\"DB\"]          | [80]     |\n| Will     | [\"Perl\"]        | [85]     |\n| Shelley  | [\"Python\"]      | [80]     |\n| Lucy     | [\"Sales\",\"HR\"]  | [89,94]  |\n+----------+-----------------+----------+\n</code></pre> <p>Y finalmente, con el mapa de departamentos que contiene un array:</p> Todos los elementosElementos individualesPrimer elemento de los elementos individuales <p>Toda la informaci\u00f3n sobre los departamentos:</p> <pre><code>select depart_title from empleados_interna;\n</code></pre> <p>Resultado:</p> <pre><code>+----------------------------------------+\n|              depart_title              |\n+----------------------------------------+\n| {\"Product\":[\"Developer\",\"Lead\"]}       |\n| {\"Product\":[\"Lead\"],\"Test\":[\"Lead\"]}   |\n| {\"Test\":[\"Lead\"],\"COE\":[\"Architect\"]}  |\n| {\"Sales\":[\"Lead\"]}                     |\n+----------------------------------------+\n</code></pre> <p>Nombre y puntuaci\u00f3n de las habilidades:</p> <pre><code>select name, depart_title[\"Product\"] as product,\ndepart_title[\"Test\"] as test,\ndepart_title[\"COE\"] as coe,\ndepart_title[\"Sales\"] as sales\nfrom empleados_interna;\n</code></pre> <p>Resultado:</p> <pre><code>+----------+-----------------------+-----------+----------------+-----------+\n|   name   |        product        |   test    |      coe       |   sales   |\n+----------+-----------------------+-----------+----------------+-----------+\n| Michael  | [\"Developer\",\"Lead\"]  | NULL      | NULL           | NULL      |\n| Will     | [\"Lead\"]              | [\"Lead\"]  | NULL           | NULL      |\n| Shelley  | NULL                  | [\"Lead\"]  | [\"Architect\"]  | NULL      |\n| Lucy     | NULL                  | NULL      | NULL           | [\"Lead\"]  |\n+----------+-----------------------+-----------+----------------+-----------+\n</code></pre> <p>Primera habilidad de producto y pruebas de cada empleado:</p> <pre><code>select name, depart_title[\"Product\"][0] as product0,\ndepart_title[\"Test\"][0] as test0\nfrom empleados_interna;\n</code></pre> <p>Resultado:</p> <pre><code>+----------+-------------+--------+\n|   name   |  product0   | test0  |\n+----------+-------------+--------+\n| Michael  | Developer   | NULL   |\n| Will     | Lead        | Lead   |\n| Shelley  | NULL        | Lead   |\n| Lucy     | NULL        | NULL   |\n+----------+-------------+--------+\n</code></pre>"},{"location":"hadoop/06hive.html#caso-de-uso-5-tabla-externa","title":"Caso de uso 5: Tabla externa","text":"<p>En este caso de uso vamos a repetir la misma estructura de la tabla del caso anterior, pero en esta ocasi\u00f3n en una tabla externa. De esta manera, al borrar la tabla de Hive, no se borra la informaci\u00f3n de HDFS.</p> <p>Para ello, \u00fanicamente hemos de a\u00f1adir la palabra <code>EXTERNAL</code> a la instrucci\u00f3n <code>CREATE TABLE</code> y la clausula <code>LOCATION</code> para indicar la ruta de HDFS donde se encuentran los datos:</p> <pre><code>CREATE EXTERNAL TABLE IF NOT EXISTS empleados_externa\n(\nname string,\nwork_place ARRAY&lt;string&gt;,\nsex_age STRUCT&lt;sex:string,age:int&gt;,\nskills_score MAP&lt;string,int&gt;,\ndepart_title MAP&lt;STRING,ARRAY&lt;STRING&gt;&gt;\n) COMMENT \"Esto es una tabla externa\"\nROW FORMAT DELIMITED\nFIELDS TERMINATED BY '|'\nCOLLECTION ITEMS TERMINATED BY ','\nMAP KEYS TERMINATED BY ':'\nLOCATION \"/user/iabd/hive/empleados_externa\";\n</code></pre> <p>Realizamos la misma carga que en el caso anterior:</p> <pre><code>LOAD DATA LOCAL INPATH '/home/iabd/Descargas/empleados.txt' OVERWRITE INTO TABLE empleados_externa;\n</code></pre> <p>Si hacemos una consulta sobre la tabla para ver que est\u00e1n todos los campos obtendremos la misma informaci\u00f3n que antes:</p> <pre><code>SELECT * FROM empleados_externa;\n</code></pre> <p>Interna o externa</p> <p>Como normal general, si todo nuestro procesamiento lo hacemos mediante Hive, es m\u00e1s c\u00f3modo utilizar tablas internas. Si no es as\u00ed, y otras herramientas acceden al mismo dataset, es mejor utilizar tablas externas.</p> <p>Un patr\u00f3n de uso muy com\u00fan es utilizar una tabla externa para acceder al dataset inicial almacenado en HDFS (creado por otro proceso), y posteriormente crear una transformaci\u00f3n en Hive para mover los datos a una tabla interna.</p>"},{"location":"hadoop/06hive.html#estructuras-de-datos-en-hive","title":"Estructuras de datos en Hive","text":"<p>Hive proporciona una estructura basada en tablas sobre HDFS. Soporta tres tipos de estructuras: tablas, particiones y buckets. Las tablas se corresponden con directorios de HDFS, las particiones son las divisiones de las tablas y los buckets son las divisiones de las particiones.</p> <p>Acabamos de ver en el apartado anterior que Hive permite crear tablas externas, similares a las tablas en una base de datos, pero a la que se les proporciona una ubicaci\u00f3n.</p>"},{"location":"hadoop/06hive.html#particiones","title":"Particiones","text":"<p>Las particiones en Hive consisten en dividir las tablas en varios subdirectorios. Esta estructura permite aumentar el rendimiento cuando utilizamos consultas que filtran los datos mediante la cl\u00e1usula where basada en la clave de particionado.</p> <p>Por ejemplo, si estamos almacenado ficheros de log (tanto la l\u00ednea del log como su timestamp), podemos pensar en agrupar por fecha los diferentes ficheros. Podr\u00edamos a\u00f1adir otra partici\u00f3n para tambi\u00e9n dividirlos por pa\u00edses:</p> <pre><code>CREATE TABLE logs (ts BIGINT, linea STRING)\nPARTITIONED BY (fecha STRING, pais STRING);\n</code></pre> <p>Por ejemplo, para cargar los datos en una partici\u00f3n:</p> <pre><code>LOAD DATA LOCAL INPATH 'input/hive/particiones/log1'\nINTO TABLE logs\nPARTITION (fecha='2022-01-01', pais='ES');\n</code></pre> <p>A nivel del sistema de fichero, las particiones se traducen en subdirectorios dentro de la carpeta de la tabla. Por ejemplo, tras insertar varios ficheros de logs, podr\u00edamos tener una estructura similar a:</p> <pre><code>/user/hive/warehouse/logs\n\u251c\u2500\u2500 fecha=2022-01-01/\n\u2502   \u251c\u2500\u2500 pais=ES/\n\u2502   \u2502   \u251c\u2500\u2500 log1\n\u2502   \u2502   \u2514\u2500\u2500 log2\n\u2502   \u2514\u2500\u2500 pais=US/\n\u2502       \u2514\u2500\u2500 log3\n\u2514\u2500\u2500 fecha=2022-01-02/\n    \u251c\u2500\u2500 pais=ES/\n    \u2502   \u2514\u2500\u2500 log4\n    \u2514\u2500\u2500 pais=US/\n        \u251c\u2500\u2500 log5\n        \u2514\u2500\u2500 log6\n</code></pre> <p>Para averiguar las particiones en Hive, utilizaremos el comando <code>SHOW PARTITIONS</code>:</p> <pre><code>hive&gt; SHOW PARTITIONS logs;\nfecha=2022-01-01/pais=ES\nfecha=2022-01-01/pais=US\nfecha=2022-01-02/pais=ES\nfecha=2022-01-02/pais=US\n</code></pre> <p>Hay que tener en cuenta que la definici\u00f3n de columnas de la clausula <code>PARTITIONED BY</code> forman parte de las columnas de la tabla, y se conocen como columnas de partici\u00f3n. Sin embargo, los ficheros de datos no contienen valores para esas columnas, ya que se deriva el nombre del subdirectorio.</p> <p>Podemos utilizar las columnas de partici\u00f3n en las consultas igual que una columna ordinaria. Hive traduce la consulta en la navegaci\u00f3n adecuada para s\u00f3lo escanear las particiones relevantes. Por ejemplo, la siguiente consulta solo escanear\u00e1 los ficheros <code>log1</code>, <code>log2</code> y <code>log4</code>:</p> <pre><code>SELECT ts, fecha, linea\nFROM logs\nWHERE pais='ES';\n</code></pre> <p>Moviendo datos a una tabla particionada</p> <p>Si queremos mover datos de una tabla ordinaria a una particionada (vaciando los datos de la partici\u00f3n existente):</p> <pre><code>INSERT OVERWRITE TABLE logs\nPARTITION (fecha='2022-01-01')\nSELECT col1, col2 FROM fuente;\n</code></pre> <p>Otra posibilidad es utilizar un particionado din\u00e1mico, de manera que las particiones se crean de forma relativa a los datos:</p> <pre><code>INSERT OVERWRITE TABLE logs\nPARTITION (fecha)\nSELECT fecha, col1, col2 FROM fuente;\n</code></pre> <p>Para ello, previamente hay que habilitarlo (por defecto est\u00e1 desactivado para evitar la creaci\u00f3n de m\u00faltiples particiones sin querer) y configurar el modo no estricto para que no nos obligue a indicar al menos una partici\u00f3n est\u00e1tica:</p> <pre><code>set hive.exec.dynamic.partition = true\nset hive.exec.dynamic.partition.mode = nonstrict;\n</code></pre>"},{"location":"hadoop/06hive.html#buckets","title":"Buckets","text":"<p>Otro concepto importante en Hive son los buckets. Son particiones hasheadas por una columna/clave, en las que los datos se distribuyen en funci\u00f3n de su valor hash.</p> <p>Existen dos razones por las cuales queramos organizar las tablas (o particiones) en buckets. La primera es para conseguir consultas m\u00e1s eficientes, ya que imponen una estructura extra en las tablas. Los buckets pueden acelerar las operaciones de tipo join si las claves de bucketing y de join coinciden, ya que una clave ajena busca \u00fanicamente en el bucket adecuado de la clave primaria. Debido a los beneficios de los buckets/particiones, se deben considerar siempre que puedan optimizar el rendimiento de las consultas realizadas.</p> <p>Para indicar que nuestras tablas utilicen buckets, hemos de emplear la clausula <code>CLUSTERED BY</code> para indicar la columnas y el n\u00famero de buckets (se recomienda que la cantidad de buckets sea potencia de 2):</p> <pre><code>CREATE TABLE usuarios_bucketed (id INT, nombre STRING)\nCLUSTERED BY (id) INTO 4 BUCKETS;\n</code></pre> <p>Bucketing est\u00e1 muy relacionado con el proceso de carga de datos. Para cargar los datos en una tabla con buckets, debemos bien indicar el n\u00famero m\u00e1ximo de reducers para que coincida con el n\u00famero de buckets, o habilitar el bucketing (esta es la recomendada):</p> <pre><code>set map.reduce.tasks = 4;\nset hive.enforce.bucketing = true; -- mejor as\u00ed\n</code></pre> <p>Una vez creada la tabla, se rellena con los datos que tenemos en otra tabla:</p> <pre><code>INSERT OVERWRITE TABLE usuarios_bucketed\nSELECT * FROM usuarios;\n</code></pre> <p>F\u00edsicamente, cada bucket es un fichero de la carpeta con la tabla (o partici\u00f3n). El nombre del fichero no es importante, pero el bucket <code>n</code> es el fichero n\u00famero <code>n</code>. Por ejemplo, si miramos el contenido de la tabla en HDFS tendremos:</p> <pre><code>hive&gt; dfs -ls /user/hive/warehouse/usuarios_bucketed;\n000000_0\n000001_0\n000002_0\n000003_0\n</code></pre> <p>El segundo motivo es para obtener un sampling de forma m\u00e1s eficiente. Al trabajar con grandes datasets, normalmente obtenemos una peque\u00f1a fracci\u00f3n del dataset para comprender o refinar los datos. Por ejemplo, podemos obtener los datos de \u00fanicamente uno de los buckets:</p> <pre><code>SELECT * FROM usuarios_bucketed\nTABLESAMPLE(BUCKET 1 OUT OF 4 ON id);\n</code></pre> <p>Mediante el <code>id</code> del usuario determinamos el bucket (el cual se utiliza para realizar el hash del valor y ubicarlo dentro de uno de los buckets), de manera que cada bucket contendr\u00e1 de manera eficiente un conjunto aleatorio de usuarios.</p>"},{"location":"hadoop/06hive.html#resumen","title":"Resumen","text":"<p>A continuaci\u00f3n mostramos en una tabla puntos a favor y en contra de utilizar estas estructuras</p> Particionado + Particionado - Bucketing + Bucketing - Distribuye la carga de ejecuci\u00f3n horizontalmente. Existe la posibilidad de crear demasiadas particiones que contienen muy poco datos Proporciona una respuesta de consulta m\u00e1s r\u00e1pida, al acceder a porciones. El n\u00famero de buckets se define durante la creaci\u00f3n de la tabla -&gt; Los programadores deben cargar manualmente un volumen equilibrado de datos. En la partici\u00f3n tiene lugar la ejecuci\u00f3n m\u00e1s r\u00e1pida de consultas con el volumen de datos bajo. Por ejemplo, la poblaci\u00f3n de b\u00fasqueda de la Ciudad del Vaticano devuelve muy r\u00e1pido en lugar de buscar la poblaci\u00f3n mundial completa. La partici\u00f3n es eficaz para datos de bajo volumen. Pero algunas consultas como agrupar por un gran volumen de datos tardan mucho en ejecutarse. Por ejemplo, agrupar las consultas del mes de Enero tardar\u00e1 m\u00e1s que los viernes de Enero. Al utilizar vol\u00famenes similares de datos en cada partici\u00f3n, los map joins ser\u00e1n m\u00e1s r\u00e1pidos. <p>Supongamos que <code>$HDFS_HIVE</code> contiene la ruta con la ra\u00edz de las tablas internas de Hive, en nuestro caso <code>/user/hive/warehouse</code>. Respecto al nivel de estructura y representaci\u00f3n en carpetas de HDFS tendr\u00edamos:</p> ENTIDAD EJEMPLO UBICACI\u00d3N base de datos iabd <code>$HDFS_HIVE/iabd.db</code> tabla T <code>$HDFS_HIVE/iabd.db/T</code> partici\u00f3n fecha='01012022' <code>$HDFS_HIVE/iabd.db/T/fecha=01012022</code> bucket columna id <code>$HDFS_HIVE/iabd.db/T/fecha=01012022/000000_0</code>"},{"location":"hadoop/06hive.html#caso-de-uso-6-particionado-y-bucketing","title":"Caso de uso 6: Particionado y Bucketing","text":"<p>A continuaci\u00f3n, vamos a coger los datos de las productos y las categor\u00edas de la base de datos <code>retail_db</code>, y colocarlos en una estructura de Hive particionada y que utilice bucketing.</p> <p>La estructura de las tablas es la siguiente:</p> Relaci\u00f3n entre productos y categor\u00edas <p>El primer paso es traernos los datos de MariaDB a tablas internas haciendo uso de Sqoop:</p> Tabla categoriesTabla products <pre><code>sqoop import --connect jdbc:mysql://localhost/retail_db \\\n--username=iabd --password=iabd \\\n--table=categories --driver=com.mysql.jdbc.Driver \\\n--hive-import --hive-database iabd \\\n--create-hive-table --hive-table categories\n</code></pre> <pre><code>sqoop import --connect jdbc:mysql://localhost/retail_db \\\n--username=iabd --password=iabd \\\n--table=products --driver=com.mysql.jdbc.Driver \\\n--hive-import --hive-database iabd \\\n--create-hive-table --hive-table products\n</code></pre> <p>El siguiente paso que vamos a realizar es crear en Hive una tabla con el c\u00f3digo del producto, su nombre, el nombre de la categor\u00eda y el precio del producto. Estos datos los vamos a particionar por categor\u00eda y clusterizado en 8 buckets:</p> <pre><code>CREATE TABLE IF NOT EXISTS productos (\nid INT,\nnombre STRING,\nprecio DOUBLE\n)\nPARTITIONED BY (categoria STRING)\nCLUSTERED BY (id) INTO 8 BUCKETS;\n</code></pre> <p>Y cargamos los datos con una consulta que realice un join de las tablas <code>categories</code> y <code>products</code> con particionado din\u00e1mico (recuerda activarlo mediante <code>set hive.exec.dynamic.partition.mode=nonstrict;</code>):</p> <pre><code>INSERT OVERWRITE TABLE productos\nPARTITION (categoria)\nSELECT p.product_id as id, p.product_name as nombre, p.product_price as precio, c.category_name as categoria FROM products p join categories c on (p.product_category_id = c.category_id);\n</code></pre> <p>Si queremos comprobar c\u00f3mo se han creado las particiones y los buckets, desde un terminal podemos acceder a HDFS y mostrar su contenido:</p> <pre><code>hdfs dfs -ls hdfs://iabd-virtualbox:9000/user/hive/warehouse/iabd.db/productos\nhdfs dfs -ls hdfs://iabd-virtualbox:9000/user/hive/warehouse/iabd.db/productos/categoria=Accessories\n</code></pre> <p>Si volvemos a Hive, ahora podemos consultar los datos:</p> <pre><code>select * from productos limit 5;\n</code></pre> <p>Y vemos c\u00f3mo aparecen 5 elementos que pertenecen a la primera partici\u00f3n. Si quisi\u00e9ramos, por ejemplo, 10 elementos de particiones diferentes deber\u00edamos ordenarlos de manera aleatoria:</p> <pre><code>select * from productos order by rand() limit 10;\n</code></pre>"},{"location":"hadoop/06hive.html#funciones-ventana","title":"Funciones ventana","text":"<p>A continuaci\u00f3n vamos a realizar diversas consultas utilizando las funciones ventana que soporta Hive. M\u00e1s informaci\u00f3n en https://cwiki.apache.org/confluence/display/Hive/LanguageManual+WindowingAndAnalytics.</p>"},{"location":"hadoop/06hive.html#consultas-con-enteros-que-cuentanordenan","title":"Consultas con enteros que cuentan/ordenan","text":"<p>Consultas sobre categor\u00edas</p> <p>Las siguientes consultas las vamos a realizar sobre s\u00f3lo dos categor\u00edas para acotar los resultados obtenidos.</p> <p>Adem\u00e1s, hemos recortado el nombre del producto a 20 caracteres para facilitar la legibilidad de los resultados.</p> <p>Las funciones <code>rank</code> y <code>dense_rank</code> permite obtener la posici\u00f3n que ocupan los datos. Se diferencia en que <code>rank</code> cuenta los elementos repetidos/empatados, mientras que <code>dense_rank</code> no.</p> <p>Por ejemplo, vamos a obtener la posici\u00f3n que ocupan los productos respecto al precio agrupados por su categor\u00eda:</p> <pre><code>select substr(nombre, 1, 20) as nombre, categoria, precio, rank() over (partition by categoria order by precio desc) as rank,\ndense_rank() over (partition by categoria order by precio desc) as denseRank\nfrom productos\nwhere categoria = \"Bike &amp; Skate Shop\" or categoria = \"Basketball\";\n</code></pre> <p>En el caso de que tengamos m\u00e1s de un elemento con el mismo valor, tanto en <code>rank</code> como con <code>dense_rank</code>, todos los elementos ocupar\u00e1n la misma posici\u00f3n.</p> <p>Resultado:</p> <pre><code>+-----------------------+--------------------+----------+-------+------------+\n|        nombre         |     categoria      |  precio  | rank  | denserank  |\n+-----------------------+--------------------+----------+-------+------------+\n| SOLE F85 Treadmill    | Basketball         | 1799.99  | 1     | 1          |\n| SOLE E25 Elliptical   | Basketball         | 999.99   | 2     | 2          |\n| Diamondback Adult Re  | Basketball         | 349.98   | 3     | 3          |\n| Diamondback Adult Ou  | Basketball         | 309.99   | 4     | 4          |\n| Diamondback Girls' C  | Basketball         | 299.99   | 5     | 5          |\n| Diamondback Boys' In  | Basketball         | 299.99   | 5     | 5          |\n| Diamondback Adult So  | Basketball         | 299.98   | 7     | 6          |\n| Easton Mako Youth Ba  | Basketball         | 249.97   | 8     | 7          |\n| Fitness Gear 300 lb   | Basketball         | 209.99   | 9     | 8          |\n| Quik Shade Summit SX  | Basketball         | 199.99   | 10    | 9          |\n| Easton XL1 Youth Bat  | Basketball         | 179.97   | 11    | 10         |\n| Easton S1 Youth Bat   | Basketball         | 179.97   | 11    | 10         |\n| adidas Brazuca 2014   | Basketball         | 159.99   | 13    | 11         |\n| Quest 12' x 12' Dome  | Basketball         | 149.99   | 14    | 12         |\n| Fitbit Flex Wireless  | Basketball         | 99.95    | 15    | 13         |\n| Nike+ Fuelband SE     | Basketball         | 99.0     | 16    | 14         |\n| Elevation Training M  | Basketball         | 79.99    | 17    | 15         |\n| MAC Sports Collapsib  | Basketball         | 69.99    | 18    | 16         |\n| Quest Q64 10 FT. x 1  | Basketball         | 59.98    | 19    | 17         |\n| adidas Brazuca 2014   | Basketball         | 39.99    | 20    | 18         |\n| Kijaro Dual Lock Cha  | Basketball         | 29.99    | 21    | 19         |\n| adidas Brazuca 2014   | Basketball         | 29.99    | 21    | 19         |\n| Nike Women's Pro Cor  | Basketball         | 28.0     | 23    | 20         |\n| Nike Women's Pro Vic  | Basketball         | 21.99    | 24    | 21         |\n| Nike VR_S Covert Dri  | Bike &amp; Skate Shop  | 179.99   | 1     | 1          |\n| TaylorMade RocketBal  | Bike &amp; Skate Shop  | 169.99   | 2     | 2          |\n| Cobra AMP Cell Drive  | Bike &amp; Skate Shop  | 169.99   | 2     | 2          |\n| Cleveland Golf Class  | Bike &amp; Skate Shop  | 119.99   | 4     | 3          |\n| Callaway X Hot Drive  | Bike &amp; Skate Shop  | 0.0      | 5     | 4          |\n+-----------------------+--------------------+----------+-------+------------+\n</code></pre> <p>La funci\u00f3n <code>row_number</code> permite numerar los resultados, da igual que tengamos elementos que repiten valor:</p> <pre><code>select substr(nombre, 1, 20) as nombre, categoria, precio, row_number() over (partition by categoria order by precio desc) as numfila\nfrom productos\nwhere categoria = \"Bike &amp; Skate Shop\" or categoria = \"Basketball\";\n</code></pre> <p>Resultado:</p> <pre><code>+-----------------------+--------------------+----------+----------+\n|        nombre         |     categoria      |  precio  | numfila  |\n+-----------------------+--------------------+----------+----------+\n| SOLE F85 Treadmill    | Basketball         | 1799.99  | 1        |\n| SOLE E25 Elliptical   | Basketball         | 999.99   | 2        |\n| Diamondback Adult Re  | Basketball         | 349.98   | 3        |\n| Diamondback Adult Ou  | Basketball         | 309.99   | 4        |\n| Diamondback Girls' C  | Basketball         | 299.99   | 5        |\n| Diamondback Boys' In  | Basketball         | 299.99   | 6        |\n| Diamondback Adult So  | Basketball         | 299.98   | 7        |\n| Easton Mako Youth Ba  | Basketball         | 249.97   | 8        |\n| Fitness Gear 300 lb   | Basketball         | 209.99   | 9        |\n| Quik Shade Summit SX  | Basketball         | 199.99   | 10       |\n| Easton XL1 Youth Bat  | Basketball         | 179.97   | 11       |\n| Easton S1 Youth Bat   | Basketball         | 179.97   | 12       |\n| adidas Brazuca 2014   | Basketball         | 159.99   | 13       |\n| Quest 12' x 12' Dome  | Basketball         | 149.99   | 14       |\n| Fitbit Flex Wireless  | Basketball         | 99.95    | 15       |\n| Nike+ Fuelband SE     | Basketball         | 99.0     | 16       |\n| Elevation Training M  | Basketball         | 79.99    | 17       |\n| MAC Sports Collapsib  | Basketball         | 69.99    | 18       |\n| Quest Q64 10 FT. x 1  | Basketball         | 59.98    | 19       |\n| adidas Brazuca 2014   | Basketball         | 39.99    | 20       |\n| Kijaro Dual Lock Cha  | Basketball         | 29.99    | 21       |\n| adidas Brazuca 2014   | Basketball         | 29.99    | 22       |\n| Nike Women's Pro Cor  | Basketball         | 28.0     | 23       |\n| Nike Women's Pro Vic  | Basketball         | 21.99    | 24       |\n| Nike VR_S Covert Dri  | Bike &amp; Skate Shop  | 179.99   | 1        |\n| TaylorMade RocketBal  | Bike &amp; Skate Shop  | 169.99   | 2        |\n| Cobra AMP Cell Drive  | Bike &amp; Skate Shop  | 169.99   | 3        |\n| Cleveland Golf Class  | Bike &amp; Skate Shop  | 119.99   | 4        |\n| Callaway X Hot Drive  | Bike &amp; Skate Shop  | 0.0      | 5        |\n+-----------------------+--------------------+----------+----------+\n</code></pre>"},{"location":"hadoop/06hive.html#consultas-por-posicion","title":"Consultas por posici\u00f3n","text":"<p>A continuaci\u00f3n vamos a ver las funciones <code>lead</code> y <code>lag</code>. Estas funciones se encargan de obtener el valor posterior y anterior respecto a un valor.</p> <pre><code>select substr(nombre, 1, 20) as nombre, categoria, precio, lead(precio) over (partition by categoria order by precio desc) as sig,\nlag(precio) over (partition by categoria order by precio desc) as ant\nfrom productos\nwhere categoria = \"Bike &amp; Skate Shop\" or categoria = \"Basketball\";\n</code></pre> <p>Resultado:</p> <pre><code>+-----------------------+--------------------+----------+---------+----------+\n|        nombre         |     categoria      |  precio  |   sig   |   ant    |\n+-----------------------+--------------------+----------+---------+----------+\n| SOLE F85 Treadmill    | Basketball         | 1799.99  | 999.99  | NULL     |\n| SOLE E25 Elliptical   | Basketball         | 999.99   | 349.98  | 1799.99  |\n| Diamondback Adult Re  | Basketball         | 349.98   | 309.99  | 999.99   |\n| Diamondback Adult Ou  | Basketball         | 309.99   | 299.99  | 349.98   |\n| Diamondback Girls' C  | Basketball         | 299.99   | 299.99  | 309.99   |\n| Diamondback Boys' In  | Basketball         | 299.99   | 299.98  | 299.99   |\n| Diamondback Adult So  | Basketball         | 299.98   | 249.97  | 299.99   |\n| Easton Mako Youth Ba  | Basketball         | 249.97   | 209.99  | 299.98   |\n| Fitness Gear 300 lb   | Basketball         | 209.99   | 199.99  | 249.97   |\n| Quik Shade Summit SX  | Basketball         | 199.99   | 179.97  | 209.99   |\n| Easton XL1 Youth Bat  | Basketball         | 179.97   | 179.97  | 199.99   |\n| Easton S1 Youth Bat   | Basketball         | 179.97   | 159.99  | 179.97   |\n| adidas Brazuca 2014   | Basketball         | 159.99   | 149.99  | 179.97   |\n| Quest 12' x 12' Dome  | Basketball         | 149.99   | 99.95   | 159.99   |\n| Fitbit Flex Wireless  | Basketball         | 99.95    | 99.0    | 149.99   |\n| Nike+ Fuelband SE     | Basketball         | 99.0     | 79.99   | 99.95    |\n| Elevation Training M  | Basketball         | 79.99    | 69.99   | 99.0     |\n| MAC Sports Collapsib  | Basketball         | 69.99    | 59.98   | 79.99    |\n| Quest Q64 10 FT. x 1  | Basketball         | 59.98    | 39.99   | 69.99    |\n| adidas Brazuca 2014   | Basketball         | 39.99    | 29.99   | 59.98    |\n| Kijaro Dual Lock Cha  | Basketball         | 29.99    | 29.99   | 39.99    |\n| adidas Brazuca 2014   | Basketball         | 29.99    | 28.0    | 29.99    |\n| Nike Women's Pro Cor  | Basketball         | 28.0     | 21.99   | 29.99    |\n| Nike Women's Pro Vic  | Basketball         | 21.99    | NULL    | 28.0     |\n| Nike VR_S Covert Dri  | Bike &amp; Skate Shop  | 179.99   | 169.99  | NULL     |\n| TaylorMade RocketBal  | Bike &amp; Skate Shop  | 169.99   | 169.99  | 179.99   |\n| Cobra AMP Cell Drive  | Bike &amp; Skate Shop  | 169.99   | 119.99  | 169.99   |\n| Cleveland Golf Class  | Bike &amp; Skate Shop  | 119.99   | 0.0     | 169.99   |\n| Callaway X Hot Drive  | Bike &amp; Skate Shop  | 0.0      | NULL    | 119.99   |\n+-----------------------+--------------------+----------+---------+----------+\n</code></pre>"},{"location":"hadoop/06hive.html#consultas-de-agregacion","title":"Consultas de agregaci\u00f3n","text":"<p>Las funciones de agregaci\u00f3n que ya conocemos como <code>count</code>, <code>sum</code>, <code>min</code> y <code>max</code> tambi\u00e9n las podemos aplicar sobre particiones de datos y as\u00ed poder mostrar los datos agregados para cada elemento:</p> <pre><code>select substr(nombre, 1, 20) as nombre, categoria,\ncount(precio) over (partition by categoria) as cantidad,\nmin(precio) over (partition by categoria) as menor,\nmax(precio) over (partition by categoria) as mayor\nfrom productos\nwhere categoria = \"Bike &amp; Skate Shop\" or categoria = \"Basketball\";\n</code></pre> <p>Resultado:</p> <pre><code>+-----------------------+--------------------+-----------+--------+----------+\n|        nombre         |     categoria      | cantidad  | menor  |  mayor   |\n+-----------------------+--------------------+-----------+--------+----------+\n| Fitbit Flex Wireless  | Basketball         | 24        | 21.99  | 1799.99  |\n| adidas Brazuca 2014   | Basketball         | 24        | 21.99  | 1799.99  |\n| Fitness Gear 300 lb   | Basketball         | 24        | 21.99  | 1799.99  |\n| Diamondback Adult Re  | Basketball         | 24        | 21.99  | 1799.99  |\n| Nike+ Fuelband SE     | Basketball         | 24        | 21.99  | 1799.99  |\n| Elevation Training M  | Basketball         | 24        | 21.99  | 1799.99  |\n| Easton XL1 Youth Bat  | Basketball         | 24        | 21.99  | 1799.99  |\n| adidas Brazuca 2014   | Basketball         | 24        | 21.99  | 1799.99  |\n| Diamondback Girls' C  | Basketball         | 24        | 21.99  | 1799.99  |\n| Easton S1 Youth Bat   | Basketball         | 24        | 21.99  | 1799.99  |\n| Easton Mako Youth Ba  | Basketball         | 24        | 21.99  | 1799.99  |\n| SOLE E25 Elliptical   | Basketball         | 24        | 21.99  | 1799.99  |\n| Diamondback Adult Ou  | Basketball         | 24        | 21.99  | 1799.99  |\n| Kijaro Dual Lock Cha  | Basketball         | 24        | 21.99  | 1799.99  |\n| MAC Sports Collapsib  | Basketball         | 24        | 21.99  | 1799.99  |\n| adidas Brazuca 2014   | Basketball         | 24        | 21.99  | 1799.99  |\n| SOLE F85 Treadmill    | Basketball         | 24        | 21.99  | 1799.99  |\n| Quest Q64 10 FT. x 1  | Basketball         | 24        | 21.99  | 1799.99  |\n| Diamondback Boys' In  | Basketball         | 24        | 21.99  | 1799.99  |\n| Diamondback Adult So  | Basketball         | 24        | 21.99  | 1799.99  |\n| Nike Women's Pro Cor  | Basketball         | 24        | 21.99  | 1799.99  |\n| Quik Shade Summit SX  | Basketball         | 24        | 21.99  | 1799.99  |\n| Quest 12' x 12' Dome  | Basketball         | 24        | 21.99  | 1799.99  |\n| Nike Women's Pro Vic  | Basketball         | 24        | 21.99  | 1799.99  |\n| Cleveland Golf Class  | Bike &amp; Skate Shop  | 5         | 0.0    | 179.99   |\n| TaylorMade RocketBal  | Bike &amp; Skate Shop  | 5         | 0.0    | 179.99   |\n| Callaway X Hot Drive  | Bike &amp; Skate Shop  | 5         | 0.0    | 179.99   |\n| Nike VR_S Covert Dri  | Bike &amp; Skate Shop  | 5         | 0.0    | 179.99   |\n| Cobra AMP Cell Drive  | Bike &amp; Skate Shop  | 5         | 0.0    | 179.99   |\n+-----------------------+--------------------+-----------+--------+----------+\n</code></pre> <p>Las consultas que hemos visto en este caso de uso tambi\u00e9n se conocen como funciones ventana, ya que se ejecutan sobre un subconjunto de los datos. La ventana viene dada por la partici\u00f3n o por la posici\u00f3n una vez ordenados los datos.</p> <p>Los posibles valores son:</p> <ul> <li><code>rows between current row and unbounded following</code>: desde la fila actual hasta el final de la ventana/partici\u00f3n.</li> <li><code>rows between current row and N following</code>: desde la fila actual hasta los N siguientes.</li> <li><code>rows between unbounded preceding and current row</code>: desde el inicio de la ventana hasta la fila actual.</li> <li><code>rows between unbounded preceding and N following</code>: desde el inicio de la ventana hasta los N siguientes.</li> <li><code>rows between unbounded preceding and unbounded following</code>: desde el inicio de la ventana hasta el final de la ventana (caso por defecto)</li> <li><code>rows between N preceding and M following</code>: desde N filas anteriores hasta M filas siguientes.</li> </ul> <p>Por ejemplo, para obtener el m\u00e1ximo precio desde la fila actual hasta el resto de la partici\u00f3n:</p> <pre><code>select substr(nombre, 1, 20) as nombre, categoria, precio, max(precio) over (\npartition by categoria\nrows between current row and unbounded following\n) as mayor\nfrom productos\nwhere categoria = \"Bike &amp; Skate Shop\" or categoria = \"Basketball\";\n</code></pre> <p>Resultado:</p> <pre><code>+-----------------------+--------------------+----------+----------+\n|        nombre         |     categoria      |  precio  |  mayor   |\n+-----------------------+--------------------+----------+----------+\n| Fitbit Flex Wireless  | Basketball         | 99.95    | 1799.99  |\n| adidas Brazuca 2014   | Basketball         | 39.99    | 1799.99  |\n| Fitness Gear 300 lb   | Basketball         | 209.99   | 1799.99  |\n| Diamondback Adult Re  | Basketball         | 349.98   | 1799.99  |\n| Nike+ Fuelband SE     | Basketball         | 99.0     | 1799.99  |\n| Elevation Training M  | Basketball         | 79.99    | 1799.99  |\n| Easton XL1 Youth Bat  | Basketball         | 179.97   | 1799.99  |\n| adidas Brazuca 2014   | Basketball         | 29.99    | 1799.99  |\n| Diamondback Girls' C  | Basketball         | 299.99   | 1799.99  |\n| Easton S1 Youth Bat   | Basketball         | 179.97   | 1799.99  |\n| Easton Mako Youth Ba  | Basketball         | 249.97   | 1799.99  |\n| SOLE E25 Elliptical   | Basketball         | 999.99   | 1799.99  |\n| Diamondback Adult Ou  | Basketball         | 309.99   | 1799.99  |\n| Kijaro Dual Lock Cha  | Basketball         | 29.99    | 1799.99  |\n| MAC Sports Collapsib  | Basketball         | 69.99    | 1799.99  |\n| adidas Brazuca 2014   | Basketball         | 159.99   | 1799.99  |\n| SOLE F85 Treadmill    | Basketball         | 1799.99  | 1799.99  |\n| Quest Q64 10 FT. x 1  | Basketball         | 59.98    | 299.99   |\n| Diamondback Boys' In  | Basketball         | 299.99   | 299.99   |\n| Diamondback Adult So  | Basketball         | 299.98   | 299.98   |\n| Nike Women's Pro Cor  | Basketball         | 28.0     | 199.99   |\n| Quik Shade Summit SX  | Basketball         | 199.99   | 199.99   |\n| Quest 12' x 12' Dome  | Basketball         | 149.99   | 149.99   |\n| Nike Women's Pro Vic  | Basketball         | 21.99    | 21.99    |\n| Cleveland Golf Class  | Bike &amp; Skate Shop  | 119.99   | 179.99   |\n| TaylorMade RocketBal  | Bike &amp; Skate Shop  | 169.99   | 179.99   |\n| Callaway X Hot Drive  | Bike &amp; Skate Shop  | 0.0      | 179.99   |\n| Nike VR_S Covert Dri  | Bike &amp; Skate Shop  | 179.99   | 179.99   |\n| Cobra AMP Cell Drive  | Bike &amp; Skate Shop  | 169.99   | 169.99   |\n+-----------------------+--------------------+----------+----------+\n</code></pre> <p>Si queremos comparar el precio y quedarnos con el mayor respecto al anterior y el posterior podr\u00edamos realizar la siguiente consulta:</p> <pre><code>select substr(nombre, 1, 20) as nombre, categoria, precio, max(precio) over (\npartition by categoria\nrows between 1 preceding and 1 following\n) as mayor\nfrom productos\nwhere categoria = \"Bike &amp; Skate Shop\" or categoria = \"Basketball\";\n</code></pre> <p>Resultado:</p> <pre><code>+-----------------------+--------------------+----------+----------+\n|        nombre         |     categoria      |  precio  |  mayor   |\n+-----------------------+--------------------+----------+----------+\n| Fitbit Flex Wireless  | Basketball         | 99.95    | 99.95    |\n| adidas Brazuca 2014   | Basketball         | 39.99    | 209.99   |\n| Fitness Gear 300 lb   | Basketball         | 209.99   | 349.98   |\n| Diamondback Adult Re  | Basketball         | 349.98   | 349.98   |\n| Nike+ Fuelband SE     | Basketball         | 99.0     | 349.98   |\n| Elevation Training M  | Basketball         | 79.99    | 179.97   |\n| Easton XL1 Youth Bat  | Basketball         | 179.97   | 179.97   |\n| adidas Brazuca 2014   | Basketball         | 29.99    | 299.99   |\n| Diamondback Girls' C  | Basketball         | 299.99   | 299.99   |\n| Easton S1 Youth Bat   | Basketball         | 179.97   | 299.99   |\n| Easton Mako Youth Ba  | Basketball         | 249.97   | 999.99   |\n| SOLE E25 Elliptical   | Basketball         | 999.99   | 999.99   |\n| Diamondback Adult Ou  | Basketball         | 309.99   | 999.99   |\n| Kijaro Dual Lock Cha  | Basketball         | 29.99    | 309.99   |\n| MAC Sports Collapsib  | Basketball         | 69.99    | 159.99   |\n| adidas Brazuca 2014   | Basketball         | 159.99   | 1799.99  |\n| SOLE F85 Treadmill    | Basketball         | 1799.99  | 1799.99  |\n| Quest Q64 10 FT. x 1  | Basketball         | 59.98    | 1799.99  |\n| Diamondback Boys' In  | Basketball         | 299.99   | 299.99   |\n| Diamondback Adult So  | Basketball         | 299.98   | 299.99   |\n| Nike Women's Pro Cor  | Basketball         | 28.0     | 299.98   |\n| Quik Shade Summit SX  | Basketball         | 199.99   | 199.99   |\n| Quest 12' x 12' Dome  | Basketball         | 149.99   | 199.99   |\n| Nike Women's Pro Vic  | Basketball         | 21.99    | 149.99   |\n| Cleveland Golf Class  | Bike &amp; Skate Shop  | 119.99   | 169.99   |\n| TaylorMade RocketBal  | Bike &amp; Skate Shop  | 169.99   | 169.99   |\n| Callaway X Hot Drive  | Bike &amp; Skate Shop  | 0.0      | 179.99   |\n| Nike VR_S Covert Dri  | Bike &amp; Skate Shop  | 179.99   | 179.99   |\n| Cobra AMP Cell Drive  | Bike &amp; Skate Shop  | 169.99   | 179.99   |\n+-----------------------+--------------------+----------+----------+\n</code></pre>"},{"location":"hadoop/06hive.html#referencias","title":"Referencias","text":"<ul> <li>P\u00e1gina oficial de Hive</li> <li>Apache Hive Essentials - Second Edition de Dayong Du.</li> <li>Hive Cheatsheet</li> <li>Tutorial de Hive de TutorialsPoint.</li> </ul>"},{"location":"hadoop/06hive.html#actividades","title":"Actividades","text":"<ol> <li> <p>(RA5074.3 / CE4.3d / 2,5p) Realiza los casos de uso del 1 al 5. En la entrega debes adjuntar una captura de pantalla donde se vea la ejecuci\u00f3n de las diferentes instrucciones.</p> </li> <li> <p>(RA5074.3 / CE4.3b y CE4.3d / 1p) A partir de la base de datos <code>retail_db</code>, importa las tablas <code>orders</code> y <code>order_items</code>, en las cuales puedes obtener la cantidad de productos que contiene un pedido. Utilizando todas las tablas que ya hemos importado en los casos anteriores, crea una tabla externa en Hive llamada <code>pedidos</code> utilizando 8 buckets con el c\u00f3digo del cliente, que contenga:</p> <ul> <li>C\u00f3digo y fecha del pedido.</li> <li>Precio del pedido (sumando las l\u00edneas de pedido).</li> <li>C\u00f3digo, nombre y apellidos del cliente.</li> </ul> <p>Adjunta scripts y capturas de:</p> <ul> <li>la importaci\u00f3n, creaci\u00f3n y carga de datos de las tablas que necesites.</li> <li>la definici\u00f3n de la tabla: <code>describe formatted pedidos;</code></li> <li>contenido de HDFS que demuestre la creaci\u00f3n de los buckets.</li> </ul> </li> <li> <p>(RA5074.3 / CE4.3d / 0,5p) Investiga la creaci\u00f3n de vistas en Hive y crea una vista con los datos de los clientes y sus pedidos siempre y cuando superen los 200$.</p> </li> </ol>"},{"location":"sa/index.html","title":"Sistemas de almacenamiento","text":""},{"location":"sa/index.html#resultados-de-aprendizaje","title":"Resultados de aprendizaje","text":"<ul> <li>RA5074.1 Aplica t\u00e9cnicas de an\u00e1lisis de datos que integran, procesan y analizan la informaci\u00f3n, adaptando e implementando sistemas que las utilicen.  </li> <li>RA5074.3 Gestiona y almacena datos facilitando la b\u00fasqueda de respuestas en grandes conjuntos de datos.  </li> <li>RA5075.1 Gestiona soluciones a problemas propuestos, utilizando sistemas de almacenamiento y herramientas asociadas al centro de datos.  </li> <li>RA5075.2 Gestiona sistemas de almacenamiento y el amplio ecosistema alrededor de ellos facilitando el procesamiento de grandes cantidades de datos sin fallos y de forma r\u00e1pida.  </li> <li>RA5075.3 Genera mecanismos de integridad de los datos, comprobando su mantenimiento en los sistemas de ficheros distribuidos y valorando la sobrecarga que conlleva en el tratamiento de los datos.</li> </ul>"},{"location":"sa/index.html#planificacion-24h","title":"Planificaci\u00f3n (24h)","text":"Sesi\u00f3n Fecha Duraci\u00f3n (h) 18.- Almacenamiento de datos / NoSQL Mi\u00e9rcoles 26 Oct 1p + 1o 19.- MongoDB Mi\u00e9rcoles 26 Oct  Mi\u00e9rcoles 2 Nov 3p + 3o 21.- Modelado documental Lunes 7 Nov 2p + 2o 25.- Agregaciones en MongoDB Mi\u00e9rcoles 9 Nov 2p + 2o 28.- Replicaci\u00f3n y Particionado Lunes 14 Nov 2p + 2o 30.- MongoDB y Python Mi\u00e9rcoles 16 Nov 2p + 2o"},{"location":"sa/01nosql.html","title":"Almacenamiento de datos. NoSQL","text":""},{"location":"sa/01nosql.html#almacenamiento-de-datos","title":"Almacenamiento de Datos","text":"<p>Se puede decir que estamos en la tercera plataforma del almacenamiento de datos. La primera lleg\u00f3 con los primeros computadores y se materializ\u00f3 en las bases de datos jer\u00e1rquicas y en red, as\u00ed como en el almacenamiento ISAM. La segunda vino de la mano de internet y las arquitecturas cliente-servidor, lo que dio lugar a las bases de datos relacionales.</p> <p>La tercera se ve motivada por el big data, los dispositivos m\u00f3viles, las arquitecturas cloud, las redes de IoT y las tecnolog\u00edas/redes sociales. Es tal el volumen de datos que se genera que aparecen nuevos paradigmas como NoSQL, NewSQL y las plataformas de Big Data. En esta sesi\u00f3n nos vamos a centrar en NoSQL.</p> <p>NoSQL aparece como una necesidad debida al creciente volumen de datos sobre usuarios, objetos y productos que las empresas tienen que almacenar, as\u00ed como la frecuencia con la que se accede a los datos. Los SGDB relacionales existentes no fueron dise\u00f1ados teniendo en cuenta la escalabilidad ni la flexibilidad necesaria por las frecuentes modificaciones que necesitan las aplicaciones modernas; tampoco aprovechan que el almacenamiento a d\u00eda de hoy es muy barato, ni el nivel de procesamiento que alcanzan las m\u00e1quinas actuales.</p> Motivaci\u00f3n de NoSQL <p>La soluci\u00f3n es el despliegue de las aplicaciones y sus datos en cl\u00fasteres de servidores, distribuyendo el procesamiento en m\u00faltiples m\u00e1quinas.</p>"},{"location":"sa/01nosql.html#no-solo-sql","title":"No Solo SQL","text":"<p>Si definimos NoSQL formalmente, podemos decir que se trata de un conjunto de tecnolog\u00edas que permiten el procesamiento r\u00e1pido y eficiente de conjuntos de datos dando la mayor importancia al rendimiento, la fiabilidad y la agilidad.</p> <p>Si nos basamos en el acr\u00f3nimo, el t\u00e9rmino se refiere a cualquier almac\u00e9n de datos que no sigue un modelo relacional, los datos no son relacionales y por tanto no utilizan SQL como lenguaje de consulta. Otra aceptaci\u00f3n implica que el No hace referencia a not only, es decir, que los sistemas NoSQL se centran en sistemas complementarios a los SGBD relacionales, que fijan sus prioridades en la escalabilidad y la disponibilidad en contra de la atomicidad y consistencia de los datos.</p> <p></p> <p>ACID</p> <p>Las bases de datos relacionales cumplen las caracter\u00edsticas ACID para ofrecer transaccionalidad sobre los datos:</p> <ul> <li>Atomicidad: las transacciones implican que se realizan todas las operaciones o no se realiza ninguna.</li> <li>Consistencia: la base de datos asegura que los datos pasan de un estado v\u00e1lido o otro tambi\u00e9n.</li> <li>Isolation (Aislamiento): Una transacci\u00f3n no afecta a otras transacciones, de manera que la modificaci\u00f3n de un registro / documento no es visible por otras lecturas.</li> <li>Durabilidad: La escritura de los datos asegura que una vez finalizada una operaci\u00f3n, los datos no se perder\u00e1n.</li> </ul> <p>Los diferentes tipos de bases de datos NoSQL existentes se pueden agrupar en cuatro categor\u00edas:</p> <ul> <li> <p>Clave-Valor: Los almacenes clave-valor son las bases de datos NoSQL m\u00e1s simples. Cada elemento de la base de datos se almacena con un nombre de atributo (o clave) junto a su valor. Los almacenes m\u00e1s conocidos son Redis, Riak y AWS DynamoDB. Algunos almacenes, como es el caso de Redis, permiten que cada valor tenga un tipo (por ejemplo, integer) lo cual a\u00f1ade funcionalidad extra.</p> </li> <li> <p>Documentales: Cada clave se asocia a una estructura compleja que se conoce como documento. Este puede contener diferentes pares clave-valor, o pares de clave-array o incluso documentos anidados, como en un documento JSON. Los ejemplos m\u00e1s conocidos son MongoDB y CouchDB.</p> </li> <li> <p>Grafos: Los almacenes de grafos se usan para almacenar informaci\u00f3n sobre redes, como pueden ser conexiones sociales. Los ejemplos m\u00e1s conocidos son Neo4J, AWS Neptune y ArangoDB.</p> </li> <li> <p>Basados en columnas: Los almacenes basados en columnas como BigTable, Cassandra y HBase est\u00e1n optimizados para consultas sobre grandes conjuntos de datos, y almacenan los datos como columnas en vez de como filas.</p> </li> </ul> Sistemas NoSQL"},{"location":"sa/01nosql.html#caracteristicas","title":"Caracter\u00edsticas","text":"<p>Si nos centramos en sus beneficios y los comparamos con las base de datos relacionales, las bases de datos NoSQL son m\u00e1s escalables, ofrecen un rendimiento mayor y sus modelos de datos resuelven varios problemas que no se plantearon al definir el modelo relacional:</p> <ul> <li>Grandes vol\u00famenes de datos estructurados, semi-estructurados y sin estructurar. Casi todas las implementaciones NoSQL ofrecen alg\u00fan tipo de representaci\u00f3n para datos sin esquema, lo que permite comenzar con una estructura y con el paso del tiempo, a\u00f1adir nuevos campos, ya sean sencillos o anidados a datos ya existentes.</li> <li>Sprints \u00e1giles, iteraciones r\u00e1pidas y frecuentes commits/pushes de c\u00f3digo, al emplear una sintaxis sencilla para la realizaci\u00f3n de consultas y la posibilidad de tener un modelo que vaya creciendo al mismo ritmo que el desarrollo.</li> <li>Arquitectura eficiente y escalable dise\u00f1ada para trabajar con clusters en vez de una arquitectura monol\u00edtica y costosa. Las soluciones NoSQL soportan la escalabilidad de un modo transparente para el desarrollador.</li> </ul> <p>Una caracter\u00edstica adicional que comparten los sistemas NoSQL es que ofrecen un mecanismo de cach\u00e9 de datos integrado (en los sistemas relacionales se pueden configurar de manera externa), de manera que se pueden configurar los sistemas para que los datos se mantengan en memoria y se persistan de manera peri\u00f3dica. El uso de una cach\u00e9 conlleva que la consistencia de los datos no sea completa y podamos tener una consistencia eventual.</p>"},{"location":"sa/01nosql.html#esquema-dinamicos","title":"Esquema din\u00e1micos","text":"<p>Las bases de datos relacionales requieren definir los esquemas antes de a\u00f1adir los datos. Una base de datos SQL necesita saber de antemano los datos que vamos a almacenar; por ejemplo, si nos centramos en los datos de un cliente, ser\u00edan el nombre, apellidos, n\u00famero de tel\u00e9fono, etc\u2026\u200b</p> <p>Esto casa bastante mal con los enfoques de desarrollo \u00e1gil, ya que cada vez que a\u00f1adimos nuevas funcionalidades, el esquema de la base de datos suele cambiar. De modo que si a mitad de desarrollo decidimos almacenar los productos favoritos de un cliente del cual guard\u00e1bamos su direcci\u00f3n y n\u00fameros de tel\u00e9fono, tendr\u00edamos que a\u00f1adir una nueva columna a la base de datos y migrar la base de datos entera a un nuevo esquema.</p> <p>Si la base de datos es grande, conlleva un proceso lento que implica parar el sistema durante un tiempo considerable. Si frecuentemente cambiamos los datos que la aplicaci\u00f3n almacena (al usar un desarrollo iterativo), tambi\u00e9n tendremos per\u00edodos frecuentes de inactividad del sistema. As\u00ed pues, no hay un modo efectivo mediante una base de datos relacional, de almacenar los datos que est\u00e1n desestructurados o que no se conocen de antemano.</p> <p>Las bases de datos NoSQL se construyen para permitir la inserci\u00f3n de datos sin un esquema predefinido. Esto facilita la modificaci\u00f3n de la aplicaci\u00f3n en tiempo real, sin preocuparse por interrupciones de servicio. Aunque no tengamos un esquema al guardar la informaci\u00f3n, s\u00ed que podemos definir esquemas de lectura (schema-on-read) para comprobar que la informaci\u00f3n almacenada tiene el formato que espera cargar cada aplicaci\u00f3n.</p> <p>De este modo se consigue un desarrollo m\u00e1s r\u00e1pido, integraci\u00f3n de c\u00f3digo m\u00e1s robusto y menos tiempo empleado en la administraci\u00f3n de la base de datos.</p>"},{"location":"sa/01nosql.html#particionado","title":"Particionado","text":"<p>Dado el modo en el que se estructuran las bases de datos relacionales, normalmente escalan verticalmente - un \u00fanico servidor que almacena toda la base de datos para asegurar la disponibilidad continua de los datos. Esto se traduce en costes que se incrementan r\u00e1pidamente, con un l\u00edmites definidos por el propio hardware, y en un peque\u00f1o n\u00famero de puntos cr\u00edticos de fallo dentro de la infraestructura de datos.</p> <p>La soluci\u00f3n es escalar horizontalmente, a\u00f1adiendo nuevos servidores en vez de concentrarse en incrementar la capacidad de un \u00fanico servidor, lo que permite tratar con conjuntos de datos m\u00e1s grandes de lo que ser\u00eda capaz cualquier m\u00e1quina por s\u00ed sola. Este escalado horizontal se conoce como Sharding o Particionado.</p> <p>El particionado no es \u00fanico de las bases de datos NoSQL. Las bases de datos relacionales tambi\u00e9n lo soportan. Si en un sistema relacional queremos particionar los datos, podemos distinguir entre particionado:</p> <ul> <li>Horizontal: diferentes filas en diferentes particiones.</li> <li>Vertical: diferentes columnas en particiones distintas.</li> </ul> Particionado de los datos - digitalocean.com <p>En el caso de las bases de datos NoSQL, el particionado depende del modelo de la base de datos:</p> <ul> <li>Los almacenes clave-valor y las bases de datos documentales normalmente se particionan horizontalmente.</li> <li>Las bases de datos basados en columnas se pueden particionar horizontal o verticalmente.</li> </ul> <p>Escalar horizontalmente una base de datos relacional entre muchas instancias de servidores se puede conseguir pero normalmente conlleva el uso de SANs (Storage Area Networks) y otras triqui\u00f1uelas para hacer que el hardware act\u00fae como un \u00fanico servidor.</p> <p>Como los sistemas SQL no ofrecen esta prestaci\u00f3n de forma nativa, los equipos de desarrollo se las tienen que ingeniar para conseguir desplegar m\u00faltiples bases de datos relacionales en varias m\u00e1quinas. Para ello:</p> <ul> <li>Los datos se almacenan en cada instancia de base de datos de manera aut\u00f3noma</li> <li>El c\u00f3digo de aplicaci\u00f3n se desarrolla para distribuir los datos y las consultas y agregar los resultados de los datos a trav\u00e9s de todas las instancias de bases de datos</li> <li>Se debe desarrollar c\u00f3digo adicional para gestionar los fallos sobre los recursos, para realizar joins entre diferentes bases de datos, balancear los datos y/o replicarlos, etc\u2026\u200b</li> </ul> <p>Adem\u00e1s, muchos beneficios de las bases de datos como la integridad transaccional se ven comprometidos o incluso eliminados al emplear un escalado horizontal.</p>"},{"location":"sa/01nosql.html#auto-sharding","title":"Auto-sharding","text":"<p>Por contra, las bases de datos NoSQL normalmente soportan auto-sharding, lo que implica que de manera nativa y autom\u00e1ticamente se dividen los datos entre un n\u00famero arbitrario de servidores, sin que la aplicaci\u00f3n sea consciente de la composici\u00f3n del pool de servidores. Los datos y las consultas se balancean entre los servidores.</p> <p>El particionado se realiza mediante un m\u00e9todo consistente, como puede ser:</p> <ul> <li> <p>Por rangos de su id: por ejemplo \"los usuarios del 1 al mill\u00f3n est\u00e1n en la partici\u00f3n 1\" o \"los usuarios cuyo nombre va de la A a la E\" en una partici\u00f3n, en otra de la M a la Q, y de la R a la Z en la tercera.</p> <p> Particionado por rango - digitalocean.com </p> </li> <li> <p>Por listas: dividiendo los datos por la categor\u00eda del dato, es decir, en el caso de datos sobre libros, las novelas en una partici\u00f3n, las recetas de cocina en otra, etc..</p> </li> <li> <p>Mediante un funci\u00f3n hash, la cual devuelve un valor para un elemento que determine a que partici\u00f3n pertenece.</p> <p> Particionado por hash - digitalocean.com </p> </li> </ul>"},{"location":"sa/01nosql.html#cuando-particionar","title":"Cuando particionar","text":"<p>El motivo para particionar los datos se debe a:</p> <ul> <li>limitaciones de almacenamiento: los datos no caben en un \u00fanico servidor, tanto a nivel de disco como de memoria RAM.</li> <li>rendimiento: al balancear la carga entre particiones las escrituras ser\u00e1n m\u00e1s r\u00e1pidas que al centrarlas en un \u00fanico servidor.</li> <li>disponibilidad: si un servidor esta ocupado, otro servidor puede devolver los datos. La carga de los servidores se reduce.</li> </ul> <p>No particionaremos los datos cuando la cantidad sea peque\u00f1a, ya que el hecho de distribuir los datos conlleva unos costes que pueden no compensar con un volumen de datos insuficiente. Tampoco esperaremos a particionar cuando tengamos much\u00edsimos datos, ya que el proceso de particionado puede provocar sobrecarga del sistema.</p> <p>La nube facilita de manera considerable este escalado, mediante proveedores como AWS o Azure los cuales ofrecen virtualmente una capacidad ilimitada bajo demanda, y despreocup\u00e1ndose de todas las tareas necesarias para la administraci\u00f3n de la base de datos.</p> <p>Los desarrolladores ya no necesitamos construir plataformas complejas para nuestras aplicaciones, de modo que nos podemos centrar en escribir c\u00f3digo de aplicaci\u00f3n. Una granja de servidores con commodity hardware puede ofrecer el mismo procesamiento y capacidad de almacenamiento que un \u00fanico servidor de alto rendimiento por mucho menos coste.</p>"},{"location":"sa/01nosql.html#replicacion","title":"Replicaci\u00f3n","text":"<p>La replicaci\u00f3n mantiene copias id\u00e9nticas de los datos en m\u00faltiples servidores, lo que facilita que las aplicaciones siempre funcionen y los datos se mantengan seguros, incluso si alguno de los servidores sufre alg\u00fan problema.</p> <p>La mayor\u00eda de las bases de datos NoSQL tambi\u00e9n soportan la replicaci\u00f3n autom\u00e1tica, lo que implica una alta disponibilidad y recuperaci\u00f3n frente a desastres sin la necesidad de aplicaciones de terceros encargadas de ello. Desde el punto de vista del desarrollador, el entorno de almacenamiento es virtual y ajeno al c\u00f3digo de aplicaci\u00f3n.</p> <p>Existen dos formas de realiza la replicaci\u00f3n:</p>"},{"location":"sa/01nosql.html#maestro-esclavo-primario-secundario","title":"Maestro-esclavo / Primario-secundario","text":"<p>Todas las escrituras se realizan en el nodo principal y despu\u00e9s se replican a los nodos secundarios. El nodo primario es un SPOF (single point of failure).</p> Replicaci\u00f3n primario-secundario"},{"location":"sa/01nosql.html#par-a-par-peer-to-peer","title":"Par-a-par (peer-to-peer)","text":"<p>Todos los nodos tienen el mismo nivel jer\u00e1rquico, de manera que todos admiten escrituras. Al poder haber escrituras simult\u00e1neas sobre el mismo datos en diferentes nodos, pueden darse inconsistencia en los datos.</p> Replicaci\u00f3n Peer-to-peer <p>La replicaci\u00f3n de los datos se utiliza para alcanzar:</p> <ul> <li>escalabilidad, incrementando el rendimiento al poder distribuir las consultas en diferentes nodos, y mejorar la redundancia al permitir que cada nodo tenga una copia de los datos.</li> <li>disponibilidad, ofreciendo tolerancia a fallos de hardware o corrupci\u00f3n de la base de datos. Al replicar los datos vamos a poder tener una copia de la base de datos, dar soporte a un servidor de datos agregados, o tener nodos a modo de copias de seguridad que pueden tomar el control en caso de fallo.</li> <li>aislamiento (la i en ACID - isolation), entendido como la propiedad que define cuando y c\u00f3mo al realizar cambios en un nodo se propagan al resto de nodos. Si replicamos los datos podemos crear copias sincronizadas para separar procesos de la base de datos de producci\u00f3n, pudiendo ejecutar informes, anal\u00edtica de datos o copias de seguridad en nodos secundarios de modo que no tenga un impacto negativo en el nodo principal, as\u00ed como ofrecer un sistema sencillo para separar el entorno de producci\u00f3n del de preproducci\u00f3n.</li> </ul> <p>Replicaci\u00f3n vs particionado</p> <p>No hay que confundir la replicaci\u00f3n (copia de los datos en varias m\u00e1quinas) con el particionado (cada m\u00e1quina tiene un subconjunto de los datos). El entorno m\u00e1s seguro y con mejor rendimiento es aquel que tiene los datos particionados y replicados (cada m\u00e1quina que tiene un subconjunto de los datos est\u00e1 replicada en 2 o m\u00e1s).</p> <p> Replicaci\u00f3n y particionado - codingexplained.com/figcaption&gt;"},{"location":"sa/01nosql.html#implantando-nosql","title":"Implantando NoSQL","text":"<p>Normalmente, las empresas empezar\u00e1n con una prueba de baja escalabilidad de una base de datos NoSQL, de modo que les permita comprender la tecnolog\u00eda asumiendo muy poco riesgo. La mayor\u00eda de las bases de datos NoSQL tambi\u00e9n son open-source, y por tanto se pueden probar sin ning\u00fan coste extra. Al tener unos ciclos de desarrollo m\u00e1s r\u00e1pidos, las empresas pueden innovar con mayor velocidad y mejorar la experiencia de sus cliente a un menor coste.</p> <p>Elegir la base de datos correcta para el proyecto es un tema importante. Se deben considerar las diferentes alternativas a las infraestructuras legacy teniendo en cuenta varios factores:</p> <ul> <li>la escalabilidad o el rendimiento m\u00e1s all\u00e1 de las capacidades del sistema existente.</li> <li>identificar alternativas viables respecto al software propietario.</li> <li>incrementar la velocidad y agilidad del proceso de desarrollo.</li> </ul> <p>As\u00ed pues, al elegir un base de datos hemos de tener en cuenta las siguientes dimensiones:</p> <ul> <li>modelo de datos: A elegir entre un modelo documental, basado en columnas, de grafos o mediante clave-valor.</li> <li>modelo de consultas: Dependiendo de la aplicaci\u00f3n, puede ser aceptable un modelo de consultas que s\u00f3lo accede a los registros por su clave primaria. En cambio, otras aplicaciones pueden necesitar consultar por diferentes valores de cada registro. Adem\u00e1s, si la aplicaci\u00f3n necesita modificar los registros, la base de datos necesita consultar los datos por un \u00edndice secundario.</li> <li>modelo de consistencia: Los sistemas NoSQL normalmente mantienen m\u00faltiples copias de los datos para ofrecer disponibilidad y escalabilidad al sistema, lo que define la consistencia del mismo. Los sistemas NoSQL tienden a ser consistentes o eventualmente consistentes.</li> <li>APIs: No existe un est\u00e1ndar para interactuar con los sistemas NoSQL. Cada sistema presenta diferentes dise\u00f1os y capacidades para los equipos de desarrollo. La madurez de un API puede suponer una inversi\u00f3n en tiempo y dinero a la hora de desarrollar y mantener el sistema NoSQL.</li> <li> <p>soporte comercial y de la comunidad: Los usuarios deben considerar la salud de la compa\u00f1\u00eda o de los proyectos al evaluar una base de datos. El producto debe evolucionar y mantenerse para introducir nuevas prestaciones y corregir fallos. Una base de datos con una comunidad fuerte de usuarios:</p> <ul> <li>permite encontrar y contratar desarrolladores con destrezas en el producto.</li> <li>facilita encontrar informaci\u00f3n, documentaci\u00f3n y ejemplos de c\u00f3digo.</li> <li>ayuda a las empresas a retener el talento.</li> <li>favorece que otras empresas de software integren sus productos y participen en el ecosistema de la base de datos.</li> </ul> </li> </ul>"},{"location":"sa/01nosql.html#casos-de-uso","title":"Casos de uso","text":"<p>Una vez conocemos los diferentes sistemas y qu\u00e9 elementos puede hacer que nos decidamos por una soluci\u00f3n u otra, conviene repasar los casos de uso m\u00e1s comunes:</p> <ul> <li>si vamos a crear una aplicaci\u00f3n web cuyo campos sean personalizables, usaremos una soluci\u00f3n documental.</li> <li>como una capa de cach\u00e9, mediante un almac\u00e9n clave-valor.</li> <li>para almacenar archivos binarios sin preocuparse de la gesti\u00f3n de permisos del sistema de archivos, y poder realizar consultas sobre sus metadatos, ya sea mediante una soluci\u00f3n documental o un almac\u00e9n clave-valor.</li> <li>para almacenar un enorme volumen de datos, donde la consistencia no es lo m\u00e1s importante, pero si la disponibilidad y su capacidad de ser distribuida, mediante una soluci\u00f3n documental o basada en columnas.</li> </ul>"},{"location":"sa/01nosql.html#modelos-de-datos","title":"Modelos de Datos","text":"<p>La principal clasificaci\u00f3n de los sistemas de bases de datos NoSQL se realiza respecto a los diferentes modelos de datos:</p>"},{"location":"sa/01nosql.html#documental","title":"Documental","text":"<p>Mientras las bases de datos relacionales almacenan los datos en filas y columnas, las bases de datos documentales emplean documentos. Estos documentos utilizan una estructura JSON, ofreciendo un modo natural e intuitivo para modelar datos de manera similar a la orientaci\u00f3n a objetos, donde cada documento es un objeto.</p> Representaci\u00f3n de un documento <p>Los documentos se agrupan en colecciones o bases de datos, dependiendo del sistema, lo que permite agrupar documentos.</p> <p>Los documentos contienen uno o m\u00e1s campos, donde cada campo contiene un valor con un tipo, ya sea cadena, entero, flotante, fecha, binario o array u otro documento. En vez de extender los datos entre m\u00faltiples columnas y tablas, cada registro y sus datos asociados se almacenan de manera unida en un \u00fanico documento. Esto simplifica el acceso a los datos y reduce (y en ocasiones elimina) la necesidad de joins y transacciones complejas.</p> <p>Dicho de otra manera, en las bases de datos documentales, los datos que van juntos y se emplean juntos, se almacenan juntos.</p>"},{"location":"sa/01nosql.html#caracteristicas_1","title":"Caracter\u00edsticas","text":"<p>En una base de datos documental, la noci\u00f3n de esquema es din\u00e1mico: cada documento puede contener diferentes campos. Esta flexibilidad puede ser \u00fatil para modelar datos desestructurados y polim\u00f3rficos, lo que facilita la evoluci\u00f3n del desarrollo al permitir a\u00f1adir nuevos campos de manera din\u00e1mica.</p> <p>Perfectamente podemos tener dos documentos que pertenecen a la misma colecci\u00f3n, pero con atributos diferentes. Por ejemplo, un primer documento puede ser el siguiente:</p> <pre><code>{\n\"_id\": \"BW001\",\n\"nombre\": \"Bruce\",\n\"apellido\": \"Wayne\",\n\"edad\": 35,\n\"salario\": 10000000\n}\n</code></pre> <p>Mientras que un segundo documento dentro de la misma colecci\u00f3n podr\u00eda ser:</p> <pre><code>{\n\"_id\": \"JK1\",\n\"nombre\": \"Joker\",\n\"edad\": 34,\n\"salario\": 5000000,\n\"direccion\": {               // (1)!\n\"calle\": \"Asilo Arkham\",\n\"ciudad\": \"Gotham\"\n},\n\"proyectos\": [               // (2)!\n\"desintoxicacion-virus\",\n\"top-secret-007\"\n]\n}\n</code></pre> <ol> <li>Un objeto o subdocumento permite agrupar informaci\u00f3n similar a una relaci\u00f3n 1:1 de un modelo relacional. De esta manera, no necesitamos una tabla <code>Direccion</code>.</li> <li>Un array puede contener valores o documentos, de manera que podr\u00edamos tener un array de documentos, permitiendo agrupar informaci\u00f3n similar a una relaci\u00f3n 1:N de un modelo relacional. De esta manera, no necesitamos una tabla <code>Proyectos</code>.</li> </ol> <p>Normalmente, cada documento contiene un elemento clave, sobre el cual se puede obtener un documento de manera un\u00edvoca. De todos modos, las bases de datos documentales ofrecen un completo mecanismo de consultas, posibilitando obtener informaci\u00f3n por cualquier campo del documento. Algunos productos ofrecen opciones de indexado para optimizar las consultas, como pueden ser \u00edndices compuestos, dispersos, con tiempo de vida (TTL), \u00fanicos, de texto o geoespaciales.</p> <p>Adem\u00e1s, estos sistemas ofrecen productos que permiten analizar los datos, mediante funciones de agregaci\u00f3n o implementaci\u00f3n de MapReduce.</p> <p>Respecto a la modificaciones, los documentos se pueden actualizar en una \u00fanica sentencia, sin necesidad de dar rodeos para elegir los datos a modificar.</p>"},{"location":"sa/01nosql.html#casos-de-uso_1","title":"Casos de uso","text":"<p>Las bases de datos documentales sirven para prop\u00f3sito general, v\u00e1lidos para un amplio abanico de aplicaciones gracias a la flexibilidad que ofrece el modelo de datos, lo que permite consultar cualquier campo y modelar de manera natural de manera similar a la programaci\u00f3n orientada a objetos.</p> <p>Entre los casos de \u00e9xito de estos sistemas cabe destacar:</p> <ul> <li>Sistemas de flujo de eventos: entre diferentes aplicaciones dentro de una empresa</li> <li>Gestores de Contenido, plataformas de Blogging: al almacenar los documentos mediante JSON, facilita la estructura de datos para guardar los comentarios, registros de usuarios, etc\u2026\u200b</li> <li>Anal\u00edticas Web, datos en Tiempo Real: al permitir modificar partes de un documento, e insertar nuevos atributos a un documento cuando se necesita una nueva m\u00e9trica</li> <li>Aplicaciones eCommerce: conforme las aplicaciones crecen, el esquema tambi\u00e9n lo hace</li> </ul> <p>Si nos centramos en aquellos casos donde no conviene este tipo de sistemas podemos destacar:</p> <ul> <li>Sistemas operacionales con transacciones complejas.</li> <li>Sistemas con consultas agregadas que modifican su estructura. Si los criterios de las consultas no paran de cambiar, acabaremos normalizando los datos.</li> </ul> <p>Los productos m\u00e1s destacados son:</p> <ul> <li>MongoDB: http://www.mongodb.com. Esta base de datos la vamos a estudiar en profundidad en esta unidad de trabajo.</li> <li>CouchDB: http://couchdb.apache.org</li> </ul>"},{"location":"sa/01nosql.html#clave-valor","title":"Clave-Valor","text":"<p>Un almac\u00e9n clave-valor es una simple tabla hash donde todos los accesos a la base de datos se realizan a trav\u00e9s de la clave primaria.</p> <p>Desde una perspectiva de modelo de datos, los almacenes de clave-valor son los m\u00e1s b\u00e1sicos.</p> <p>Su funcionamiento es similar a tener una tabla relacional con dos columnas, por ejemplo <code>id</code> y <code>nombre</code>, siendo <code>id</code> la columna utilizada como clave y <code>nombre</code> como valor. Mientras que en una base de datos en el campo <code>nombre</code> s\u00f3lo podemos almacenar datos de tipo cadena o num\u00e9rico, en un almac\u00e9n clave-valor, el valor puede ser de un dato simple o un objeto. Cuando una aplicaci\u00f3n accede mediante la clave y el valor, se almacenan el par de elementos. Si la clave ya existe, el valor se modifica.</p> Representaci\u00f3n de un almac\u00e9n clave-valor <p>El cliente puede tanto obtener el valor por la clave, asignar un valor a una clave o eliminar una clave del almac\u00e9n. El valor, sin embargo, es opaco al sistema, el cual no sabe que hay dentro de \u00e9l, ya que los datos s\u00f3lo se pueden consultar por la clave, lo cual puede ser un inconveniente. As\u00ed pues, la aplicaci\u00f3n es responsable de saber qu\u00e9 hay almacenado en cada valor.</p> <p>Por ejemplo, Riak utiliza el concepto de bucket (cubo) como una manera de agrupar claves, de manera similar a una tabla.</p> <p>Por ejemplo, Riak permite interactuar con la base de datos mediante peticiones HTTP:</p> <pre><code>curl -v -X PUT &lt;http://localhost:8091/riak/heroes/ace&gt; -H \"Content-Type: application/json\" -d {\"nombre\" : \"Batman\", \"color\" : \"Negro\"}\n</code></pre> <p>Algunos almacenes clave-valor, como puede ser Redis, permiten almacenar datos con cualquier estructura, como por ejemplos listas, conjuntos, hashes y pueden realizar operaciones como intersecci\u00f3n, uni\u00f3n, diferencia y rango.</p> Comandos RedisPython <pre><code>SET nombre \"Bruce Wayne\"      // String\nHSET heroe nombre \"Batman\"    // Hash \u2013 set\nHSET heroe color \"Negro\"\nSADD \"heroe:amigos\" \"Robin\" \"Alfred\"   // Set \u2013 create/update\n</code></pre> <pre><code>import redis\nr = redis.Redis()\nr.mset({\"Croatia\": \"Zagreb\", \"Bahamas\": \"Nassau\"})\nr.get(\"Bahamas\")\n# b'Nassau'\n</code></pre> <p>Estas prestaciones hacen que Redis se extrapole a \u00e1mbitos ajenos a un almac\u00e9n clave-valor. Otra caracter\u00edstica que ofrecen algunos almacenes es que permiten crear un segundo nivel de consulta o incluso definir m\u00e1s de una clave para un mismo objeto.</p> <p>Como los almacenes clave-valor siempre utilizan accesos por clave primaria, de manera general tienen un gran rendimiento y son f\u00e1cilmente escalables.</p> <p>Si queremos que su rendimiento sea m\u00e1ximo, pueden configurarse para que mantengan la informaci\u00f3n en memoria y que se serialice de manera peri\u00f3dica, a costa de tener una consistencia eventual de los datos.</p>"},{"location":"sa/01nosql.html#casos-de-uso_2","title":"Casos de uso","text":"<p>Este modelo es muy \u00fatil para representar datos desestructurados o polim\u00f3rficos, ya que no fuerzan ning\u00fan esquema m\u00e1s all\u00e1 de los pares de clave-valor.</p> <p>Entre los casos de uso de estos almacenes podemos destacar el almacenaje de:</p> <ul> <li>Informaci\u00f3n sobre la sesi\u00f3n de navegaci\u00f3n (sessionid)</li> <li>Perfiles de usuario, preferencias</li> <li>Datos del carrito de la compra</li> <li>Cachear datos</li> </ul> <p>Todas estas operaciones van a asociada a operaciones de recuperaci\u00f3n, modificaci\u00f3n o inserci\u00f3n de los datos de una sola vez, de ah\u00ed su elecci\u00f3n.</p> <p>En cambio, no conviene utilizar estos almacenes cuando queremos realizar:</p> <ul> <li>Relaciones entre datos</li> <li>Transacciones entre varias operaciones</li> <li>Consultas por los datos del valor</li> <li>Operaciones con conjuntos de claves</li> </ul> <p>Los almacenes m\u00e1s empleados son:</p> <ul> <li>Riak: https://riak.com</li> <li>Redis: http://redis.io</li> <li>AWS DynamoDB: http://aws.amazon.com/dynamodb</li> <li>Voldemort: http://www.project-voldemort.com/voldemort implementaci\u00f3n open-source de Amazon DynamoDB</li> </ul>"},{"location":"sa/01nosql.html#basado-en-columnas","title":"Basado en columnas","text":"<p>Las bases de datos relacionales utilizan la fila como unidad de almacenamiento, lo que permite un buen rendimiento de escritura. Sin embargo, cuando las escrituras son ocasionales y es m\u00e1s com\u00fan tener que leer unas pocas columnas de muchas filas a la vez, es mejor utilizar como unidad de almacenamiento un grupos de columnas. Es decir, lo que hacemos es girar el modelo 90 grados, de manera que los registros se almacenan en columnas en vez de hacerlo por filas.</p> <p>Supongamos que tenemos los siguientes datos:</p> Ejemplo de tabla <p>Dependiendo del almacenamiento en filas o columnas tendr\u00edamos la siguiente representaci\u00f3n:</p> Comparaci\u00f3n filas y columnas <p>En un formato columnar los datos del mismo tipo se agrupan, lo que permite codificarlos/comprimirlos, lo que mejora el rendimiento de acceso y reduce el tama\u00f1o:</p> Comparaci\u00f3n filas y columnas <p>Autoevaluaci\u00f3n</p> <p>Si tenemos que a\u00f1adir un nuevo registro \u00bfQu\u00e9 modelo ser\u00e1 m\u00e1s eficiente?</p> <p>Sin embargo, a medida que se incrementa la utilizaci\u00f3n de an\u00e1lisis de datos en memoria, con soluciones como Spark, los beneficios relativos de la base de datos columnares comparados con los de las bases de datos orientadas a filas pueden llegar a ser menos importantes.</p>"},{"location":"sa/01nosql.html#representacion","title":"Representaci\u00f3n","text":"<p>Un modelo basado en columnas se representa como una estructura agregada de dos niveles. El primer nivel formado por un almac\u00e9n clave-valor, siendo la clave el identificador de la fila, y el valor un nuevo mapa con los datos agregados de la fila (familias de columnas). Los valores de este segundo nivel son las columnas. De este modo, podemos acceder a los datos de un fila, o a una determinada columna:</p> Representaci\u00f3n de un almac\u00e9n basado en columnas <p>BigTable</p> <p>Los modelos de datos basados en columnas se basan en la implementaci\u00f3n de Google de la tecnolog\u00eda BigTable (http://research.google.com/archive/bigtable.html), la cual consiste en columnas separadas y sin esquema, a modo de mapa de dos niveles.</p> <p>As\u00ed pues, los almacenes basados en columnas utilizan un mapa ordenado multi-dimensional y distribuido para almacenar los datos. Est\u00e1n pensados para que cada fila tenga una gran n\u00famero de columnas (del orden del mill\u00f3n), almacenando las diferentes versiones que tenga una fila (pudiendo almacenar del orden de miles de millones de filas).</p>"},{"location":"sa/01nosql.html#familias-de-columnas","title":"Familias de columnas","text":"<p>Una columna consiste en un pareja <code>name</code>-<code>value</code>, donde el nombre hace de clave. Adem\u00e1s, contiene un atributo <code>timestamp</code> para poder expirar datos y resolver conflictos de escritura.</p> <p>Un ejemplo de columna podr\u00eda ser:</p> <pre><code>{\nname: \"nombre\",\nvalue: \"Bruce\",\ntimestamp: 12345667890\n}\n</code></pre> <p>Una fila es una colecci\u00f3n de columnas agrupadas a una clave.</p> <pre><code>{\n{\nname: \"nombre\",\nvalue: \"Bruce\",\ntimestamp: 12345667890\n},\n{\nname: \"nombre\",\nvalue: \"Clark\",\ntimestamp: 12345667891\n},\n{\nname: \"nombre\",\nvalue: \"Barbara\",\ntimestamp: 12345667892\n}\n}\n</code></pre> <p>Si agrupamos filas similares tendremos una familia de columnas:</p> <pre><code>// familia de columnas\n{\n// fila\n\"tim-gordon\" : {\nnombre: \"Tim\",\napellido: \"Gordon\",\nultimaVisita: \"2015/12/12\"\n}\n// fila\n\"bruce-wayne\" : {\nnombre: \"Bruce\",\napellido: \"Wayne\",\nlugar: \"Gotham\"\n}\n}\n</code></pre> <p>Con este ejemplo, podemos ver como las diferentes filas de la misma tabla (familia de columnas) no tienen por que compartir el mismo conjunto de columnas.</p> <p>Adem\u00e1s, las columnas se pueden anidar dentro de otras formando super-columnas, donde el valor es un nuevo mapa de columnas.</p> <pre><code>{\nname: \"libro:978-84-16152-08-7\",\nvalue: {\nautor: \"Grant Morrison\",\ntitulo: \"Batman - Asilo Arkham\",\nisbn: \"978-84-16152-08-7\"\n}\n}\n</code></pre> <p>Cuando se utilizan super columnas para crear familias de columnas tendremos una familia de super columnas.</p> <p>En resumen, las bases de datos basadas en columnas, almacenan los datos en familias de columnas como filas, las cuales tienen muchas columnas asociadas al identificador de una fila. Las familias de columnas son grupos de datos relacionados, a las cuales normalmente se accede de manera conjunta.</p>"},{"location":"sa/01nosql.html#operaciones","title":"Operaciones","text":"<p>A la hora de consultar los datos, \u00e9stos se pueden obtener por la clave primaria de la familia. As\u00ed pues, podemos obtener toda una familia, o la columna de una familia:</p> <pre><code>// Mediante Cassandra\nGET Clientes['bruce-wayne'];  // familia\nGET Clientes['bruce-wayne']['lugar']; // columna\n</code></pre> <p>Algunos productos ofrecen un soporte limitado para \u00edndices secundarios, pero con restricciones. Por ejemplo, Cassandra ofrece el lenguaje CQL similar a SQL pero sin joins, ni subconsultas donde las restricciones de where son sencillas:</p> <pre><code>SELECT * FROM Clientes\nSELECT nombre,email FROM Clientes\nSELECT nombre,email FROM Clientes WHERE lugar='Gotham'\n</code></pre> <p>Las actualizaciones se realizan en dos pasos: primero encontrar el registro y segundo modificarlo. En estos sistemas, una modificaci\u00f3n puede suponer una reescritura completa del registro independientemente que hayan cambiado unos pocos bytes del mismo.</p>"},{"location":"sa/01nosql.html#casos-de-uso_3","title":"Casos de uso","text":"<p>Las bases de datos columnares se han empleado durante d\u00e9cadas ofreciendo beneficios a las aplicaciones de negocio modernas, como la anal\u00edtica de datos, business intelligence y data warehousing.</p> <p>Son multiprop\u00f3sito, aunque su uso se centra en el mercado del big data, la anal\u00edtica de datos, cubos multidimensionales OLAP y/o almacenar metadatos y realizar anal\u00edtica en tiempo real.</p> <p>Adem\u00e1s de poder comprimir los datos, los datos est\u00e1n auto-indexados, lo que implica que utiliza menos espacio en disco, y acelera la ejecuci\u00f3n de consultas agregadas entre m\u00faltiples tablas que implica el uso de joins.</p> <p>En cambio, no se recomienda su uso en aplicaciones de procesamiento transaccional (OLTP), ya que las bases de datos relacionales gestionan mejor el procesamiento concurrente y el aislamiento de las operaciones.</p> <p>Los productos m\u00e1s destacados son:</p> <ul> <li>HBase : http://hbase.apache.org, el cual se basa en Hadoop - http://hadoop.apache.org</li> <li>Cassandra : http://cassandra.apache.org</li> <li>Amazon Redshift: https://aws.amazon.com/es/redshift/</li> </ul>"},{"location":"sa/01nosql.html#grafos","title":"Grafos","text":"<p>Las bases de datos de grafos almacenan entidades y las relaciones entre estas entidades. Las entidades se conocen como nodos, los cuales tienen propiedades. Cada nodo es similar a una instancia de un objeto. Las relaciones, tambi\u00e9n conocidas como v\u00e9rtices, a su vez tienen propiedades, y su sentido es importante.</p> Representaci\u00f3n de un grafo <p>Los nodos se organizan mediante relaciones que facilitan encontrar patrones de informaci\u00f3n existente entre los nodos. Este tipo de organizaci\u00f3n permite almacenar los datos una vez e interpretar los datos de diferentes maneras dependiendo de sus relaciones.</p> <p>Los nodos son entidades que tienen propiedades, tales como el nombre. Por ejemplo, en el gr\u00e1fico cada nodo tiene una propiedad <code>name</code>. Tambi\u00e9n podemos ver que las relaciones tienen tipos, como <code>label</code>, <code>since</code>, etc\u2026\u200b Estas propiedades permiten organizar los nodos. Las relaciones pueden tener m\u00faltiples propiedades, y adem\u00e1s tienen direcci\u00f3n, con lo cual si queremos incluir bidireccionalidad tenemos que a\u00f1adir dos relaciones en sentidos opuestos. Tanto los nodos como las relaciones tienen un atributo <code>id</code> que los identifica.</p> <p>Por ejemplo, podemos comenzar a crear el grafo anterior mediante Neo4J de la siguiente manera:</p> <pre><code>Node alice = graphDb.createNode();\nalice.setProperty(\"name\", \"Alice\");\nNode bob = graphDb.createNode();\nbob.setProperty(\"name\", \"Bob\");\nalice.createRelationshipTo(bob, FRIEND);\nbob.createRelationshipTo(alice, FRIEND);\n</code></pre> <p>Los nodos permiten tener diferentes tipos de relaciones entre ellos y as\u00ed representar relaciones entre las entidades del dominio, y tener relaciones secundarias para caracter\u00edsticas como categor\u00eda, camino, \u00e1rboles de tiempo, listas enlazas para acceso ordenado, etc\u2026\u200b Al no existir un l\u00edmite en el n\u00famero ni en el tipo de relaciones que puede tener un nodo, todas se pueden representar en la misma base de datos.</p>"},{"location":"sa/01nosql.html#traversing","title":"Traversing","text":"<p>Una vez tenemos creado un grafo de nodos y relaciones, podemos consultar el grafo de muchas maneras; por ejemplo \"obtener todos los nodos que son miembros del grupo de ajedrez y que tienen m\u00e1s de 20 a\u00f1os\". Realizar una consulta se conoce como hacer un traversing (recorrido) del mismo.</p> <p>Un ejemplo de traversing mediante Neo4J ser\u00eda:</p> <pre><code>Node ajedrez = nodeIndex.get(\"name\", \"chess\").getSingle();\nallRelationships = ajedrez.getRelationships(Direction.INCOMING);\n</code></pre> <p>Una ventaja a destacar de las bases de datos basadas en grafos es que podemos cambiar los requisitos de traversing sin tener que cambiar los nodos o sus relaciones.</p> <p>En las bases de datos de grafos, recorrer las relaciones es muy r\u00e1pido, ya que no se calculan en tiempo de consulta, sino que se persisten como una relaci\u00f3n, y por tanto no hay que hacer ning\u00fan c\u00e1lculo.</p> <p>En cambio, en una base de datos relacional, para crear una estructura de grafo se realiza para una relaci\u00f3n sencilla (\u00bfQuien es mi jefe?\"). Para poder a\u00f1adir otras relaciones necesitamos muchos cambios en el esquema y trasladar datos entre tablas. Adem\u00e1s, necesitamos de antemano saber qu\u00e9 consultas queremos realizar para modelar las tablas y las relaciones acorde a las consultas.</p> <p>As\u00ed pues, estos sistemas ofrecen modelos ricos de consultas donde se pueden investigar las relaciones simples y complejas entre los nodos para obtener informaci\u00f3n directa e indirecta de los datos del sistemas. Los tipos de an\u00e1lisis que se realizan sobre estos sistema se ci\u00f1en a los tipos de relaci\u00f3n existente entre los datos.</p>"},{"location":"sa/01nosql.html#casos-de-uso_4","title":"Casos de uso","text":"<p>Mientras que el modelo de grafos no es muy intuitivo y tiene una importante curva de aprendizaje, se puede usar en un gran n\u00famero de aplicaciones.</p> <p>Su principal atractivo es que facilitan almacenar las relaciones entre entidades de una aplicaci\u00f3n, como por ejemplo en una red social, o las intersecciones existentes entre carreteras. Es decir, se emplean para almacenar datos que se representan como nodos interconectados.</p> <p>Por lo tanto, los casos de uso son:</p> <ul> <li>Datos conectados: redes sociales con diferentes tipos de conexiones entre los usuarios.</li> <li>Enrutamiento, entrega o servicios basados en la posici\u00f3n: si las relaciones almacenan la distancia entre los nodos, podemos realizar consultas sobre lugares cercanos, trayecto m\u00e1s corto, etc\u2026\u200b</li> <li>Motores de recomendaciones: de compras, de lugares visitados, etc\u2026\u200b</li> </ul> <p>En cambio, no se recomienda su uso cuando necesitemos modificar todos o un subconjunto de entidades, ya que modificar una propiedad en todos los nodos es una operaci\u00f3n compleja.</p> <p>Los productos m\u00e1s destacados son:</p> <ul> <li>Neo4j: http://neo4j.com</li> <li>ArangoDB: https://www.arangodb.com/</li> <li>Apache Giraph: https://giraph.apache.org/</li> <li>Amazon Neptune: https://aws.amazon.com/es/neptune/</li> </ul>"},{"location":"sa/01nosql.html#consistencia","title":"Consistencia","text":"<p>En un sistema consistente, las escrituras de una aplicaci\u00f3n son visibles en siguientes consultas. Con una consistencia eventual, las escrituras no son visibles inmediatamente.</p> <p>Por ejemplo, en un sistema de control de stock, si el sistema es consistente, cada consulta obtendr\u00e1 el estado real del inventario, mientras que si tiene consistencia eventual, puede que no sea el estado real en un momento concreto pero terminar\u00e1 si\u00e9ndolo en breve.</p>"},{"location":"sa/01nosql.html#sistemas-consistentes","title":"Sistemas consistentes","text":"<p>Cada aplicaci\u00f3n tiene diferentes requisitos para la consistencia de los datos. Para muchas aplicaciones, es imprescindible que los datos sean consistentes en todo momento. Como los equipos de desarrollo han estado trabajo con un modelo de datos relacional durante d\u00e9cadas, este enfoque parece natural. Sin embargo, en otras ocasiones, la consistencia eventual es un traspi\u00e9s aceptable si conlleva una mayor flexibilidad en la disponibilidad del sistema.</p> <p>Las bases de datos documentales y de grafos pueden ser consistentes o eventualmente consistentes. Por ejemplo, MongoDB ofrece un consistencia configurable. De manera predeterminada, los datos son consistentes, de modo que todas las escrituras y lecturas se realizan sobre la copia principal de los datos. Pero como opci\u00f3n, las consultas de lectura, se pueden realizar con las copias secundarias donde los datos tendr\u00e1n consistencia eventual. La elecci\u00f3n de la consistencia se realiza a nivel de consulta.</p>"},{"location":"sa/01nosql.html#sistemas-de-consistencia-eventual","title":"Sistemas de consistencia eventual","text":"<p>Con los sistemas eventualmente consistentes, hay un per\u00edodo de tiempo en el que todas las copias de los datos no est\u00e1n sincronizados. Esto puede ser aceptable para aplicaciones de s\u00f3lo-lectura y almacenes de datos que no cambian frecuentemente, como los archivos hist\u00f3ricos. Dentro del mismo saco podemos meter las aplicaciones con alta tasa de escritura donde las lecturas sean poco frecuentes, como un archivo de log.</p> <p>Un claro ejemplo de sistema eventualmente consistente es el servicio DNS, donde tras registrar un dominio, puede tardar varios d\u00edas en propagar los datos a trav\u00e9s de Internet, pero siempre est\u00e1n disponibles aunque contenga una versi\u00f3n antigua de los datos.</p> <p>Respecto a las bases de datos NoSQL, los almacenes de clave-valor y los basados en columnas son sistemas eventualmente consistentes. Estos tienen que soportar conflictos en las actualizaciones de registros individuales.</p> <p>Como las escrituras se pueden aplicar a cualquier copia de los datos, puede ocurrir, y no ser\u00eda muy extra\u00f1o, que hubiese un conflicto de escritura.</p> <p>Algunos sistemas como Riak utilizan vectores de reloj para determinar el orden de los eventos y asegurar que la operaci\u00f3n m\u00e1s reciente gana en caso de un conflicto.</p> <p>Otros sistemas como CouchDB, retienen todos los valores conflictivos y permiten al usuario resolver el conflicto. Otro enfoque seguido por Cassandra sencillamente asume que el valor m\u00e1s grande es el correcto.</p> <p>Por estos motivos, las escrituras tienden a comportarse bien en sistemas eventualmente consistentes, pero las actualizaciones pueden conllevar sacrificios que complican la aplicaci\u00f3n.</p>"},{"location":"sa/01nosql.html#teorema-de-cap","title":"Teorema de CAP","text":"<p>Propuesto por Eric Brewer en el a\u00f1o 2000, prueba que podemos crear una base de datos distribuida que elija dos de las siguientes tres caracter\u00edsticas:</p> <ul> <li>Consistencia: las escrituras son at\u00f3micas y todas las peticiones posteriores obtienen el nuevo valor, independientemente del lugar de la petici\u00f3n.</li> <li>Disponibilidad (Available): la base de datos devolver\u00e1 siempre un valor. En la pr\u00e1ctica significa que no hay downtime.</li> <li>Tolerancia a Particiones: el sistema funcionar\u00e1 incluso si la comunicaci\u00f3n con un servidor se interrumpe de manera temporal (para ello, ha de dividir los datos entre diferentes nodos). Es decir, implica que se pueden recibir lecturas desde unos nodos que no contienen informaci\u00f3n escrita en otros.</li> </ul> <p>En otras palabras, podemos crear un sistema de base de datos que sea consistente y tolerante a particiones (CP), un sistema que sea disponible y tolerante a particiones (AP), o un sistema que sea consistente y disponible (CA). Pero no es posible crear una base de datos distribuida que sea consistente, disponible y tolerante a particiones al mismo tiempo.</p> Teorema de CAP <p>El teorema CAP es \u00fatil cuando consideramos el sistema de base de datos que necesitamos, ya que nos permite decidir cual de las tres caracter\u00edsticas vamos a descartar. La elecci\u00f3n realmente se centra entre la disponibilidad y la consistencia, ya que la tolerancia a particiones es una decisi\u00f3n de arquitectura (sea o no distribuida).</p> <p>Aunque el teorema dicte que si en un sistema distribuido elegimos disponibilidad no podemos tener consistencia, todav\u00eda podemos obtener consistencia eventual. Es decir, cada nodo siempre estar\u00e1 disponible para servir peticiones, aunque estos nodos no puedan asegurar que la informaci\u00f3n que contienen sea consistente (pero si bastante precisa), en alg\u00fan momento lo ser\u00e1.</p> <p>Algunas bases de datos tolerantes a particiones se pueden ajustar para ser m\u00e1s o menos consistentes o disponible a nivel de petici\u00f3n. Por ejemplo, Riak trabaja de esta manera, permitiendo a los clientes decidir en tiempo de petici\u00f3n qu\u00e9 nivel de consistencia necesitan.</p>"},{"location":"sa/01nosql.html#clasificacion-segun-cap","title":"Clasificaci\u00f3n seg\u00fan CAP","text":"<p>El siguiente gr\u00e1fico muestra c\u00f3mo dependiendo de estos atributos podemos clasificar los sistemas NoSQL:</p> Clasificaci\u00f3n seg\u00fan CAP <p>As\u00ed pues, las bases de datos NoSQL se clasifican en:</p> <ul> <li>CP: Consistente y tolerantes a particiones. Tanto MongoDB como HBase son CP, ya que dentro de una partici\u00f3n pueden no estar disponibles para responder una determinada consulta (por ejemplo, evitando lecturas en los nodos secundarios), aunque son tolerantes a fallos porque cualquier nodo secundario se puede convertir en principal y asumir el rol del nodo ca\u00eddo.</li> <li>AP: Disponibles y tolerantes a particiones. DynamoDB permite replicar los datos entre sus nodos aunque no garantiza la consistencia en ninguno de los sus servidores.</li> <li>CA: Consistentes y disponible. Aqu\u00ed es donde situar\u00edamos a los SGDB relacionales. Por ejemplo, PostreSQL es CA (aunque ofrece un producto complementario para dar soporte al particionado, como PgCluster), ya que no distribuyen los datos y por tanto la partici\u00f3n no es una restricci\u00f3n.</li> </ul> <p>Lo bueno es que la gran mayor\u00eda de sistemas permiten configurarse para cambiar su tipo CAP, lo que permite que MongoDB pase de CP a AP, o CouchDB de AP a CP.</p>"},{"location":"sa/01nosql.html#base","title":"BASE","text":"<p>De forma an\u00e1loga al modelo transaccional ACID para las bases de datos relacionales que dan soporte a la transaccionalidad ofreciendo en todo momento un sistema consistente, las bases de datos distribuidas siguen el modelo transaccional BASE, el cual se centra en la alta disponibilidad y significa:</p> <ul> <li>B\u00e1sicamente disponible (Basically Available): la base de datos siempre responde a las solicitudes recibidas, ya sea con una respuesta exitosa o con un error, a\u00fan en el caso de que el sistema soporte la tolerancia a particiones (de manera que caiga alg\u00fan nodo o no est\u00e9 accesible por problemas de la red). Esto puedo implicar lecturas desde nodos que no han recibido la \u00faltima escritura, por lo que el resultado puede no ser consistente.</li> <li>Estado blando (Soft State): la base de datos puede encontrarse en un estado inconsistente cuando se produce una lectura, de modo que es posible realizar dos veces la misma lectura y obtener dos resultados distintos a pesar de que no haya habido ninguna escritura entre ambas operaciones, sino que la escritura se hab\u00eda realizado antes en el tiempo y no se hab\u00eda persistido hasta ese momento.</li> <li>Consistencia eventual (Eventual consistency): tras cada escritura, la consistencia de la base de datos s\u00f3lo se alcanza una vez el cambio ha sido propagado a todos los nodos. Durante el tiempo que tarda en producirse la consistencia, observamos un estado blando de la base de datos.</li> </ul> <p>Una base de datos que sigue el modelo transaccional BASE prefiere la disponibilidad antes que la consistencia (es decir, desde el punto de vista del teorema CAP es AP).</p>"},{"location":"sa/01nosql.html#referencias","title":"Referencias","text":"<ul> <li>Next Generation Databases: NoSQL, NewSQL, and Big Data</li> <li>NoSQL Distilled: A Brief Guide to the Emerging World of Polyglot Persistence</li> <li>Row vs Column Oriented Databases</li> <li>Understanding Database Sharding</li> </ul>"},{"location":"sa/01nosql.html#actividades","title":"Actividades","text":"<ol> <li> <p>(RA5075.2 / CE5.2a / 2p) Contesta a las siguientes preguntas:</p> <ol> <li>\u00bfQu\u00e9 significa el prefijo No del acr\u00f3nimo NoSQL?</li> <li>\u00bfUn sistema puede soportar al mismo tiempo replicaci\u00f3n y particionado?</li> <li>Para los siguientes supuestos, indica qu\u00e9 modelo de datos emplear\u00edas y justifica tu respuesta:<ol> <li>Wiki sobre de personajes de c\u00f3mics.</li> <li>Informaci\u00f3n acad\u00e9mica de un pa\u00eds (centros, alumnos, profesores, asignaturas, calificaciones, \u2026\u200b)</li> </ol> </li> <li>Investiga en qu\u00e9 consiste la persistencia pol\u00edglota.</li> <li>Clasifica las siguientes bases de datos seg\u00fan el teorema de CAP en CA, CP o AP: BigTable, Cassandra, CouchDB, DynamoDB, HBase, MongoDB, Redis, Riak, Voldemort.</li> </ol> </li> <li> <p>(RA5075.2 / CE5.2a / 1p) Crea una presentaci\u00f3n de 5-6 diapositivas donde expliques en qu\u00e9 consiste el movimiento NewSQL, su relaci\u00f3n con NoSQL y qu\u00e9 ofrecen bases de datos como CockroachDB y/o VoltDB.</p> </li> </ol>"},{"location":"sa/02mongo.html","title":"MongoDB","text":"<p>MongoDB (http://www.mongodb.com) es una de las bases de datos NoSQL m\u00e1s conocidas. Sigue un modelo de datos documental, donde los documentos se basan en JSON.</p> <p>huMONGOus</p> <p>Como curiosidad, su nombre viene de la palabra inglesa humongous, que significa gigantesco/enorme.</p> <p>MongoDB destaca porque:</p> <ul> <li>Soporta esquemas din\u00e1micos: diferentes documentos de una misma colecci\u00f3n pueden tener atributos diferentes.</li> <li>Aunque inicialmente ten\u00eda un soporte limitado de joins, desde la versi\u00f3n 5.2 se pueden realizar incluso entre colecciones particionadas.</li> <li>Soporte de transacciones s\u00f3lo a nivel de aplicaci\u00f3n. Lo que en un RDMS puede suponer m\u00faltiples operaciones, con MongoDB se puede hacer en una sola operaci\u00f3n al insertar/actualizar todo un documento de una sola vez, pero si queremos crear una transacci\u00f3n entre dos documentos, la gesti\u00f3n la debe realizar el driver.</li> </ul>"},{"location":"sa/02mongo.html#conceptos","title":"Conceptos","text":"<p>Hay una serie de conceptos que conviene conocer antes de entrar en detalle:</p> <ul> <li>MongoDB tienen el mismo concepto de base de datos que un RDMS. Dentro de una instancia de MongoDB podemos tener 0 o m\u00e1s bases de datos, actuando cada una como un contenedor de alto nivel.</li> <li>Una base de datos tendr\u00e1 0 o m\u00e1s colecciones. Una colecci\u00f3n es muy similar a lo que entendemos como tabla dentro de un RDMS. MongoDB ofrece diferentes tipos de colecciones, desde las normales cuyo tama\u00f1o crece conforme lo hace el n\u00famero de documentos, como las colecciones capped, las cuales tienen un tama\u00f1o predefinido y que pueden contener una cierta cantidad de informaci\u00f3n que se sustituir\u00e1 por nueva cuando se llene.</li> <li>Las colecciones contienen 0 o m\u00e1s documentos, por lo que es similar a una fila o registro de un RDMS.</li> <li>Cada documento contiene 0 o m\u00e1s atributos, compuestos de parejas clave/valor. Cada uno de estos documentos no sigue ning\u00fan esquema, por lo que dos documentos de una misma colecci\u00f3n pueden contener todos los atributos diferentes entre s\u00ed.</li> </ul> Elementos de MongoDB <p>As\u00ed pues, tenemos que una base de datos va a contener varias colecciones, donde cada colecci\u00f3n contendr\u00e1 un conjunto de documentos:</p> Modelo de MongoDB <p>Adem\u00e1s, MongoDB soporta \u00edndices, igual que cualquier RDMS, para acelerar la b\u00fasqueda de datos. Al realizar cualquier consulta, se devuelve un cursor, con el cual podemos hacer cosas tales como contar, ordenar, limitar o saltar documentos.</p>"},{"location":"sa/02mongo.html#bson","title":"BSON","text":"<p>Mediante JavaScript podemos crear objetos que se representan con JSON. Internamente, MongoDB almacena los documentos mediante BSON (Binary JSON). Podemos consultar la especificaci\u00f3n en http://BSONSpec.org</p> Especificaci\u00f3n BSON <p>BSON representa un superset de JSON ya que:</p> <ul> <li>Permite almacenar datos en binario</li> <li>Incluye un conjunto de tipos de datos no incluidos en JSON, como pueden ser <code>ObjectId</code>, <code>Date</code> o <code>BinData</code>.</li> </ul> <p>Podemos consultar todos los tipos que soporta un objeto BSON en http://docs.mongodb.org/manual/reference/bson-types/</p> <p>Un ejemplo de un objeto BSON podr\u00eda ser:</p> <pre><code>var yo = {\nnombre: \"Aitor\",\napellidos: \"Medrano\",\nfnac: new Date(\"Oct 3, 1977\"),\nhobbies: [\"programaci\u00f3n\", \"videojuegos\", \"baloncesto\"],\ncasado: true,\nhijos: 2,\ncontacto: {\ntwitter: \"@aitormedrano\",\nemail: \"a.medrano@edu.gva.es\"\n},\nfechaCreacion: new Timestamp()\n}\n</code></pre> <p>Los documentos BSON tienen las siguientes restricciones:</p> <ul> <li>No pueden tener un tama\u00f1o superior a 16 MB.</li> <li>El atributo <code>_id</code> queda reservado para la clave primaria.</li> <li>Desde MongoDB 5.0 los nombres de los campos pueden empezar por <code>$</code> y/o contener el <code>.</code>, aunque en la medida de lo posible, es recomendable evitar su uso.</li> </ul> <p>Adem\u00e1s MongoDB:</p> <ul> <li>No asegura que el orden de los campos se respete.</li> <li>Es sensible a los tipos de los datos</li> <li>Es sensible a las may\u00fasculas.</li> </ul> <p>Por lo que estos documentos son distintos:</p> <pre><code>{\"edad\": \"18\"}\n{\"edad\": 18}\n{\"Edad\": 18}\n</code></pre> <p>Si queremos validar si un documento JSON es v\u00e1lido, podemos usar http://jsonlint.com/. Hemos de tener en cuenta que s\u00f3lo valida JSON y no BSON, por tanto nos dar\u00e1 errores en los tipos de datos propios de BSON.</p>"},{"location":"sa/02mongo.html#puesta-en-marcha","title":"Puesta en marcha","text":"<p>En la actualidad, MongoDB se comercializa mediante tres productos:</p> <ul> <li>Mongo Atlas, como plataforma cloud, con una opci\u00f3n gratuita mediante un cluster de 512MB.</li> <li>MongoDB Community Edition, versi\u00f3n gratuita para trabajar on-premise, con versiones para Windows, MacOS y Linux.</li> <li>MongoDB Enterprise Advanced, versi\u00f3n de pago con soporte, herramientas avanzadas de monitorizaci\u00f3n y seguridad, y administraci\u00f3n automatizada.</li> </ul>"},{"location":"sa/02mongo.html#instalacion","title":"Instalaci\u00f3n","text":"<p>Desde https://www.mongodb.com/try/download/community podemos descargar la versi\u00f3n Community acorde a nuestro sistema operativo.</p> <p>Independientemente de nuestro sistema operativo, por defecto, el demonio se lanza sobre el puerto 27017. Una vez instalado, si accedemos a http://localhost:27017 podremos ver que nos indica c\u00f3mo estamos intentando acceder mediante HTTP a MongoDB mediante el puerto reservado al driver nativo.</p> Acceso al puerto 27017 <p>En vez de instalarlo como un servicio en nuestra m\u00e1quina, a d\u00eda de hoy, es mucho m\u00e1s c\u00f3modo hacer uso de contenedores Docker o utilizar una soluci\u00f3n cloud.</p>"},{"location":"sa/02mongo.html#docker","title":"Docker","text":"<p>Para lanzar el contenedor de Docker al que llamaremos <code>iadb-mongo</code> mediante el siguiente comando:</p> <pre><code>docker run -p 127.0.0.1:27017:27017 --name iabd-mongo -d mongo\n</code></pre> <p>MongoDB y procesadores AVX</p> <p>Si tenemos un procesador sin soporte para AVX, necesitamos instalar una versi\u00f3n inferior a la 5.0.</p> <p>As\u00ed pues, podemos indicar la versi\u00f3n 4.4:</p> <pre><code>docker run -p 127.0.0.1:27017:27017 --name iabd-mongo -d mongo:4.4\n</code></pre> <p>A continuaci\u00f3n vamos a descargar el conjunto de datos sampledata.archive.gz que ofrece MongoDB a modo de prueba, el cual vamos a emplear a lo largo de las diferentes sesiones.</p> <p>Volvemos al terminal de nuestro sistema y copiamos los datos desde nuestro sistema a la carpeta <code>/tmp</code> del contenedor:</p> <pre><code>docker cp sampledata.archive.gz iabd-mongo:/tmp\n</code></pre> <p>Posteriormente abrimos un terminal dentro de nuestro contenedor  (o mediante Attach Shell en VSCode):</p> <pre><code>docker exec -it iabd-mongo bash\n</code></pre> <p>Y finalmente, restauramos los datos mediante <code>mongorestore</code>:</p> <pre><code>mongorestore --gzip --archive=/tmp/sampledata.archive.gz\n</code></pre> <p>Una vez cargados, nos informar\u00e1 que se han restaurado 433281 documentos.</p>"},{"location":"sa/02mongo.html#mongo-atlas","title":"Mongo Atlas","text":"<p>Y si preferimos una soluci\u00f3n cloud, disponemos de Mongo Atlas, que nos ofrece de manera gratuita un cluster compartido de servidores con 3 nodos y 512 MB para datos. Si queremos una soluci\u00f3n serverless o un servidor dedicado, ya tendremos que pasar por caja.</p> Registro en Mongo Atlas <p>Para comenzar a utilizar Mongo Atlas el primer paso es registrarnos y completar un cuestionario sobre nuestro uso. Tras ello:</p> <ol> <li> <p>Creamos el cluster de despliegue. En nuestro caso, hemos realizado el despliegue en AWS en la regi\u00f3n de Paris (<code>eu-west-3</code>) y dejado el nombre por defecto, <code>Cluster 0</code>. Elecci\u00f3n del cluster </p> </li> <li> <p>Creamos un usuario/contrase\u00f1a para autenticar nuestra conexi\u00f3n. En nuestro caso, hemos creado el usuario <code>iabd</code> con la contrase\u00f1a <code>iabdiabd</code> (despu\u00e9s la podemos modificar desde el men\u00fa Security -&gt; Database Access):</p> <p> Configuraci\u00f3n del usuario </p> <p>En la misma pantalla, indicamos que permitimos las conexiones desde todas las direcciones IP (esta decisi\u00f3n s\u00f3lo la tomamos por comodidad, para poder conectarnos desde casa y el centro) mediante la IP <code>0.0.0.0</code> (despu\u00e9s podemos modificar la configuraci\u00f3n desde el men\u00fa Security -&gt; Network Access).</p> </li> <li> <p>Una vez realizados los dos pasos anteriores, comenzar\u00e1 la creaci\u00f3n del cluster, la cual puede tardar de 2 a 3 minutos.</p> <p> Dashboard del cluster </p> </li> <li> <p>A continuaci\u00f3n, cargaremos los datos de ejemplo. Para ello, en el men\u00fa con los tres puntos (<code>...</code>), elegiremos la opci\u00f3n Load Sample Dataset. Una vez haya finalizado, podremos ver los datos cargados pulsando sobre el bot\u00f3n Browse Collections:</p> <p> Colecciones con los datos de prueba </p> </li> </ol> <p>Conexi\u00f3n segura</p> <p>Mediante <code>srv</code> se establece una conexi\u00f3n segura</p> <p>Finalmente, para obtener la cadena de conexi\u00f3n, desde el dashboard del cluster con la opci\u00f3n Connect o desde la pesta\u00f1a Cmd Line Tools del propio cluster, podremos obtener la cadena de conexi\u00f3n, que tendr\u00e1 un formato similar a :</p> <pre><code>mongodb+srv://usuario:password@host/basededatos\n</code></pre> <p>A continuaci\u00f3n, vamos a conocer las diferentes herramientas que nos ofrece MongoDB para posteriormente estudiar todas las operaciones que podemos realizar.</p>"},{"location":"sa/02mongo.html#mongosh","title":"mongosh","text":"<p>Tras arrancar el demonio <code>mongod</code> (el cual se lanza autom\u00e1ticamente mediante Docker o con el cluster de Mongo Atlas) llega el momento de acceder mediante el cliente <code>mongosh</code> (en versiones anteriores el comando utilizado era <code>mongo</code>), el cual funciona igual que un shell, de modo que con la fecha hacia arriba visualizaremos el \u00faltimo comando. El cliente utiliza JavaScript como lenguaje de interacci\u00f3n con la base de datos.</p> <p>Si nos conectamos desde Docker, no necesitamos instalarlo. Primero nos conectamos al contenedor:</p> <pre><code>docker exec -it iabd-mongo bash\n</code></pre> <p>Al conectar con <code>mongosh</code> si no le indicamos nada se conectar\u00e1 por defecto a la base de datos <code>test</code> de localhost. Si queremos conectarnos a una base de datos concreta, por ejemplo a <code>sample_training</code>, la pasaremos como par\u00e1metro:</p> <pre><code>root@3ad17b675fb1:/# mongosh sample_training\nCurrent Mongosh Log ID: 6316498f30f8283fedcfabc2\nConnecting to:          mongodb://127.0.0.1:27017/sample_training?directConnection=true&amp;serverSelectionTimeoutMS=2000\nUsing MongoDB:          5.0.4\nUsing Mongosh:          1.1.2\n</code></pre> <p>Si queremos ver las bases de datos que existen ejecutaremos el comando <code>show dbs</code>:</p> <pre><code>sample_training&gt; show dbs;\nadmin                 41 kB\nconfig              73.7 kB\nlocal               73.7 kB\nsample_airbnb       55.1 MB\nsample_analytics     9.9 MB\nsample_geospatial    999 kB\nsample_mflix        48.5 MB\nsample_restaurants   6.2 MB\nsample_supplies      991 kB\nsample_training     43.4 MB\nsample_weatherdata  2.49 MB\n</code></pre> <p>Si nos quisi\u00e9ramos conectar a nuestro cluster de Mongo Atlas utilizaremos la cadena de conexi\u00f3n tras el comando <code>mongosh</code>:</p> <pre><code>root@3ad17b675fb1:/# mongosh mongodb+srv://iabd:iabdiabd@cluster0.dfaz5er.mongodb.net/test\nCurrent Mongosh Log ID: 63164ac26030844c1576f8b4\nConnecting to:          mongodb+srv://&lt;credentials&gt;@cluster0.dfaz5er.mongodb.net/test\nUsing MongoDB:          5.0.11\nUsing Mongosh:          1.1.2\n\nFor mongosh info see: https://docs.mongodb.com/mongodb-shell/\n\nAtlas atlas-4wikkb-shard-0 [primary] test&gt;\n</code></pre> <p>Uso externo</p> <p>Si no queremos tener que conectarnos al contenedor o vamos a trabajar con un servidor remoto, podemos instalar \u00fanicamente el shell desde https://www.mongodb.com/try/download/shell</p>"},{"location":"sa/02mongo.html#mongodb-database-tools","title":"MongoDB Database Tools","text":"<p>Adem\u00e1s del propio servidor de MongoDB y el cliente para conectarse a \u00e9l, MongoDB ofrece un conjunto de herramientas para interactuar con las bases de datos, permitiendo crear y restaurar copias de seguridad.</p> <p>Si estamos interesados en introducir o exportar una colecci\u00f3n de datos mediante JSON, podemos emplear los comandos <code>mongoimport</code> y <code>mongoexport</code>:</p> <pre><code>mongoimport -d nombreBaseDatos -c coleccion \u2013-file nombreFichero.json\nmongoexport -d nombreBaseDatos -c coleccion nombreFichero.json\n</code></pre> <p>Estas herramientas interact\u00faan con datos JSON y no sobre toda la base de datos.</p> <p>Un caso particular y muy com\u00fan es importar datos que se encuentran en formato CSV/TSV. Para ello, emplearemos el par\u00e1metro <code>--type csv</code>:</p> <pre><code>mongoimport --type tsv -d test -c poblacion --headerline --drop poblacionEspanya2013.tsv\n</code></pre> <p>En vez de realizar un export, es m\u00e1s conveniente realizar un backup en binario mediante <code>mongodump</code>, el cual genera ficheros BSON. Estos archivos posteriormente se restauran mediante <code>mongorestore</code>:</p> <pre><code>mongodump -d nombreBaseDatos nombreFichero.bson\nmongorestore -d nombreBaseDatos nombreFichero.bson\n</code></pre> <p>Autoevaluaci\u00f3n</p> <p>Intenta exportar los datos de la base de datos <code>sample_training</code> desde MongoAtlas. Veras que ha creado una carpeta que contiene dos archivos \u00bfCu\u00e1les son? \u00bfQu\u00e9 contiene cada uno de ellos y cual es su formato?</p> <p>Si necesitamos transformar un fichero BSON a JSON (de binario a texto), tenemos el comando <code>bsondump</code>:</p> <pre><code>bsondump file.bson &gt; file.json\n</code></pre> <p>Info</p> <p>M\u00e1s informaci\u00f3n sobre copias de seguridad en https://www.mongodb.com/docs/manual/core/backups/.</p> <p>Para poder trabajar con MongoDB desde cualquier aplicaci\u00f3n necesitamos un driver. MongoDB ofrece drivers oficiales para casi todos los lenguajes de programaci\u00f3n actuales. En la sesi\u00f3n 28 de 'MongoDB y Python' trabajaremos con PyMongo.</p> <p>Monitorizaci\u00f3n</p> <p>Tanto <code>mongostat</code> como <code>mongotop</code> permiten visualizar el estado del servidor MongoDB, as\u00ed como algunas estad\u00edsticas sobre su rendimiento. Si trabajamos con MongoAtlas estas herramientas est\u00e1n integradas en las diferentes herramientas de monitorizaci\u00f3n de la plataforma.</p> <p>En versiones anteriores, una herramienta de terceros bastante utilizada era RoboMongo / Robo3T / Studio3T el cual extiende el shell y ofrece un IDE m\u00e1s amigable. A d\u00edas de hoy, MongoDB tiene su propio IDE conocido como Mongo Compass.</p>"},{"location":"sa/02mongo.html#mongodb-compass","title":"MongoDB Compass","text":"<p>En el curso nos vamos a centrar en el uso del shell y la conectividad de MongoDB mediante Python, pero no est\u00e1 de m\u00e1s conocer las herramientas visuales que facilitan el trabajo con MongoDB en el d\u00eda a d\u00eda.</p> <p>Una de ellas es MongoDB Compass, que facilita la exploraci\u00f3n y manipulaci\u00f3n de los datos. De una manera flexible e intuitiva, Compass ofrece visualizaciones detalladas de los esquemas, m\u00e9tricas de rendimiento en tiempo real as\u00ed como herramientas para la creaci\u00f3n de consultas.</p> <p>Existen tres versiones de Compass, una completa con todas las caracter\u00edsticas, una de s\u00f3lo lectura sin posibilidad de insertar, modificar o eliminar datos (perfecta para anal\u00edtica de datos) y una \u00faltima versi\u00f3n isolated que solo permite la conexi\u00f3n a una instancia local.</p> <p>Una vez descargada e instalada la versi\u00f3n que nos interesa, tras crear la conexi\u00f3n a partir de la cadena de conexi\u00f3n (similar a <code>mongodb+srv://iabd:iabdiabd@cluster0.4hm7u8y.mongodb.net/test</code>), veremos en el men\u00fa de la izquierda un resumen del cluster, as\u00ed como las consultas que vayamos almacenando y las diferentes bases de datos almacenadas:</p> GUI de Mongo Compass <p>Si seleccionamos una base de datos concreta, y de ella, una colecci\u00f3n en el men\u00fa de la izquierda, en el panel central tendremos una visualizaci\u00f3n de los datos contenidos, as\u00ed como opciones para ver su esquema, realizar consultas agregadas, editar los \u00edndices, etc... Adem\u00e1s, podremos realizar consultas sobre los datos:</p> Opciones desde una colecci\u00f3n <p>mongosh en Compass</p> <p>Si te fijas, en la barra inferior podemos desplegar un panel para interactuar mediante comandos como lo har\u00edamos desde <code>mongosh</code>.</p>"},{"location":"sa/02mongo.html#mongodb-for-vscode","title":"MongoDB for VSCode","text":"<p>Tambi\u00e9n podemos utilizar la extensi\u00f3n que lleva VSCode para trabajar con MongoDB.</p> <p>Tras su instalaci\u00f3n creamos una conexi\u00f3n a partir de la cadena de conexi\u00f3n (similar a <code>mongodb+srv://iabd:iabdiabd@cluster0.4hm7u8y.mongodb.net/test</code>), y una vez conectados, podremos recorrer las colecciones con los datos as\u00ed como utilizar un playground para interactuar de manera similar al shell:</p> Uso de la extensi\u00f3n de VSCode"},{"location":"sa/02mongo.html#hola-mongodb","title":"Hola MongoDB","text":"<p>Pues una vez que ya nos hemos conectado a MongoDB mediante <code>mongosh</code>, vamos a empezar a interactuar con los datos.</p> <p>En cualquier momento podemos cambiar la base de datos activa mediante <code>use nombreBaseDatos</code>. Si la base de datos no existiese, MongoDB crear\u00e1 dicha base de datos. Esto es una verdad a medias, ya que la base de datos realmente se crea al insertar datos dentro de alguna colecci\u00f3n.</p> <p>As\u00ed pues, vamos a crear nuestra base de datos <code>iabd</code>:</p> <pre><code>use iabd\n</code></pre> <p>Una vez creada, podemos crear nuestra primera colecci\u00f3n, que llamaremos <code>people</code>, e insertaremos un persona con nuestros datos personales mediante el m\u00e9todo <code>insertOne</code>, al que le pasamos un objeto JSON:</p> <pre><code>db.people.insertOne({ nombre: \"Aitor Medrano\", edad: 45, profesion: \"Profesor\" })\n</code></pre> <p>Tras ejecutar el comando, veremos que nos devuelve un objeto JSON con su ACK y el identificador del documento insertado:</p> <pre><code>{\nacknowledged: true,\ninsertedId: ObjectId(\"6316fc938cc2bc168bfed066\")\n}\n</code></pre> <p>Una vez insertada, s\u00f3lo nos queda realizar una consulta para recuperar los datos y comprobar que todo funciona correctamente mediante el m\u00e9todo <code>findOne</code>:</p> <pre><code>db.people.findOne()\n</code></pre> <p>Lo que nos dar\u00e1 como resultado un objeto JSON que contiene un atributo <code>_id</code> con el mismo identificador mostrado anteriormente, adem\u00e1s de los que le a\u00f1adimos al insertar la persona:</p> <pre><code>{\n_id: ObjectId(\"6316fc938cc2bc168bfed066\"),\nnombre: 'Aitor Medrano',\nedad: 45,\nprofesion: 'Profesor'\n}\n</code></pre> <p>Como podemos observar, todas las instrucciones van a seguir el patr\u00f3n de <code>db.nombreColeccion.operacion()</code>.</p>"},{"location":"sa/02mongo.html#trabajando-con-el-shell","title":"Trabajando con el shell","text":"<p>Antes de entrar en detalles en las instrucciones necesarias para realizar las operaciones CRUD, veamos algunos comandos que nos ser\u00e1n muy \u00fatiles al interactuar con el shell:</p> Comando Funci\u00f3n <code>show dbs</code> Muestra el nombre de las bases de datos <code>show collections</code> Muestra el nombre de las colecciones <code>db</code> Muestra el nombre de la base de datos que estamos utilizando <code>db.dropDatabase()</code> Elimina la base de datos actual <code>db.help()</code> Muestra los comandos disponibles <code>db.version()</code> Muestra la versi\u00f3n actual del servidor <p>En el resto de la sesi\u00f3n vamos a hacer un uso intenso del shell de MongoDB. Por ejemplo, si nos basamos en el objeto definido en el apartado de BSON, podemos ejecutar las siguientes instrucciones:</p> <pre><code>&gt; db.people.insertOne(yo)  // (1)\n&lt; {\nacknowledged: true,\ninsertedId: ObjectId(\"631704a042aae0893122f2d6\")\n}\n&gt; db.people.find()  // (2)\n&lt; [\n{\n_id: ObjectId(\"6316fc938cc2bc168bfed066\"),\nnombre: 'Aitor Medrano',\nedad: 45,\nprofesion: 'Profesor'\n},\n{\n_id: ObjectId(\"631704a042aae0893122f2d6\"),\nnombre: 'Aitor',\napellidos: 'Medrano',\nfnac: ISODate(\"1977-10-03T00:00:00.000Z\"),\nhobbies: [ 'programaci\u00f3n', 'videojuegos', 'baloncesto' ],\ncasado: true,\nhijos: 2,\ncontacto: { twitter: '@aitormedrano', email: 'a.medrano@edu.gva.es' },\nfechaCreacion: Timestamp({ t: 1662452896, i: 1 })\n}\n]\n&gt; yo.profesion = \"Profesor\"\n&lt; Profesor\n&gt; db.people.insertOne(yo)   // (3)\n&lt; [\n{\n_id: ObjectId(\"6316fc938cc2bc168bfed066\"),\nnombre: 'Aitor Medrano',\nedad: 45,\nprofesion: 'Profesor'\n},\n{\n_id: ObjectId(\"631704a042aae0893122f2d6\"),\nnombre: 'Aitor',\napellidos: 'Medrano',\nfnac: ISODate(\"1977-10-03T00:00:00.000Z\"),\nhobbies: [ 'programaci\u00f3n', 'videojuegos', 'baloncesto' ],\ncasado: true,\nhijos: 2,\ncontacto: { twitter: '@aitormedrano', email: 'a.medrano@edu.gva.es' },\nfechaCreacion: Timestamp({ t: 1662452896, i: 1 })\n},\n{\n_id: ObjectId(\"6317056d42aae0893122f2d7\"),\nnombre: 'Aitor',\napellidos: 'Medrano',\nfnac: ISODate(\"1977-10-03T00:00:00.000Z\"),\nhobbies: [ 'programaci\u00f3n', 'videojuegos', 'baloncesto' ],\ncasado: true,\nhijos: 2,\ncontacto: { twitter: '@aitormedrano', email: 'a.medrano@edu.gva.es' },\nfechaCreacion: Timestamp({ t: 1662453101, i: 1 }),\nprofesion: 'Profesor'\n}\n]\n&gt; db.people.countDocuments()    // (4)\n&lt; 3\n</code></pre> <ol> <li>Si queremos insertar un documento en una colecci\u00f3n, hemos de utilizar el m\u00e9todo <code>insertOne</code> pas\u00e1ndole como par\u00e1metro el documento que queremos insertar, ya sea a partir de una variable o el propio documento en s\u00ed.</li> <li><code>find</code> recupera todos los documentos de la colecci\u00f3n</li> <li>Modificamos nuestro documento y los volvemos a insertar. Realmente va a crear un nuevo documento, y no se va a quejar de que ya exista, porque nuestro documento no contiene ning\u00fan atributo identificador, por lo que considera que se trata de una nueva persona.</li> <li>Obtenemos la cantidad de documentos de la colecci\u00f3n mediante <code>countDocuments</code>.</li> </ol> <p>Con este ejemplo, hemos podido observar como los documentos de una misma colecci\u00f3n no tienen por qu\u00e9 tener el mismo esquema, ni hemos necesitado definirlo expl\u00edcitamente antes de insertar datos. As\u00ed pues, el esquema se ir\u00e1 generando y actualizando conforme se inserten documentos. M\u00e1s adelante veremos que podemos definir un esquema para validar que los datos que insertamos cumplan restricciones de tipos de datos o elementos que obligatoriamente deben estar rellenados.</p>"},{"location":"sa/02mongo.html#empleando-javascript","title":"Empleando JavaScript","text":"<p>Ya hemos comentado que el shell utiliza JavaScript como lenguaje de interacci\u00f3n, por lo que podemos almacenar los comandos en un script externo y ejecutarlo mediante <code>load()</code>:</p> <pre><code>load(\"scripts/misDatos.js\");\nload(\"/data/db/scripts/misDatos.js\");\n</code></pre> <p>Si hacemos una referencia relativa, lo hace respecto a la ruta desde la cual se ejecuta el shell <code>mongosh</code>.</p> <p>Otra manera de lanzar un script es hacerlo desde la l\u00ednea de comandos, pas\u00e1ndole como segundo par\u00e1metro el script a ejecutar:</p> <pre><code>mongosh iabd misDatos.js\n</code></pre> <p>Si el c\u00f3digo a ejecutar no necesita almacenarse en un script externo, el propio shell permite introducir instrucciones en varias l\u00edneas:</p> <pre><code>&gt; for (var i=0;i&lt;10;i++) {\n...     db.espias.insertOne({\"nombre\":\"James Bond \" + i, \"agente\":\"00\" + i});\n... }\n&lt; {\nacknowledged: true,\ninsertedId: ObjectId(\"63171d2142aae0893122f2e1\")\n}\n&gt; db.espias.find()\n&lt; [\n{\n_id: ObjectId(\"63171d2142aae0893122f2d8\"),\nnombre: 'James Bond 0',\nagente: '000'\n},\n{\n_id: ObjectId(\"63171d2142aae0893122f2d9\"),\nnombre: 'James Bond 1',\nagente: '001'\n},\n...\n{\n_id: ObjectId(\"63171d2142aae0893122f2e1\"),\nnombre: 'James Bond 9',\nagente: '009'\n}\n]\n</code></pre>"},{"location":"sa/02mongo.html#objectid","title":"ObjectId","text":"<p>En MongoDB, el atributo <code>_id</code> es \u00fanico dentro de la colecci\u00f3n, y hace la funci\u00f3n de clave primaria. Se le asocia un <code>ObjectId</code>, el cual es un tipo BSON de 12 bytes que se crea mediante:</p> <ul> <li>el timestamp actual (4 bytes)</li> <li>un valor aleatorio y \u00fanico por m\u00e1quina y proceso (5 bytes)</li> <li>un contador inicializado a n\u00famero aleatorio (3 bytes).</li> </ul> <p>Este objeto lo crea el driver y no MongoDB, por lo cual no deberemos considerar que siguen un orden concreto, ya que clientes diferentes pueden tener timestamps desincronizados. Lo que s\u00ed que podemos obtener a partir del <code>ObjectId</code> es la fecha de creaci\u00f3n del documento, mediante el m\u00e9todo <code>getTimestamp()</code> del atributo <code>_id</code>.</p> <p>Obteniendo la fecha de creaci\u00f3n de un documento</p> <pre><code>&gt; db.people.findOne()._id\n&lt; ObjectId(\"6316fc938cc2bc168bfed066\")\n&gt; db.people.findOne()._id.getTimestamp()\n&lt; ISODate(\"2022-09-06T07:53:55.000Z\")\n</code></pre> <p>Este identificador es global, \u00fanico e inmutable. Esto es, no habr\u00e1 dos repetidos y una vez un documento tiene un <code>_id</code>, \u00e9ste no se puede modificar.</p> <p>Si en la definici\u00f3n del objeto a insertar no ponemos el atributo identificador, MongoDB crear\u00e1 uno de manera autom\u00e1tica. Si lo ponemos nosotros de manera expl\u00edcita, MongoDB no a\u00f1adir\u00e1 ning\u00fan <code>ObjectId</code>. Eso s\u00ed, debemos asegurarnos que sea \u00fanico (podemos usar n\u00fameros, cadenas, etc\u2026\u200b).</p> <p>Por lo tanto, podemos asignar un identificador al insertar:</p> <pre><code>&gt; db.people.insert({_id:4, nombre:\"Marina\", edad:14 })\n&lt; { acknowledged: true, insertedIds: { '0': 4 } }\n</code></pre> <p>Tipos de datos</p> <p>Cuidado con los tipos, ya que no es lo mismo insertar un atributo con <code>edad:14</code> (se considera el campo como entero) que con <code>edad:\"14\"</code>, ya que considera el campo como texto.</p> <p>O tambi\u00e9n, si queremos podemos hacer que el <code>_id</code> de un documento sea un documento en s\u00ed, y no un entero, para ello, al insertarlo, podemos asignarle un objeto JSON al atributo identificador:</p> <pre><code>&gt; db.people.insertOne({_id:{nombre:'Aitor', apellidos:'Medrano', twitter:'@aitormedrano'}, ciudad:'Elx'})\n&lt; {\nacknowledged: true,\ninsertedId: { nombre: 'Aitor', apellidos: 'Medrano', twitter: '@aitormedrano' }\n}\n</code></pre>"},{"location":"sa/02mongo.html#recuperando-datos","title":"Recuperando datos","text":"<p>Para recuperar los datos de una colecci\u00f3n o un documento en concreto usaremos el m\u00e9todo <code>find()</code>:</p> <pre><code>&gt; db.people.find()\n&lt; { _id: ObjectId(\"6316fc1597eb703de2add36e\"),\nnombre: 'Aitor',\nedad: 45,\nprofesion: 'Profesor' }\n{ _id: ObjectId(\"6317048697eb703de2add36f\"),\nnombre: 'Aitor',\napellidos: 'Medrano',\nfnac: 1977-10-02T23:00:00.000Z,\nhobbies: [ 'programaci\u00f3n', 'videojuegos', 'baloncesto' ],\ncasado: true,\nhijos: 2,\ncontacto: { twitter: '@aitormedrano', email: 'a.medrano@edu.gva.es' },\nfechaCreacion: Timestamp({ t: 1662452870, i: 3 }) }\n</code></pre> <p>El m\u00e9todo <code>find()</code> sobre una colecci\u00f3n devuelve un cursor a los datos obtenidos, el cual se queda abierto con el servidor y que se cierra autom\u00e1ticamente a los 30 minutos de inactividad o al finalizar su recorrido. Si hay muchos resultados, la consola nos mostrar\u00e1 un subconjunto de los datos (20). Si queremos seguir obteniendo resultados, solo tenemos que introducir <code>it</code>, para que contin\u00fae iterando el cursor.</p> <p>En cambio, si s\u00f3lo queremos recuperar un documento hemos de utilizar <code>findOne()</code>:</p> <pre><code>&gt; db.people.findOne()\n&gt; { _id: ObjectId(\"6316fc1597eb703de2add36e\"),\nnombre: 'Aitor',\nedad: 45,\nprofesion: 'Profesor' }\n</code></pre> <p>Preparando los ejemplos</p> <p>Para los siguientes ejemplos, vamos a utilizar una colecci\u00f3n de 10.000 documentos sobre los viajes realizados por los usuarios de una empresa de alquiler de bicicletas, los cuales han sido extra\u00eddos de https://ride.citibikenyc.com/system-data.</p> <p>Esta colecci\u00f3n (<code>trips</code>) est\u00e1 cargada tanto en el cluster de MongoAtlas como en el contenedor de Docker (si has seguido las instrucciones) de la base de datos <code>sample_training</code>.</p> <p>Un ejemplo de viaje ser\u00eda:</p> <pre><code>&gt; use sample_training\n&lt; 'switched to db sample_training'\n&gt; db.trips.findOne()\n&lt; { _id: ObjectId(\"572bb8222b288919b68abf5b\"),\ntripduration: 889,\n'start station id': 268,\n'start station name': 'Howard St &amp; Centre St',\n'end station id': 3002,\n'end station name': 'South End Ave &amp; Liberty St',\nbikeid: 22794,\nusertype: 'Subscriber',\n'birth year': 1961,\n'start station location': { type: 'Point', coordinates: [ -73.99973337, 40.71910537 ] },\n'end station location': { type: 'Point', coordinates: [ -74.015756, 40.711512 ] },\n'start time': 2016-01-01T00:01:06.000Z,\n'stop time': 2016-01-01T00:15:56.000Z }\n</code></pre>"},{"location":"sa/02mongo.html#criterios-en-consultas","title":"Criterios en consultas","text":"<p>Al hacer una consulta, si queremos obtener datos mediante m\u00e1s de un criterio, en el primer par\u00e1metro del <code>find</code> podemos pasar un objeto JSON con los campos a cumplir (condici\u00f3n Y).</p> ConsultaResultado <pre><code>db.trips.find({'start station id': 405, 'end station id': 146})\n</code></pre> <pre><code>{ _id: ObjectId(\"572bb8222b288919b68ad197\"),\ntripduration: 1143,\n'start station id': 405,\n'start station name': 'Washington St &amp; Gansevoort St',\n'end station id': 146,\n'end station name': 'Hudson St &amp; Reade St',\nbikeid: 23724,\nusertype: 'Customer',\n'birth year': '',\n'start station location': { type: 'Point', coordinates: [ -74.008119, 40.739323 ] },\n'end station location': { type: 'Point', coordinates: [ -74.0091059, 40.71625008 ] },\n'start time': 2016-01-01T13:37:45.000Z,\n'stop time': 2016-01-01T13:56:48.000Z }\n{ _id: ObjectId(\"572bb8222b288919b68ad191\"),\ntripduration: 1143,\n'start station id': 405,\n'start station name': 'Washington St &amp; Gansevoort St',\n'end station id': 146,\n'end station name': 'Hudson St &amp; Reade St',\nbikeid: 17075,\nusertype: 'Customer',\n'birth year': '',\n'start station location': { type: 'Point', coordinates: [ -74.008119, 40.739323 ] },\n'end station location': { type: 'Point', coordinates: [ -74.0091059, 40.71625008 ] },\n'start time': 2016-01-01T13:37:38.000Z,\n'stop time': 2016-01-01T13:56:42.000Z }\n</code></pre> <p>Consejo de Rendimiento</p> <p>Las consultas disyuntivas, es decir, con varios criterios u operador <code>$and</code>, deben filtrar el conjunto m\u00e1s peque\u00f1o cuanto m\u00e1s pronto posible.</p> <p>Supongamos que vamos a consultar documentos que cumplen los criterios A, B y C. Digamos que el criterio A lo cumplen 40.000 documentos, el B lo hacen 9.000 y el C s\u00f3lo 200. Si filtramos A, luego B, y finalmente C, el conjunto que trabaja cada criterio es muy grande.</p> <p> Restringiendo consultas AND </p> <p>En cambio, si hacemos una consulta que primero empiece por el criterio m\u00e1s restrictivo, el resultado con lo que se intersecciona el siguiente criterio es menor, y por tanto, se realizar\u00e1 m\u00e1s r\u00e1pido.</p> <p> Restringiendo consultas AND de menor a mayor </p> <p>MongoDB tambi\u00e9n ofrece operadores l\u00f3gicos para los campos num\u00e9ricos:</p> Comparador Operador menor que (<code>&lt;</code>) <code>$lt</code> menor o igual que (<code>\u2264</code>) <code>$lte</code> mayor que (<code>&gt;</code>) <code>$gt</code> mayor o igual que (<code>\u2265</code>) <code>$gte</code> <p>Estos operadores se pueden utilizar de forma simult\u00e1nea sobre un mismo campo o sobre diferentes campos, sobre campos anidados o que forman parte de un array, y se colocan como un nuevo documento en el valor del campo a filtrar, compuesto del operador y del valor a comparar mediante la siguiente sintaxis:</p> <pre><code>db.&lt;coleccion&gt;.find({ &lt;campo&gt;: { &lt;operador&gt;: &lt;valor&gt; } })\n</code></pre> <p>Por ejemplo, para recuperar los viajes que han durado menos de 5 minutos o comprendidos entre 3 y 5 minutos (el campo almacena el tiempo en segundos), podemos hacer:</p> <pre><code>db.trips.find({ \"tripduration\": {$lt:300} })\ndb.trips.find({ \"tripduration\": {$gt:180, $lte:300} })\n</code></pre> <p>Para los campos de texto, adem\u00e1s de la comparaci\u00f3n directa, podemos usar el operador <code>$ne</code> para obtener los documentos cuyo campos no tienen un determinado valor (not equal). As\u00ed pues, podemos usarlo para averiguar todos los trayectos realizados por usuarios que no son subscriptores (<code>Subscriber</code>):</p> <pre><code>db.trips.find({ \"usertype\": {$ne:\"Subscriber\"} })\n</code></pre> <p>Por supuesto, podemos tener diferentes operadores en campos distintos. Por ejemplo, si queremos ver los viajes de menos de un minuto y medio realizado por usuarios que no son subscriptores har\u00edamos:</p> <pre><code>db.trips.find({ \"tripduration\": {$lt:90}, \"usertype\": {$ne:\"Subscriber\"} })\n</code></pre> <p>Case sensitive</p> <p>Las comparaciones de cadenas se realizan siguiendo el orden UTF8, similar a ASCII, con lo cual no es lo mismo buscar un rango entre may\u00fasculas que min\u00fasculas.</p> <p>Con cierto parecido a la condici\u00f3n de valor no nulo de las BBDD relacionales y teniendo en cuenta que la libertad de esquema puede provocar que un documento tenga unos campos determinados y otro no lo tenga, podemos utilizar el operador <code>$exists</code> si queremos averiguar si un campo existe (y por tanto tiene alg\u00fan valor).</p> <pre><code>db.people.find({\"edad\":{$exists:true}})\n</code></pre> <p>Polimorfismo</p> <p>Mucho cuidado al usar polimorfismo y almacenar en un mismo campo un entero y una cadena, ya que al hacer comparaciones para recuperar datos, no vamos a poder mezclar cadenas con valores num\u00e9ricos. Se considera un antipatr\u00f3n el mezclar tipos de datos en un campo.</p> <p>Pese a que ciertos operadores contengan su correspondiente operador negado, MongoDB ofrece el operador <code>$not</code>. \u00c9ste puede utilizarse conjuntamente con otros operadores para negar el resultado de los documentos obtenidos.</p> <p>Por ejemplo, si queremos obtener todas las personas cuya edad no sea m\u00faltiplo de 5, podr\u00edamos hacerlo as\u00ed:</p> <pre><code>db.people.find({edad:{$not: {$mod: [5,0]}}})\n</code></pre>"},{"location":"sa/02mongo.html#expresiones-regulares","title":"Expresiones regulares","text":"<p>Finalmente, si queremos realizar consultas sobre partes de un campo de texto, hemos de emplear expresiones regulares. Para ello, tenemos el operador <code>$regexp</code> o, de manera m\u00e1s sencilla, indicando como valor la expresi\u00f3n regular a cumplir:</p> <p>Por ejemplo, para buscar la cantidad de viajes que salen da alguna estaci\u00f3n cuyo nombre contenga <code>Central Park</code> podemos hacer:</p> <pre><code>db.trips.find({\"start station name\":/Central Park/}).count()\ndb.trips.find({\"start station name\":/central park/i}).count()\ndb.trips.find({\"start station name\":{$regex:/central park/i}}).count()\n</code></pre> <p>B\u00fasquedas sobre textos</p> <p>Si vamos a realizar b\u00fasquedas intensivas sobre texto, desde MongoDB han creado un producto espec\u00edfico dentro del ecosistema de Mongo Atlas el cual ofrece un mejor rendimiento y mayor funcionalidad que el uso de expresiones regulares, conocido con Mongo Atlas Search.</p> <p>Si usamos una soluci\u00f3n on-premise, mediante \u00edndices de texto y el operator <code>$text</code> podemos realizar b\u00fasquedas.</p>"},{"location":"sa/02mongo.html#operador-expr","title":"Operador $expr","text":"<p>El operador <code>$expr</code> es un operador de consulta expresiva que permite utilizar expresiones de agregaci\u00f3n dentro de las consultas.</p> <p>Permite utilizar variables y sentencias condicionales, asi como comparar campos dentro de un documento. As\u00ed pues, si queremos comparar valores entre dos campos, podemos hacerlo mediante <code>$expr</code> referenciando a los campos anteponiendo un dolar (<code>$</code>) delante del campo, de manera que si queremos obtener los viajes que comienzan y finalizan en la misma estaci\u00f3n podemos hacer:</p> <pre><code>db.trips.find({ \"$expr\": { \"$eq\": [ \"$end station id\", \"$start station id\" ]}})\n</code></pre> <p>Al poner el <code>$</code> delante de un campo, en vez de referenciar al campo, lo que hace es referenciar a su valor, por lo que <code>$end station id</code> est\u00e1 referenciando al valor del campo <code>end station id</code>.</p> <p>Otros operadores</p> <p>El operador <code>$type</code> permite recuperar documentos que dependan del tipo de campo que contiene.</p> <p>El operador <code>$where</code> permite introducir una expresi\u00f3n JavaScript.</p>"},{"location":"sa/02mongo.html#proyeccion-de-campos","title":"Proyecci\u00f3n de campos","text":"<p>Las consultas realizadas hasta ahora devuelven los documentos completos. Si queremos que devuelva un campo o varios campos en concreto, hemos de pasar un segundo par\u00e1metro de tipo JSON con aquellos campos que deseamos mostrar con el valor <code>true</code> o <code>1</code>. Destacar que si no se indica nada, por defecto siempre mostrar\u00e1 el campo <code>_id</code></p> <pre><code>&gt; db.trips.find({'start station id': 405, 'end station id': 146}, {tripduration: 1})\n&lt; { _id: ObjectId(\"572bb8222b288919b68ad191\"),\ntripduration: 1143 }\n</code></pre> <p>Por lo tanto, si queremos que no se muestre el <code>_id</code>, lo podremos a <code>false</code> o <code>0</code>:</p> <pre><code>&gt; db.trips.find({'start station id': 405, 'end station id': 146}, {tripduration: 1, _id:0})\n&lt; { tripduration: 1143 }\n</code></pre> <p>No mezcles</p> <p>Al hacer una proyecci\u00f3n, no podemos mezclar campos que se vean (<code>1</code>) con los que no ( <code>0</code>). Es decir, hemos de hacer algo similar a:</p> <pre><code>db.&lt;coleccion&gt;.find({ &lt;consulta&gt; }, {&lt;campo1&gt;: 1, &lt;campo2&gt;: 1})\ndb.&lt;coleccion&gt;.find({ &lt;consulta&gt; }, {&lt;campo1&gt;: 0, &lt;campo2&gt;: 0})\n</code></pre> <p>As\u00ed pues, s\u00f3lo se mezclar\u00e1 la visibilidad de los campos cuando queramos ocultar el <code>_id</code>.</p>"},{"location":"sa/02mongo.html#condiciones-compuestas-con-y-o","title":"Condiciones compuestas con Y / O","text":"<p>Para usar la conjunci\u00f3n o la disyunci\u00f3n, tenemos los operadores <code>$and</code> y <code>$or</code>. Son operadores prefijo, de modo que se ponen antes de las subconsultas que se van a evaluar. Estos operadores trabajan con arrays, donde cada uno de los elementos es un documento con la condici\u00f3n a evaluar, de modo que se realiza la uni\u00f3n entre estas condiciones, aplicando la l\u00f3gica asociada a AND y a OR.</p> <pre><code>db.trips.find({ $or:[{'start station id': 405}, {'end station id': 146}] })\ndb.trips.find({ $or:[{ \"tripduration\": {$lte:70}}, { \"tripduration\": {$gte:3600}}] })\n</code></pre> <p>Realmente el operador <code>$and</code> no se suele usar porque podemos anidar en la consulta dos criterios, al poner uno dentro del otro. As\u00ed pues, estas dos consultas hacen lo mismo:</p> <pre><code>db.trips.find({'start station id': 405, 'end station id': 146})\ndb.trips.find({ $and:[ {'start station id': 405}, {'end station id': 146} ] })\n</code></pre> <p>Consejo de Rendimiento</p> <p>Las consultas conjuntivas, es decir, con varios criterios excluyentes u operador <code>$or</code>, deben filtrar el conjunto m\u00e1s grande cuanto m\u00e1s pronto posible.</p> <p>Supongamos que vamos a consultar los mismos documentos que cumplen los criterios A (40.000 documentos), B (9.000 documentos) y C (200 documentos).</p> <p>Si filtramos C, luego B, y finalmente A, el conjunto de documentos que tiene que comprobar MongoDB es muy grande.</p> <p> Restringiendo consultas OR de menor a mayor </p> <p>En cambio, si hacemos una consulta que primero empiece por el criterio menos restrictivo, el conjunto de documentos sobre el cual va a tener que comprobar siguientes criterios va a ser menor, y por tanto, se realizar\u00e1 m\u00e1s r\u00e1pido.</p> <p> Restringiendo consultas OR de mayor a menor </p> <p>Tambi\u00e9n podemos utilizar el operado <code>$nor</code>, que no es m\u00e1s que la negaci\u00f3n de <code>$or</code> y que obtendr\u00e1 aquellos documentos que no cumplan ninguna de las condiciones.</p> <p>Autoevaluaci\u00f3n</p> <p>Que obtendr\u00edamos al ejecutar la siguiente consulta:</p> <pre><code>db.trips.find({ \"tripduration\": {$lte:65}, $nor:[ {usertype:\"Customer\"}, {\"birth year\":1989} ] })\n</code></pre> <p>Finalmente, si queremos indicar mediante un array los diferentes valores que puede cumplir un campo, podemos utilizar el operador <code>$in</code>:</p> <pre><code>db.trips.find({ \"birth year\": {$in: [1977, 1980]} })\n</code></pre> <p>Por supuesto, tambi\u00e9n existe su negaci\u00f3n mediante <code>$nin</code>.</p>"},{"location":"sa/02mongo.html#condiciones-sobre-objetos-anidados","title":"Condiciones sobre objetos anidados","text":"<p>Si queremos acceder a campos de subdocumentos, siguiendo la sintaxis de JSON, se utiliza la notaci\u00f3n punto. Esta notaci\u00f3n permite acceder al campo de un documento anidado, da igual el nivel en el que est\u00e9 y su orden respecto al resto de campos.</p> <p>Preparando los ejemplos</p> <p>Para los siguientes ejemplos sobre documentos anidados y arrays, vamos a utilizar una colecci\u00f3n de 500 documentos sobre mensajes de un blog.</p> <p>Esta colecci\u00f3n (<code>posts</code>) est\u00e1 cargada tanto en el cluster de MongoAtlas como en el contenedor de Docker (si has seguido las instrucciones) de la base de datos <code>sample_training</code>.</p> <p>Un ejemplo de mensaje ser\u00eda:</p> <pre><code>&gt; use sample_training\n'switched to db sample_training'\n&gt; db.posts.findOne()\n&lt; { _id: ObjectId(\"50ab0f8bbcf1bfe2536dc3f9\"),\nbody: 'Amendment I\\n&lt;p&gt;Congress shall make ....\"\\n&lt;p&gt;\\n',\npermalink: 'aRjNnLZkJkTyspAIoRGe',\nauthor: 'machine',\ntitle: 'Bill of Rights',\ntags:\n'santa',\n'xylophone',\n'math',\n'dream',\n'action' ],\ncomments:\n[ { body: 'Lorem ipsum dolor ...',\nemail: 'HvizfYVx@pKvLaagH.com',\nauthor: 'Santiago Dollins' },\n{ body: 'Lorem ipsum dolor sit...',\nemail: 'WpOUCpdD@hccdxJvT.com',\nauthor: 'Jaclyn Morado' },\n{ body: 'Lorem ipsum dolor sit amet...',\nemail: 'OgDzHfFN@cWsDtCtx.com',\nauthor: 'Houston Valenti' }],\ndate: 2012-11-20T05:05:15.231Z }\n</code></pre> <p>Para acceder al autor de los comentarios de un mensaje usar\u00edamos la propiedad <code>comments.author</code>.</p> <p>Por ejemplo, para averiguar los mensajes titulados <code>Bill of Rights</code> y que tienen alg\u00fan comentario creado por <code>Santiago Dollins</code> har\u00edamos:</p> <pre><code>db.posts.find({title: 'Bill of Rights', \"comments.author\":'Santiago Dollins'})\n</code></pre>"},{"location":"sa/02mongo.html#consultas-sobre-arrays","title":"Consultas sobre arrays","text":"<p>Si trabajamos con arrays, vamos a poder consultar el contenido de una posici\u00f3n del mismo tal como si fuera un campo normal, siempre que sea un campo de primer nivel, es decir, no sea un documento embebido dentro de un array.</p> <p>Si queremos filtrar teniendo en cuenta el n\u00famero de ocurrencias del array, podemos utilizar:</p> <ul> <li><code>$all</code> para filtrar ocurrencias que tienen todos los valores del array, es decir, los valores pasados a la consulta ser\u00e1n un subconjunto del resultado. Puede que devuelva los mismos, o un array con m\u00e1s campos (el orden no importa)</li> <li><code>$in</code>, igual que SQL, para obtener las ocurrencias que cumple con alguno de los valores pasados (similar a usar <code>$or</code> sobre un conjunto de valores de un mismo campo). Si queremos su negaci\u00f3n, usaremos <code>$nin</code>, para obtener los documentos que no cumplen ninguno de los valores.</li> </ul> <p>Por ejemplo, si queremos obtener los mensajes que contenga las etiquetas <code>dream</code> y <code>action</code> tendr\u00edamos:</p> <pre><code>db.posts.find( {tags: {$all: [\"dream\", \"action\"]}} )\n</code></pre> <p>En cambio, si queremos los mensajes que contengan alguna de esas etiquetas har\u00edamos:</p> <pre><code>db.posts.find( {tags: {$in: [\"dream\", \"action\"]}} )\n</code></pre> <p>Si el array contiene documentos y queremos filtrar la consulta sobre los campos de los documentos del array, tenemos que utilizar <code>$elemMatch</code>, de manera que obtengamos aquellos que al menos encuentre un elemento que cumpla el criterio. As\u00ed pues, si queremos recuperar los mensajes que tienen un comentario cuyo autor sea <code>Santiago Dollins</code> har\u00edamos:</p> <pre><code>db.posts.find( {comments: {$elemMatch: { author: \"Santiago Dollins\", email: \"xnZKyvWD@jHfVKtUh.com\"}}} )\n</code></pre> <p>Criterio con notaci\u00f3n punto</p> <p>En el ejemplo anterior, si s\u00f3lo hubi\u00e9ramos tenido un campo para el filtrado, podr\u00edamos haber utilizado la notaci\u00f3n punto <code>comments.author</code>.</p> <p>Si s\u00f3lo queremos los comentarios escritos por un determinado autor, adem\u00e1s de en el filtrado, hemos de indicarlo en la proyecci\u00f3n:</p> <pre><code>db.posts.find(\n{comments: {$elemMatch: { author: \"Santiago Dollins\", email: \"xnZKyvWD@jHfVKtUh.com\"}}},\n{comments: {$elemMatch: { author: \"Santiago Dollins\", email: \"xnZKyvWD@jHfVKtUh.com\"}}} )\n</code></pre> <p>Si lo que nos interesa es la cantidad de elementos que contiene un array, emplearemos el operador <code>$size</code>. Por ejemplo, para obtener los mensajes que tienen 10 etiquetas har\u00edamos:</p> <pre><code>db.posts.find( {tags : {$size : 10}} )\n</code></pre> <p>Finalmente, a la hora de proyectar los datos, si no estamos interesados en todos los valores de un campo que es un array, podemos restringir el resultado mediante el operador <code>$slice</code>. As\u00ed pues, si quisi\u00e9ramos obtener los mensajes titulados <code>US Constitution</code> y que de esos mensajes, mostrara s\u00f3lo tres etiquetas y dos comentarios, har\u00edamos:</p> <pre><code>&gt; db.posts.find( {title : \"US Constitution\"}, {comments: {$slice:2}, tags: {$slice:3}} )\n&lt; { _id: ObjectId(\"50ab0f8bbcf1bfe2536dc416\"),\nbody: 'We the People ...',\npermalink: 'NhWDUNColpvxFjovsgqU',\nauthor: 'machine',\ntitle: 'US Constitution',\ntags: [ 'engineer', 'granddaughter', 'sundial' ],\ncomments: [ { body: 'Lorem ipsum dolor ...',\nemail: 'ftRlVMZN@auLhwhlj.com',\nauthor: 'Leonida Lafond' },\n{ body: 'Lorem ipsum dolor sit...',\nemail: 'dsoLAdFS@VGBBuDVs.com',\nauthor: 'Nobuko Linzey' } ],\ndate: 2012-11-20T05:05:15.276Z }\n</code></pre>"},{"location":"sa/02mongo.html#conjunto-de-valores","title":"Conjunto de valores","text":"<p>Igual que en SQL, a partir de un colecci\u00f3n, si queremos obtener todos los diferentes valores que existen en un campo, utilizaremos el m\u00e9todo <code>distinct</code>:</p> <pre><code>&gt; db.trips.distinct('usertype')\n&lt; [ 'Customer', 'Subscriber' ]\n</code></pre> <p>Si queremos filtrar los datos sobre los que se obtienen los valores, le pasaremos un segundo par\u00e1metro con el criterio a aplicar:</p> <pre><code>&gt; db.trips.distinct('usertype', { \"birth year\": { $gt: 1990 } } )\n&lt; [ 'Subscriber' ]\n</code></pre>"},{"location":"sa/02mongo.html#cursores","title":"Cursores","text":"<p>Al hacer una consulta en el shell se devuelve un cursor. Este cursor lo podemos guardar en un variable, y partir de ah\u00ed trabajar con \u00e9l como har\u00edamos mediante cualquier lenguaje de programaci\u00f3n. Si <code>cur</code> es la variable que referencia al cursor, podremos utilizar los siguientes m\u00e9todos:</p> M\u00e9todo Uso Lugar de ejecuci\u00f3n <code>cur.hasNext()</code> <code>true</code>/<code>false</code> para saber si quedan elementos Cliente <code>cur.next()</code> Pasa al siguiente documento Cliente <code>cur.limit(cantidad)</code> Restringe el n\u00famero de resultados a <code>cantidad</code> Servidor <code>cur.sort({campo:1})</code> Ordena los datos por campo: <code>1</code> ascendente o <code>-1</code> o descendente Servidor <code>cur.skip(cantidad)</code> Permite saltar <code>cantidad</code> elementos con el cursor Servidor <p>La consulta no se ejecuta hasta que el cursor comprueba o pasa al siguiente documento (<code>next</code>/<code>hasNext</code>), por ello que tanto <code>limit</code> como <code>sort</code> (ambos modifican el cursor) s\u00f3lo se pueden realizar antes de recorrer cualquier elemento del cursor.</p> <p>Como tras realizar una consulta con <code>find</code>, realmente se devuelve un cursor, un uso muy habitual es encadenar una operaci\u00f3n de <code>find</code> con <code>sort</code> y/o <code>limit</code> para ordenar el resultado por uno o m\u00e1s campos y posteriormente limitar el n\u00famero de documentos a devolver.</p> <p>As\u00ed pues, si quisi\u00e9ramos obtener los tres viajes que m\u00e1s han durado, podr\u00edamos hacerlo as\u00ed:</p> <pre><code>db.trips.find().sort({\"tripduration\":-1}).limit(3)\n</code></pre> <p>Tambi\u00e9n podemos filtrar previamente a ordenar y limitar:</p> <pre><code>db.trips.find({usertype:\"Customer\"}).sort({\"tripduration\":-1}).limit(3)\n</code></pre> <p>Finalmente, podemos paginar utilizando el m\u00e9todo <code>skip</code>, para mostrar viajes de 10 en 10 a partir de la tercera p\u00e1gina, podr\u00edamos hacer algo as\u00ed:</p> <pre><code>db.trips.find({usertype:\"Customer\"}).sort({\"tripduration\":-1}).limit(10).skip(20)\n</code></pre> <p>Autoevaluaci\u00f3n</p> <p>A partir de la colecci\u00f3n <code>trips</code>, escribe un consulta que recupere los viajes realizados por subscriptores ordenados descendentemente por su duraci\u00f3n y que obtenga los documentos de 15 al 20.</p>"},{"location":"sa/02mongo.html#contando-documentos","title":"Contando Documentos","text":"<p>Para contar el n\u00famero de documentos, en vez de <code>find</code> usaremos el m\u00e9todo <code>countDocuments</code>. Por ejemplo:</p> <pre><code>&gt; db.trips.countDocuments({\"birth year\":1977})\n&lt; 186  &gt; db.trips.countDocuments({\"birth year\":1977, \"tripduration\":{$lt:600}})\n&lt; 116\n</code></pre> <p>count</p> <p>Desde la versi\u00f3n 4.0, los m\u00e9todos <code>count</code> a nivel de colecci\u00f3n y de cursor est\u00e1n caducados (deprecated), y no se recomienda su utilizaci\u00f3n. A\u00fan as\u00ed, es muy com\u00fan utilizarlo como m\u00e9todo de un cursor:</p> <pre><code>db.trips.find({\"birth year\":1977, \"tripduration\":{$lt:600}}).count()\n</code></pre> <p>Cuando tenemos much\u00edsimos datos, si no necesitamos exactitud pero queremos un valor estimado el cual tarde menos en conseguirse (utiliza los metadatos de las colecciones), podemos usar <code>estimatedDocumentCount</code></p> <pre><code>&gt; db.trips.estimatedDocumentCount({\"birth year\":1977})\n&lt; 10.000\n&gt; db.trips.estimatedDocumentCount({\"birth year\":1977, \"tripduration\":{$lt:600}})\n&lt; 10.000 </code></pre>"},{"location":"sa/02mongo.html#modificando-documentos","title":"Modificando documentos","text":"<p>Preparando un persona</p> <p>Para este apartado, vamos a insertar dos veces la misma persona sobre la cual realizaremos las modificaciones:</p> <pre><code>db.people.insertOne({ nombre: \"Aitor Medrano\", edad: 45, profesion: \"Profesor\" })\ndb.people.insertOne({ nombre: \"Aitor Medrano\", edad: 45, profesion: \"Profesor\" })\n</code></pre> <p>Para actualizar (y fusionar datos), se utilizan los m\u00e9todos <code>updateOne</code> / <code>updateMany</code> dependiendo de cuantos documentos queremos que modifique. Ambos m\u00e9todos requieren 2 par\u00e1metros: el primero es la consulta para averiguar sobre qu\u00e9 documentos, y en el segundo par\u00e1metro, los campos a modificar utilizando los operadores de actualizaci\u00f3n:</p> <pre><code>db.people.updateOne({nombre:\"Aitor Medrano\"}, {$set:{nombre:\"Marina Medrano\", salario: 123456}})\n</code></pre> <p>Al realizar la modificaci\u00f3n, el shell nos devolver\u00e1 informaci\u00f3n sobre cuantos documentos ha encontrado, modificado y m\u00e1s informaci\u00f3n:</p> <pre><code>{ acknowledged: true,\ninsertedId: null,\nmatchedCount: 1,\nmodifiedCount: 1,\nupsertedCount: 0 }\n</code></pre> <p>Como hay m\u00e1s de una persona con el mismo nombre, al haber utilizado <code>updateOne</code> s\u00f3lo modificar\u00e1 el primer documento que ha encontrado.</p> <p>\u00a1Cuidado!</p> <p>En versiones antiguas de MongoDB, adem\u00e1s de utilizar los operadores de actualizaci\u00f3n, pod\u00edamos pasarle como par\u00e1metro un documento, de manera que MongoDB realizaba un reemplazo de los campos, es decir, si en el origen hab\u00eda 100 campos y en la operaci\u00f3n de modificaci\u00f3n s\u00f3lo pon\u00edamos 2, el resultado \u00fanicamente contendr\u00eda 2 campos. Es por ello, que ahora es obligatorio utilizar los operadores.</p> <p>Si cuando vamos a actualizar, en el criterio de selecci\u00f3n no encuentra el documento sobre el que hacer los cambios, no se realiza ninguna acci\u00f3n.</p> <p>Si quisi\u00e9ramos que en el caso de no encontrar nada insertase un nuevo documento, acci\u00f3n conocida como upsert (update + insert), hay que pasarle un tercer par\u00e1metro al m\u00e9todo con el objeto <code>{upsert:true}</code>. Si encuentra el documento, lo modificar\u00e1, pero si no, crear\u00e1 uno nuevo:</p> <pre><code>db.people.updateOne({nombre:\"Andreu Medrano\"},\n{$set:{name:\"Andreu Medrano\", twitter: \"@andreumedrano\"}},\n{upsert: true})\n</code></pre>"},{"location":"sa/02mongo.html#operadores-de-actualizacion","title":"Operadores de actualizaci\u00f3n","text":"<p>MongoDB ofrece un conjunto de operadores para simplificar la modificaci\u00f3n de campos.</p> <p>El operador m\u00e1s utilizado es el operador <code>$set</code>, el cual admite los campos que se van a modificar. Si el campo no existe, lo crear\u00e1.</p> <p>Por ejemplo, para modificar el <code>salario</code> har\u00edamos:</p> <pre><code>db.people.updateOne({nombre:\"Aitor Medrano\"}, {$set:{salario: 1000000}})\n</code></pre> <p>Mediante <code>$inc</code> podemos incrementar el valor de una variable:</p> <pre><code>db.people.updateOne({nombre:\"Aitor Medrano\"}, {$inc:{salario: 1000}})\n</code></pre> <p>Para eliminar un campo de un documento, usaremos el operador <code>$unset</code>.</p> <p>De este modo, para eliminar el campo twitter de una persona har\u00edamos:</p> <pre><code>db.people.updateOne({nombre:\"Aitor Medrano\"}, {$unset:{twitter: ''}})\n</code></pre> <p>Otros operadores que podemos utilizar son <code>$mul</code>, <code>$min</code>, <code>$max</code> y <code>$currentDate</code>. Podemos consultar todos los operadores disponibles en https://www.mongodb.com/docs/manual/reference/operator/update/</p> <p>Autoevaluaci\u00f3n</p> <p>Tras realizar la siguiente operaci\u00f3n sobre una colecci\u00f3n vac\u00eda:</p> <pre><code>db.people.updateOne({nombre:'yo'}, {'$set':{'hobbies':['gaming', 'sofing']}}, {upsert: true} );\n</code></pre> <p>\u00bfCu\u00e1l es el estado de la colecci\u00f3n?</p> <p>Finalmente, un caso particular de las actualizaciones es la posibilidad de renombrar un campo mediante el operador <code>$rename</code>:</p> <pre><code>db.people.updateMany( {_id:1}, {$rename:{'nickname':'alias', 'cell':'movil'}})\n</code></pre> <p>Podemos consultar todas las opciones de configuraci\u00f3n de una actualizaci\u00f3n en https://www.mongodb.com/docs/manual/reference/method/db.collection.update/.</p>"},{"location":"sa/02mongo.html#control-de-la-concurrencia","title":"Control de la concurrencia","text":"<p>Cuando se hace una actualizaci\u00f3n m\u00faltiple, MongoDB no realiza la operaci\u00f3n de manera at\u00f3mica (a no ser que utilicemos transacciones desde el driver), lo que provoca que se puedan producir pausas (pause yielding). Cada documento en s\u00ed es at\u00f3mico, por lo que ninguno se va a quedar a la mitad.</p> <p>MongoDB ofrece el m\u00e9todo <code>findAndModify</code> para encontrar y modificar un documento de manera at\u00f3mica, y as\u00ed evitar que, entre la b\u00fasqueda y la modificaci\u00f3n, el estado del documento se vea afectado. Adem\u00e1s, devuelve el documento modificado. Un caso de uso muy com\u00fan es para contadores y casos similares.</p> <pre><code>db.people.findAndModify({\nquery: {nombre:\"Marina Medrano\"},\nupdate: {$inc:{salario:100, edad:-30}},\nnew: true\n})\n</code></pre> <p>Por defecto, el documento devuelto ser\u00e1 el resultado que ha encontrado con la consulta. Si queremos que nos devuelva el documento modificado con los cambios deseados, necesitamos utilizar el par\u00e1metro <code>new</code> a <code>true</code>. Si no lo indicamos o lo ponemos a <code>false</code>, tendremos el comportamiento por defecto.</p>"},{"location":"sa/02mongo.html#actualizaciones-sobre-arrays","title":"Actualizaciones sobre Arrays","text":"<p>Para trabajar con arrays necesitamos nuevos operadores que nos permitan tanto introducir como eliminar elementos de una manera m\u00e1s sencilla que sustituir todos los elementos del array.</p> <p>Los operadores que podemos emplear para trabajar con arrays son:</p> Operador Prop\u00f3sito <code>$push</code> A\u00f1ade uno o varios elementos <code>$addToSet</code> A\u00f1ade un elemento sin duplicados <code>$pull</code> Elimina un elemento <code>$pullAll</code> Elimina varios elementos <code>$pop</code> Elimina el primer o el \u00faltimo <p>Preparando los ejemplos</p> <p>Para trabajar con los arrays, vamos a suponer que tenemos una colecci\u00f3n de enlaces donde vamos a almacenar un documento por cada site, con un atributo <code>tags</code> con etiquetas sobre el enlace en cuesti\u00f3n</p> <pre><code>db.enlaces.insertOne({titulo:\"www.google.es\", tags:[\"mapas\", \"videos\"]})\n</code></pre> <p>De modo que tendr\u00edamos el siguiente documento:</p> <pre><code>{ _id: ObjectId(\"633c60e8ac452ac9d7f9fe74\"),\ntitulo: 'www.google.es',\ntags: [ 'mapas', 'videos' ] }\n</code></pre>"},{"location":"sa/02mongo.html#anadiendo-elementos","title":"A\u00f1adiendo elementos","text":"<p>Si queremos a\u00f1adir uno o varios elementos, usaremos el operador <code>$push</code>. Cuando queremos a\u00f1adir varios elementos a la vez, mediante el operador <code>$each</code> le pasamos un array con los datos:</p> <pre><code>db.enlaces.updateMany({titulo:\"www.google.es\"},\n{$push: {tags:\"blog\"}} )\ndb.enlaces.updateMany({titulo:\"www.google.es\"},\n{$push: {tags:{$each:[\"calendario\", \"email\", \"mapas\"]}}})\n</code></pre> <p>Al hacer estar modificaci\u00f3n, el resultado del documento ser\u00eda:</p> <pre><code>{ _id: ObjectId(\"633c61b5ac452ac9d7f9fe75\"),\ntitulo: 'www.google.es',\ntags: [ 'mapas', 'videos', 'blog', 'calendario', 'email', 'mapas' ] }\n</code></pre> <p>Al utilizar <code>$push</code> no se tiene en cuenta lo que contiene el array, por tanto, si un elemento ya existe, se repetir\u00e1 y tendremos duplicados. Si queremos evitar los duplicados, usaremos <code>$addToSet</code>:</p> <pre><code>db.enlaces.updateMany({titulo:\"www.google.es\"},\n{$addToSet:{tags:\"buscador\"}})\n</code></pre> <p>Si queremos a\u00f1adir m\u00e1s de un campo a la vez sin duplicados, debemos anidar el operador <code>$each</code> igual que hemos hecho antes:</p> <pre><code>db.enlaces.updateMany({titulo:\"www.google.es\"},\n{$addToSet:{tags:{$each:[\"drive\", \"traductor\"]}}})\n</code></pre> <p>En cambio, si queremos eliminar elementos de un array, usaremos el operador <code>$pull</code>:</p> <pre><code>db.enlaces.updateMany({titulo:\"www.google.es\"},\n{$pull:{tags:\"traductor\"}})\n</code></pre> <p>Similar al caso anterior, con <code>$pullAll</code>, eliminaremos varios elementos de una sola vez:</p> <pre><code>db.enlaces.updateMany({titulo:\"www.google.es\"},\n{$pullAll:{tags:[\"calendario\", \"email\"]}})\n</code></pre> <p>Otra manera de eliminar elementos del array es mediante <code>$pop</code>, el cual elimina el primero (<code>-1</code>) o el \u00faltimo (<code>1</code>) elemento del array:</p> <pre><code>db.enlaces.updateMany({titulo:\"www.google.es\"}, {$pop:{tags:-1}})\n</code></pre>"},{"location":"sa/02mongo.html#operador-posicional","title":"Operador posicional","text":"<p>Por \u00faltimo, tenemos el operador posicional, el cual se expresa con el s\u00edmbolo <code>$</code> y nos permite modificar el elemento que ocupa una determinada posici\u00f3n del array sin saber exactamente cual es esa posici\u00f3n.</p> <p>Supongamos que tenemos las calificaciones de los estudiantes (colecci\u00f3n <code>students</code>) en un documento con una estructura similar a la siguiente:</p> <pre><code>{ \"_id\" : 1, \"notas\" : [ 80, 85, 90 ] }\n</code></pre> <p>y queremos cambiar la calificaci\u00f3n de 80 por 82. Mediante el operador posicional haremos:</p> <pre><code>db.students.updateOne( { _id: 1, notas: 80 }, { $set: { \"notas.$\" : 82 } } )\n</code></pre> <p>De manera similar, si queremos modificar parte de un documento el cual forma parte de un array, debemos usar la notaci\u00f3n punto tras el <code>$</code>.</p> <p>Por ejemplo, supongamos que tenemos estas calificaciones de un determinado alumno, las cuales forman parte de un objeto dentro de un array:</p> <pre><code>{ \"_id\" : 4, \"notas\" :\n[ { nota: 80, media: 75 },\n{ nota: 85, media: 90 },\n{ nota: 90, media: 85 } ] }\n</code></pre> <p>Podemos observar como tenemos cada calificaci\u00f3n como parte de un objeto dentro de un array. Si queremos cambiar el valor de <code>media</code> a <code>89</code> de la calificaci\u00f3n cuya <code>nota</code> es <code>85</code>, haremos:</p> <pre><code>db.students.updateOne( { _id: 4, \"notas.nota\": 85 }, { $set: { \"notas.$.media\" : 89 } } )\n</code></pre> <p>Es decir, el <code>$</code> referencia al documento que ha cumplido el filtro de b\u00fasqueda.</p> <p>M\u00e1s operadores posicionales</p> <p>Adem\u00e1s del operador posicional $, tenemos disponible el operador posicional <code>$[]</code> que indica que afecta a todos los elementos del array, y el operador posicional <code>$[identificador]</code> que identifica que elementos del array cumplen una condici\u00f3n para su filtrado.</p> <p>Podemos consultar toda la documentaci\u00f3n disponible sobre estos operadores en http://docs.mongodb.org/manual/reference/operator/update-array/</p>"},{"location":"sa/02mongo.html#borrando-documentos","title":"Borrando documentos","text":"<p>Para borrar, usaremos los m\u00e9todo <code>deleteOne</code> o <code>deleteMany</code>, los cuales funcionan de manera similar a <code>findOne</code> y <code>find</code>. Si no pasamos ning\u00fan par\u00e1metro, <code>deleteOne</code> borrar\u00e1 el primer documento, o en el caso de <code>deleteMany</code> toda la colecci\u00f3n documento a documento. Si le pasamos un par\u00e1metro, \u00e9ste ser\u00e1 el criterio de selecci\u00f3n de documentos a eliminar.</p> <pre><code>db.people.deleteOne({nombre:\"Marina Medrano\"})\n</code></pre> <p>Al eliminar un documento, no podemos olvidar que cualquier referencia al documento que exista en la base de datos seguir\u00e1 existiendo. Por este motivo, manualmente tambi\u00e9n hay que eliminar o modificar esas referencias.</p> <p>Si queremos borrar toda la colecci\u00f3n, es m\u00e1s eficiente usar el m\u00e9todo <code>drop</code>, ya que tambi\u00e9n elimina los \u00edndices.</p> <pre><code>db.people.drop()\n</code></pre> <p>Eliminar un campo</p> <p>Recordad que eliminar un determinado campo de un documento no se considera un operaci\u00f3n de borrado, sino una actualizaci\u00f3n mediante el operador <code>$unset</code>.</p>"},{"location":"sa/02mongo.html#referencias","title":"Referencias","text":"<ul> <li>Manual de MongoDB</li> <li>Cheatsheet oficial</li> <li>Comparaci\u00f3n entre SQL y MongoDB</li> <li>Cursos gratuitos de Mongo University</li> <li>Consultas solucionadas sobre la colecci\u00f3n <code>sample_restaurants.restaurants</code> en w3resource</li> </ul>"},{"location":"sa/02mongo.html#actividades","title":"Actividades","text":"<ol> <li> <p>(RA5075.2 / CE5.2b / 1p) Crea un cluster en MongoAtlas, carga los datos de ejemplo y adjunta capturas de pantalla de:</p> <ul> <li>Dashboard del cluster</li> <li>Bases de datos / colecciones creadas</li> </ul> <p>A continuaci\u00f3n, con\u00e9ctate mediante MongoDB Compass y adjunta una captura de pantalla tras conectar con el cl\u00faster.</p> </li> <li> <p>(RA5075.1 / CE5.1d / 2p) Haciendo uso de <code>mongosh</code>, escribe los comandos necesarios para:</p> <ol> <li>Obtener las bases de datos creadas.</li> <li>Sobre la base de datos <code>sample_training</code> y la colecci\u00f3n <code>zips</code> averigua:<ol> <li>Cuantos documentos hay en la ciudad de <code>SAN DIEGO</code>.</li> <li>Cuantos documentos tienen menos de 100 personas (campo <code>pop</code>).</li> <li>Obt\u00e9n los estados de la ciudad de <code>SAN DIEGO</code> (Soluci\u00f3n: <code>[ 'CA', 'TX' ]</code>).</li> <li>Cual es el c\u00f3digo postal de la ciudad de <code>ALLEN</code> que no tiene habitantes (s\u00f3lo recupera el <code>zip</code>, no nos interesa ning\u00fan otro campo, ni el <code>_id</code>).</li> <li>Listado con los 5 c\u00f3digos postales m\u00e1s poblados (muestra los documentos completos).</li> <li>Cantidad de documentos que no tienen menos de 5.000 habitantes ni m\u00e1s de 1.000.000 (debes utilizar el operador <code>$nor</code>).</li> <li>Cuantos documentos tienen m\u00e1s habitantes que su propio c\u00f3digo postal (campo <code>zip</code>).</li> </ol> </li> <li>Sobre la colecci\u00f3n <code>posts</code> averigua:<ol> <li>Cuantos mensajes tienen las etiquetas <code>restaurant</code> o <code>moon</code>.</li> <li>Los comentarios que ha escrito el usuario <code>Salena Olmos</code>.</li> <li>Recupera los mensajes que en <code>body</code> contengan la palabra <code>earth</code>, y devuelve el t\u00edtulo, 3 comentarios y 5 etiquetas.</li> </ol> </li> </ol> </li> <li> <p>(RA5075.1 / CE5.1d / 2p) Escribe los comandos necesarios para realizar las siguientes operaciones sobre la colecci\u00f3n <code>zips</code>:</p> <ol> <li> <p>Crea una entrada con los siguientes datos:</p> <pre><code>{ city: 'ELX',\nzip: '03206',\nloc: {  x: 38.265500, y: -0.698459 },\npop: 230224,\nstate: 'Espa\u00f1a' }\n</code></pre> </li> <li> <p>Crea una entrada con los datos del c\u00f3digo postal donde vives (si es el mismo c\u00f3digo postal, crea uno diferente).</p> </li> <li>Modifica la poblaci\u00f3n de tu c\u00f3digo postal a <code>1.000.000</code>.</li> <li>Incrementa la poblaci\u00f3n de todas los documentos de <code>Espa\u00f1a</code> en 666 personas.</li> <li>A\u00f1ade un campo <code>prov</code> a ambos documentos con valor <code>Alicante</code>.</li> <li>Modifica los documentos de <code>Espa\u00f1a</code> y a\u00f1ade un atributo <code>tags</code> que contenga un array vac\u00edo.</li> <li>Modifica todos los documentos de la provincia de <code>Alicante</code> y a\u00f1ade al atributo <code>tags</code> el valor <code>sun</code>.</li> <li>Modifica el valor de <code>sun</code> de tu c\u00f3digo postal y sustit\u00fayelo por <code>house</code>.</li> <li>Renombra en los documentos de la provincia de <code>Alicante</code> el atributo <code>prov</code> por <code>provincia</code></li> <li>Elimina las coordenadas del zip <code>03206</code>.</li> <li>Elimina tu entrada.</li> </ol> </li> </ol>"},{"location":"sa/03modelado.html","title":"Modelado de datos NoSQL","text":"<p>Antes de estudiar c\u00f3mo modelar de forma adecuada nuestros datos en un modelo de datos documental, en concreto dentro de MongoDB, es conveniente recordar que:</p> <ul> <li>Mediante un documento podemos mantener toda la informaci\u00f3n que se utiliza junta en un \u00fanico documento, sin necesidad de separar los datos en diferentes colecciones.</li> <li>Las propiedades transaccionales ACID se cumplen a nivel de documento. Si tenemos la informaci\u00f3n separada en varios documentos, tenemos que utilizar el modelo transaccional de MongoDB de forma programativa.</li> </ul> <p>Dependiendo del tipo de relaci\u00f3n entre dos documentos, normalizaremos los datos para minimizar la redundancia pero manteniendo en la medida de lo posible que mediante operaciones at\u00f3micas se mantenga la integridad de los datos. Para ello, bien crearemos referencias entre dos documentos o embeberemos un documento dentro de otro, pero intentando que la informaci\u00f3n m\u00e1s utilizada quepa en un \u00fanico documento.</p> <p>MongoDB es una base de datos documental, no relacional, donde el esquema no se debe basar en el uso de claves ajenas/joins, ya que realmente no existen. A la hora de dise\u00f1ar un esquema, si nos encontramos que el esquema est\u00e1 en 3FN o si cuando hacemos consultas estamos teniendo que realizar varias consultas de manera programativa (primero acceder a una tabla, con ese <code>_id</code> ir a otra tabla, etc\u2026 o hacemos un uso extensivo del operador <code>$lookup</code> mediante el framework de agregaci\u00f3n.) es que no estamos siguiendo el enfoque adecuado.</p> <p>En resumen, dise\u00f1ar un buen modelo de datos puede suponer que nuestro c\u00f3digo sea m\u00e1s legible y mantenible, as\u00ed como un mayor rendimiento de nuestras aplicaciones.</p>"},{"location":"sa/03modelado.html#metodologia","title":"Metodolog\u00eda","text":"<p>A la hora de tomar decisiones sobre nuestro modelo, nuestra primera decisi\u00f3n es si vamos a modelar para obtener una mayor simplicidad del esquema o queremos un mejor rendimiento.</p> <p>Si nuestro equipo de desarrollo es peque\u00f1o o estamos desarrollando una \u00fanica aplicaci\u00f3n, nos decantaremos por la simplicidad cuando las consultas suelan ser siempre las mismas, pudiendo embeber la mayor\u00eda de entidades en un \u00fanico documento. En cambio, si nuestro equipo es grande, multiples aplicaciones realizan un gran n\u00famero de lecturas/escrituras, nos centraremos en el rendimiento, donde nos centraremos en el tama\u00f1o de los datos, la cantidad de las operaciones y su calificaci\u00f3n/importancia, y embebiendo o relacionando los documentos conforme sea mejor.</p> <p>Simplicidad vs Rendimiento</p> <p>Es m\u00e1s f\u00e1cil optimizar el c\u00f3digo de una aplicaci\u00f3n para obtener mejor rendimiento que simplificar el c\u00f3digo o el esquema de una aplicaci\u00f3n compleja. As\u00ed pues, en un principio, siempre hemos de apostar por la simplicidad.</p> <p>Desde MongoDB recomiendan seguir la siguiente metodolog\u00eda a la hora de definir nuestro modelo de datos, la cual han separado en tres fases:</p> Metodolog\u00eda de modelado de datos <ol> <li>Definir la carga (workload):<ul> <li>Comprender para qu\u00e9 operaciones estamos modelando.</li> <li>Cuantificar y calificar las operaciones de lectura y escritura.</li> <li>Listar las operaciones m\u00e1s importantes.</li> </ul> </li> <li>Modelar las relaciones<ul> <li>Las relaciones 1:1 normalmente se modelan con un documento embebido</li> <li>las relaciones 1:M y N:M mediante un array de documentos o referencias a documentos de otra colecci\u00f3n.</li> </ul> </li> <li>Reconocer y aplicar patrones de dise\u00f1o sobre el esquema<ul> <li>Realizar transformaciones sobre el esquema, que se centran en el rendimiento, mantenimiento o simplificaci\u00f3n de los requisitos.</li> </ul> </li> </ol> <p>Si cruzamos nuestra decisi\u00f3n de simplicidad/rendimiento con la metodolog\u00eda tenemos:</p> Objetivo Simplicidad Simplicidad y Rendimiento Rendimiento 1. Definir la carga Operaciones m\u00e1s frecuentes Mayor\u00eda de operacionesTama\u00f1o de los datosCantidad de operaciones Todas las operacionesTama\u00f1o de los datos Cantidad de operacionesCalificaci\u00f3n de las operaciones 2. Entidades y relaciones Embeber siempre que sea posible Embeber y relacionar Embeber y relacionar 3. Patrones de transformaci\u00f3n Patr\u00f3n A Patrones A y B Patrones A, B y C <p>A continuaci\u00f3n veremos cada una de estas fases en detalle.</p>"},{"location":"sa/03modelado.html#definir-la-carga","title":"Definir la carga","text":"<p>En esta primera fase es muy importante comprender para qu\u00e9 operaciones estamos modelando, para ello hemos medir los datos a almacenar, cuantificar y calificar las operaciones de lectura y escritura, as\u00ed como listar las operaciones m\u00e1s importantes, con m\u00e9tricas tipo operaciones por segundo, latencia requerida o atributos utilizados en las consultas.</p> <p>Para ello, partiremos de diferentes escenarios de uso de la aplicaci\u00f3n, los logs y estad\u00edsticas que tengamos disponibles o el conocimiento de los analistas de negocio.</p> <p>Dependiendo de la carga, puede provocar diferentes soluciones de modelado, ya que en unas pueden ser m\u00e1s importantes las lecturas y en otras las escrituras.</p> <p>Ejemplo de carga</p> <p>El siguiente ejemplo est\u00e1 extra\u00eddo del curso M320 de Modelado de datos de la MongoDB University.</p> <ul> <li>Caso de uso<ul> <li>Una organizaci\u00f3n ha desplegado 100.000.000 de sensores meteorol\u00f3gicos.</li> <li>El objeto es capturar en una base de datos los datos transmitidos de todos los dispositivos para realizar predicciones y analizar tendencias.</li> </ul> </li> <li>Datos principales<ul> <li>N\u00famero de dispositivos: 100.000.000</li> <li>Duraci\u00f3n: 10 a\u00f1os</li> <li>An\u00e1lisis: 10 a\u00f1os</li> </ul> </li> <li>Supuestos:<ul> <li>Para las predicciones, son igual de v\u00e1lidos los datos por hora que por minutos.</li> <li>Para an\u00e1lisis m\u00e1s profundos, es necesario mantener los datos por minutos. </li> </ul> </li> <li> <p>Operaciones:</p> Actor CRUD Datos en operaciones Tipo de operaci\u00f3n Ratio Informaci\u00f3n extra sensor env\u00edo de datos cada minuto <code>sensor_id</code>, m\u00e9tricas escritura 1.666.667 por seg se almacena una copia (no hace falta redundancia), 1000 bytes de datos le\u00eddos, tiempo de vida de 10 a\u00f1os sistema identificar sensores inoperativos <code>sensor_id</code>, tiempos de m\u00e9tricas lectura 1 por hora latencia y tiempo de consulta de 1 hora, mediante un full scan de los datos, los datos se renuevan cada hora sistema agregar datos cada hora <code>sensor_id</code>, m\u00e9tricas escritura 1 por hora redundancia en la mayor\u00eda de nodos, tiempo de vida de 10 a\u00f1os analista / cient\u00edfico de datos ejecutar 10 consultas anal\u00edticas por hora m\u00e9tricas de temperatura lectura 100 por hora (10 por hora por 10 analistas) latencia y tiempo de consulta de 10 minutos, mediante un full scan de los datos, los datos se renuevan cada hora </li> <li> <p>Operaci\u00f3n detallada:</p> <ul> <li>Actor: sensor</li> <li>Descripci\u00f3n: Env\u00edo de datos meteorol\u00f3gicos al servidor</li> <li>Tipo: escritura</li> <li>Datos: <code>sensor_id</code>, <code>timestamp</code>, m\u00e9tricas del sensor</li> <li>Frecuencia: 1.600.000 por seg === 100.000.000 por hora / 60</li> <li>Tama\u00f1o de datos: 1000 bytes</li> <li>Tiempo de vida: 10 a\u00f1os</li> <li>Duraci\u00f3n de los datos: 1 nodo, sin necesidad de redundancia</li> </ul> </li> </ul> <p>De este supuesto podemos deducir que la carga es mayoritariamente de escrituras (con un ratio de 99% de escrituras y 1% de lecturas), donde debemos en la medida de lo posible, reducirlas o agruparlas. Adem\u00e1s, la mayor\u00eda de lecturas requieren un full scan de los datos con baja latencia, de manera que podemos ejecutar esas consultas sobre nodos dedicados a la anal\u00edtica. La creaci\u00f3n de consultas agregadas o pre-calculadas puede acelerar estas consultas.</p>"},{"location":"sa/03modelado.html#modelar-las-relaciones","title":"Modelar las relaciones","text":"<p>Las aplicaciones que emplean MongoDB utilizan dos t\u00e9cnicas para relacionar documentos:</p> <ul> <li>Crear referencias</li> <li>Embeber documentos</li> </ul>"},{"location":"sa/03modelado.html#referencias-manuales","title":"Referencias manuales","text":"<p>De manera similar a una base de datos relacional, se almacena el campo <code>_id</code> de un documento en otro documento a modo de clave ajena. De este modo, la aplicaci\u00f3n realiza una segunda consulta para obtener los datos relacionados. Estas referencias son sencillas y suficientes para la mayor\u00eda de casos de uso.</p> Referencias manuales <p>Por ejemplo, si nos basamos en el gr\u00e1fico anterior, podemos conseguir referenciar manualmente estos objetos del siguiente modo:</p> <pre><code>var idUsuario = ObjectId();\ndb.usuario.insertOne({\n_id: idUsuario,\nnombre: \"123xyz\"\n});\ndb.contacto.insertOne({\nusuario_id: idUsuario,\ntelefono: \"123 456 7890\",\nemail: \"xyz@ejemplo.com\"\n});\n</code></pre> <p>Para relacionar los dos documentos, haremos uso de la operaci\u00f3n <code>$lookup</code> para hacer el join, o haremos una segunda consulta para la segunda colecci\u00f3n. Un ejemplo de join mediante <code>$lookup</code>:</p> <pre><code>db.usuario.aggregate([ {\n$lookup: {\nfrom: \"contacto\",\nlocalField: \"_id\",\nforeignField: \"usuario_id\",\nas: \"contacto_data\"\n}\n} ])\n</code></pre> <p>Y como resultado obtenemos un documento con el usuario y la informaci\u00f3n del contacto dentro de un array embebido (aunque en este ejemplo s\u00f3lo tenemos un contacto para el usuario)</p> <pre><code>{ _id: ObjectId(\"634589696e96ece54fbcbca2\"),\nnombre: '123xyz',\ncontacto_data: [ { _id: ObjectId(\"634589696e96ece54fbcbca3\"),\nusuario_id: ObjectId(\"634589696e96ece54fbcbca2\"),\ntelefono: '123 456 7890',\nemail: 'xyz@ejemplo.com' } ] }\n</code></pre> <p>El operador <code>$lookup</code> lo estudiaremos en profundidad en la siguiente sesi\u00f3n.</p>"},{"location":"sa/03modelado.html#dbref","title":"DBRef","text":"<p>Son referencias de un documento a otro mediante el valor del campo <code>_id</code>, el nombre de la colecci\u00f3n y, opcionalmente, el nombre de la base de datos. Estos objetos siguen una convenci\u00f3n para representar un documento mediante la notaci\u00f3n <code>{ \"$ref\" : &lt;nombreColeccion&gt;, \"$id\" : &lt;valorCampo_id&gt;, \"$db\" : &lt;nombreBaseDatos&gt; }</code>.</p> <p>Al incluir estos nombres, las DBRef permite referenciar documentos localizados en diferentes colecciones.</p> <p>As\u00ed pues, si reescribimos el c\u00f3digo anterior mediante DBRef tendr\u00edamos que el contacto lo insertamos de la siguiente manera:</p> <pre><code>db.contacto.insertOne({\nusuario_id: new DBRef(\"usuario\", idUsuario),\ntelefono: \"123-456-7890\",\nemail: \"xyz@example.com\"\n});\n</code></pre> <p>Y al recuperarlo, vemos que ha almacenado la referencia:</p> <pre><code>{\n_id: ObjectId(\"6345899d6e96ece54fbcbca4\"),\nusuario_id: DBRef(\"usuario\", ObjectId(\"634589696e96ece54fbcbca2\")),\ntelefono: '123-456-7890',\nemail: 'xyz@example.com' }\n}\n</code></pre> <p>De manera similar a las referencias manuales, mediante consultas adicionales se obtendr\u00e1n los documentos referenciados.</p> <p>Muchos drivers (incluido el de Python, mediante la clase DBRef) contienen m\u00e9todos auxiliares que realizan las consultas con referencias DBRef autom\u00e1ticamente.</p> <p>Evita DBRef</p> <p>Desde la propia documentaci\u00f3n de MongoDB recomiendan el uso de referencias manuales y el operador <code>$lookup</code>, a no ser que dispongamos documentos de una colecci\u00f3n que referencian a documentos que se encuentran en varias colecciones diferentes.</p>"},{"location":"sa/03modelado.html#datos-embebidos","title":"Datos embebidos","text":"<p>En cambio, si dentro de un documento almacenamos los datos mediante sub-documentos, ya sea dentro de un atributo o un array, podremos obtener todos los datos mediante un \u00fanico acceso, sin necesidad de claves ajenas ni comprobaciones de integridad referencial.</p> Datos embebidos <p>Generalmente, emplearemos datos embebidos cuando tengamos:</p> <ul> <li>relaciones \"contiene\" entre entidades, entre relaciones de documentos \"uno a uno\" o \"uno a pocos\".</li> <li>relaciones \"uno a muchos\" entre entidades. En estas relaciones los documentos hijo (o \"muchos\") siempre aparecen dentro del contexto del padre o del documento \"uno\".</li> </ul> <p>Los datos embebidos/incrustados ofrecen mejor rendimiento al permitir obtener los datos mediante una \u00fanica operaci\u00f3n, as\u00ed como modificar datos relacionados en una sola operaci\u00f3n at\u00f3mica de escritura (sin necesidad de transacciones)</p> <p>Un aspecto a tener en cuenta es que un documento BSON puede contener un m\u00e1ximo de 16MB. Si quisi\u00e9ramos que un atributo contenga m\u00e1s informaci\u00f3n, tendr\u00edamos que utilizar el API de GridFS.</p> <p>Vamos a estudiar en detalle cada uno de los tipos de relaciones, para intentar clarificar cuando es conveniente utilizar referencias o datos embebidos.</p>"},{"location":"sa/03modelado.html#relaciones-11","title":"Relaciones 1:1","text":"<p>Cuando existe una relaci\u00f3n 1:1, como pueda ser entre <code>Persona</code> y <code>Curriculum</code>, o <code>Persona</code> y <code>Direccion</code> hay que embeber un documento dentro del otro, como parte de un atributo:</p> persona.json<pre><code>{\nnombre: \"Aitor\",\nedad: 45,\ndireccion: {\ncalle: \"Secreta\",\nciudad: \"Elx\"\n}\n}\n</code></pre> <p>La principal ventaja de este planteamiento es que mediante una \u00fanica consulta podemos obtener tanto los detalles del usuario como su direcci\u00f3n.</p> <p>Un par de aspectos que nos pueden llevar a no embeberlos son:</p> <ul> <li>la frecuencia de acceso. Si a uno de ellos se accede raramente, puede que convenga tenerlos separados para liberar memoria.</li> <li>el tama\u00f1o de los elementos. Si hay uno que es mucho m\u00e1s grande que el otro, o uno lo modificamos muchas m\u00e1s veces que el otro, para que cada vez que hagamos un cambio en un documento no tengamos que modificar el otro ser\u00e1 mejor separarlos en documentos separados.</li> </ul> <p>Pero siempre teniendo en cuenta la atomicidad de los datos, ya que si necesitamos modificar los dos documentos al mismo tiempo, tendremos que embeber uno dentro del otro.</p>"},{"location":"sa/03modelado.html#relaciones-1n","title":"Relaciones 1:N","text":"<p>Vamos a distinguir dos tipos:</p> <ul> <li> <p>1 a pocos (1:F) (one to few), como por ejemplo, dentro de un blog, la relaci\u00f3n entre <code>Mensaje</code> y <code>Comentario</code>. En este caso, la mejor soluci\u00f3n es crear un array dentro de la entidad 1 (en nuestro caso, <code>Mensaje</code>). De este modo, el <code>Mensaje</code> contiene un array de <code>Comentario</code>:</p> mensaje.json<pre><code>{\ntitulo: \"La broma asesina\",\nurl: \"http://es.wikipedia.org/wiki/Batman:_The_Killing_Joke\",\ntexto: \"La dualidad de Batman y Joker\",\ncomentarios: [\n{\nautor: \"Bruce Wayne\",\nfecha: ISODate(\"2022-10-11T09:31:32Z\"),\ncomentario: \"A m\u00ed me encant\u00f3\"\n},\n{\nautor: \"Bruno D\u00edaz\",\nfecha: ISODate(\"2022-10-11T10:07:28Z\"),\ncomentario: \"El mejor\"\n}\n]\n}\n</code></pre> <p>Vigilar el tama\u00f1o</p> <p>Hay que tener siempre en mente la restricci\u00f3n de los 16 MB de BSON. Si vamos a embeber muchos documentos y estos son grandes, hay que vigilar no llegar a dicho tama\u00f1o.</p> </li> <li> <p>1 a muchos (1:N) (one to many), como puede ser entre <code>Editorial</code> y <code>Libro</code>. Para este tipo de relaci\u00f3n es mejor usar referencias entre los documentos colocando la referencia en el lado del muchos:</p> editorial.json<pre><code>{\n_id: 1,\nnombre: \"O'Reilly\",\npais: \"EE.UU.\"\n}\n</code></pre> libros.json<pre><code>{\n_id: 1234,\ntitulo: \"MongoDB: The Definitive Guide\",\nautor: [ \"Kristina Chodorow\", \"Mike Dirolf\" ],\nnumPaginas: 216,\neditorial_id: 1,\n},\n{\n_id: 1235,\ntitulo: \"50 Tips and Tricks for MongoDB Developer\",\nautor: \"Kristina Chodorow\",\nnumPaginas: 68,\neditorial_id: 1,\n}\n</code></pre> <p>Si cada vez que recuperamos un libro queremos tener el nombre de la editorial y con una sola consulta recuperar todos los datos, en vez poner la referencia a la editorial, podemos embeber toda la informaci\u00f3n (esto se conoce como el patr\u00f3n referencia extendida), a costa de que un futuro cambio en el nombre de la editorial conlleve modificar muchos libros:</p> libros2.json<pre><code>{\n_id: 1234,\ntitulo: \"MongoDB: The Definitive Guide\",\nautor: [ \"Kristina Chodorow\", \"Mike Dirolf\" ],\nnumPaginas: 216,\neditorial: {\n_id: 1,\nnombre: \"O'Reilly\",\npais: \"EE.UU.\"\n}\n},{\n_id: 1235,\ntitulo: \"50 Tips and Tricks for MongoDB Developer\",\nautor: \"Kristina Chodorow\",\nnumPaginas: 68,\neditorial: {\n_id: 1,\nnombre: \"O'Reilly\",\npais: \"EE.UU.\"\n}\n}\n</code></pre> <p>Un caso particular en las relaciones uno a muchos que se traducen en documentos embebidos es cuando la informaci\u00f3n que nos interesa tiene un valor concreto en un momento determinado. Por ejemplo, dentro de un pedido, el precio de los productos debe embeberse, ya que si en un futuro se modifica el precio de un producto determinado debido a una oferta, el pedido realizado no debe modificar su precio total.</p> <p>Del mismo modo, al almacenar la direcci\u00f3n de una persona, tambi\u00e9n es conveniente embeberla. No queremos que la direcci\u00f3n de env\u00edo de un pedido ya enviado se modifique si un usuario cambia sus datos personales.</p> <p>En cambio, si necesitamos acceder por separado a los diferentes objetos de una relaci\u00f3n, puede que nos convenga separarlo en dos colecciones distintas, aunque luego tengamos que hacer un join.</p> </li> <li> <p>1 a much\u00edsimos/tropecientos (1:S) (one to squillions/zillions), como puede ser entre una aplicaci\u00f3n y los mensajes del log, los cuales pueden llegar a tener un volumen de millones de mensaje por aplicaci\u00f3n. Teniendo siempre en mente la restricci\u00f3n de los 16MB de BSON, podemos modelar estas relaciones mediante un array de referencias:</p> aplicacion.json<pre><code>{\n_id: ObjectId(\"111111\"),\nnombre: \"Gesti\u00f3n de clientes\",\n}\n</code></pre> logs.json<pre><code>{\n_id: ObjectId(\"123456\"),\napp: ObjectId(\"111111\"),\nactividad: \"Alta Cliente\",\nmensaje: \"El cliente XXX se ha creado correctamente\"\ndate: ISODate(\"2022-10-12\")\n},{\n_id: ObjectId(\"123457\"),\napp: ObjectId(\"111111\"),\nactividad: \"Modificaci\u00f3n Cliente\",\nmensaje: \"No se ha podido modificar el XXX por un error del sistema\"\ndate: ISODate(\"2022-10-12\")\n},\n</code></pre> <p>De esta manera, pasamos la relaci\u00f3n de 1 a muchos a realmente ser de muchos a 1, donde cada mensaje de log almacena la aplicaci\u00f3n a la que pertenecen, y ya no tenemos que mantener un array de logs dentro de cada aplicaci\u00f3n.</p> </li> </ul>"},{"location":"sa/03modelado.html#relaciones-nm","title":"Relaciones N:M","text":"<p>M\u00e1s que relaciones muchos a muchos, suelen ser relaciones pocos a pocos, como por ejemplo, <code>Libro</code> y <code>Autor</code>, o <code>Profesor</code> y <code>Estudiante</code>.</p> <p>Supongamos que tenemos libros modelados de la siguiente manera:</p> libro.json<pre><code>{\n_id: 1,\ntitulo: \"La historia interminable\",\nanyo: 1979\n}\n</code></pre> <p>Y autores con la siguiente estructura:</p> autor.json<pre><code>{\n_id: 1,\nnombre: \"Michael Ende\",\npais: \"Alemania\"\n}\n</code></pre> <p>Podemos resolver esta relaci\u00f3n de tres maneras:</p> <ol> <li> <p>Siguiendo un enfoque relacional, empleando un documento como la entidad que agrupa con referencias manuales a los dos documentos.</p> libro-autor.json<pre><code>{\n_id: 1,\nautor_id: 1,\nlibro_id: 1\n}\n</code></pre> <p>Este enfoque se desaconseja porque necesita acceder a tres colecciones para obtener toda la informaci\u00f3n.</p> </li> <li> <p>Mediante 2 documentos, cada uno con un array que contenga los identificadores del otro documento (2 Way Embedding). Hay que tener cuidado porque podemos tener problemas de inconsistencia de datos si no actualizamos correctamente.</p> libro-con-autores.json<pre><code>{\n_id: 1,\ntitulo: \"La historia interminable\",\nanyo: 1979,\nautores: [1]\n},{\n_id: 2,\ntitulo: \"Momo\",\nanyo: 1973,\nautores: [1]\n}\n</code></pre> autor-con-libros.json<pre><code>{\n_id: 1,\nnombre: \"Michael Ende\",\npais: \"Alemania\",\nlibros: [1, 2]\n}\n</code></pre> </li> <li> <p>Embeber un documento dentro de otro (One Way Embedding). Por ejemplo:</p> libro-con-autores-embebidos.json<pre><code>{\n_id: 1,\ntitulo: \"La historia interminable\",\nanyo: 1979,\nautores: [{nombre:\"Michael Ende\", pais:\"Alemania\"}]\n},{\n_id: 2,\ntitulo: \"Momo\",\nanyo: 1973,\nautores: [{nombre:\"Michael Ende\", pais:\"Alemania\"}]\n}\n</code></pre> <p>En principio este enfoque no se recomienda porque el documento puede crecer mucho y provocar anomal\u00edas de modificaciones donde la informaci\u00f3n no es consistente. Si se opta por esta soluci\u00f3n, hay que tener en cuenta que si un documento depende de otro para su creaci\u00f3n (por ejemplo, si metemos los profesores dentro de los estudiantes, no vamos a poder dar de alta a profesores sin haber dado de alta previamente a un alumno).</p> <p>A modo de resumen, en las relaciones N:M, hay que establecer el tama\u00f1o de N y M. Si N como m\u00e1ximo vale 3 y M 500000, entonces deber\u00edamos seguir un enfoque de embeber la N dentro de la M (One Way Embedding).</p> <p>En cambio, si N vale 3 y M vale 5, entonces podemos hacer que ambos embeban al otro documento (Two Way Embedding).</p> </li> </ol> <p>Rendimiento e Integridad</p> <p>A modo de resumen, embeber documentos ofrece un mejor rendimiento que referenciar, ya que con una \u00fanica operaci\u00f3n (ya sea una lectura o una escritura) podemos acceder a varios documentos.</p> <p>Cuidado con los arrays</p> <p>Los array no pueden crecer de forma descontrolada. Si hay un par de cientos de documentos en el lado de N, no hay que embeberlos. Si hay m\u00e1s de unos pocos miles de documentos en el lado de N, no hay que usar un array de referencias. Arrays con una alta cardinalidad son una clara pista para no embeber.</p>"},{"location":"sa/03modelado.html#jerarquicas","title":"Jer\u00e1rquicas","text":"<p>Si tenemos que modelar alguna entidad que tenga hijos y nos importa las relaciones padre-hijos (categor\u00eda-subcategor\u00eda), podemos tanto embeber un array con los hijos de un documento (children), como embeber un array con los padres de un documento (ancestors)</p> <p>M\u00e1s informaci\u00f3n en https://www.mongodb.com/docs/manual/applications/data-models-tree-structures/</p>"},{"location":"sa/03modelado.html#patrones","title":"Patrones","text":"<p>Ahora que ya hemos estudiado como modelar las relaciones entre diferentes documentos, hay un conjunto de patrones, e igual de importante, anti-patrones, que nos pueden ayudar a la hora de dise\u00f1ar o migrar un sistema.</p> <p>Podemos agrupar los patrones en tres categor\u00edas:</p> <ul> <li>Representaci\u00f3n: atributo, versionado de documentos y esquema, polim\u00f3rfico</li> <li>Frecuencia de acceso: subconjuntos, aproximaci\u00f3n, referencia cruzada</li> <li>Agrupaci\u00f3n: calculado, cubo, at\u00edpico</li> </ul> Patrones y Casos de Uso - mongodb.com"},{"location":"sa/03modelado.html#representacion","title":"Representaci\u00f3n","text":"<p>Los patrones de representaci\u00f3n se centran en la representaci\u00f3n del esquema. Destacamos los patrones:</p> <ul> <li>Atributo</li> <li>Versionado de documento</li> <li>Versionado de esquema</li> <li>Polim\u00f3rfico</li> </ul>"},{"location":"sa/03modelado.html#atributo","title":"Atributo","text":"<p>El patr\u00f3n atributo / attribute se utiliza cuando tenemos un conjunto de valores separados entre varios campos que sem\u00e1nticamente est\u00e1n agrupados.</p> <p>Supongamos que tenemos un documento con informaci\u00f3n sobre el precio de un producto:</p> <pre><code>{\nproducto: \"ps5\",\nprecio_es: 549.99,\nprecio_uk: 479.99,\nprecio_us: 499.99\n}\n</code></pre> <p>Agrupamos los atributos en un campo <code>precios</code> (normalmente un array de documentos embebidos):</p> <pre><code>{\nproducto: \"ps5\",\nprecios: [\n{ pais: \"es\", precio: 549.99},\n{ pais: \"uk\", precio: 479.99},\n{ pais: \"us\", precio: 499.99},\n]\n}\n</code></pre> <p>Al a\u00f1adir un nuevo elemento, en vez de a\u00f1adir un nuevo campo al documento, crearemos un nuevo documento dentro del array.</p> <p>Adem\u00e1s, con este patr\u00f3n podr\u00edamos a\u00f1adir m\u00e1s informaci\u00f3n, como puede ser la moneda:</p> <pre><code>{\nproducto: \"ps5\",\nprecios: [\n{ pais: \"es\", precio: 549.99, moneda:\"eur\"},\n{ pais: \"uk\", precio: 479.99, moneda:\"pound\"},\n{ pais: \"us\", precio: 499.99, moneda:\"dollar\"},\n]\n}\n</code></pre> <p>Como ventaja, podemos destacar que esta soluci\u00f3n facilita la indexaci\u00f3n de los campos y que permite realizar la ordenaci\u00f3n de los datos por los campos embebidos.</p>"},{"location":"sa/03modelado.html#versionado-de-documentos","title":"Versionado de documentos","text":"<p>El patr\u00f3n versionado de documentos / document versioning se utiliza cuando necesitamos mantener diferentes versiones de un documento, por ejemplo, para mantener un hist\u00f3rico.</p> <p>En ese caso, podemos a\u00f1adir un atributo <code>revision</code>  (de manera similar a como lo hace git) a modo de un contador con las diferentes versiones de cada documento. Adem\u00e1s, tendremos dos colecciones, una con los datos hist\u00f3ricos, y otra con los \u00faltimos datos (y sobre la cual se suelen hacer las consultas).</p>"},{"location":"sa/03modelado.html#versionado-de-esquema","title":"Versionado de esquema","text":"<p>El patr\u00f3n versionado de esquema / schema versioning se utiliza cuando tenemos diferentes esquemas para un mismo documento, ya sea por una evoluci\u00f3n de nuestro modelo, por la integraci\u00f3n de datos externos, etc...</p> <p>Para ello, a\u00f1adiremos un atributo <code>schema_version</code> para indicar que versi\u00f3n del esquema cumplen los datos y poder identificar la estructura del documento con el que estamos trabajando. Adem\u00e1s, nos permite evitar el downtime al realizar la actualizaci\u00f3n del esquema facilitando la transici\u00f3n del esquema antiguo al nuevo.</p> <p>Supongamos que partimos del siguiente esquema para nuestros clientes:</p> cliente.json<pre><code>    _id: ObjectId(\"12345\"),\nnombre: \"Aitor Medrano\",\nemail: \"a.medrano@edu.gva.es\",\ntelefono: \"612 34 56 78\"\n</code></pre> <p>Y conforme evoluciona nuestra aplicaci\u00f3n vemos que vamos a\u00f1adiendo m\u00e1s y m\u00e1s m\u00e9todos de contacto, por lo que decidimos crear un documento embebido para agrupar funcionalmente dichos datos. Esta acci\u00f3n puede provocar accesos err\u00f3neos al tel\u00e9fono o al email, por lo que creamos el atributo <code>schema_version</code> para saber cu\u00e1l es la estructura que nuestra aplicaci\u00f3n espera leer:</p> cliente-esquema-v2.json<pre><code>    _id: ObjectId(\"12345\"),\nschema_version: 2,\nnombre: \"Aitor Medrano\",\ncontacto: {\nemail: \"a.medrano@edu.gva.es\",\ntelefono: \"612 34 56 78\", twitter: \"@aitormedrano\"\n}\n</code></pre>"},{"location":"sa/03modelado.html#polimorfico","title":"Polim\u00f3rfico","text":"<p>El patr\u00f3n polim\u00f3rfico / polymorphic se utiliza cuando tenemos un conjunto de documentos que tienen m\u00e1s similitudes que diferencias y necesitamos que est\u00e9n en una \u00fanica colecci\u00f3n.</p> <p>Supongamos que tenemos una base de datos sobre pel\u00edculas, y tenemos una colecci\u00f3n para los directores, otra para los actores/actrices, otra para los m\u00fasicos, etc... Claramente dichos documentos compartir\u00e1n muchos atributos, como son el nombre, la fecha de nacimiento, sexo, lugar de origen, etc... los cuales podemos colocar en la misma colecci\u00f3n a\u00f1adiendo un atributo <code>type</code> con el tipo del documento (por ejemplo, <code>actor</code>, <code>m\u00fasico</code>, <code>director</code>, etc...). Aquellos datos que son diferentes, los podemos colocar en subdocumentos para agrupar sus atributos de forma sem\u00e1ntica.</p> <p>Al agruparlos en una \u00fanica colecci\u00f3n, adem\u00e1s de ser m\u00e1s f\u00e1cil de implementar, permite unificar las consultas en una \u00fanica colecci\u00f3n.</p>"},{"location":"sa/03modelado.html#frecuencia-de-acceso","title":"Frecuencia de acceso","text":"<p>Son los patrones que debemos utilizar cuando los casos de uso hagan lecturas de forma intensiva, destacando los patrones:</p> <ul> <li>Subconjunto</li> <li>Aproximaci\u00f3n</li> <li>Referencia cruzada</li> </ul>"},{"location":"sa/03modelado.html#subconjunto","title":"Subconjunto","text":"<p>El patr\u00f3n subconjunto / subset se utiliza cuando tenemos documentos muy grandes, con muchos atributos y que contienen colecciones de muchos documentos que normalmente no se necesitan al recuperar un documento.</p> <p>Es decir, tenemos documentos de los cuales s\u00f3lo necesitamos un subconjunto de sus datos. Al aplicar este patr\u00f3n, creamos dos colecciones, una con los datos originales, y otra los atributos m\u00e1s utilizados, relacionando ambas colecciones mediante un atributo que cree una relaci\u00f3n 1:1.</p> <p>Si retomamos el ejemplo de la base de datos de pel\u00edcula, al entrar en una pel\u00edcula normalmente no recuperaremos toda la informaci\u00f3n de la misma ni el listado completo de actores y dem\u00e1s personal que haya trabajado en la misma. Probablemente, con una peque\u00f1a sinopsis, el director y los tres o cuatro actores/actrices principales sea suficiente, lo que conllevar\u00e1 consultas m\u00e1s r\u00e1pidas y menos tiempo de respuesta al transmitir menos informaci\u00f3n.</p>"},{"location":"sa/03modelado.html#aproximacion","title":"Aproximaci\u00f3n","text":"<p>El patr\u00f3n aproximaci\u00f3n / approximation se utiliza cuando tenemos una aplicaci\u00f3n que realiza much\u00edsimas escrituras y la exactitud en el resultado no es prioritario.</p> <p>Por ejemplo, si necesitamos almacenar la cantidad de visitas a una p\u00e1gina web, o la poblaci\u00f3n de una determinada ciudad, con un valor aproximado de los datos puede ser suficiente. En vez de realizar una operaci\u00f3n de inserci\u00f3n/modificaci\u00f3n con cada visita, la aplicaci\u00f3n cliente puede ir acumulando las operaciones y comnunicarse con la base de datos cada 100 operaciones, lo que supone ahorrarnos 99 operaciones.</p> <p>La aplicaci\u00f3n cliente puede utilizar un contador para ir contando las operaciones y al llegar a 100 realizar una modificaci\u00f3n o, en vez de un contador, llamar a una funci\u00f3n que devuelva un numero aleatorio entre 0 y 100, el cual devolver\u00e1 0 alrededor del 1% de las veces, de manera que al cumplirse la condici\u00f3n, realicemos la operaci\u00f3n de modificaci\u00f3n.</p> <p>De esta manera, conseguiremos realizar menos escrituras y mantener ciertos valores estad\u00edsticos v\u00e1lidos. En contra, no tendremos el valor exacto y la implementaci\u00f3n se debe realizar en el cliente.</p>"},{"location":"sa/03modelado.html#referencia-extendida","title":"Referencia extendida","text":"<p>El patr\u00f3n referencia extendida / extended reference se utiliza cuando vemos que realizamos muchos join para obtener toda la informaci\u00f3n a la que la aplicaci\u00f3n suele acceder.</p> <p>Para ello, duplicaremos los datos de los documentos referenciados.</p> <p>Aunque ya vimos un ejemplo de este patr\u00f3n en las relaciones 1:N, supongamos que tenemos una colecci\u00f3n de pedidos que referencia al cliente que realiza la compra:</p> pedidos.json<pre><code>{\n_id: ObjectId(\"12345\"),\nfecha: ISODate(\"2022-10-13T17:41:33Z\"),\ncliente_id: ObjectId(\"112233\"),\npedido: {\nproducto: \"ps5\",\ncantidad: 1,\nprecio: 499\n}\n}\n</code></pre> <p>Y otra colecci\u00f3n de clientes con los datos del comprador:</p> clientes.json<pre><code>{\n_id: ObjectId(\"12345\"),\nnombre: \"Aitor Medrano\",\ncalle: \"Secreta\",\nciudad: \"Elx\",\ncategoria: \"Platino\",\ncontacto: [\n{\ntipo: \"email\",\nvalor: \"a.medrano@edu.gva.es\"\n},     {\ntipo: \"telefono\",\nvalor: \"612 345 678\"\n} ]\n}\n</code></pre> <p>Si cada vez que recuperamos un pedido nos interesa el nombre y la direcci\u00f3n de la persona que lo realiza, vamos a necesitar siempre un join. El patr\u00f3n referencia extendida se traduce en duplicar los datos aunque haya redundancia para evitar dicho join:</p> pedidos-extendido.json<pre><code>{\n_id: ObjectId(\"12345\"),\nfecha: ISODate(\"2022-10-13T17:41:33Z\"),\ncliente: {\n_id: ObjectId(\"112233\"),\nnombre: \"Aitor Medrano\",\ncalle: \"Secreta\",\nciudad: \"Elx\"\n}\npedido: {\nproducto: \"ps5\",\ncantidad: 1,\nprecio: 499\n}\n}\n</code></pre>"},{"location":"sa/03modelado.html#agrupacion","title":"Agrupaci\u00f3n","text":"<p>Los patrones de agrupaci\u00f3n se utilizan para escalar el esquema de manera r\u00e1pida y de forma eficiente. Se utilizan para aplicaciones que hacen muchas m\u00e1s lecturas que escrituras, destacando los patrones:</p> <ul> <li>Calculado</li> <li>Cubo</li> <li>At\u00edpico</li> </ul>"},{"location":"sa/03modelado.html#calculado","title":"Calculado","text":"<p>El patr\u00f3n calculado / computed se utiliza cuando queremos evitar tener que recalcular datos en cada lectura. Para ello, en una colecci\u00f3n aparte se guardan los datos calculados, de manera que cuando llega un nuevo registro a la colecci\u00f3n con los datos, se recalcula este valor y se modifica el documento oportuno en la colecci\u00f3n de datos calculados.</p> Patr\u00f3n calculado - mongodb.com <p>Este patr\u00f3n tiene sentido en aplicaciones donde hay muchas m\u00e1s lecturas que escrituras, ya que el c\u00e1lculo se realiza en tiempo de escritura.</p>"},{"location":"sa/03modelado.html#cubo","title":"Cubo","text":"<p>Cuando trabajamos con IoT, anal\u00edtica de datos, o series temporales es normal crear una colecci\u00f3n con un documento por cada medida que se tome.</p> sensor.json<pre><code>{\nsensor_id: 12345,\ntimestamp: ISODate(\"2022-01-31T10:00:00.000Z\"),\ntemp: 40\n},\n{\nsensor_id: 12345,\ntimestamp: ISODate(\"2022-01-31T10:01:00.000Z\"),\ntemp: 40\n},\n</code></pre> <p>Para evitar la creaci\u00f3n de \u00edndices que ocupen much\u00edsima memoria RAM, mediante el patr\u00f3n cubo / bucket crearemos un array de documentos con cada medida y un resumen con los datos agregados:</p> sensor-cubo.json<pre><code>{\nsensor_id: 12345,\nfecha_inicio: ISODate(\"2022-01-31T10:00:00.000Z\"),\nfecha_fin: ISODate(\"2022-01-31T10:59:59.000Z\"),\nmedidas: [\n{\ntimestamp: ISODate(\"2022-01-31T10:00:00.000Z\"),\ntemp: 40\n},\n{\ntimestamp: ISODate(\"2022-01-31T10:01:00.000Z\"),\ntemp: 40\n}\n],\ncantidad: 2,\nsuma: 80\n}\n</code></pre> <p>Estos documentos los podemos agrupar por horas, d\u00edas, etc... lo cuales podemos colocar en colecciones con datos trimestrales, anuales, etc... De esta manera, nos facilita el almacenamiento, an\u00e1lisis y purga de los datos dentro de los requisitos temporales de nuestras aplicaciones.</p>"},{"location":"sa/03modelado.html#atipico","title":"At\u00edpico","text":"<p>El patr\u00f3n at\u00edpico / outlier se utiliza cuando tenemos datos que son at\u00edpicos, es decir, que se salen del rango normal de comportamiento de la aplicaci\u00f3n.</p> <p>Supongamos que tenemos una aplicaci\u00f3n de cine donde marcamos en una lista las pel\u00edculas que queremos ver (whistlist), y suponemos que los usuarios colocar\u00e1n dentro de dicho array un m\u00e1ximo de 100 pel\u00edculas. \u00bfQu\u00e9 sucede si un usuario quiere a\u00f1adir 1000 pel\u00edculas? Ese usuario es un caso at\u00edpico, y en vez de cambiar todo el modelo de datos por \u00e9l, se crea una excepci\u00f3n mediante el patr\u00f3n at\u00edpico.</p> <p>Para ello, podemos a\u00f1adir un atributo al documento, al que podemos llamar <code>outlier</code> que marcaremos a <code>true</code> cuando necesitemos acceder a otra colecci\u00f3n para recuperar las pel\u00edculas favoritas que le faltan al usuario.</p> <p>Con una primera consulta, si vemos que tenemos un <code>outlier</code>, desde la aplicaci\u00f3n haremos el join para recuperar el resto de datos.</p> <p>Otros patrones</p> <ul> <li>Patr\u00f3n \u00c1rbol / Tree: Para la representaci\u00f3n de datos jer\u00e1rquicos y evitar joins a la hora de hacer consultas, incluyendo la referencia de hijos, padres, array de ancestors, etc...</li> <li>Patr\u00f3n Preasignaci\u00f3n / Pre-Allocation: El cual plantea una definici\u00f3n inicial de una estructura de datos para simplificar posteriormente su uso. Este patr\u00f3n era m\u00e1s necesario en versiones antiguas de MongoDB, cuando gestionaba la memoria de forma menos eficiente que las versiones actuales. </li> </ul>"},{"location":"sa/03modelado.html#validacion-de-esquemas","title":"Validaci\u00f3n de esquemas","text":"<p>Aunque los esquemas son din\u00e1micos y podemos a\u00f1adir nuevos campos conforme evoluciona nuestro modelo, podemos validar los esquemas para:</p> <ul> <li>asegurar la existencia de un campo.</li> <li>asegurar que un campo est\u00e1 rellenado (no nulo).</li> <li>asegurar el tipo de datos de un campo.</li> <li>restringir entre un conjunto de valores.</li> </ul> <p>Desde la versi\u00f3n 3.6 de MongoDB, podemos utilizar el operador <code>$jsonSchema</code> para validar los documentos.</p> <p>Para ello, definimos un documento con, al menos, las propiedades:</p> <ul> <li><code>required</code>: indica los campos obligatorios</li> <li><code>properties</code>: define los nombres de los campos y sus tipos (mediante la propiedad <code>bsonType</code>).</li> </ul> <p>Por ejemplo, vamos a basarnos en un documento que vimos en la sesi\u00f3n anterior:</p> <pre><code>yo = {\n_id: ObjectId(\"631704a042aae0893122f2d6\"),\nnombre: 'Aitor',\napellidos: 'Medrano',\nfnac: ISODate(\"1977-10-03T00:00:00.000Z\"),\nhobbies: [ 'programaci\u00f3n', 'videojuegos', 'baloncesto' ],\ncasado: true,\nhijos: 2,  contacto: { twitter: '@aitormedrano', email: 'a.medrano@edu.gva.es' },\nfechaCreacion: Timestamp({ t: 1662452896, i: 1 })\n}\n</code></pre> <p>Podr\u00edamos definir su validador de la siguiente manera:</p> <pre><code>validador = {\nvalidator: {  $jsonSchema: {\nrequired: [ \"nombre\", \"fnac\", \"contacto\"],\nproperties: {\nnombre: {\nbsonType: \"string\",\ndescription: \"debe ser un string y es un campo obligatorio\"\n},\napellidos: {\nbsonType: \"string\"\n},\nfnac: {\nbsonType: \"date\"\n},\nhobbies: {\nbsonType: \"array\",\nuniqueItems: true,\nitems: {\nbsonType: \"string\",\n}\n},\ncasado: {\nbsonType: \"bool\"\n},\nhijos: {\nbsonType: \"int\",\nminimum: 0,\nmaximum: 49,\ndescription: \"la cantidad de hijos debe ser positiva e inferior a 50\"\n},\ncontacto: {\nbsonType: \"object\",\nrequired: [ \"email\" ],\nproperties: {\n\"twitter\": { bsonType: \"string\" },\n\"email\": { bsonType: \"string\" }\n}\n}, fechaCreacion: {\nbsonType: \"timestamp\"\n}\n}\n}\n}\n}\ndb.createCollection(\"personas\", validador)\n</code></pre> <p>De manera, que si ahora insertamos la persona, no tendremos ning\u00fan error. Vamos a crear una nueva persona que no cumpla la validaci\u00f3n:</p> <pre><code>mal = {\nnombre: 'Usuario mal',\nhijos: 333,  contacto: { twitter: '@usuario_mal'}\n}\ndb.personas.insertOne(mal)\n</code></pre> <p>Y recibiremos un error de validaci\u00f3n describiendo los errores encontrado:</p> <pre><code>MongoServerError: Document failed validation\nAdditional information:\n{ failingDocumentId: {},\ndetails: { operatorName: '$jsonSchema',\nschemaRulesNotSatisfied: [ { operatorName: 'properties',\npropertiesNotSatisfied: [ { propertyName: 'hijos',\ndetails: [ { operatorName: 'maximum',\nspecifiedAs: { maximum: 49 },\nreason: 'comparison failed',\nconsideredValue: 333 } ] },\n{ propertyName: 'contacto',\ndetails: [ { operatorName: 'required',\nspecifiedAs: { required: [ 'email' ] },\nmissingProperties: [ 'email' ] } ] } ] },\n{ operatorName: 'required',\nspecifiedAs: { required: [ 'nombre', 'fnac', 'contacto' ] },\nmissingProperties: [ 'fnac' ] } ] } }\n</code></pre> <p>Expresiones de validaci\u00f3n</p> <p>Tambi\u00e9n podemos a\u00f1adir expresiones de validaci\u00f3n entre campos, de manera que el valor de un campo depende del valor de otro:</p> <pre><code>db.createCollection{ \"ventas\", {\nvalidator: {\n\"$and\": [         { // Mediante expresiones de consultas\n\"$expr\": {\n\"$lt\": [\"$lineaPedido.precioConDescuento\", \"$lineaPedido.precio\"]\n}\n},\n{ // Mediante el esquema JSON                    \n\"$jsonSchema\": {\n\"properties\": {\n\"productos\": { \"bsonType\": \"array\" }\n}\n}\n}\n]\n}\n}\n</code></pre> <p>Si queremos a\u00f1adir una validaci\u00f3n a una colecci\u00f3n ya existente, podemos hacer uso del comando <code>collMod</code>:</p> <pre><code>db.runCommand(\"collMod\": &lt;nombreColeccion&gt;, \"validator\": &lt;esquemaValidador&gt;)\n</code></pre> <p>M\u00e1s informaci\u00f3n sobre la validaci\u00f3n de esquemas en https://www.mongodb.com/docs/manual/core/schema-validation/ y en https://www.digitalocean.com/community/tutorials/how-to-use-schema-validation-in-mongodb</p> <p>Consejo final</p> <p>Independientemente de la carga, la manera que modelemos las relaciones y los patrones que apliquemos, lo m\u00e1s importante es que el modelado va a depender directamente de la forma que nuestras aplicaciones accedan a los datos. Por ello es tan importante definir primero los casos de uso/historias de usuario que van provocar el acceso a los datos.</p>"},{"location":"sa/03modelado.html#referencias","title":"Referencias","text":"<ul> <li>Curso M320: Data Modeling de la MongoDB University</li> <li>V\u00eddeo A Complete Methodology of Data Modeling for MongoDB</li> <li>New Cardinality Notations and Styles for Modeling NoSQL Document-store Databases</li> <li>MongoDB Schema Design Best Practices</li> <li>6 Rules of Thumb for MongoDB Schema Design</li> <li>Performance Best Practices: MongoDB Data Modeling and Memory Sizing</li> </ul>"},{"location":"sa/03modelado.html#actividades","title":"Actividades","text":"<ol> <li> <p>(RA5075.1 / CE5.1a / 3p) Define el modelo de datos necesario para modelar al aplicaci\u00f3n de captura de datos del PIA Lara:</p> <ul> <li>Debes tener en cuenta la gesti\u00f3n de los usuarios, los cuales pueden ser los usuarios finales (clientes), los t\u00e9cnicos de asistencia (t\u00e9cnicos), as\u00ed como los usuarios administradores de la aplicaci\u00f3n.</li> <li>De los clientes, adem\u00e1s del nombre completo, sexo y la fecha de nacimiento, registraremos su enfermedad (puede que con subcategor\u00edas), as\u00ed como su patolog\u00eda/disfon\u00eda (\u00bfcon una descripci\u00f3n?), y otros datos que consideres oportunos.</li> <li>Un cliente va a grabar muchas muestras de audios, y adem\u00e1s del audio (el cual almacenaremos en un sistema externo y del cual en nuestra base de datos NoSQL almacenaremos su ruta/id), guardaremos la fecha de la grabaci\u00f3n, usuario, texto, \u00bfestado de \u00e1nimo del cliente?, \u00bfvelocidad de grabaci\u00f3n? ... (aqu\u00ed deber\u00e9is pensar en todos los datos que necesitemos para un mejor etiquetado de los datos).</li> <li>Los textos de grabaci\u00f3n (sylabus) pueden estar predefinidos, de manera que desde el administrador o el t\u00e9cnico se d\u00e9n de alta, o que cada cliente/t\u00e9cnico los inserte en el momento de grabar el audio. Todos los textos se agrupar\u00e1n por categor\u00eda, y cada texto/frase, puede tener un n\u00famero de orden, as\u00ed como un estado de \u00e1nimo.</li> <li>Los listados que luego necesitaremos para recuperar los datos son:<ul> <li>Cliente de una determinada enfermedad/patolog\u00eda, pudiendo segmentar por rangos de edad y sexo.</li> <li>Audios y datos de las muestras de un determinado cliente.</li> <li>Audios y datos de las muestras de una determinada enfermedad.</li> <li>Audios y datos de las muestras de una determinada patolog\u00eda.</li> <li>Textos predefinidos de una categor\u00eda asignados a un cliente.</li> </ul> </li> </ul> <p>Recuerda</p> <p>Para luego realizar un buen modelo de IA, los datos en su mayor\u00eda deber\u00edan ser num\u00e9ricos. Los datos categ\u00f3ricos sirven para matizar y/o filtrar los datos, y si son un conjunto cerrado, luego se pueden codificar como n\u00fameros, por ejemplo mediante el patr\u00f3n One Hot Encoding.</p> <p>Para ello, primero define la carga del modelo y a continuaci\u00f3n, crea diferentes colecciones/documentos JSON con datos de muestra as\u00ed como validadores para cada una de las colecciones que necesites.</p> </li> <li> <p>(RA5075.1 / CE5.1a / 1p) Nuestro ayuntamiento est\u00e1 dise\u00f1ando un plan energ\u00e9tico para fomentar la instalaci\u00f3n de placas solares. Aquellos viviendas que se sit\u00faen en barrios que generan m\u00e1s energ\u00eda de la que consumen recibir\u00e1n un bono econ\u00f3mico por el exceso de energ\u00eda.</p> <p>Nuestra base de datos almacena, para cada vivienda, cuanta energ\u00eda produce por hora (en kW), cuanta consume, y cuanta necesita consumir de la red el\u00e9ctrica. Un dato de una muestra de energ\u00eda ser\u00eda:</p> energia.json<pre><code>{\n\"_id\": ObjectId(\"6316fc1597eb703de2add36e\"),\n\"propietario_id\": ObjectId(\"6317048697eb703de2add36f\"),\n\"date\": ISODate(\"2022-10-26T13:01:00.000Z\"),\n\"kW hora\": {\n\"consumo\": 11,\n\"generado\": 6,\n\"necesidad-red\": 5\n}\n}\n</code></pre> <p>Y los datos de un propietario:</p> cliente.json<pre><code>{\n\"_id\": ObjectId(\"6317048697eb703de2add36f\"),\n\"nombre\": \"Aitor Medrano\",\n\"direccion\": {\n\"calle\": \"Secreta\",\n\"numero\": \"123\",\n\"ciudad\": \"Elche\",\n\"barrio\": \"Carr\u00fas\",\n\"provincia\": \"Alicante\",\n\"cp\": \"03206\"\n}\n}\n</code></pre> <p>Refactoriza el documento/colecci\u00f3n aplicando los patrones que consideres necesarios, explicando cada uno de los patrones que hayas empleado, con el objetivo de recuperar para cada d\u00eda, la medidas acumuladas para un determinado barrio.</p> </li> </ol>"},{"location":"sa/05agregaciones.html","title":"Framework de agregaci\u00f3n en MongoDB","text":"<p>Para poder agrupar datos y realizar c\u00e1lculos sobre \u00e9stos, MongoDB ofrece diferentes alternativas:</p> <ol> <li> <p>Mediante operaciones Map-reduce con la operaci\u00f3n <code>mapreduce()</code> cuyo uso est\u00e1 deprecated desde MongoBD 5.0.</p> </li> <li> <p>Mediante el uso conjunto de <code>$function</code> y <code>$accumulator</code> que permiten definir expresiones de agregaci\u00f3n mediante JavaScript.</p> </li> <li> <p>Mediante operaciones de agrupaci\u00f3n sencilla, como pueden ser las operaciones <code>count()</code> o <code>distinct()</code>.</p> </li> <li> <p>Mediante el uso del Aggregation Framework, basado en el uso de pipelines, el cual permite realizar diversas operaciones sobre los datos. Este framework es el mecanismo m\u00e1s eficiente y usable para la realizaci\u00f3n de agregaciones, y por tanto, en el que nos vamos a centrar en esta sesi\u00f3n.</p> <p>Para ello, a partir de una colecci\u00f3n, mediante el m\u00e9todo <code>aggregate</code> le pasaremos un array con las fases a realizar:</p> <pre><code>db.productos.aggregate([\n{$group:\n{_id:\"$fabricante\", numProductos:{$sum:1}}\n},\n{$sort: {numProductos:-1}}\n])\n</code></pre> </li> </ol>"},{"location":"sa/05agregaciones.html#pipeline-de-agregacion","title":"Pipeline de agregaci\u00f3n","text":"<p>Las agregaciones usan un pipeline, conocido como Aggregation Pipeline, de ah\u00ed el uso de un array con <code>[ ]</code> donde cada elemento es una fase del pipeline, de modo que la salida de una fase es la entrada de la siguiente:</p> <pre><code>db.coleccion.aggregate([op1, op2, ... opN])\n</code></pre> <p>Cuidado con el tama\u00f1o</p> <p>El resultado del pipeline es un documento y por lo tanto est\u00e1 sujeto a la restricci\u00f3n de BSON, que limita su tama\u00f1o a 16MB.</p> <p>En la siguiente imagen se resumen los pasos de una agrupaci\u00f3n donde primero se eligen los elementos que vamos a agrupar mediante <code>$match</code>, el resultado saliente se agrupan con <code>$group</code>, y sobre los agrupado mediante <code>$sum</code> se calcula el total:</p> Ejemplo de pipeline con $match y $group <p>Al realizar un pipeline dividimos las consultas en fases, donde cada fase utiliza un operador para realizar una transformaci\u00f3n. Aunque no hay l\u00edmite en el n\u00famero de fases en una consulta, es importante destacar que el orden importa, y que hay optimizaciones para ayudar a que el pipeline tenga un mejor rendimiento (por ejemplo, hacer un <code>$match</code> al principio para reducir la cantidad de datos)</p>"},{"location":"sa/05agregaciones.html#operadores-del-pipeline","title":"Operadores del pipeline","text":"<p>Antes de nada destacar que las fases se pueden repetir, por lo que una consulta puede repetir operadores.</p> <p>A continuaci\u00f3n vamos a estudiar todos estos operadores:</p> Operador Descripci\u00f3n Cardinalidad $project Proyecci\u00f3n de campos, es decir, propiedades en las que estamos interesados. Tambi\u00e9n nos permite modificar un documento, o crear un subdocumento (reshape) 1:1 $match Filtrado de campos, similar a where N:1 $group Para agrupar los datos, similar a group by N:1 $sort Ordenar 1:1 $skip Saltar N:1 $limit Limitar los resultados N:1 $unwind Separa los datos que hay dentro de un array 1:N <p>Preparando los ejemplos</p> <p>Para los siguientes ejemplos, vamos a utilizar una colecci\u00f3n de productos (productos.js) de un tienda de electr\u00f3nica con las caracter\u00edsticas y precios de los mismos.</p> <p>Un ejemplo de un producto ser\u00eda:</p> <pre><code>&gt; db.productos.findOne()\n{\n\"_id\" : ObjectId(\"5345afc1176f38ea4eda4787\"),\n\"nombre\" : \"iPad 16GB Wifi\",\n\"fabricante\" : \"Apple\",\n\"categoria\" : \"Tablets\",\n\"precio\" : 499\n}\n</code></pre> <p>Para cargar este archivo desde la consola nos podemos conectar a nuestro cluster y realizar la carga:</p> <pre><code>mongosh mongodb+srv://iabd:iabdiabd@cluster0.dfaz5er.mongodb.net/iabd &lt; productos.js\n</code></pre> <p>O si ya nos hemos conectado previamente:</p> <pre><code>load(\"productos.js\")\n</code></pre>"},{"location":"sa/05agregaciones.html#group","title":"$group","text":"<p>La fase <code>group</code> agrupa los documentos con el prop\u00f3sito de calcular valores agregados de una colecci\u00f3n de documentos. Por ejemplo, podemos usar <code>$group</code> para calcular la media de p\u00e1ginas visitas de manera diaria.</p> <p>Cuidado</p> <p>La salida de <code>$group</code> esta desordenada</p> <p>La salida de <code>$group</code> depende de c\u00f3mo se definan los grupos. Se empieza especificando un identificador (por ejemplo, un campo <code>_id</code>) para el grupo que creamos con el pipeline. Para este campo <code>_id</code>, podemos especificar varias expresiones, incluyendo un \u00fanico campo proveniente de un documento del pipeline, un valor calculado de una fase anterior, un documento con muchos campos y otras expresiones v\u00e1lidas, tales como constantes o campos de subdocumentos. Tambi\u00e9n podemos usar operadores de <code>$project</code> para el campo <code>_id</code>.</p> <p>Cuando referenciemos al valor de un campo lo haremos poniendo entre comillas un <code>$</code> delante del nombre del campo. As\u00ed pues, para referenciar al fabricante de un producto lo haremos mediante <code>$fabricante</code>.</p> <pre><code>&gt; db.productos.aggregate([\n{ $group: {\n_id: \"$fabricante\",\ntotal: { $sum:1 }\n}\n}])\n&lt; { _id: 'Apple', total: 4 }\n{ _id: 'Samsung', total: 2 }\n{ _id: 'Sony', total: 1 }\n{ _id: 'Google', total: 1 }\n{ _id: 'Amazon', total: 2 }\n</code></pre> <p>Si lo que queremos es que el valor del identificador contenga un objeto, lo podemos hacer asociandolo como valor:</p> <pre><code>&gt; db.productos.aggregate([\n{ $group: {\n_id: { \"empresa\": \"$fabricante\" },\ntotal: { $sum:1 }\n}\n}])\n&lt;\n{ _id: { empresa: 'Sony' }, total: 1 }\n{ _id: { empresa: 'Apple' }, total: 4 }\n{ _id: { empresa: 'Google' }, total: 1 }\n{ _id: { empresa: 'Samsung' }, total: 2 }\n{ _id: { empresa: 'Amazon' }, total: 2 }\n</code></pre> <p>Tambi\u00e9n podemos agrupar m\u00e1s de un atributo, de tal modo que tengamos un <code>_id</code> compuesto. Por ejemplo:</p> <pre><code>&gt; db.productos.aggregate([\n{ $group: {\n_id: {\n\"empresa\": \"$fabricante\",\n\"tipo\": \"$categoria\" },\ntotal: {$sum:1}\n}\n}])\n&lt; { _id: { empresa: 'Apple', tipo: 'Tablets' }, total: 3 }\n{ _id: { empresa: 'Sony', tipo: 'Port\u00e1tiles' }, total: 1 }\n{ _id: { empresa: 'Apple', tipo: 'Port\u00e1tiles' }, total: 1 }\n{ _id: { empresa: 'Samsung', tipo: 'Smartphones' }, total: 1 }\n{ _id: { empresa: 'Amazon', tipo: 'Tablets' }, total: 2 }\n{ _id: { empresa: 'Google', tipo: 'Tablets' }, total: 1 }\n{ _id: { empresa: 'Samsung', tipo: 'Tablets' }, total: 1 }\n</code></pre> <p>Siempre <code>_id</code></p> <p>Cada expresi\u00f3n de <code>$group</code> debe especificar un campo <code>_id</code>.</p>"},{"location":"sa/05agregaciones.html#acumuladores","title":"Acumuladores","text":"<p>Adem\u00e1s del campo <code>_id</code>, la expresi\u00f3n <code>$group</code> puede incluir campos calculados. Estos otros campos deben utilizar uno de los siguientes acumuladores.</p> Nombre Descripci\u00f3n <code>$addToSet</code> Devuelve un array con todos los valores \u00fanicos para los campos seleccionados entre cada documento del grupo (sin repeticiones) <code>$first</code> Devuelve el primer valor del grupo. Se suele usar despu\u00e9s de ordenar. <code>$last</code> Devuelve el \u00faltimo valor del grupo. Se suele usar despu\u00e9s de ordenar. <code>$max</code> Devuelve el mayor valor de un grupo <code>$min</code> Devuelve el menor valor de un grupo. <code>$avg</code> Devuelve el promedio de todos los valores de un grupo <code>$push</code> Devuelve un array con todos los valores del campo seleccionado entre cada documento del grupo (puede haber repeticiones) <code>$sum</code> Devuelve la suma de todos los valores del grupo <p>A continuaci\u00f3n vamos a ver ejemplos de cada uno de estos acumuladores.</p>"},{"location":"sa/05agregaciones.html#sum","title":"$sum","text":"<p>El operador <code>$sum</code> acumula los valores y devuelve la suma.</p> <p>Por ejemplo, para obtener el montante total de los productos agrupados por fabricante, har\u00edamos:</p> <pre><code>&gt; db.productos.aggregate([{\n$group: {\n_id: {\n\"empresa\": \"$fabricante\"\n},\ntotalPrecio: {$sum:\"$precio\"}\n}\n}])\n&lt; { _id: { empresa: 'Apple' }, totalPrecio: 2296 }\n{ _id: { empresa: 'Samsung' }, totalPrecio: 1014.98 }\n{ _id: { empresa: 'Sony' }, totalPrecio: 499 }\n{ _id: { empresa: 'Google' }, totalPrecio: 199 }\n{ _id: { empresa: 'Amazon' }, totalPrecio: 328 }\n</code></pre>"},{"location":"sa/05agregaciones.html#avg","title":"$avg","text":"<p>Mediante <code>$avg</code> podemos obtener el promedio de los valores de un campo num\u00e9rico.</p> <p>Por ejemplo, para obtener el precio medio de los productos agrupados por categor\u00eda, har\u00edamos:</p> <pre><code>&gt; db.productos.aggregate([{\n$group: {\n_id: {\n\"categoria\":\"$categoria\"\n},\nprecioMedio: {$avg:\"$precio\"}\n}\n}])\n&lt; { _id: { categoria: 'Smartphones' }, precioMedio: 563.99 }\n{ _id: { categoria: 'Port\u00e1tiles' }, precioMedio: 499 }\n{ _id: { categoria: 'Tablets' }, precioMedio: 396.4271428571428 }\n</code></pre>"},{"location":"sa/05agregaciones.html#addtoset","title":"$addToSet","text":"<p>Mediante <code>$addToSet</code>  obtendremos un array con todos los valores \u00fanicos para los campos seleccionados entre cada documento del grupo (sin repeticiones).</p> <p>Por ejemplo, para obtener para cada empresa las categor\u00edas en las que tienen productos, har\u00edamos:</p> <pre><code>&gt; db.productos.aggregate([{\n$group: {\n_id: {\n\"fabricante\":\"$fabricante\"\n},\ncategorias: {$addToSet:\"$categoria\"}\n}\n}])\n&lt; { _id: { fabricante: 'Apple' }, categorias: [ 'Port\u00e1tiles', 'Tablets' ] }\n{ _id: { fabricante: 'Amazon' }, categorias: [ 'Tablets' ] }\n{ _id: { fabricante: 'Sony' }, categorias: [ 'Port\u00e1tiles' ] }\n{ _id: { fabricante: 'Google' }, categorias: [ 'Tablets' ] }\n{ _id: { fabricante: 'Samsung' }, categorias: [ 'Tablets', 'Smartphones' ] }\n</code></pre>"},{"location":"sa/05agregaciones.html#push","title":"$push","text":"<p>Mediante <code>$push</code> tambi\u00e9n obtendremos un array con todos los valores para los campos seleccionados entre cada documento del grupo, pero con repeticiones. Es decir, funciona de manera similar a <code>$addToSet</code> pero permitiendo elementos repetidos.</p> <p>Por ello, si reescribimos la consulta anterior pero haciendo uso de <code>$push</code> obtendremos categor\u00edas repetidas:</p> <pre><code>&gt; db.productos.aggregate([{\n$group: {\n_id: {\n\"empresa\":\"$fabricante\"\n},\ncategorias: {$push:\"$categoria\"}\n}\n}])\n&lt; { _id: { empresa: 'Sony' }, categorias: [ 'Port\u00e1tiles' ] }\n{ _id: { empresa: 'Apple' }, categorias: [ 'Tablets', 'Tablets', 'Tablets', 'Port\u00e1tiles' ] }\n{ _id: { empresa: 'Google' }, categorias: [ 'Tablets' ] }\n{ _id: { empresa: 'Samsung' }, categorias: [ 'Smartphones', 'Tablets' ] }\n{ _id: { empresa: 'Amazon' }, categorias: [ 'Tablets', 'Tablets' ] }\n</code></pre>"},{"location":"sa/05agregaciones.html#max-y-min","title":"$max y $min","text":"<p>Los operadores <code>$max</code> y <code>$min</code> permiten obtener el mayor y el menor valor, respectivamente, del campo por el que se agrupan los documentos.</p> <p>Por ejemplo, para obtener el precio del producto m\u00e1s caro que tiene cada empresa har\u00edamos:</p> <pre><code>&gt; db.productos.aggregate([{\n$group: {\n_id: {\n\"empresa\":\"$fabricante\"\n},\nprecioMaximo: {$max:\"$precio\"},\nprecioMinimo: {$min:\"$precio\"},\n}\n}])\n{ \"_id\" : { \"empresa\" : \"Amazon\" }, \"precioMaximo\" : 199, \"precioMinimo\" : 129 }\n{ \"_id\" : { \"empresa\" : \"Sony\" }, \"precioMaximo\" : 499, \"precioMinimo\" : 499 }\n{ \"_id\" : { \"empresa\" : \"Samsung\" }, \"precioMaximo\" : 563.99, \"precioMinimo\" : 450.99 }\n{ \"_id\" : { \"empresa\" : \"Google\" }, \"precioMaximo\" : 199, \"precioMinimo\" : 199 }\n{ \"_id\" : { \"empresa\" : \"Apple\" }, \"precioMaximo\" : 699, \"precioMinimo\" : 499 }\n</code></pre>"},{"location":"sa/05agregaciones.html#doble-group","title":"Doble $group","text":"<p>Si queremos obtener el resultado de una agrupaci\u00f3n podemos aplicar el operador <code>$group</code> sobre otro <code>$group</code>.</p> <p>Por ejemplo, para obtener el precio medio de los precios medios de los tipos de producto por empresa har\u00edamos:</p> <pre><code>&gt; db.productos.aggregate([\n{$group: {\n_id: {\n\"empresa\":\"$fabricante\",\n\"categoria\":\"$categoria\"\n},\nprecioMedio: {$avg:\"$precio\"} // (1)!\n}\n},\n{$group: {\n_id: \"$_id.empresa\",\nprecioMedio: {$avg: \"$precioMedio\"} // (2)!\n}\n}\n])\n&lt; { _id: 'Google', precioMedio: 199 }\n{ _id: 'Sony', precioMedio: 499 }\n{ _id: 'Samsung', precioMedio: 507.49 }\n{ _id: 'Apple', precioMedio: 549 }\n{ _id: 'Amazon', precioMedio: 164 }\n</code></pre> <ol> <li>Precio medio por empresa y categor\u00eda</li> <li>Precio medio por empresa en base al precio medio anterior</li> </ol>"},{"location":"sa/05agregaciones.html#first-y-last","title":"$first y $last","text":"<p>Estos operadores devuelven el valor resultante de aplicar la expresi\u00f3n al primer ($first) y/o \u00faltimo ($last) elemento de un grupo de documentos que comparten el mismo grupo por clave.</p> <p>Por ejemplo, para obtener para cada empresa, cual es el tipo de producto que m\u00e1s tiene y la cantidad de dicho tipo har\u00edamos:</p> <pre><code>&gt; db.productos.aggregate([\n{$group: {\n_id: {\n\"empresa\": \"$fabricante\",\n\"tipo\" : \"$categoria\" },\ntotal: {$sum:1}\n}\n},\n{$sort: {\"total\":-1}},\n{$group: {\n_id:\"$_id.empresa\",\nproducto: {$first: \"$_id.tipo\"},  // (1)!\ncantidad: {$first:\"$total\"}\n}\n}\n])\n&lt; { _id: 'Sony', producto: 'Port\u00e1tiles', cantidad: 1 }\n{ _id: 'Samsung', producto: 'Tablets', cantidad: 1 }\n{ _id: 'Amazon', producto: 'Tablets', cantidad: 2 }\n{ _id: 'Apple', producto: 'Tablets', cantidad: 3 }\n{ _id: 'Google', producto: 'Tablets', cantidad: 1 }\n</code></pre> <ol> <li>Al agrupar por empresa, elegimos la categor\u00eda de producto que tiene m\u00e1s unidades</li> </ol>"},{"location":"sa/05agregaciones.html#project","title":"$project","text":"<p>Si queremos realizar una proyecci\u00f3n sobre el conjunto de resultados y quedarnos con un subconjunto de los campos usaremos el operador <code>$project</code>. Como resultado obtendremos el mismo n\u00famero de documentos, y en el orden indicado en la proyecci\u00f3n.</p> <p>La proyecci\u00f3n dentro del framework de agregaci\u00f3n es mucho m\u00e1s potente que dentro de las consultas normales. Se emplea para:</p> <ul> <li>renombrar campos.</li> <li>introducir campos calculados en el documento resultante mediante <code>$add</code>, <code>$substract</code>, <code>$multiply</code>, <code>$divide</code> o <code>$mod</code></li> <li>transformar campos a may\u00fasculas <code>$toUpper</code> o min\u00fasculas <code>$toLower</code>, concatenar campos mediante <code>$concat</code> u obtener subcadenas con <code>$substr</code>.</li> <li>transformar campos en base a valores obtenidos a partir de una condici\u00f3n mediante expresiones l\u00f3gicas con los operadores de comparaci\u00f3n vistos en las consultas.</li> </ul> <pre><code>&gt; db.productos.aggregate([\n{$project:\n{\n_id: 0, // (1)!\n\"empresa\": { \"$toUpper\": \"$fabricante\" }, // (2)!\n\"detalles\": { // (3)!\n\"categoria\": \"$categoria\",\n\"precio\": { \"$multiply\": [\"$precio\", 1.1] } // (4)!\n},\n\"elemento\": \"$nombre\" // (5)!\n}\n}\n])\n&lt; { empresa: 'APPLE',\ndetalles: { categoria: 'Tablets', precio: 548.9000000000001 },\nelemento: 'iPad 16GB Wifi' }\n{ empresa: 'APPLE',\ndetalles: { categoria: 'Tablets', precio: 658.9000000000001 },\nelemento: 'iPad 32GB Wifi' }\n...\n</code></pre> <ol> <li>Ocultamos el campo <code>_id</code></li> <li>Transforma un campo y lo pasa a may\u00fasculas</li> <li>Crea un documento anidado</li> <li>Incrementa el precio el 10%</li> <li>Renombra el campo</li> </ol>"},{"location":"sa/05agregaciones.html#match","title":"$match","text":"<p>El operador <code>$match</code> se utiliza principalmente para filtrar los documentos que pasar\u00e1n a la siguiente etapa del pipeline o a la salida final.</p> <p>Por ejemplo, para seleccionar s\u00f3lo las tablets har\u00edamos:</p> <pre><code>db.productos.aggregate([{$match:{categoria:\"Tablets\"}}])\n</code></pre> <p>Aparte de igualar un valor a un campo, podemos emplear los operadores usuales de consulta, como <code>$gt</code>, <code>$lt</code>, <code>$in</code>, etc\u2026\u200b</p> <p>Se recomienda poner el operador <code>$match</code> al principio del pipeline para limitar los documentos a procesar en siguientes fases. Si usamos este operador como primera fase podremos hacer uso de los indices de la colecci\u00f3n de una manera eficiente.</p> <p>As\u00ed pues, para obtener la cantidad de Tablets de menos de 500 euros har\u00edamos:</p> <pre><code>&gt; db.productos.aggregate([\n{$match:\n{categoria:\"Tablets\",\nprecio: {$lt: 500}}},\n{$group:\n{_id: {\"empresa\":\"$fabricante\"},\ncantidad: {$sum:1}}\n}\n])\n&lt; { _id: { empresa: 'Samsung' }, cantidad: 1 }\n{ _id: { empresa: 'Amazon' }, cantidad: 2 }\n{ _id: { empresa: 'Google' }, cantidad: 1 }\n{ _id: { empresa: 'Apple' }, cantidad: 1 }\n</code></pre>"},{"location":"sa/05agregaciones.html#sort","title":"$sort","text":"<p>El operador <code>$sort</code> ordena los documentos recibidos por el campo, y el orden indicado por la expresi\u00f3n indicada al pipeline.</p> <p>Por ejemplo, para ordenar los productos por precio descendentemente har\u00edamos:</p> <pre><code>db.productos.aggregate({$sort:{precio:-1}})\n</code></pre> <p>El operador <code>$sort</code> ordena los datos en memoria, por lo que hay que tener cuidado con el tama\u00f1o de los datos. Por ello, se emplea en las \u00faltimas fases del pipeline, cuando el conjunto de resultados es el menor posible.</p> <p>Si retomamos el ejemplo anterior, y ordenamos los datos por el precio total tenemos:</p> <pre><code>&gt; db.productos.aggregate([\n{$match:{categoria:\"Tablets\"}},\n{$group:\n{_id: {\"empresa\":\"$fabricante\"},\ntotalPrecio: {$sum:\"$precio\"}}\n},\n{$sort:{totalPrecio:-1}}   // (1)!\n])\n&lt; { _id: { empresa: 'Apple' }, totalPrecio: 1797 }\n{ _id: { empresa: 'Samsung' }, totalPrecio: 450.99 }\n{ _id: { empresa: 'Amazon' }, totalPrecio: 328 }\n{ _id: { empresa: 'Google' }, totalPrecio: 199 }\n</code></pre> <ol> <li>Al ordenar los datos, referenciamos al campo que hemos creado en la fase de $group</li> </ol> <p>Un operador muy relacionado es <code>$sortByCount</code>. Este operador es similar a realizar las siguientes operaciones:</p> <pre><code>{ $group: { _id: &lt;expresion&gt;, cantidad: { $sum: 1 } } },\n{ $sort: { cantidad: -1 } }\n</code></pre> <p>As\u00ed pues, podemos reescribir la consulta que hemos hecho en el operador <code>$group</code>:</p> <pre><code>db.productos.aggregate([\n{ $group: {\n_id: \"$fabricante\",\ntotal: { $sum:1 }\n}\n},\n{$sort: {\"total\": -1}}\n])\n</code></pre> <p>Y hacerla con:</p> ConsultaResultado <pre><code>db.productos.aggregate([{ $sortByCount: \"$fabricante\"}])\n</code></pre> <pre><code>{ _id: 'Apple', count: 4 }\n{ _id: 'Samsung', count: 2 }\n{ _id: 'Amazon', count: 2 }\n{ _id: 'Sony', count: 1 }\n{ _id: 'Google', count: 1 }\n</code></pre>"},{"location":"sa/05agregaciones.html#skip-y-limit","title":"$skip y $limit","text":"<p>El operador <code>$limit</code> \u00fanicamente limita el n\u00famero de documentos que pasan a trav\u00e9s del pipeline.</p> <p>El operador recibe un n\u00famero como par\u00e1metro:</p> <pre><code>db.productos.aggregate([{$limit:3}])\n</code></pre> <p>Este operador no modifica los documentos, s\u00f3lo restringe quien pasa a la siguiente fase.</p> <p>De manera similar, con el operador <code>$skip</code>, saltamos un n\u00famero determinado de documentos:</p> <pre><code>db.productos.aggregate([{$skip:3}])\n</code></pre> <p>El orden en el que empleemos estos operadores importa, y mucho, ya que no es lo mismo saltar y luego limitar, donde la cantidad de elementos la fija <code>$limit</code>:</p> <pre><code>&gt; db.productos.aggregate([{$skip:2}, {$limit:3}])\n&lt; { _id: ObjectId(\"635194b32e6059646a8e7fee\"),\nnombre: 'iPad 64GB Wifi',\ncategoria: 'Tablets',\nfabricante: 'Apple',\nprecio: 699 }\n{ _id: ObjectId(\"635194b32e6059646a8e7fef\"),\nnombre: 'Galaxy S3',\ncategoria: 'Smartphones',\nfabricante: 'Samsung',\nprecio: 563.99 }\n{ _id: ObjectId(\"635194b32e6059646a8e7ff0\"),\nnombre: 'Galaxy Tab 10',\ncategoria: 'Tablets',\nfabricante: 'Samsung',\nprecio: 450.99 }\n</code></pre> <p>En cambio, si primero limitamos y luego saltamos, la cantidad de elementos se obtiene de la diferencia entre el l\u00edmite y el salto:</p> <pre><code>&gt; db.productos.aggregate([{$limit:3}, {$skip:2}])\n&gt; { _id: ObjectId(\"635194b32e6059646a8e7fee\"),\nnombre: 'iPad 64GB Wifi',\ncategoria: 'Tablets',\nfabricante: 'Apple',\nprecio: 699 }\n</code></pre> <p>$sample</p> <p>Si tenemos un dataset muy grande, y queremos probar las consultas con un n\u00famero reducido de documentos, podemos emplear el operador <code>$sample</code> y reducir la cantidad de documentos de manera aleatoria:</p> <pre><code>db.productos.aggregate([ { $sample: { size: 3 } } ])\n</code></pre>"},{"location":"sa/05agregaciones.html#unwind","title":"$unwind","text":"<p>El operador <code>$unwind</code> es muy interesante y se utiliza s\u00f3lo con operadores array. Al usarlo con un campo array de tama\u00f1o N en un documento, lo transforma en N documentos con el campo tomando el valor individual de cada uno de los elementos del array.</p> <p>Si retomamos el ejemplo de la sesi\u00f3n anterior donde actualiz\u00e1bamos una colecci\u00f3n de enlaces, ten\u00edamos un enlace con la siguiente informaci\u00f3n:</p> <pre><code>&gt; db.enlaces.findOne()\n&lt; { _id: ObjectId(\"635533668420cd585aac88f3\"),\ntitulo: 'www.google.es',\ntags: [ 'mapas', 'videos', 'blog', 'calendario', 'email', 'mapas' ] }\n</code></pre> <p>Podemos observar como el campo <code>tags</code> contiene 6 valores dentro del array (con un valor repetido). A continuaci\u00f3n vamos a desenrollar el array:</p> <pre><code>&gt; db.enlaces.aggregate([\n{$match:{titulo:\"www.google.es\"}},\n{$unwind:\"$tags\"}\n])\n&lt; { _id: ObjectId(\"635533668420cd585aac88f3\"),\ntitulo: 'www.google.es', tags: 'mapas' }\n{ _id: ObjectId(\"635533668420cd585aac88f3\"),\ntitulo: 'www.google.es', tags: 'videos' }\n{ _id: ObjectId(\"635533668420cd585aac88f3\"),\ntitulo: 'www.google.es', tags: 'blog' }\n{ _id: ObjectId(\"635533668420cd585aac88f3\"),\ntitulo: 'www.google.es', tags: 'calendario' }\n{ _id: ObjectId(\"635533668420cd585aac88f3\"),\ntitulo: 'www.google.es', tags: 'email' }\n{ _id: ObjectId(\"635533668420cd585aac88f3\"),\ntitulo: 'www.google.es', tags: 'mapas' }\n</code></pre> <p>As\u00ed pues hemos obtenido 6 documentos con el mismo <code>_id</code> y <code>titulo</code>, es decir, un documento por elemento del array.</p> <p>De este modo, podemos realizar consultas que sumen/cuenten los elementos del array. Por ejemplo, si queremos obtener las 3 etiquetas que m\u00e1s aparecen en todos los enlaces har\u00edamos:</p> <pre><code>&gt; db.enlaces.aggregate([\n{\"$unwind\":\"$tags\"},\n{\"$group\":\n{\"_id\":\"$tags\",\n\"total\":{$sum:1}\n}\n},\n{\"$sort\":{\"total\":-1}},\n{\"$limit\": 3}\n])\n&lt; { _id: 'mapas', total: 2 }\n{ _id: 'blog', total: 1 }\n{ _id: 'calendario', total: 1 }\n</code></pre>"},{"location":"sa/05agregaciones.html#doble-unwind","title":"Doble $unwind","text":"<p>Si trabajamos con documentos que tienen varios arrays, podemos necesitar desenrollar los dos arrays. Al hacer un doble unwind se crea un producto cartesiano entre los elementos de los 2 arrays.</p> <p>Supongamos que tenemos los datos del siguiente inventario de ropa:</p> <pre><code>&gt; db.inventario.drop();\n&gt; db.inventario.insertOne({'nombre':\"Camiseta\",\n'tallas':[\"S\", \"M\", \"L\"],\n'colores':['azul', 'blanco', 'naranja', 'rojo']})\n&gt; db.inventario.insertOne({'nombre':\"Jersey\",\n'tallas':[\"S\", \"M\", \"L\", \"XL\"],\n'colores':['azul', 'negro', 'naranja', 'rojo']})\n&gt; db.inventario.insertOne({'nombre':\"Pantalones\",\n'tallas':[\"32x32\", \"32x30\", \"36x32\"],\n'colores':['azul', 'blanco', 'naranja', 'negro']})\n</code></pre> <p>Para obtener un listado de cantidad de pares talla/color har\u00edamos:</p> <pre><code>&gt; db.inventario.aggregate([\n{$unwind: \"$tallas\"},\n{$unwind: \"$colores\"},\n{$group:\n{ '_id': {'talla': '$tallas', 'color': '$colores'},\n'total' : {'$sum': 1}\n}\n}\n])\n{ \"_id\" : { \"talla\" : \"XL\", \"color\" : \"rojo\" }, \"total\" : 1 }\n{ \"_id\" : { \"talla\" : \"XL\", \"color\" : \"negro\" }, \"total\" : 1 }\n{ \"_id\" : { \"talla\" : \"L\", \"color\" : \"negro\" }, \"total\" : 1 }\n{ \"_id\" : { \"talla\" : \"M\", \"color\" : \"negro\" }, \"total\" : 1 }\n...\n</code></pre>"},{"location":"sa/05agregaciones.html#lookup","title":"$lookup","text":"<p>Si necesitamos unir los datos de dos colecciones, emplearemos el operador $lookup, el cual realiza un left outer join a una colecci\u00f3n de la misma base de datos para filtrar los documentos de la colecci\u00f3n joineada.</p> <p>El resultado es un nuevo campo array para cada documento de entrada, el cual contiene los documentos que cumplen el criterio del join.</p> <p>El operador <code>$lookup</code> utiliza cuatro par\u00e1metros:</p> <ul> <li><code>from</code>: colecci\u00f3n con la que se realiza el join.</li> <li><code>localField</code>: campo de la colecci\u00f3n origen (ser\u00eda la clave ajena).</li> <li><code>foreignField</code>: campo en la colecci\u00f3n destino que permite la uni\u00f3n (ser\u00eda la clave primaria de la otra colecci\u00f3n).</li> <li><code>as</code>: nombre del array que contendr\u00e1 los documentos enlazados.</li> </ul> <p>Preparando los datos</p> <p>Vamos a utilizar la colecci\u00f3n <code>zips</code> empleada en anteriores sesiones la cual tiene una estructura similar a:</p> <pre><code>{ _id: ObjectId(\"5c8eccc1caa187d17ca6ed18\"),\ncity: 'ACMAR',\nzip: '35004',\nloc: { y: 33.584132, x: 86.51557 },\npop: 6055,\nstate: 'AL' }\n</code></pre> <p>A continuaci\u00f3n vamos a crear una nueva colecci\u00f3n llamada <code>state</code> con el nombre de los estados (states.js), la cual cargaremos en la base de datos <code>sample_training</code>:</p> <pre><code>db.states.insertMany([\n{\n\"name\": \"Alabama\",\n\"abbreviation\": \"AL\"\n},\n{\n\"name\": \"Alaska\",\n\"abbreviation\": \"AK\"\n},\n...\n])\n</code></pre> <p>Vamos a estudiar como funciona el operador <code>$lookup</code> mediante un ejemplo. Primero vamos a recuperar los tres estados m\u00e1s poblados. Para ello, podr\u00edamos hacer la siguiente consulta agregada:</p> ConsultaResultado <pre><code>db.zips.aggregate([\n{$group: {\n_id: \"$state\",\n\"totalPoblacion\": {$sum:\"$pop\"}\n}},\n{$sort:{\"totalPoblacion\":-1}} ,\n{$limit: 3}  ])\n</code></pre> <pre><code>{ _id: 'CA', totalPoblacion: 29760021 }\n{ _id: 'NY', totalPoblacion: 17990455 }\n{ _id: 'TX', totalPoblacion: 16986510 }\n</code></pre> <p>Si ahora queremos recuperar el nombre de esos tres estados, a\u00f1adimos una nueva fase:</p> <pre><code>db.zips.aggregate([\n{$group: {\n_id: \"$state\",\n\"totalPoblacion\": {$sum:\"$pop\"}\n}},\n{$sort:{\"totalPoblacion\":-1}} ,\n{$limit: 3},\n{$lookup: {\nfrom: \"states\",\nlocalField: \"_id\",\nforeignField: \"abbreviation\",\nas: \"estados\"\n}},    ])\n</code></pre> <p>Y ahora obtenemos para cada documento, un array con los documentos que coinciden (en este caso es una relaci\u00f3n 1:1, y por eso cada array s\u00f3lo contiene un elemento):</p> <pre><code>{ _id: 'CA',\ntotalPoblacion: 29760021,\nestados: [ { _id: ObjectId(\"63565cd82889ecee358e0cd5\"),\nname: 'California',\nabbreviation: 'CA' } ] }\n{ _id: 'NY',\ntotalPoblacion: 17990455,\nestados: [ { _id: ObjectId(\"63565cd82889ecee358e0cf4\"),\nname: 'New York',\nabbreviation: 'NY' } ] }\n{ _id: 'TX',\ntotalPoblacion: 16986510,\nestados: [ { _id: ObjectId(\"63565cd82889ecee358e0d02\"),\nname: 'Texas',\nabbreviation: 'TX' } ] }\n</code></pre> <p>Como la relaci\u00f3n siempre va a provocar la creaci\u00f3n de un array, mediante <code>$unwind</code>, lo podemos deshacer:</p> ConsultaResultado <pre><code>db.zips.aggregate([\n{$group: {\n_id: \"$state\",\n\"totalPoblacion\": {$sum:\"$pop\"}\n}},\n{$sort:{\"totalPoblacion\":-1}} ,\n{$limit: 3},\n{$lookup: {\nfrom: \"states\",\nlocalField: \"_id\",\nforeignField: \"abbreviation\",\nas: \"estados\"\n}},    {$unwind:\"$estados\"}\n])\n</code></pre> <pre><code>{ _id: 'CA',\ntotalPoblacion: 29760021,\nestados: { _id: ObjectId(\"63565cd82889ecee358e0cd5\"),\nname: 'California',\nabbreviation: 'CA' } }\n{ _id: 'NY',\ntotalPoblacion: 17990455,\nestados: { _id: ObjectId(\"63565cd82889ecee358e0cf4\"),\nname: 'New York',\nabbreviation: 'NY' } }\n{ _id: 'TX',\ntotalPoblacion: 16986510,\nestados: { _id: ObjectId(\"63565cd82889ecee358e0d02\"),\nname: 'Texas',\nabbreviation: 'TX' } }\n</code></pre> <p>As\u00ed pues, para finalmente obtener el nombre de cada estado, mediante <code>$project</code> recuperamos el campo <code>name</code>:</p> <pre><code>db.zips.aggregate([\n{$group: {\n_id: \"$state\",\n\"totalPoblacion\": {$sum:\"$pop\"}\n}},\n{$sort:{\"totalPoblacion\":-1}} ,\n{$limit: 3},\n{$lookup: {\nfrom: \"states\",\nlocalField: \"_id\",\nforeignField: \"abbreviation\",\nas: \"estados\"\n}},\n{$unwind:\"$estados\"},  {$project: {\n\"estado\": \"$estados.name\",\n\"poblacion\": \"$totalPoblacion\"\n}}    ])\n</code></pre> <p>Obteniendo el resultado deseado:</p> <pre><code>{ _id: 'CA', estado: 'California', poblacion: 29760021 }\n{ _id: 'NY', estado: 'New York', poblacion: 17990455 }\n{ _id: 'TX', estado: 'Texas', poblacion: 16986510 }\n</code></pre>"},{"location":"sa/05agregaciones.html#persistiendo-los-resultados","title":"Persistiendo los resultados","text":"<p>Una vez hemos realizado nuestras consultas mediante el framework de agregaci\u00f3n, es muy posible que queramos almacenar el resultado en una nueva colecci\u00f3n para poder volver a consultar el resultado sin necesidad de ejecutar todas las fases.</p> <p>Para ello, podemos emplear los operadores:</p> <ul> <li><code>$out</code> recoge los documentos de una agregaci\u00f3n y los persiste en una colecci\u00f3n, sobrescribiendo los datos existentes.</li> <li><code>$merge</code> similar a <code>$out</code>, pero permite a\u00f1adir el resultado a la misma colecci\u00f3n y adem\u00e1s soporta trabajar con colecciones particionadas.</li> </ul> <p>Por ejemplo, vamos a basarnos en las consultas con join, para crear una nueva colecci\u00f3n con la poblaci\u00f3n total de todos dos estados, y la vamos a almacenar en una nueva colecci\u00f3n denominada <code>states_population</code>:</p> <pre><code>db.zips.aggregate([\n{$group: {\n_id: \"$state\",\n\"totalPoblacion\": {$sum:\"$pop\"}\n}},\n{$lookup: {\nfrom: \"states\",\nlocalField: \"_id\",\nforeignField: \"abbreviation\",\nas: \"estados\"\n}},\n{$unwind:\"$estados\"},  {$project: {\n\"estado\": \"$estados.name\",\n\"poblacion\": \"$totalPoblacion\"\n}},\n{$out: \"states_population\"}    ])\n</code></pre> <p>Tras su ejecuci\u00f3n, podemos recuperar los datos:</p> <pre><code>&gt; db.states_population.findOne()\n&lt; { _id: 'WY', estado: 'Wyoming', poblacion: 453588 }\n</code></pre>"},{"location":"sa/05agregaciones.html#de-sql-al-pipeline-de-agregaciones","title":"De SQL al Pipeline de agregaciones","text":"<p>Ya hemos visto que el pipeline ofrece operadores para realizar la misma funcionalidad de agrupaci\u00f3n que ofrece SQL.</p> <p>Si relacionamos los comandos SQL con el pipeline de agregaciones tenemos las siguientes equivalencias:</p> SQL Pipeline de Agregaciones WHERE $match GROUP BY $group HAVING $match SELECT $project ORDER BY $sort LIMIT $limit SUM() $sum COUNT() $sum / $sortByCount join $lookup <p>Podemos encontrar ejemplos de consultas SQL transformadas al pipeline en https://www.mongodb.com/docs/manual/reference/sql-aggregation-comparison/</p>"},{"location":"sa/05agregaciones.html#limitaciones","title":"Limitaciones","text":"<p>Hay que tener en cuenta las siguiente limitaciones:</p> <ul> <li>En versiones anteriores a la 2.6, el pipeline devolv\u00eda en cada fase un objeto BSON, y por tanto, el resultado estaba limitado a 16MB</li> <li>Actualmente, s\u00f3lo cada documento que forme parte del resultado final debe ocupar menos de 16MB.</li> <li>Las fases tienen un l\u00edmite de 100MB en memoria. Si una fase excede dicho l\u00edmite, se producir\u00e1 un error. En este caso, hay que habilitar el uso de disco mediante <code>allowDiskUse</code> en las opciones de la agregaci\u00f3n.</li> </ul> <p>M\u00e1s informaci\u00f3n en https://www.mongodb.com/docs/manual/core/aggregation-pipeline-limits/</p>"},{"location":"sa/05agregaciones.html#agregaciones-con-compass","title":"Agregaciones con Compass","text":"<p>MongoDB Compass nos ofrece la herramienta Aggregation Pipeline Builder para crear, borrar y reorganizar f\u00e1cilmente fases en un pipeline, as\u00ed como evaluar los documento resultantes en tiempo real.</p> <p>Vamos a practicar con la colecci\u00f3n de <code>zips</code>:</p> Agregaciones en MongoDB Compass <p>Y vamos a reproducir la consulta con <code>$lookup</code> que acabamos de realizar, pero en nuestro caso, iremos paso a paso:</p> <pre><code>db.zips.aggregate([\n{$group: {\n_id: \"$state\",\n\"totalPoblacion\": {$sum:\"$pop\"}\n}},\n{$lookup: {\nfrom: \"states\",\nlocalField: \"_id\",\nforeignField: \"abbreviation\",\nas: \"estados\"\n}},\n{$unwind:\"$estados\"},  {$project: {\n\"estado\": \"$estados.name\",\n\"poblacion\": \"$totalPoblacion\"\n}} ])\n</code></pre> <p>Para ello, pulsamos sobre el bot\u00f3n de Add Stage, seleccionamos el operador <code>$group</code> y escribimos la expresi\u00f3n de agrupaci\u00f3n. Al hacerlo, en el panel anexo aparecer\u00e1n 10 documentos de muestra con el resultado de ejecutar dicha fase:</p> $group en MongoDB Compass <p>Paso a paso, iremos a\u00f1adiendo el resto de fases hasta tenerlas todas, pudiendo ver los datos que va generando cada fase:</p> Resultado en MongoDB Compass <p>Una vez tenemos nuestra agregaci\u00f3n, podemos obtener una versi\u00f3n del pipeline en Python, Java, C# o Node.js, mediante la opci\u00f3n Export-to-Language.</p> Exportando la agregaci\u00f3n a PyMongo"},{"location":"sa/05agregaciones.html#referencias","title":"Referencias","text":"<ul> <li>Documentaci\u00f3n oficial del Aggregation Framework.</li> <li>Curso M121: The MongoDB Aggregation Framework de la Mongo University.</li> <li>Libro Practical MongoDB Aggregations</li> </ul>"},{"location":"sa/05agregaciones.html#actividades","title":"Actividades","text":"<p>Para las siguientes actividades, vamos a utilizar la base de datos <code>sample_mflix</code>, y en concreto, la colecci\u00f3n <code>movies</code> . Un documento de ejemplo ser\u00eda similar a:</p> movies.json<pre><code>{ _id: ObjectId(\"573a1390f29313caabcd548c\"),\nplot: 'The Civil War divides ...',\ngenres: [ 'Drama', 'History', 'Romance' ],\nruntime: 165,\nrated: 'NOT RATED',\ncast: [ 'Lillian Gish',\n'Mae Marsh',\n'Henry B. Walthall',\n'Miriam Cooper' ],\nposter: 'https://m.media-amazon.com/images/M/MV5BYTM4ZDhiYTQtYzExNC00YjVlLTg2YWYtYTk3NTAzMzcwNTExXkEyXkFqcGdeQXVyNjU0OTQ0OTY@._V1_SY1000_SX677_AL_.jpg',\ntitle: 'The Birth of a Nation',\nfullplot: 'Two brothers...',\ncountries: [ 'USA' ],\nreleased: 1915-03-03T00:00:00.000Z,\ndirectors: [ 'D.W. Griffith' ],\nwriters: [ 'Thomas Dixon Jr. (adapted from ...\")',\n  'Thomas Dixon Jr. (play)',\n  'Thomas Dixon Jr. (novel)',\n  'D.W. Griffith',\n  'Frank E. Woods' ],\nawards: { wins: 2, nominations: 0, text: '2 wins.' },\nlastupdated: '2015-09-11 00:32:27.763000000',\nyear: 1915,\nimdb: { rating: 6.8, votes: 15715, id: 4972 },\ntype: 'movie',\ntomatoes: \n{ viewer: { rating: 3.2, numReviews: 4358, meter: 57 },\n  dvd: 2004-06-29T00:00:00.000Z,\n  critic: { rating: 8, numReviews: 38, meter: 100 },\n  lastUpdated: 2015-09-10T18:30:23.000Z,\n  consensus: 'Racial depictions aside...',\n  rotten: 0,\n  production: 'Gravitas',\n  fresh: 38 },\nnum_mflix_comments: 0 }\n</code></pre> <ol> <li> <p>(RA5075.1 / CE5.1d / 3p) Haciendo uso del framework de agregaci\u00f3n y el shell de MongoDB, resuelve las siguientes consultas:</p> <ol> <li>(0.5) Encuentra todas las pel\u00edculas que entre sus g\u00e9neros (<code>genres</code>) se encuentre el <code>Drama</code>. S\u00f3lo queremos recuperar el t\u00edtulo y la calificaci\u00f3n (<code>rating</code>) de IMDB.</li> <li>(0.5) Recupera los t\u00edtulos de las tres pel\u00edculas rom\u00e1nticas (<code>Romance</code>) con mayor calificaci\u00f3n en IMDB que se lanzaron (<code>released</code>) antes del 2001.</li> <li>(0.5) Averigua la cantidad de pel\u00edculas que hay de cada categor\u00eda de calificaci\u00f3n (<code>rated</code>).</li> <li> <p>(0.5) Teniendo en cuenta las pel\u00edculas anteriores al a\u00f1o 2001, para cada g\u00e9nero, recupera la media y la m\u00e1xima calificaci\u00f3n en IMDB as\u00ed como el tiempo ajustado (con trailers, los cuales duran 12 minutos) de la pel\u00edcula m\u00e1s larga, ordenando los g\u00e9neros por popularidad.</p> <p>El resultado ser\u00e1 similar a:</p> <pre><code>{ _id: 'Film-Noir',\nnota_media: 7.62,\nmejor_nota: 8.3,\ntiempo_ajustado: 123 }\n{ _id: 'Documentary',\nnota_media: 7.555313351498638,\nmejor_nota: 9.4,\ntiempo_ajustado: 1152 }\n{ _id: 'Short',\nnota_media: 7.386,\nmejor_nota: 8.6,\ntiempo_ajustado: 56 }\n...\n</code></pre> </li> <li> <p>(0.5) Sobre la consulta anterior, adem\u00e1s de la informaci\u00f3n ya recuperada, queremos buscar qu\u00e9 pel\u00edcula recomendar de cada categor\u00eda siempre y cuando duren un m\u00e1ximo de 218 minutos y tengan al menos una calificaci\u00f3n de 7.  (pista: necesitas utilizar <code>$first</code>)</p> <p>El resultado ser\u00e1 similar a:</p> <pre><code>{ _id: 'Documentary',\ntitulo_recomendado: 'Cosmos',\nnota_recomendado: 9.3,\ntiempo_recomendado: 60,\npopularidad: 7.69695945945946,\nmejor_nota: 9.3,\ntiempo_ajustado_maslargo: 212 }\n{ _id: 'Sci-Fi',\ntitulo_recomendado: 'Blade Runner',\nnota_recomendado: 8.2,\ntiempo_recomendado: 117,\npopularidad: 7.3999999999999995,\nmejor_nota: 8.2,\ntiempo_ajustado_maslargo: 209 }\n...\n</code></pre> </li> <li> <p>(0.5) Recupera las 5 pel\u00edculas m\u00e1s comentadas (los comentarios se almacenan en la colecci\u00f3n <code>comments</code>), devolviendo el t\u00edtulo, su g\u00e9nero y la cantidad de comentarios. Adem\u00e1s, queremos almacenar el resultado en la colecci\u00f3n <code>movies_most_commented</code>.</p> <pre><code>&gt; db.most_commented_movies.findOne()\n&lt; { _id: ObjectId(\"573a13bff29313caabd5e91e\"),\nsumComments: 161,\nmovie: { imdb: { rating: 6.4 }, title: 'The Taking of Pelham 1 2 3' } }\n</code></pre> </li> </ol> </li> <li> <p>(RA5075.1 / CE5.1d / 1p) Haciendo uso de MongoDBCompass, mejora la siguiente consulta que obtiene los tres documentales m\u00e1s premiados, siempre y cuando hayan ganado alg\u00fan premio:</p> <pre><code>var pipeline = [\n{ $sort: {\"awards.wins\": -1}}, // Ordenamos por premios ganados\n{ $match: {\"awards.wins\": { $gte: 1}}},\n{ $limit: 20}, // Obtenemos las 20 pel\u00edculas que han ganado m\u00e1s de un premio\n{ $match: {\ngenres: {$in: [\"Documentary\"]}, // Nos quedamos con los documentales\n}},\n{ $project: { title: 1, genres: 1, awards: 1}},\n{ $limit: 3}, ];\ndb.movies.aggregate(pipeline)\n</code></pre> <p>Adjunta una captura inicial y otra final, y la exportaci\u00f3n de la agregaci\u00f3n a Python.</p> </li> </ol>"},{"location":"sa/06replicacion.html","title":"Replicaci\u00f3n y particionado (sharding) en MongoDB.","text":""},{"location":"sa/06replicacion.html#replicacion","title":"Replicaci\u00f3n","text":"<p>Un aspecto muy importante de MongoDB es que soporta la replicaci\u00f3n de los datos de forma nativa mediante el uso de conjuntos de r\u00e9plicas.</p>"},{"location":"sa/06replicacion.html#conjunto-de-replicas","title":"Conjunto de r\u00e9plicas","text":"<p>En MongoDB se replican los datos mediante un conjunto de r\u00e9plicas  (Replica Set), el cual es un grupo de servidores (nodos mongod) donde uno de ellos ejerce la funci\u00f3n de primario y por tanto recibe las peticiones de los clientes, y el resto de servidores hace de secundarios, manteniendo copias de los datos del primario.</p> Conjunto de R\u00e9plicas en MongoDB <p>Si el nodo primario se cae, los secundarios eligen un nuevo primario entre ellos mismos, en un proceso que se conoce como votaci\u00f3n. La aplicaci\u00f3n se conectar\u00e1 al nuevo primario de manera transparente. Cuando el antiguo nodo primario vuelva en s\u00ed, ser\u00e1 un nuevo nodo secundario.</p> <p>Al usar replicaci\u00f3n, si un servidor se cae, siempre vamos a poder obtener los datos a partir de otros servidores del conjunto. Si los datos de un servidor se da\u00f1an o son inaccesibles, podemos crear una nueva copia desde uno de los miembros del conjunto.</p>"},{"location":"sa/06replicacion.html#elementos-de-un-conjunto-de-replicas","title":"Elementos de un conjunto de r\u00e9plicas","text":"<p>Los tipos de nodos que podemos encontrar en un conjunto de r\u00e9plica son:</p> <ul> <li>Regular: Es el tipo de nodo m\u00e1s com\u00fan.</li> <li>Primario: Acepta todas las operaciones de escritura de los clientes. Cada conjunto de r\u00e9plicas tendr\u00e1 s\u00f3lo un primario, y como s\u00f3lo un miembro acepta operaciones de escritura, ofrece consistencia estricta para todas las lecturas realizadas desde \u00e9l.</li> <li> <p>Secundario: Los secundarios replican el oplog primario y aplican las operaciones a sus conjuntos de datos. De este modo, los nodos secundarios son un espejo del primario. Si el primario deja de estar disponible, el conjunto de r\u00e9plica elegir\u00e1 a un secundario para que sea el nuevo primario, mediante un proceso de votaci\u00f3n.</p> <p>Por defecto, los clientes realizan las lecturas desde el nodo primario. Sin embargo, los clientes pueden indicar que quieren realizar lecturas desde los nodos secundarios.</p> <p>Consistencia eventual</p> <p>Es posible que al realizar lecturas de un nodo secundario la informaci\u00f3n que se obtenga no refleje el estado del nodo primario.</p> </li> <li> <p>\u00c1rbitro: se emplea s\u00f3lo para votar. No contiene copia de los datos y no se puede convertir en primario. Los conjuntos de r\u00e9plica pueden tener \u00e1rbitros para a\u00f1adir votos en las elecciones de un nuevo primario. Siempre tienen un voto, y permiten que los conjuntos de r\u00e9plica tengan un n\u00famero impar de nodos, sin la necesidad de tener un miembro que replique los datos. Adem\u00e1s, no requieren hardware dedicado.</p> <p>A tener en cuenta</p> <ul> <li>No ejecutar un \u00e1rbitro en sistemas que tambi\u00e9n ejecutan los miembros primarios y secundarios del conjunto de r\u00e9plicas.</li> <li>S\u00f3lo a\u00f1adir un \u00e1rbitro a un conjunto con un n\u00famero par de miembros.</li> <li>Si se a\u00f1ade un \u00e1rbitro a un conjunto con un n\u00famero impar de miembros, el conjunto puede sufrir un empate.</li> </ul> </li> <li> <p>Retrasado (delayed): nodo que se emplea para la recuperaci\u00f3n del sistema ante un fallo. Para ello, hay que asignar la propiedad <code>priority:0</code>. Este nodo nunca ser\u00e1 un nodo primario.</p> </li> <li> <p>Oculto: empleado para anal\u00edticas del sistema.</p> </li> </ul>"},{"location":"sa/06replicacion.html#oplog","title":"oplog","text":"<p>Para soportar la replicaci\u00f3n, el nodo primario almacena todos los cambios en su oplog.</p> <p>De manera simplificada, el oplog es un diario de todos los cambios que la instancia principal realiza en las bases de datos con el prop\u00f3sito de replicar dichos cambios en un nodo secundario para asegurar que las dos bases de datos sean id\u00e9nticas.</p> <p>El servidor principal mantiene el oplog, y el secundario consulta al principal por nuevas entradas que aplicar a sus propias copias de las bases de datos replicadas. Este proceso se realiza de manera as\u00edncrona, de manera que todos los miembros del conjunto de r\u00e9plicas contienen una copia del oplog.</p> <p>El oplog crea un timestamp para cada entrada. Esto permite que un secundario controle la cantidad de informaci\u00f3n que se ha modificado desde una lectura anterior, y qu\u00e9 entradas necesita transferir para ponerse al d\u00eda. Si paramos un secundario y lo reiniciamos m\u00e1s adelante, utilizar\u00e1 el oplog para obtener todos los cambios que ha perdido mientras estaba offline.</p> <p>El oplog se almacena en una colecci\u00f3n limitada (capped) y ordenada de un tama\u00f1o determinado. La opci\u00f3n <code>oplogSize</code> define en MB el tama\u00f1o del archivo. Para un sistema de 64 bits con comportamiento de lectura/escritura normales, el <code>oplogSize</code> deber\u00eda ser de al menos un 5% del espacio de disco disponible. Si el sistema tiene m\u00e1s escrituras que lecturas, puede que necesitemos incrementar este tama\u00f1o para asegurar que cualquier nodo secundario pueda estar offline una cantidad de tiempo razonable sin perder informaci\u00f3n.</p>"},{"location":"sa/06replicacion.html#creando-un-conjunto-de-replicas","title":"Creando un conjunto de r\u00e9plicas","text":"<p>Replicaci\u00f3n y particionado en MongoAtlas</p> <p>El cluster gratuito de MongoAtlas ya ofrece replicaci\u00f3n de los datos, pero no nos permite administrarlo, al tratarse de un cl\u00faster compartido.</p> <p>Para poder probar tanto la replicaci\u00f3n como el particionado, necesitamos tener control sobre los servidores. Por ello, en esta sesi\u00f3n vamos a utilizar Docker para montar la infraestructura.</p> <p>Para ello, vamos a partir del archivo de docker-compose-replicaset.yml donde creamos tres contenedores (siendo <code>mongo1</code> el nodo principal y <code>mongo2</code> y <code>mongo3</code> los secundarios) dentro de una misma red y que pertenecen al conjunto de r\u00e9plicas <code>iabdrs</code>:</p> docker-compose-replicaset.yml<pre><code>services:\nmongo1:\ncontainer_name: mongo1\nimage: mongo\nvolumes:\n- ./rs-init.sh:/scripts/rs-init.sh\n- ./init.js:/scripts/init.js\nnetworks:\n- mongo-network\nports:\n- 27017:27017\ndepends_on:\n- mongo2\n- mongo3\nlinks:\n- mongo2\n- mongo3\nentrypoint: [ \"/usr/bin/mongod\", \"--bind_ip_all\", \"--replSet\", \"iabdrs\" ]\nmongo2:\ncontainer_name: mongo2\nimage: mongo\nnetworks:\n- mongo-network\nports:\n- 27018:27017\nentrypoint: [ \"/usr/bin/mongod\", \"--bind_ip_all\", \"--replSet\", \"iabdrs\" ]\nmongo3:\ncontainer_name: mongo3\nimage: mongo\nnetworks:\n- mongo-network\nports:\n- 27019:27017\nentrypoint: [ \"/usr/bin/mongod\", \"--bind_ip_all\", \"--replSet\", \"iabdrs\" ]\nnetworks:\nmongo-network:\ndriver: bridge\n</code></pre> <p>Despliegue</p> <p>Normalmente, cada instancia <code>mongod</code> se coloca en un servidor f\u00edsico y todos en el puerto est\u00e1ndar (27017).</p> <p>En nuestro caso, vamos a crear un conjunto de tres r\u00e9plicas, y en vez de hacerlo en tres m\u00e1quinas distintas, como los tres contenedores residen en la misma m\u00e1quina, lo haremos en tres puertos diferentes (del 27017 al 27019)</p> <p>El nodo principal necesita un script para inicializarse, el cual cargamos en el volumen como <code>rs-init.sh</code>. En dicho fichero definimos un documento con la configuraci\u00f3n del cl\u00faster, donde el <code>_id</code> tiene que ser igual al usado al crear la r\u00e9plica, y el array de <code>members</code> contiene las r\u00e9plicas creadas donde los puertos han de coincidir. Dicho documento se pasar\u00e1 como par\u00e1metro a la operaci\u00f3n <code>rs.initiate</code>:</p> rs-init.sh<pre><code>#!/bin/bash\nDELAY=25\nmongosh &lt;&lt;EOF\nvar config = {\n    \"_id\": \"iabdrs\",\n    \"version\": 1,\n    \"members\": [\n        {\n            \"_id\": 1,\n            \"host\": \"mongo1:27017\",\n            \"priority\": 2\n        },\n        {\n            \"_id\": 2,\n            \"host\": \"mongo2:27017\",\n            \"priority\": 1\n        },\n        {\n            \"_id\": 3,\n            \"host\": \"mongo3:27017\",\n            \"priority\": 1\n        }\n    ]\n};\nrs.initiate(config, { force: true });\nEOF\necho \"****** Esperando ${DELAY} segundos a que se apliquen la configuraci\u00f3n del conjunto de r\u00e9plicas ******\"\nsleep $DELAY\nmongosh &lt; /scripts/init.js\n</code></pre> <p>Finalmente, mediante el archivo <code>init.js</code> comprobamos el estado de la r\u00e9plica y creamos el usuario administrador:</p> init.js<pre><code>rs.status();\ndb.createUser({user: 'admin', pwd: 'admin', roles: [ { role: 'root', db: 'admin' } ]});\n</code></pre> <p>As\u00ed pues, una vez tenemos los tres archivos en la misma carpeta, ya podemos lanzar Docker Compose para crear los contenedores:</p> <pre><code>docker-compose --file docker-compose-replicaset.yml --project-name iabd-mongodb-replica up -d\n</code></pre> <p>Ya s\u00f3lo nos queda ejecutar el script de inicializaci\u00f3n sobre el nodo principal:</p> <pre><code>docker exec mongo1 sh /scripts/rs-init.sh\n</code></pre> <p>Al ejecutarse el script, se inicializa el conjunto de r\u00e9plicas y se obtiene su estado (mediante <code>rs.status()</code>) el cual se muestra por consola y podemos observar como ha creado los tres nodos, diferenciando el nodo principal de los secundarios:</p> <pre><code>iabdrs [direct: primary] test&gt; {\nset: 'iabdrs',\ndate: ISODate(\"2022-10-26T09:54:42.137Z\"),\nmyState: 1,\nterm: Long(\"1\"),\nsyncSourceHost: '',\nsyncSourceId: -1,\nheartbeatIntervalMillis: Long(\"2000\"),\nmajorityVoteCount: 2,\nwriteMajorityCount: 2,\nvotingMembersCount: 3,\nwritableVotingMembersCount: 3,\noptimes: {\nlastCommittedOpTime: { ts: Timestamp({ t: 1666778080, i: 1 }), t: Long(\"1\") },\nlastCommittedWallTime: ISODate(\"2022-10-26T09:54:40.457Z\"),\nreadConcernMajorityOpTime: { ts: Timestamp({ t: 1666778080, i: 1 }), t: Long(\"1\") },\nappliedOpTime: { ts: Timestamp({ t: 1666778080, i: 1 }), t: Long(\"1\") },\ndurableOpTime: { ts: Timestamp({ t: 1666778080, i: 1 }), t: Long(\"1\") },\nlastAppliedWallTime: ISODate(\"2022-10-26T09:54:40.457Z\"),\nlastDurableWallTime: ISODate(\"2022-10-26T09:54:40.457Z\")\n},\nlastStableRecoveryTimestamp: Timestamp({ t: 1666778030, i: 1 }),\nelectionCandidateMetrics: {\nlastElectionReason: 'electionTimeout',\nlastElectionDate: ISODate(\"2022-10-26T09:53:10.197Z\"),\nelectionTerm: Long(\"1\"),\nlastCommittedOpTimeAtElection: { ts: Timestamp({ t: 1666777979, i: 1 }), t: Long(\"-1\") },\nlastSeenOpTimeAtElection: { ts: Timestamp({ t: 1666777979, i: 1 }), t: Long(\"-1\") },\nnumVotesNeeded: 2,\npriorityAtElection: 2,\nelectionTimeoutMillis: Long(\"10000\"),\nnumCatchUpOps: Long(\"0\"),\nnewTermStartDate: ISODate(\"2022-10-26T09:53:10.363Z\"),\nwMajorityWriteAvailabilityDate: ISODate(\"2022-10-26T09:53:11.139Z\")\n},\nmembers: [\n{\n_id: 1,\nname: 'mongo1:27017',\nhealth: 1,\nstate: 1,\nstateStr: 'PRIMARY',\nuptime: 129,\noptime: { ts: Timestamp({ t: 1666778080, i: 1 }), t: Long(\"1\") },\noptimeDate: ISODate(\"2022-10-26T09:54:40.000Z\"),\nlastAppliedWallTime: ISODate(\"2022-10-26T09:54:40.457Z\"),\nlastDurableWallTime: ISODate(\"2022-10-26T09:54:40.457Z\"),\nsyncSourceHost: '',\nsyncSourceId: -1,\ninfoMessage: 'Could not find member to sync from',\nelectionTime: Timestamp({ t: 1666777990, i: 1 }),\nelectionDate: ISODate(\"2022-10-26T09:53:10.000Z\"),\nconfigVersion: 1,\nconfigTerm: 1,\nself: true,\nlastHeartbeatMessage: ''\n},\n{\n_id: 2,\nname: 'mongo2:27017',\nhealth: 1,\nstate: 2,\nstateStr: 'SECONDARY',\nuptime: 102,\noptime: { ts: Timestamp({ t: 1666778070, i: 1 }), t: Long(\"1\") },\noptimeDurable: { ts: Timestamp({ t: 1666778070, i: 1 }), t: Long(\"1\") },\noptimeDate: ISODate(\"2022-10-26T09:54:30.000Z\"),\noptimeDurableDate: ISODate(\"2022-10-26T09:54:30.000Z\"),\nlastAppliedWallTime: ISODate(\"2022-10-26T09:54:40.457Z\"),\nlastDurableWallTime: ISODate(\"2022-10-26T09:54:40.457Z\"),\nlastHeartbeat: ISODate(\"2022-10-26T09:54:40.322Z\"),\nlastHeartbeatRecv: ISODate(\"2022-10-26T09:54:41.327Z\"),\npingMs: Long(\"0\"),\nlastHeartbeatMessage: '',\nsyncSourceHost: 'mongo1:27017',\nsyncSourceId: 1,\ninfoMessage: '',\nconfigVersion: 1,\nconfigTerm: 1\n},\n{\n_id: 3,\nname: 'mongo3:27017',\nhealth: 1,\nstate: 2,\nstateStr: 'SECONDARY',\nuptime: 102,\noptime: { ts: Timestamp({ t: 1666778070, i: 1 }), t: Long(\"1\") },\noptimeDurable: { ts: Timestamp({ t: 1666778070, i: 1 }), t: Long(\"1\") },\noptimeDate: ISODate(\"2022-10-26T09:54:30.000Z\"),\noptimeDurableDate: ISODate(\"2022-10-26T09:54:30.000Z\"),\nlastAppliedWallTime: ISODate(\"2022-10-26T09:54:40.457Z\"),\nlastDurableWallTime: ISODate(\"2022-10-26T09:54:40.457Z\"),\nlastHeartbeat: ISODate(\"2022-10-26T09:54:40.322Z\"),\nlastHeartbeatRecv: ISODate(\"2022-10-26T09:54:41.326Z\"),\npingMs: Long(\"0\"),\nlastHeartbeatMessage: '',\nsyncSourceHost: 'mongo1:27017',\nsyncSourceId: 1,\ninfoMessage: '',\nconfigVersion: 1,\nconfigTerm: 1\n}\n],\nok: 1,\n'$clusterTime': {\nclusterTime: Timestamp({ t: 1666778080, i: 1 }),\nsignature: {\nhash: Binary(Buffer.from(\"0000000000000000000000000000000000000000\", \"hex\"), 0),\nkeyId: Long(\"0\")\n}\n},\noperationTime: Timestamp({ t: 1666778080, i: 1 })\n}\n</code></pre> <p>Una vez que ya hemos arrancando todo, podemos conectarnos a nuestro conjunto de r\u00e9plica mediante <code>mongosh</code> (si no le pasamos ning\u00fan par\u00e1metro, se conecta autom\u00e1ticamente a <code>localhost</code> y al puerto 27017). Dentro del shell, los comandos que trabajan con r\u00e9plicas comienzan por el prefijo <code>rs</code>. Por ejemplo, mediante <code>rs.help()</code> obtendremos la ayuda de los m\u00e9todos disponibles:</p> <pre><code>&gt; mongosh\niabdrs [direct: primary] test&gt; rs.help()\nReplica Set Class:\n\ninitiate                                   Initiates the replica set.\n    config                                     Returns a document that contains the current replica set configuration.\n    conf                                       Calls replSetConfig\n    reconfig                                   Reconfigures an existing replica set, overwriting the existing replica set configuration.\n    reconfigForPSASet                          Reconfigures an existing replica set, overwriting the existing replica set configuration, if the reconfiguration is a transition from a Primary-Arbiter to a Primary-Secondary-Arbiter set.\n    status                                     Calls replSetGetStatus\n    isMaster                                   Calls isMaster\n    hello                                      Calls hello\n    printSecondaryReplicationInfo              Calls db.printSecondaryReplicationInfo\n    printSlaveReplicationInfo                  DEPRECATED. Use rs.printSecondaryReplicationInfo\n    printReplicationInfo                       Calls db.printReplicationInfo\n    add                                        Adds replica set member to replica set.\n    addArb                                     Calls rs.add with arbiterOnly=true\nremove                                     Removes a replica set member.\n    freeze                                     Prevents the current member from seeking election as primary for a period of time. Uses the replSetFreeze command\nstepDown                                   Causes the current primary to become a secondary which forces an election. If no stepDownSecs is provided, uses 60 seconds. Uses the replSetStepDown command\nsyncFrom                                   Sets the member that this replica set member will sync from, overriding the default sync target selection logic.\n    secondaryOk                                This method is deprecated. Use db.getMongo().setReadPref() instead\n\nFor more information on usage: https://docs.mongodb.com/manual/reference/method/js-replication/\n</code></pre> <p>La pr\u00f3xima vez que lancemos las r\u00e9plicas ya no deberemos configurarlas. As\u00ed pues, el proceso de enlazar e iniciar las r\u00e9plicas s\u00f3lo se realiza una vez.</p>"},{"location":"sa/06replicacion.html#trabajando-con-las-replicas","title":"Trabajando con las r\u00e9plicas","text":"<p>Una vez que hemos visto que las tres r\u00e9plicas est\u00e1n funcionando, vamos a comprobar c\u00f3mo podemos trabajar con ellas.</p> <p>Ya hemos comprobado c\u00f3mo al conectarnos al cl\u00faster, nos aparece como s\u00edmbolo del shell el nombre del conjunto de la r\u00e9plica seguido de dos puntos y <code>primary</code> si nos hemos conectado al nodo principal, o <code>secondary</code> en caso contrario.</p> <pre><code>iabdrs [direct: primary] test&gt; </code></pre> <p>Para saber si nos hemos conectado al nodo correcto, mediante <code>db.hello()</code> obtendremos el tipo del nodo (propiedad <code>isWritablePrimary</code>) e informaci\u00f3n sobre el resto de nodos (antes se utilizaba el m\u00e9todo <code>isMaster</code> el cual se ha marcado como deprecated):</p> <pre><code>iabdrs [direct: primary] test&gt; db.hello()\n{\ntopologyVersion: {\nprocessId: ObjectId(\"635a9dbbc752fabab79400d6\"),\ncounter: Long(\"6\")\n},\nhosts: [ 'mongo1:27017', 'mongo2:27017', 'mongo3:27017' ],\nsetName: 'iabdrs',\nsetVersion: 1,\nisWritablePrimary: true,\nsecondary: false,\nprimary: 'mongo1:27017',\nme: 'mongo1:27017',\nelectionId: ObjectId(\"7fffffff0000000000000001\"),\nlastWrite: {\nopTime: { ts: Timestamp({ t: 1666883479, i: 1 }), t: Long(\"1\") },\nlastWriteDate: ISODate(\"2022-10-27T15:11:19.000Z\"),\nmajorityOpTime: { ts: Timestamp({ t: 1666883479, i: 1 }), t: Long(\"1\") },\nmajorityWriteDate: ISODate(\"2022-10-27T15:11:19.000Z\")\n},\nmaxBsonObjectSize: 16777216,\nmaxMessageSizeBytes: 48000000,\nmaxWriteBatchSize: 100000,\nlocalTime: ISODate(\"2022-10-27T15:11:20.366Z\"),\nlogicalSessionTimeoutMinutes: 30,\nconnectionId: 48,\nminWireVersion: 0,\nmaxWireVersion: 17,\nreadOnly: false,\nok: 1,\n'$clusterTime': {\nclusterTime: Timestamp({ t: 1666883479, i: 1 }),\nsignature: {\nhash: Binary(Buffer.from(\"0000000000000000000000000000000000000000\", \"hex\"), 0),\nkeyId: Long(\"0\")\n}\n},\noperationTime: Timestamp({ t: 1666883479, i: 1 })\n}\n</code></pre> <p>Ahora que sabemos que estamos en el nodo principal, vamos a a\u00f1adir datos.</p> <p>Para ello, vamos a insertar 1.000 documentos en la colecci\u00f3n <code>pruebas</code>:</p> <pre><code>for (i=0; i&lt;1000; i++) {\ndb.pruebas.insertOne({num: i})\n}\n</code></pre> <p>Estos 1.000 documentos se han insertado en el nodo principal, y se han replicado a los secundarios. Para comprobar la replicaci\u00f3n, abrimos un nuevo terminal y nos conectamos a un nodo secundario:</p> <pre><code>$ mongosh --port 27018\niabdrs [direct: secondary] test&gt;\n</code></pre> <p>Si desde el nodo secundario intentamos consultar el total de documentos de la colecci\u00f3n obtendremos un error:</p> <pre><code>iabdrs [direct: secondary] test&gt; db.pruebas.countDocuments()\nMongoServerError: not primary and secondaryOk=false - consider using db.getMongo().setReadPref() or readPreference in the connection string\n</code></pre> <p>El error indica que no somos un nodo primario y por lo tanto no podemos leer de \u00e9l. Para permitir lecturas en los nodos secundarios, mediante <code>db.getMongo().setReadPref('secondary')</code> le decimos a <code>mongosh</code> que sabemos que nos hemos conectado a un secundario y admitimos la posibilidad de obtener datos obsoletos.</p> <pre><code>iabdrs [direct: secondary] test&gt; db.getMongo().setReadPref('secondary')\niabdrs [direct: secondary] test&gt; db.pruebas.countDocuments()\n1000\n</code></pre> <p>Pero que podamos leer no significa que podamos escribir. Si intentamos escribir en un nodo secundario obtendremos un error:</p> <pre><code>iabdrs [direct: secondary] test&gt; db.pruebas.insertOne({num : 1001})\nMongoServerError: not primary\n</code></pre>"},{"location":"sa/06replicacion.html#preferencias-de-lectura","title":"Preferencias de lectura","text":"<p>En el ejemplo anterior hemos visto c\u00f3mo hemos cambiado las preferencias de lectura para permitir hacerlo desde los nodos secundarios. As\u00ed pues, las preferencias de lectura definen el modo en el que MongoDB enruta las lecturas realizadas a los miembros del conjunto de r\u00e9plicas.</p> Preferencias de lectura <p>Por defecto, las aplicaciones dirigen las operaciones de consulta al miembro principal (con el modo de lectura <code>primary</code>, el cual es el modo por defecto). Pero los clientes puede indicar otras preferencias:</p> <ul> <li><code>primaryPreferred</code>: si est\u00e1 disponible, las lecturas se realizan en el nodo primario, pero si no estuviera en pie, habilita las lecturas de los secundarios.</li> <li><code>secondary</code>: todas las operaciones de lectura se realizan en nodos secundarios.</li> <li><code>secondaryPreferred</code>: primero prueba con los secundarios, y si no hay ninguno disponible, la lectura la realiza del primario.</li> <li><code>nearest</code>: las lecturas se realizan del nodo m\u00e1s cercano en base a la latencia, independientemente que el nodo sea primario o secundario.</li> </ul> <p>Para indicar la preferencia de lectura, ya hemos visto que lo haremos con la funci\u00f3n Mongo.setReadPref():</p> <pre><code>iabdrs [direct: secondary] test&gt; db.getMongo().setReadPref('nearest')\n</code></pre>"},{"location":"sa/06replicacion.html#consistencia-en-la-escritura","title":"Consistencia en la escritura","text":"<p>Por defecto, tanto las lecturas como las escrituras se realizan de manera predeterminada en el nodo principal.</p> <p>Las aplicaciones pueden decidir que las escrituras vayan al nodo primario pero las lecturas al secundario. Esto puede provocar que haya lecturas caducadas, con datos obsoletos. Este hecho, que en sistemas relacionales es inadmisible, en sistemas NoSQL ofrece como beneficio que podamos escalar el sistema.</p> <p>La replicaci\u00f3n es un proceso as\u00edncrono. En el per\u00edodo de tiempo en el que el sistema de votaci\u00f3n sucede, no se completa ninguna escritura.</p> <p>MongoDB garantiza la consistencia en la escritura (Write Concern), lo que implica que sea un sistema consistente. Para ello, ofrece un mecanismo que garantiza que una escritura ha sido exitosa. Dependiendo del nivel de configuraci\u00f3n de la consistencia, las inserciones, modificaciones y borrados pueden tardar m\u00e1s o menos. Si reducimos el nivel de consistencia, el rendimiento ser\u00e1 mejor, a costa de poder obtener datos obsoletos u perder datos que no se han terminado de serializar en disco. Con un nivel de consistencia m\u00e1s alto, los clientes esperan tras enviar una operaci\u00f3n de escritura a que MongoDB les confirme la operaci\u00f3n.</p> <p>Los valores que podemos configurar se realizan mediante las siguientes opciones:</p> <ul> <li><code>w</code>: indica el n\u00famero de servidores que se han de replicar para que la inserci\u00f3n devuelva un ACK.</li> <li><code>j</code>: indica si las escrituras se tienen que trasladar a un diario de bit\u00e1cora (journal)</li> <li><code>wtimeout</code>: indica el l\u00edmite de tiempo a esperar como m\u00e1ximo, para prevenir que una escritura se bloquee indefinidamente.</li> </ul>"},{"location":"sa/06replicacion.html#niveles-de-consistencia-de-escritura","title":"Niveles de consistencia de escritura","text":"<p>Con estas opciones, podemos configurar diferentes niveles de consistencia son:</p> <ul> <li>Sin confirmaci\u00f3n: <code>w:0</code>, tambi\u00e9n conocido como fire-and-forget, ya que no se espera ning\u00fan tipo de confirmaci\u00f3n.</li> <li>Con confirmaci\u00f3n: <code>w:1</code>, el cual es el modo por defecto, y s\u00f3lo espera confirmaci\u00f3n del nodo principal.</li> <li>Con diario: <code>w:1</code>, <code>j:true</code>. Cada inserci\u00f3n primero se escribe en el diario y posteriormente en el directorio de datos.</li> <li>Con confirmaci\u00f3n de la mayor\u00eda: <code>w: \"majority\"</code>, es decir, confirman la mitad + 1 de los nodos de la r\u00e9plica. Hasta que no han confirmado todos los nodos secundarios necesarios, el principal no env\u00eda el ACK a la aplicaci\u00f3n cliente.</li> </ul> Consistencia en la escritura con confirmaci\u00f3n de la mayor\u00eda <p>Estas opciones se indican como par\u00e1metro final en las operaciones de inserci\u00f3n y modificaci\u00f3n de datos. Por ejemplo:</p> <pre><code>db.pruebas.insertOne(\n{num : 1002},\n{writeConcern: {w: \"majority\", wtimeout: 5000}}\n)\n</code></pre> <p>En resumen, a mayor cantidad de nodos, mayor es la tolerancia a fallos pero cada operaci\u00f3n necesita m\u00e1s tiempo y recursos para realizar la persistencia de los datos.</p>"},{"location":"sa/06replicacion.html#consistencia-en-la-lectura","title":"Consistencia en la lectura","text":"<p>De igual manera que podemos decidir en cuantos nodos se deben propagar las escrituras, podemos indicar cuantos nodos debemos leer para dar un dato como v\u00e1lido. Para ello, MongoDB da soporte a diferentes niveles de consistencia en la lectura (Read Concern):</p> <ul> <li><code>local</code>: devuelve el dato m\u00e1s reciente en el cluster. Cualquier dato que haya sido escrito en el nodo primario puede ser elegido para devolverse. Sin embargo, no se garantiza que este dato sea replicado a los miembros del conjunto en caso de fallo. Este es el nivel por defecto en las operaciones de lectura contra el nodo primario.</li> <li><code>available</code>: equivalente de <code>local</code> cuando las operaciones de lectura se efect\u00faan contra un nodo secundario.</li> <li><code>majority</code>: \u00fanicamente devuelve datos que hayan sido confirmados en una mayor\u00eda de nodos dentro del conjunto.</li> <li><code>linearizable</code>: devuelve datos que hayan sido confirmados por una mayor\u00eda de nodos, pero permite al desarrollador establecer su propia funcionalidad.</li> <li><code>snapshot</code>: s\u00f3lo disponible para transacciones multi-documento, realiza una \"foto\" de los datos al inicio de la transacci\u00f3n.</li> </ul> <p>Imaginemos un escenario en el cual recibimos la confirmaci\u00f3n de escritura desde el nodo primario. Inmediatamente efectuamos una operaci\u00f3n de lectura, el nodo devuelve el dato, pero \u00e9ste nodo falla antes de replicar la operaci\u00f3n de escritura a los nodos secundarios. Sobre esta operaci\u00f3n se efectuar\u00e1 un proceso de rollback en el momento que el nodo primario vuelva a estar disponible, por lo que ese dato realmente no existir\u00e1 en el conjunto replicado. Es decir, la aplicaci\u00f3n actualmente tiene un dato que no existe en el conjunto de r\u00e9plicas.</p> <p>Mediante la consistencia en la lectura, podemos obtener unas m\u00ednimas garant\u00edas de que el dato que estamos leyendo es correcto y durable. Cuando se utiliza, \u00fanicamente devolver\u00e1 datos cuya grabaci\u00f3n haya sido confirmada por el n\u00famero de nodos especificados en sus opciones. Se puede escoger entre devolver el dato m\u00e1s reciente que exista en el cl\u00faster, o el dato recibido por una mayor\u00eda de miembros en el cluster.</p> <p>El hecho de que un documento no se considere correcto, no quiere decir necesariamente que se haya perdido, sino que en el momento de su lectura, no ha cumplido las condiciones necesarias de durabilidad para ser devuelto. Puede ser que la lectura se est\u00e9 produciendo antes de que el dato haya sido propagado al n\u00famero m\u00ednimo de nodos necesario, y por eso no se obtenga, pero en lecturas sucesivas s\u00ed pueda aparecer.</p>"},{"location":"sa/06replicacion.html#tolerancia-a-fallos","title":"Tolerancia a fallos","text":"<p>Cuando un nodo primario no se comunica con otros miembros del conjunto durante m\u00e1s de 10 segundos, el conjunto de r\u00e9plicas intentar\u00e1, de entre los secundarios, que otro miembro se convierta en el nuevo primario.</p> <p>Para ello se realiza un proceso de votaci\u00f3n, de modo que el nodo que obtenga el mayor n\u00famero de votos se erigir\u00e1 en primario. Este proceso de votaci\u00f3n se realiza bastante r\u00e1pido (menos de 3 segundos), durante el cual no existe ning\u00fan nodo primario y por tanto la r\u00e9plica no acepta escrituras y todos los miembros se convierten en nodos de s\u00f3lo-lectura.</p> Elecci\u00f3n de un nuevo primario"},{"location":"sa/06replicacion.html#proceso-de-votacion","title":"Proceso de votaci\u00f3n","text":"<p>Cuando un nodo secundario no puede contactar con su nodo primario, contactar\u00e1 con el resto de miembros y les indicar\u00e1 que quiere ser elegido como primario. Es decir, cada nodo que no encuentre un primario se nominar\u00e1 como posible primario, de modo que un nodo no nomina a otro a ser primario, \u00fanicamente vota sobre una nominaci\u00f3n ya existente.</p> <p>Antes de dar su voto, el resto de nodos comprobar\u00e1n:</p> <ul> <li>si ellos tienen conectividad con el primario</li> <li>si el nodo que solicita ser primario tienen una r\u00e9plica actualizada de los datos. Todas las operaciones replicadas est\u00e1n ordenadas por el timestamp ascendentemente, de modo que los candidatos deben tener operaciones posteriores o iguales a cualquier miembro con el que tengan conectividad.</li> <li>si existe alg\u00fan nodo con una prioridad mayor que deber\u00eda ser elegido.</li> </ul> <p>Si alg\u00fan miembro que quiere ser primario recibe una mayor\u00eda de \"s\u00eds\" se convertir\u00e1 en el nuevo primario, siempre y cuando no haya un servidor que vete la votaci\u00f3n. Si un miembro la veta es porque conoce alguna raz\u00f3n por la que el nodo que quiere ser primario no deber\u00eda serlo, es decir, ha conseguido contactar con el antiguo primario.</p> <p>Una vez un candidato recibe una mayor\u00eda de \"s\u00eds\", su estado pasar\u00e1 a ser primario.</p>"},{"location":"sa/06replicacion.html#configuracion-recomendada","title":"Configuraci\u00f3n recomendada","text":"<p>Cantidad de elementos</p> <p>En la votaci\u00f3n, se necesita una mayor\u00eda de nodos para elegir un primario, ya que una escritura se considera segura cuando ha alcanzado a la mayor\u00eda de los nodos. Esta mayor\u00eda se define como m\u00e1s de la mitad de todos los nodos del conjunto. Hay que destacar que la mayor\u00eda no se basa en los elementos que queden en pie o est\u00e9n disponibles, sino en el conjunto definido en la configuraci\u00f3n del conjunto.</p> <p>Se recomiendan dos configuraciones:</p> <ol> <li>Mediante una mayor\u00eda del conjunto en un centro de datos. Este planteamiento es bueno si tenemos un data center donde queremos que siempre se aloje el nodo primario de la r\u00e9plica. Siempre que el centro de datos funcione normalmente, habr\u00e1 un nodo primario. Sin embargo, si el centro primario pierde la conectividad, el centro de datos secundario no podr\u00e1 elegir un nuevo primario.</li> <li>Mediante el mismo n\u00famero de servidores en cada centro de datos, m\u00e1s un servidor que rompe la igualdad en una tercera localizaci\u00f3n. Este dise\u00f1o es conveniente cuando ambos centros de datos tienen el mismo grado de confiabilidad y robustez.</li> </ol>"},{"location":"sa/06replicacion.html#comprobando-la-tolerancia","title":"Comprobando la tolerancia","text":"<p>Para comprobar la tolerancia a fallos, desde el nodo primario vamos a detenerlo:</p> <p>Si nos hemos conectados desde dentro del contenedor a <code>localhost</code> con la opci\u00f3n <code>--host \"127.0.0.1</code>, vamos a poder detenerlo mediante el comando <code>shutdown</code>:</p> <pre><code>iabdrs [direct: primary] test&gt; db.adminCommand({\"shutdown\" : 1})\n</code></pre> <p>Otra posibilidad en vez de detenerlo es degradarlo a nodo secundario mediante rs.stepDown() y forzar un proceso de votaci\u00f3n entre el resto de nodos:</p> <pre><code>iabdrs [direct: primary] test&gt; rs.stepDown()\n{\nok: 1,\n  '$clusterTime': {\nclusterTime: Timestamp({ t: 1666885736, i: 1 }),\n    signature: {\nhash: Binary(Buffer.from(\"0000000000000000000000000000000000000000\", \"hex\"), 0),\n      keyId: Long(\"0\")\n}\n},\n  operationTime: Timestamp({ t: 1666885736, i: 1 })\n}\niabdrs [direct: secondary] test&gt;\n</code></pre> <p>Si pasamos al shell del antiguo nodo secundario, y le preguntamos si es el principal, veremos que ahora indica que la propiedad <code>isWritablePrimary</code> es <code>true</code> y que ahora el primary es <code>mongo2:27017</code>:</p> <pre><code>iabdrs [direct: primary] test&gt; rs.hello()\n{\ntopologyVersion: {\nprocessId: ObjectId(\"635ab0cb3f36955c651fa584\"),\ncounter: Long(\"7\")\n},\nhosts: [ 'mongo1:27017', 'mongo2:27017', 'mongo3:27017' ],\nsetName: 'iabdrs',\nsetVersion: 1,\nisWritablePrimary: true,\nsecondary: false,\nprimary: 'mongo2:27017',\nme: 'mongo2:27017',\n...\n</code></pre>"},{"location":"sa/06replicacion.html#recuperacion-del-sistema","title":"Recuperaci\u00f3n del sistema","text":"<p>Si en un conjunto de r\u00e9plicas se cae el primario y hay escrituras que se han pasado al <code>oplog</code> y tenemos que otros nodos no las han replicado, cuando el nodo primario vuelva en s\u00ed como secundario y se sincronice con el nuevo primario, se dar\u00e1 cuenta que hay operaciones de escritura pendientes y las pasar\u00e1 a rollback, para que si se desean se apliquen manualmente.</p> <p>Para evitar este escenario, se necesita emplear consistencia en la escritura, de manera que hasta que la escritura no se haya replicado en la mayor\u00eda de los nodos no se considere como una escritura exitosa.</p>"},{"location":"sa/06replicacion.html#particionado","title":"Particionado","text":"<p>Ya vimos en la primera sesi\u00f3n que dentro del entorno de las bases de datos, particionar consiste en dividir los datos entre m\u00faltiples m\u00e1quinas. Al poner un subconjunto de los datos en cada m\u00e1quina, vamos a poder almacenar m\u00e1s informaci\u00f3n y soportar m\u00e1s carga sin necesidad de m\u00e1quinas m\u00e1s potentes, sino una mayor cantidad de m\u00e1quinas m\u00e1s modestas (y mucho m\u00e1s baratas).</p> <p>El Sharding es una t\u00e9cnica que fragmenta los datos de la base de datos horizontalmente agrup\u00e1ndolos de alg\u00fan modo que tenga sentido y que permita un direccionamiento m\u00e1s r\u00e1pido.</p> Sharding <p>Por lo tanto, estos shards (fragmentos) pueden estar localizados en diferentes bases de datos y localizaciones f\u00edsicas.</p> <p>El Sharding no tiene por qu\u00e9 estar basado \u00fanicamente en una colecci\u00f3n y un campo, puede ser a nivel de todas las colecciones. Por ejemplo podr\u00edamos decir \"todos los datos de usuarios cuyo perfil est\u00e9 en los Estados Unidos los redirigimos a la base de datos del servidor en Estados Unidos, y todos los de Asia van a la base de datos de Asia\".</p> <p>MongoDB implementa el sharding de forma nativa y autom\u00e1tica (de ah\u00ed el t\u00e9rmino de auto-sharding), siguiendo un enfoque basado en rangos.</p> <p>Para ello, divide una colecci\u00f3n entre diferentes servidores, utilizando <code>mongos</code> como router de las peticiones entre los sharded clusters. Esto favorece que el desarrollador ignore que la aplicaci\u00f3n no se comunica con un \u00fanico servidor, balanceando de manera autom\u00e1tica los datos y permitiendo incrementar o reducir la capacidad del sistema a conveniencia.</p> <p>Paciencia...</p> <p>Antes de plantearse hacer auto-sharding sobre nuestros datos, es conveniente dominar c\u00f3mo se trabaja con MongoDB y el uso de conjuntos de r\u00e9plica.</p>"},{"location":"sa/06replicacion.html#sharded-cluster","title":"Sharded Cluster","text":"<p>El particionado de MongoDB permite crear un cluster de muchas m\u00e1quinas, dividiendo a nivel de colecci\u00f3n y poniendo un subconjunto de los datos de la colecci\u00f3n en cada uno de los fragmentos.</p> <p>Los componentes de un sharded cluster son:</p> <ul> <li>Shards (Fragmentos): Cada una de las m\u00e1quinas del cluster, que almacena un subconjunto de los datos de la colecci\u00f3n. Cada shard es una instancia de mongod o un conjunto de r\u00e9plicas. En un entorno de producci\u00f3n, todos los shards son conjuntos de r\u00e9plica.</li> <li> <p>Servidores de Configuraci\u00f3n: Cada servidor de configuraci\u00f3n es una instancia de <code>mongod</code> que almacena metadatos sobre el cluster. Los metadatos mapean los trozos con los shards, definiendo qu\u00e9 rangos de datos definen un trozo (chunk) de la colecci\u00f3n, y qu\u00e9 trozos se encuentran en un determinado shard.     En entornos de producci\u00f3n se aconseja tener 3 servidores de configuraci\u00f3n (uno primario y dos secundarios) ya que si s\u00f3lo tuvi\u00e9semos uno, al producirse una ca\u00edda el cluster quedar\u00eda inaccesible.</p> </li> <li> <p>Enrutadores: Cada router es una instancia <code>mongos</code> que enruta las lecturas y escrituras de las aplicaciones a los shards. Las aplicaciones no acceden directamente a los shards, sino al router. Estos enrutadores funcionan de manera similar a una tabla de contenidos, indic\u00e1ndonos d\u00f3nde se encuentran los datos. Una vez recopilados los datos de los diferentes shards, se fusionan y se encarga de devolverlos a la aplicaci\u00f3n.</p> <p>En entornos de producci\u00f3n es com\u00fan tener varios routers para balancear la carga de los clientes.</p> </li> </ul> Componentes de un Sharded cluster <p>Autoevaluaci\u00f3n</p> <p>Supongamos que queremos ejecutar m\u00faltiples routers <code>mongos</code> para soportar la redundancia. \u00bfQu\u00e9 elemento asegurar\u00e1 la tolerancia a fallos y cambiar\u00e1 de un <code>mongos</code> a otro dentro de tu aplicaci\u00f3n? 1</p> <ul> <li><code>mongod</code></li> <li><code>mongos</code></li> <li>Driver</li> <li>Los servidores de configuraci\u00f3n de sharding</li> </ul>"},{"location":"sa/06replicacion.html#shard-key","title":"Shard key","text":"<p>Para que MongoDB sepa c\u00f3mo dividir una colecci\u00f3n entre rangos no solapados hay que elegir una shard key, normalmente el identificador del documento, por ejemplo, <code>student_id</code>. Este identificador (o su hash) es la clave del chunk (por lo hace la misma funci\u00f3n que una clave primaria).</p> <p>La shard key puede ser un campo sencillo o compuesto el cual debe estar indexado, y que va a determinar la distribuci\u00f3n de los documentos entre los fragmentos del cl\u00faster.</p> Fragmentaci\u00f3n por la shard-key <p>Para las b\u00fasquedas, borrados y actualizaciones, al emplear la shard key, <code>mongos</code> sabe a que shard enviar la petici\u00f3n. En cambio, si la operaci\u00f3n no la indica, se har\u00e1 un broadcast a todas los shards para averiguar donde se encuentra.</p> <p>Entre los aspectos a tener en cuenta a la hora de elegir una shard key cabe destacar que debe:</p> <ul> <li>Tener una alta cardinalidad, para asegurar que los documentos puedan dividirse en los distintos fragmentos. Por ejemplo, si elegimos un shard key que solo tiene 3 valores posibles y tenemos 5 fragmentos, MongoDB no sabr\u00e1 como separar los documentos en los 5 fragmentos. Cuantos m\u00e1s valores posibles pueda tener la clave de fragmentaci\u00f3n, m\u00e1s eficiente ser\u00e1 la divisi\u00f3n de los trozos entre los fragmentos disponibles.</li> <li>Tener un alto nivel de aleatoriedad. Si utilizamos una clave que siga un patr\u00f3n incremental como una fecha o un ID, conllevar\u00e1 que al insertar documentos, el mismo fragmento estar\u00e1 siendo utilizando constantemente durante el rango de valores definido para \u00e9l. Esto provoca que los datos est\u00e9n separados de una manera \u00f3ptima, pero pondr\u00e1 siempre bajo estr\u00e9s a un fragmento en per\u00edodos de tiempo mientras que los otros posiblemente queden con muy poca actividad (comportamiento conocido como hotspotting).     Una soluci\u00f3n a las claves que siguen patrones incrementales es aplicar una funci\u00f3n hash y crear una clave hasheada que si tiene un alto nivel de aleatoriedad.</li> <li>Considerar los patrones de las consultas, ya que si elegimos una buena clave, al realizar consultas por la clave, todos los datos se encontrar\u00e1n en el mismo fragmento.</li> </ul>"},{"location":"sa/06replicacion.html#particionado-con-docker","title":"Particionado con Docker","text":"<p>Para este caso, vamos a crear dos conjuntos de r\u00e9plicas de dos nodos cada una, y a su vez, particionaremos los datos en dos shards.</p> <p>Adem\u00e1s, vamos a a\u00f1adir un \u00fanico router y un servidor de configuraci\u00f3n (aunque lo ideal ser\u00eda crear un conjunto de r\u00e9plicas de servidores de configuraci\u00f3n).</p> <p>As\u00ed pues, crearemos:</p> <ul> <li>un contenedor para el router (<code>router1</code>) el cual ejecuta el servicio <code>mongos</code> y que va a conectar con el servidor de configuraci\u00f3n.</li> <li>un contenedor para el servidor de configuraci\u00f3n (<code>configsvr1</code>) indic\u00e1ndole mediante el par\u00e1metro <code>--configsvr</code> su prop\u00f3sito, as\u00ed como la r\u00e9plica a la que pertenece (todo servidor de configuraci\u00f3n debe pertenecer a una r\u00e9plica, aunque en nuestro caso s\u00f3lo hemos creado uno)</li> <li>dos nodos (<code>mongo-shard1a</code> y <code>mongo-shard1b</code>) para el primer shard (par\u00e1metro <code>--shardsvr</code>) que pertenecen al conjunto de r\u00e9plicas <code>iabdshard1</code>.</li> <li>dos nodos m\u00e1s (<code>mongo-shard2a</code> y <code>mongo-shard2b</code>) para el segundo shard (par\u00e1metro <code>--shardsvr</code>) que pertenecen al conjunto de r\u00e9plicas <code>iabdshard2</code>.</li> </ul> <p>Para ello, hemos definido el archivo docker-compose-replicaset-sharded.yml con la definici\u00f3n de los contenedores:</p> docker-compose-replicaset-sharded.yml<pre><code>services:\nrouter1:\ncontainer_name: router1\nimage: mongo\nvolumes:\n- ./router-init.js:/scripts/router-init.js\nnetworks:\n- mongo-network-sharded\nports:\n- 27117:27017\nentrypoint: [ \"/usr/bin/mongos\", \"--port\", \"27017\", \"--configdb\", \"rs-config-server/configsvr1:27017\", \"--bind_ip_all\" ]\nconfigsvr1:\ncontainer_name: configsvr1 image: mongo\nvolumes:\n- ./configserver-init.js:/scripts/configserver-init.js\nnetworks:\n- mongo-network-sharded\nports:\n- 27118:27017\nentrypoint: [ \"/usr/bin/mongod\", \"--port\", \"27017\", \"--configsvr\", \"--replSet\", \"rs-config-server\", \"--bind_ip_all\" ]\nlinks:\n- mongo-shard1a\n- mongo-shard2a\nmongo-shard1a:\ncontainer_name: mongo-shard1a\nimage: mongo\nvolumes:\n- ./shard1-init.js:/scripts/shard1-init.js\nnetworks:\n- mongo-network-sharded\nports:\n- 27119:27017\nentrypoint: [ \"/usr/bin/mongod\", \"--port\", \"27017\", \"--shardsvr\", \"--bind_ip_all\", \"--replSet\", \"iabdshard1\" ]\nmongo-shard1b:\ncontainer_name: mongo-shard1b\nimage: mongo\nnetworks:\n- mongo-network-sharded\nports:\n- 27120:27017\nentrypoint: [ \"/usr/bin/mongod\", \"--port\", \"27017\", \"--shardsvr\", \"--bind_ip_all\", \"--replSet\", \"iabdshard1\" ]\nmongo-shard2a:\ncontainer_name: mongo-shard2a\nimage: mongo\nvolumes:\n- ./shard2-init.js:/scripts/shard2-init.js\nnetworks:\n- mongo-network-sharded\nports:\n- 27121:27017\nentrypoint: [ \"/usr/bin/mongod\", \"--port\", \"27017\", \"--shardsvr\", \"--bind_ip_all\", \"--replSet\", \"iabdshard2\" ]\nmongo-shard2b:\ncontainer_name: mongo-shard2b\nimage: mongo\nnetworks:\n- mongo-network-sharded\nports:\n- 27122:27017\nentrypoint: [ \"/usr/bin/mongod\", \"--port\", \"27017\", \"--shardsvr\", \"--bind_ip_all\", \"--replSet\", \"iabdshard2\" ]\nnetworks:\nmongo-network-sharded:\ndriver: bridge\n</code></pre> <p>Y lanzamos los contenedores mediante docker-compose:</p> <pre><code>docker-compose --file docker-compose-replicaset-sharded.yml --project-name iabd-mongodb-replica-sharded up -d\n</code></pre>"},{"location":"sa/06replicacion.html#inicializar-los-servidores-de-configuracion","title":"Inicializar los servidores de configuraci\u00f3n","text":"<p>El primer paso es inicializar los servidores de configuraci\u00f3n mediante el script <code>configserver-init.js</code>:</p> configserver-init.js<pre><code>rs.initiate({_id: \"rs-config-server\", configsvr: true, version: 1, members: [ { _id: 0, host : 'configsvr1:27017' } ] })\n</code></pre> <p>Y lo lanzamos:</p> <pre><code>docker exec configsvr1 sh -c \"mongosh &lt; /scripts/configserver-init.js\"\n</code></pre>"},{"location":"sa/06replicacion.html#configurar-el-conjunto-de-replicas","title":"Configurar el conjunto de r\u00e9plicas","text":"<p>Para cada uno de los conjuntos de r\u00e9plicas (<code>iabdshard1</code> y <code>iabdshard2</code>) que van a contener los datos, hemos de configurar sus nodos, haciendo uso de los scripts <code>shard1-init.js</code> y <code>shard2-init.js</code>:</p> shard1-init.js<pre><code>rs.initiate(\n{\n_id: \"iabdshard1\",\nversion: 1,\nmembers: [\n{ _id: 0, host : \"mongo-shard1a:27017\" },\n{ _id: 1, host : \"mongo-shard1b:27017\" },\n]\n}\n)\n</code></pre> shard2-init.js<pre><code>rs.initiate(\n{\n_id: \"iabdshard2\",\nversion: 1,\nmembers: [\n{ _id: 0, host : \"mongo-shard2a:27017\" },\n{ _id: 1, host : \"mongo-shard2b:27017\" },\n]\n}\n)\n</code></pre> <p>E inicializamos los conjunto de r\u00e9plicas:</p> <pre><code>docker exec mongo-shard1a sh -c \"mongosh &lt; /scripts/shard1-init.js\"\ndocker exec mongo-shard2a sh -c \"mongosh &lt; /scripts/shard2-init.js\"\n</code></pre>"},{"location":"sa/06replicacion.html#configurar-el-router","title":"Configurar el router","text":"<p>Finalmente, configuramos el router a partir del script <code>router-init.js</code> donde estamos indic\u00e1ndole al router qu\u00e9 nodos forman parte del particionado:</p> router-init.js<pre><code>sh.addShard(\"iabdshard1/mongo-shard1a:27017\")\nsh.addShard(\"iabdshard1/mongo-shard1b:27017\")\nsh.addShard(\"iabdshard2/mongo-shard2a:27017\")\nsh.addShard(\"iabdshard2/mongo-shard2b:27017\")\n</code></pre> <p>Y lo ejecutamos:</p> <pre><code>docker exec router1 sh -c \"mongosh &lt; /scripts/router-init.js\"\n</code></pre> <p>sh</p> <p>De manera similar que hemos visto que con el conjunto de r\u00e9plicas se emplean el prefijo <code>rs</code>, para interactuar con los componentes implicados en el sharding se emplea <code>sh</code>, pero \u00fanicamente desde el nodo que hace de router. Por ejemplo, mediante <code>sh.help()</code> obtendremos la ayuda de los m\u00e9todos disponibles.</p>"},{"location":"sa/06replicacion.html#conexion-al-router","title":"Conexi\u00f3n al router","text":"<p>El router es un nodo de MongoDB que se va a encargar de aceptar las peticiones de los clientes y enrutarlas al shard adecuado. Para ello, podemos:</p> <ul> <li> <p>Conectarnos al contenedor y abrimos un terminal y veremos como en el prompt aparece <code>mongos</code>:</p> <pre><code>docker exec -it router1 bash\nmongosh\n[direct: mongos] test&gt; </code></pre> </li> <li> <p>O abrir directamente un sesi\u00f3n al puerto 27117, que es donde hab\u00edamos colocado nuestro router:</p> <pre><code>mongosh 127.0.0.1:27117\n[direct: mongos] test&gt;\n</code></pre> </li> </ul> <p>Si comprobamos el estado del shard veremos que tenemos dos shards, cada uno replicado en dos nodos, con sus identificadores y hosts:</p> <pre><code>[direct: mongos] test&gt; sh.status()\nshardingVersion\n{\n_id: 1,\nminCompatibleVersion: 5,\ncurrentVersion: 6,\nclusterId: ObjectId(\"6363af7bfab6e20f2a7c1409\")\n}\n---\nshards\n[\n{\n_id: 'iabdshard1',\nhost: 'iabdshard1/mongo-shard1a:27017,mongo-shard1b:27017',\nstate: 1,\ntopologyTime: Timestamp({ t: 1667477424, i: 6 })\n},\n{\n_id: 'iabdshard2',\nhost: 'iabdshard2/mongo-shard2a:27017,mongo-shard2b:27017',\nstate: 1,\ntopologyTime: Timestamp({ t: 1667477424, i: 12 })\n}\n]\n...\n</code></pre> <p>En un entorno de producci\u00f3n, en vez de tener dos shards en dos nodos, habr\u00e1 un conjunto de r\u00e9plicas para asegurar la alta disponibilidad. Adem\u00e1s, tendremos tres servidores de configuraci\u00f3n para asegurar la disponibilidad de \u00e9stos. Del mismo modo, habr\u00e1 tantos procesos <code>mongos</code> creados como conexiones de clientes:</p> Sharding en un entorno de Producci\u00f3n"},{"location":"sa/06replicacion.html#habilitando-el-sharding","title":"Habilitando el Sharding","text":"<p>Una vez hemos creado la estructura necesaria para soportar el particionado vamos a insertar un conjunto de datos para posteriormente particionarlos.</p> <p>Para ello, vamos a insertar diez mil usuarios en una colecci\u00f3n:</p> <pre><code>[direct: mongos] test&gt; use iabd\nswitched to db iabd\n[direct: mongos] iabd&gt; for (var i=0; i&lt;10000; i++) {\ndb.usuarios.insertOne({\"login\":\"usuario\" + i, \"nombre\":\"nombre\" + i*2, \"fcreacion\": new Date()},  { writeConcern: { w:\"0\"}});\n}\n</code></pre> <p>Una vez creados, comprobamos que se han insertado:</p> <pre><code>[direct: mongos] iabd&gt; db.usuarios.countDocuments()\n10000\n[direct: mongos] iabd&gt; db.usuarios.findOne()\n{\n_id: ObjectId(\"6363edb79f30da8391b700c4\"),\nlogin: 'usuario0',\nnombre: 'nombre0',\nfcreacion: ISODate(\"2022-11-03T16:35:03.184Z\")\n}\n</code></pre> <p>Como podemos observar, interactuar con <code>mongos</code> es igual a hacerlo con <code>mongosh</code>.</p> <p>Ahora mismo no sabemos en cu\u00e1l de los dos shards se han almacenado los datos. Adem\u00e1s, estos datos no est\u00e1n particionados, es decir residen en s\u00f3lo uno de los shards.</p> <p>Para habilitar el sharding a nivel de base de datos y que los datos se repartan entre los fragmentos disponibles, ejecutaremos el comando <code>sh.enableSharding(&lt;nombreDB&gt;)</code>:</p> <pre><code>[direct: mongos] iabd&gt; sh.enableSharding(\"iabd\")\n{\nok: 1,\n'$clusterTime': {\nclusterTime: Timestamp({ t: 1667493383, i: 1 }),\nsignature: {\nhash: Binary(Buffer.from(\"0000000000000000000000000000000000000000\", \"hex\"), 0),\nkeyId: Long(\"0\")\n}\n},\noperationTime: Timestamp({ t: 1667480498, i: 1 })\n}\n</code></pre> <p>Si volvemos a comprobar el estado del shard, tenemos que se ha creado la nueva base de datos y nos indica cual es su fragmento primario.</p> <pre><code>[direct: mongos] iabd&gt; sh.status()\n...\n---\ndatabases\n[\n{\ndatabase: { _id: 'config', primary: 'config', partitioned: true },\ncollections: {\n'config.system.sessions': {\nshardKey: { _id: 1 },\nunique: false,\nbalancing: true,\nchunkMetadata: [\n{ shard: 'iabdshard1', nChunks: 512 },\n{ shard: 'iabdshard2', nChunks: 512 }\n],\nchunks: [\n'too many chunks to print, use verbose if you want to force print'\n],\ntags: []\n}\n}\n},\n{\ndatabase: {\n_id: 'iabd',\nprimary: 'iabdshard1',\npartitioned: false,\nversion: {\nuuid: new UUID(\"84bce0ad-38a4-4b72-a377-350272542657\"),\ntimestamp: Timestamp({ t: 1667493302, i: 1 }),\nlastMod: 1\n}\n},\ncollections: {}\n}\n]\n</code></pre> <p>Antes de habilitar el sharding para una determinada colecci\u00f3n, tenemos que crear un \u00edndice sobre la shard key (si la colecci\u00f3n estuviera vac\u00eda, no necesitamos crear el \u00edndice, ya que al indicar la shard key, MongoDB autom\u00e1ticamente crear\u00e1 el \u00edndice por nosotros):</p> <pre><code>db.usuarios.createIndex({\"login\": 1})\n</code></pre> <p>Una vez habilitado el shard ya podemos fragmentar la colecci\u00f3n:</p> <pre><code>sh.shardCollection(\"iabd.usuarios\", {\"login\": 1}, false)\n</code></pre> <p>El m\u00e9todo shardCollection particiona una colecci\u00f3n a partir de una shard key, ya sea mediante claves hashes o utilizando rangos. En nuestro caso, al indicarle <code>{\"login\": \"hashed\"}</code> particionar\u00e1 los datos reparti\u00e9ndolos de manera equitativa entre los fragmentos.</p> <p>Para ello, recibe tres par\u00e1metros:</p> <ul> <li>nombre de la colecci\u00f3n, con nomenclatura de <code>nombreBD.nombreColecci\u00f3n</code></li> <li>nombre del campo para fragmentar la colecci\u00f3n, es decir, el shard key. Uno de los requisitos es que esta clave tenga una alta cardinalidad. Si quisi\u00e9ramos indicar que queremos utilizar una clave hasheada, lo har\u00edamos indicando como valor <code>hashed</code>, por ejemplo, <code>{\"login\": \"hashed\"}</code>. Si queremos utilizar rangos, lo indicamos con valor <code>1</code>, por ejemplo, <code>{\"login\": 1}</code>.</li> <li>booleano que indica si el valor utilizado como shard key es \u00fanico. Para ello, el \u00edndice que se crea sobre el campo debe ser del tipo unique.</li> </ul> <p>Este comando divide la colecci\u00f3n en fragmentos (chunks), la cual es la unidad que utiliza MongoDB para mover los datos. Una vez que se ha ejecutado, MongoDB comenzar\u00e1 a balancear la colecci\u00f3n entre los shards del cluster. Este proceso no es instant\u00e1neo. Si la colecci\u00f3n contiene un gran conjunto de datos puede llevar horas completar el balanceo.</p> <p>Si ahora volvemos a comprobar el estado del shard obtendremos:</p> <pre><code>[direct: mongos] iabd&gt; sh.status()\n...\ndatabases\n[\n{\ndatabase: { _id: 'config', primary: 'config', partitioned: true },\n...\n},\n{\ndatabase: {\n_id: 'iabd',\nprimary: 'iabdshard1',\npartitioned: false,\nversion: {\nuuid: new UUID(\"9e694228-600c-4a50-b11c-174f846a3c64\"),\ntimestamp: Timestamp({ t: 1667489404, i: 1 }),\nlastMod: 1\n}\n},\ncollections: {\n'iabd.usuarios': {\nshardKey: { login: 'hashed' }, // (1)!\nunique: false,\nbalancing: true,\nchunkMetadata: [ { shard: 'iabdshard1', nChunks: 1 } ],\nchunks: [               // (2)!\n{ min: { login: MinKey() }, // (3)!\nmax: { login: () },\n'on shard': 'iabdshard1',\n'last modified': Timestamp({ t: 1, i: 0 }) }\n],\ntags: []\n}\n}\n}\n]\n</code></pre> <ol> <li>Muestra que la shard key se basa en rangos</li> <li>la propiedad <code>chunks</code> muestra la cantidad de trozos que alberga cada partici\u00f3n. As\u00ed, pues en este momento tenemos un \u00fanico chunk</li> <li>Para cada uno de los fragmentos se muestra el rango de valores que alberga cada chunk, as\u00ed como en que shard se ubica. Las funciones <code>MinKey()</code> y <code>MinKey()</code> son similares a menos infinito y m\u00e1s infinito, es decir, no hay ning\u00fan valor por debajo ni por encima de ellos. Es decir, indican los topes de la colecci\u00f3n.</li> </ol>"},{"location":"sa/06replicacion.html#trabajando-con-particiones","title":"Trabajando con particiones","text":"<p>En este momento, el shard est\u00e1 creado pero todos los nodos residen en un \u00fanico fragmento dentro de una partici\u00f3n. Para obtener esta informaci\u00f3n, podemos ver el estado del sharding o consultar la distribuci\u00f3n de una colecci\u00f3n mediante el m\u00e9todo <code>getShardDistribution</code>:</p> <pre><code>[direct: mongos] iabd&gt; db.usuarios.getShardDistribution()\nShard iabdshard1 at iabdshard1/mongo-shard1a:27017,mongo-shard1b:27017\n{\ndata: '852KiB',\ndocs: 10000,\nchunks: 1,\n'estimated data per chunk': '852KiB',\n'estimated docs per chunk': 10000\n}\n---\nTotals\n{\ndata: '852KiB',\ndocs: 10000,\nchunks: 1,\n'Shard iabdshard1': [\n'100 % data',\n'100 % docs in cluster',\n'87B avg obj size on shard'\n]\n}\n</code></pre> <p>Vamos a volver a insertar 10.000 usuarios m\u00e1s a ver qu\u00e9 sucede:</p> <pre><code>[direct: mongos] iabd&gt; for (var i=10000; i&lt;20000; i++) {\ndb.usuarios.insertOne({\"login\":\"usuario\" + i, \"nombre\":\"nombre\" + i*2, \"fcreacion\": new Date()},  { writeConcern: { w:\"0\"}});\n}\n[direct: mongos] iabd&gt; db.usuarios.countDocuments()\n20000\n</code></pre> <p>Forzando el split</p> <p>Si al insertar m\u00e1s datos no se reparten los datos de forma autom\u00e1tica, podemos forzarlo mediante las operaciones <code>sh.splitAt</code>, donde le indicamos el valor donde el fragmento en dos, y <code>sh.splitFind</code> que realiza la divisi\u00f3n por la mediana, de manera que ambos fragmentos deber\u00edan ser semejantes.</p> <p>Por ejemplo:</p> <pre><code>sh.splitFind(\"iabd.usuarios\", {\"login\":1})\n</code></pre> <p>Si ahora comprobamos el estado del shard, los datos se deber\u00edan haber repartido entre los shards disponibles:</p> <pre><code>mongos&gt; sh.status()\n{\n...\ncollections: {\n'iabd.usuarios': {\nshardKey: { login: 1 },\nunique: false,\nbalancing: true,\nchunkMetadata: [\n{ shard: 'iabdshard1', nChunks: 1 },\n{ shard: 'iabdshard2', nChunks: 1 }\n],\nchunks: [\n{ min: { login: MinKey() }, max: { login: 'usuario18999' }, 'on shard': 'iabdshard2', 'last modified': Timestamp({ t: 2, i: 0 }) },\n{ min: { login: 'usuario18999' }, max: { login: MaxKey() }, 'on shard': 'iabdshard1', 'last modified': Timestamp({ t: 2, i: 1 }) }\n],\ntags: []\n}\n}\n}\n]\n</code></pre> <p>Si volvemos a comprobar la distribuci\u00f3n, ahora vemos como ha repartido los documentos:</p> <pre><code>[direct: mongos] iabd&gt; db.usuarios.getShardDistribution()\nShard iabdshard1 at iabdshard1/mongo-shard1a:27017,mongo-shard1b:27017\n{\ndata: '1.68MiB',\ndocs: 20000,\nchunks: 1,\n'estimated data per chunk': '1.68MiB',\n'estimated docs per chunk': 20000\n}\n---\nShard iabdshard2 at iabdshard2/mongo-shard2a:27017,mongo-shard2b:27017\n{\ndata: '866KiB',\ndocs: 10000,\nchunks: 1,\n'estimated data per chunk': '866KiB',\n'estimated docs per chunk': 10000\n}\n---\nTotals\n{\ndata: '2.52MiB',\ndocs: 30000,\nchunks: 2,\n'Shard iabdshard1': [\n'66.51 % data',\n'66.66 % docs in cluster',\n'88B avg obj size on shard'\n],\n'Shard iabdshard2': [\n'33.48 % data',\n'33.33 % docs in cluster',\n'88B avg obj size on shard'\n]\n}\n</code></pre>"},{"location":"sa/06replicacion.html#referencias","title":"Referencias","text":"<ul> <li>Replicaci\u00f3n en MongoDB</li> <li>Particionado en MongoDB</li> <li>How to deploy a MongoDB replica set using docker-compose</li> <li>Demo MongoDB (6.0.1) Sharded Cluster with Docker Compose</li> <li>Ejemplos de c\u00f3digo sobre replicaci\u00f3n y particionado.</li> </ul>"},{"location":"sa/06replicacion.html#actividades","title":"Actividades","text":"<ol> <li> <p>(RA5075.2 / CE5.2b, CE5.2c / 2p) Se pide crear una conjunto de 4 r\u00e9plicas de nombre <code>iabdrs4</code> en la cual insertaremos los datos de 1000 ciudades, los cuales deber\u00e1s importar a una base de datos.</p> <p>Una vez creado, se pide:</p> <ol> <li>Obtener el estado del conjunto de r\u00e9plicas</li> <li>Consultar una ciudad en un nodo secundario.</li> <li>Habilitar las lecturas en los nodos secundarios.</li> <li>Volver a consultar la ciudad en el nodo secundario.</li> <li>Insertar una ciudad en el nodo secundario.</li> <li>Degradar el nodo primario</li> <li>Averiguar cual es el nuevo nodo primario.</li> </ol> <p>Adjunta un documento con los scripts de creaci\u00f3n, comandos empleados y las salidas generadas.</p> </li> <li> <p>(RA5075.2 / CE5.2b / 2p) Se pide crear un cl\u00faster de MongoDB con tres nodos y tres particiones y volver a importar las 1000 ciudades.</p> <p>Una vez creado, se pide:</p> <ol> <li>Particionar los datos por el nombre de la ciudad.</li> <li>Una vez cargado los datos, obtener el estado del sharding.</li> <li>Si los datos no est\u00e1n particionados, forzar el split de los mismos.</li> <li>Tras ello, vaciar la colecci\u00f3n y volver a importar los datos. Una vez importados, obtener de nuevo el estado del sharding.</li> </ol> <p>Adjunta un documento con los scripts de creaci\u00f3n, los comandos empleados y las salidas generadas.</p> </li> </ol> <ol> <li> <p>El driver se encarga de manera transparente de conectar al router adecuado, y cambiar un router por otro si al que estamos conectado se cae\u00a0\u21a9</p> </li> </ol>"},{"location":"sa/07pymongo.html","title":"PyMongo","text":"<p>Para acceder a MongoDB desde Python nos vamos a centrar en la librer\u00eda PyMongo.</p> <p>Para instalar la librer\u00eda mediante <code>pip</code> usaremos el comando (recuerda hacerlo dentro de un entorno virtual):</p> <pre><code>pip install pymongo\n</code></pre> <p>Se recomienda consultar la documentaci\u00f3n o el API para cualquier duda o aclaraci\u00f3n.</p> <p>Versi\u00f3n</p> <p>En el momento de escribir los apuntes, estamos utilizando la versi\u00f3n 4.3.2 de PyMongo.</p>"},{"location":"sa/07pymongo.html#hola-pymongo","title":"Hola PyMongo","text":"<p>Un ejemplo b\u00e1sico podr\u00eda ser similar a:</p> <pre><code>from pymongo import MongoClient\ncliente = MongoClient('mongodb://localhost:27017')\niabd_db = cliente.iabd\n# Recuperamos las colecciones\nprint(iabd_db.list_collection_names())\npeople_coll = iabd_db.people\n# Recuperamos una persona\npersona = people_coll.find_one()\nprint(persona)\n</code></pre>"},{"location":"sa/07pymongo.html#mongoclient","title":"MongoClient","text":"<p>A partir de la URI de conexi\u00f3n a MongoDB, hemos de instanciar la clase <code>MongoClient</code>, ya sea pas\u00e1ndole una URI con la cadena de conexi\u00f3n, o mediante par\u00e1metros:</p> <pre><code>uri = \"mongodb+srv://usuario:contrasenya@host\"\ncliente = MongoClient(uri)\n</code></pre> <p>Par\u00e1metros adicionales</p> <p>A la hora de crear el cliente, tambi\u00e9n podemos indicarle diferentes opciones de configuraci\u00f3n:</p> <pre><code>cliente200Retry = MongoClient(uri, connectTimeoutMS=200, retryWrites=True)\n</code></pre> <p>Realmente, al crear la conexi\u00f3n se inicializa un pool de conexiones, de manera que se crean 100 conexiones, y en vez de crear y destruir una conexi\u00f3n por cada petici\u00f3n, se reutilizan, de manera que cada petici\u00f3n asigna y libera una conexi\u00f3n conforme necesidad. Por defecto, el tama\u00f1o del pool es de 100 conexiones.</p> Pool de conexiones <p>Podemos obtener informaci\u00f3n de la conexi\u00f3n mediante la propiedad <code>state</code>. Por ejemplo, en nuestro caso, nos hemos conectado a MongoAtlas y de la salida del estado podemos ver los diferentes hosts que forman parte del conjunto de r\u00e9plicas:</p> <pre><code>cliente = MongoClient('mongodb+srv://iabd:iabdiabd@cluster0.dfaz5er.mongodb.net/')\nprint(cliente.state)\n# Database(MongoClient(host=['ac-opunia9-shard-00-01.dfaz5er.mongodb.net:27017', 'ac-opunia9-shard-00-02.dfaz5er.mongodb.net:27017', 'ac-opunia9-shard-00-00.dfaz5er.mongodb.net:27017'], document_class=dict, tz_aware=False, connect=True, authsource='admin', replicaset='atlas-4wikkb-shard-0', tls=True), 'state')\n</code></pre> <p>Conexi\u00f3n a un r\u00e9plica</p> <p>Si nos queremos conectar a un conjunto de r\u00e9plicas e indicar los nodos a los que nos podemos conectar, podemos separar los hosts con comas e indicar finalmente con un par\u00e1metro el nombre del conjunto de r\u00e9plicas:</p> <pre><code>client = MongoClient('mongodb://usuario1:contra1@host1:puerto1,host2:puerto2/?replicaSet=nombreReplica')\n</code></pre> <p>A partir del cliente, podemos obtener informaci\u00f3n diversa. Por ejemplo, podemos recuperar un listado de las bases de datos mediante <code>list_database_names()</code>:</p> <pre><code>print(cliente.list_database_names())\n# ['sample_airbnb', 'sample_analytics', 'sample_geospatial', 'sample_guides', 'sample_mflix', 'sample_restaurants', 'sample_supplies', 'sample_training', 'sample_weatherdata', 'admin', 'local']\n</code></pre> <p>Para conectarnos a una base de datos en concreto, \u00fanicamente accederemos a ella como una propiedad del cliente:</p> <pre><code>bd = cliente.sample_mflix\nbd = cliente[\"sample_mflix\"] # tb podemos acceder como si fuera un diccionario\n</code></pre> <p>Bases de datos y colecciones Lazy</p> <p>Es conveniente tener en cuenta que tantos las colecciones como las bases de datos se crean y carga de forma perezosa, esto es, hasta que no realizamos una operaci\u00f3n sobre ellas, no se accede realmente a ellas. As\u00ed pues, para crear realmente una colecci\u00f3n, hemos de insertar un documento en ella.</p> <p>Una vez tenemos la base de datos, el siguiente paso es obtener una colecci\u00f3n:</p> <pre><code>coleccion = bd.movies\ncoleccion = bd[\"movies\"] \n</code></pre> <p>Si queremos obtener el nombre de todas las colecciones usaremos el m\u00e9todo <code>list_collection_names()</code>:</p> <pre><code>print(bd.list_collection_names())\n['users', 'movies', 'sessions', 'theaters', 'comments']\n</code></pre> <p>Tolerancia a fallos!</p> <p>Al crear una conexi\u00f3n, conviene especificar el tama\u00f1o del pool y el timeout de las conexiones:</p> <pre><code>db = MongoClient(URI, maxPoolSize=50, wtimeout=2500)[nombreBD]\n</code></pre> <p>Se recomienda siempre especificar un <code>wtimeout</code>, ya que cuando se realiza una escritura con mayor\u00eda de escrituras, si fallase alg\u00fan nodo no se quedar\u00eda colgado esperando.</p> <p>Si no encontrase el servidor, lanzar\u00e1 un <code>ServerSelectionTimeoutError</code> el cual deber\u00edamos capturar.</p>"},{"location":"sa/07pymongo.html#primeras-consultas","title":"Primeras consultas","text":"<p>Finalmente, sobre una colecci\u00f3n ya podemos realizar consultas y otras operaciones:</p> <pre><code>movies = bd.movies\nmovies.count_documents({})\n# 23530\nmovies.find_one()\n# {'_id': ObjectId('573a1390f29313caabcd4135'), 'plot': 'Three men hammer on an anvil and pass a bottle of beer around.', 'genres': ['Short'], 'runtime': 1, 'cast': ['Charles Kayser', 'John Ott'], 'num_mflix_comments': 1, 'title': 'Blacksmith Scene', 'fullplot': 'A stationary ...', 'countries': ['USA'], 'released': datetime.datetime(1893, 5, 9, 0, 0), 'directors': ['William K.L. Dickson'], 'rated': 'UNRATED', 'awards': {'wins': 1, 'nominations': 0, 'text': '1 win.'}, 'lastupdated': '2015-08-26 00:03:50.133000000', 'year': 1893, 'imdb': {'rating': 6.2, 'votes': 1189, 'id': 5}, 'type': 'movie', 'tomatoes': {'viewer': {'rating': 3.0, 'numReviews': 184, 'meter': 32}, 'lastUpdated': datetime.datetime(2015, 6, 28, 18, 34, 9)}}\n</code></pre> <p>Por ejemplo, podemos filtrar las pel\u00edculas cuya actriz sea <code>Salma Hayek</code>. Al realizar la consulta, <code>find</code> devuelve un <code>cursor</code>, el cual podemos recorrer:</p> ConsultaResultado <pre><code>cursor = movies.find( { \"cast\": \"Salma Hayek\" } )\nfor movie in cursor:\nprint(movie)\n</code></pre> <pre><code>{\n'_id': ObjectId('573a1399f29313caabceea6d'),\n'awards': {'nominations': 1, 'text': '1 nomination.', 'wins': 0},\n'cast': ['David Arquette', 'John Hawkes', 'Salma Hayek', 'Jason Wiles'],\n'countries': ['USA'],\n...\n'writers': ['Robert Rodriguez', 'Tommy Nix'],\n'year': 1994\n}\n{'_id': ObjectId('573a139af29313caabcef0b6'),\n'awards': {'nominations': 14, 'text': '27 wins &amp; 14 nominations.', 'wins': 27},\n'cast': ['Ernesto G\u00f3mez Cruz', 'Mar\u00eda Rojo', 'Salma Hayek', 'Bruno Bichir'],\n'countries': ['Mexico'],\n...\n}\n</code></pre> <p>Si queremos contar los documentos que cumplen un criterio, en vez de <code>find</code>, usaremos <code>count_documents</code> pas\u00e1ndole el criterio de filtrado:</p> <pre><code>cantidad = movies.count_documents( { \"cast\": \"Salma Hayek\" } )\n</code></pre> <p>Para seleccionar los campos que queremos recuperar, necesitamos pasar un segundo par\u00e1metro con la proyecci\u00f3n:</p> ConsultaResultado <pre><code>cursor = movies.find( { \"cast\": \"Salma Hayek\" }, { \"title\": 1, \"cast\": 1} )\nfor movie in cursor:\nprint(movie)\n</code></pre> <pre><code>{'_id': ObjectId('573a1399f29313caabceea6d'), 'cast': ['David Arquette', 'John Hawkes', 'Salma Hayek', 'Jason Wiles'], 'title': 'Roadracers'}\n{'_id': ObjectId('573a139af29313caabcef0b6'), 'cast': ['Ernesto G\u00f3mez Cruz', 'Mar\u00eda Rojo', 'Salma Hayek', 'Bruno Bichir'], 'title': 'Midaq Alley'}\n...\n</code></pre> <p>Como ya vimos al hacer consultas en sesiones anterior, si no queremos el campo <code>_id</code>, tenemos que indicarlo:</p> ConsultaResultado <pre><code>cursor = movies.find( { \"cast\": \"Salma Hayek\" }, { \"title\": 1, \"cast\": 1, \"_id\": 0} )\nfor zip in cursor:\nprint(zip)\n</code></pre> <pre><code>{'cast': ['David Arquette', 'John Hawkes', 'Salma Hayek', 'Jason Wiles'], 'title': 'Roadracers'}\n{'cast': ['Ernesto G\u00e8mez Cruz', 'Mar\u00e8a Rojo', 'Salma Hayek', 'Bruno Bichir'], 'title': 'Midaq Alley'}\n{'title': 'Desperado', 'cast': ['Antonio Banderas', 'Salma Hayek', 'Joaquim de Almeida', 'Cheech Marin']}\n...\n</code></pre> <p>BSON</p> <p>Cuando necesitemos pasar los documentos BSON a JSON, utilizaremos la funci\u00f3n <code>dumps</code> que transforma el documento a JSON:</p> <pre><code>cursor = movies.find( { \"cast\": \"Salma Hayek\" } )\nfrom bson.json_util import dumps\nprint(dumps(cursor, indent=2))\n\"\"\"\n[\n    {\n        \"_id\": {\n            \"$oid\": \"573a1399f29313caabceea6d\"\n        },\n        \"plot\": \"Cynical look at a 50's rebellious Rocker who has to confront his future, thugs with knives, and the crooked town sheriff.\",\n        \"genres\": [\n            \"Action\",\n            \"Drama\"\n        ],\n        \"runtime\": 95,\n        \"rated\": \"R\",\n        \"cast\": [\n            \"David Arquette\",\n            \"John Hawkes\",\n            \"Salma Hayek\",\n            \"Jason Wiles\"\n            ],\n        ...\n\"\"\"\n</code></pre>"},{"location":"sa/07pymongo.html#agregaciones","title":"Agregaciones","text":"<p>Para realizar consultas mediante el framework de agregaci\u00f3n, usaremos el m\u00e9todo <code>aggregate</code>, el cual recibe un array con el pipeline:</p> <p>Por ejemplo, vamos a recuperar el t\u00edtulo y el casting de las pel\u00edculas dirigidas por <code>Sam Raimi</code>:</p> ConsultaResultados <pre><code>match_stage = { \"$match\": { \"directors\": \"Sam Raimi\" } }\nproject_stage = { \"$project\": { \"_id\": 0, \"title\": 1, \"cast\": 1 } }\npipeline = [\nmatch_stage,\nproject_stage\n]\nsam_raimi_aggregation = movies.aggregate(pipeline)\nfor movie in sam_raimi_aggregation:\nprint(movie)\n</code></pre> <pre><code>{'cast': ['Bruce Campbell',\n'Ellen Sandweiss',\n'Richard DeManincor',\n'Betsy Baker'],\n'title': 'The Evil Dead'}\n{'cast': ['Bruce Campbell',\n'Sarah Berry',\n'Dan Hicks',\n'Kassie Wesley DePaiva'],\n'title': 'Evil Dead II'}\n{'cast': ['Liam Neeson', 'Frances McDormand', 'Colin Friels', 'Larry Drake'],\n'title': 'Darkman'}\n</code></pre> <p>Otro ejemplo, donde recuperamos los directores y la valoraci\u00f3n media de sus pel\u00edculas, ordenadas de mejor a peor:</p> ConsultaResultado <pre><code>unwind_stage = { \"$unwind\": \"$directors\" }\ngroup_stage = {\n\"$group\": {\n\"_id\": {\n\"director\": \"$directors\"\n},\n\"average_rating\": { \"$avg\": \"$imdb.rating\" }\n}\n}\nsort_stage = {\n\"$sort\": { \"average_rating\": -1 }\n}\n# Creamos un pipeline con las tres fases\npipeline = [\nunwind_stage,\ngroup_stage,\nsort_stage\n]\ndirector_ratings = movies.aggregate(pipeline)\nfor director in director_ratings:\nprint(director)\n</code></pre> <pre><code>{'_id': {'director': 'Sara Hirsh Bordo'}, 'average_rating': 9.4}\n{'_id': {'director': 'Kevin Derek'}, 'average_rating': 9.3}\n{'_id': {'director': 'Michael Benson'}, 'average_rating': 9.0}\n{'_id': {'director': 'Slobodan Sijan'}, 'average_rating': 8.95}\n{'_id': {'director': \"Bozidar 'Bota' Nikolic\"}, 'average_rating': 8.9}\n...\n</code></pre> <p>O realizamos un join entre las pel\u00edculas y sus comentarios para recuperar una pel\u00edcula por su identificador:</p> ConsultaResultado <pre><code>from bson.objectid import ObjectId\npeliculaId = \"573a13aef29313caabd2c349\"\npipeline = [\n{\n\"$match\": {\n\"_id\": ObjectId(peliculaId)\n}\n}, {\n\"$lookup\": {\n\"from\": \"comments\",\n\"localField\": \"_id\",\n\"foreignField\": \"movie_id\",\n\"as\": 'comentarios'\n}\n}\n]\npeliculaConComentarios = movies.aggregate(pipeline).next()\nprint(peliculaConComentarios)\n</code></pre> <pre><code>{'_id': ObjectId('573a13aef29313caabd2c349'),\n'awards': {'nominations': 48,\n'text': 'Nominated for 1 Oscar. Another 21 wins &amp; 48 nominations.',\n'wins': 22},\n'cast': ['Christian Bale', 'Michael Caine', 'Liam Neeson', 'Katie Holmes'],\n'comentarios': [{'_id': ObjectId('5a9427658b0beebeb696f672'),\n'date': datetime.datetime(1972, 3, 2, 15, 58, 41),\n'email': 'donald_sumpter@gameofthron.es',\n'movie_id': ObjectId('573a13aef29313caabd2c349'),\n'name': 'Maester Luwin',\n'text': 'Atque ...'}],\n'countries': ['USA', 'UK'],\n'directors': ['Christopher Nolan'],\n'fullplot': 'When ...\",\n'genres': ['Action', 'Adventure'],\n'imdb': {'id': 372784, 'rating': 8.3, 'votes': 860733},\n'languages': ['English', 'Urdu', 'Mandarin'],\n'lastupdated': datetime.datetime(2015, 8, 31, 0, 1, 54, 590000),\n'metacritic': 70,\n'num_mflix_comments': 1,\n'plot': 'After training ....',\n'poster': 'https://m.media-amazon.com/images/M/MV5BZmUwNGU2ZmItMmRiNC00MjhlLTg5YWUtODMyNzkxODYzMmZlXkEyXkFqcGdeQXVyNTIzOTk5ODM@._V1_SY1000_SX677_AL_.jpg',\n'rated': 'PG-13',\n'released': datetime.datetime(2005, 6, 15, 0, 0),\n'runtime': 140,\n'title': 'Batman Begins',\n'type': 'movie',\n'writers': ['Bob Kane (characters)',\n            'David S. Goyer (story)',\n            'Christopher Nolan (screenplay)',\n            'David S. Goyer (screenplay)'],\n'year': 2005}\n</code></pre>"},{"location":"sa/07pymongo.html#trabajando-con-cursores","title":"Trabajando con cursores","text":"<p>A continuaci\u00f3n vamos a realizar algunas operaciones sobre los cursores con PyMongo y a comparar a c\u00f3mo podemos realizar la misma operaci\u00f3n mediante el motor de agregaciones.</p>"},{"location":"sa/07pymongo.html#limitando","title":"Limitando","text":"<p>Sobre el cursor podemos restringir la cantidad de resultados devueltos mediante el m\u00e9todo <code>.limit()</code> equivalente a la agregaci\u00f3n <code>$limit</code>:</p> PyMongoAgregaci\u00f3nSalida <pre><code>limited_cursor = movies.find(\n{ \"directors\": \"Sam Raimi\" },\n{ \"_id\": 0, \"title\": 1, \"cast\": 1 }\n).limit(2)\nfor movie in limited_cursor:\nprint(movie)\n</code></pre> <pre><code>pipeline = [\n{ \"$match\": { \"directors\": \"Sam Raimi\" } },\n{ \"$project\": { \"_id\": 0, \"title\": 1, \"cast\": 1 } },\n{ \"$limit\": 2 }\n]\nlimited_aggregation = movies.aggregate( pipeline )\nfor movie in limited_aggregation:\nprint(movie)\n</code></pre> <pre><code>[\n{\n\"cast\": [\n\"Bruce Campbell\",\n\"Ellen Sandweiss\",\n\"Richard DeManincor\",\n\"Betsy Baker\"\n],\n\"title\": \"The Evil Dead\"\n},\n{\n\"title\": \"Evil Dead II\",\n\"cast\": [\n\"Bruce Campbell\",\n\"Sarah Berry\",\n\"Dan Hicks\",\n\"Kassie Wesley DePaiva\"\n]\n}\n]\n</code></pre>"},{"location":"sa/07pymongo.html#ordenando","title":"Ordenando","text":"<p>Para ordenar usaremos el m\u00e9todo <code>.sort()</code> que adem\u00e1s de los campos de ordenaci\u00f3n, indicaremos si el criterio ser\u00e1 ascendente (<code>ASCENDING</code>) o descendente (<code>DESCENDING</code>), de forma similar a como lo hacemos con la operaci\u00f3n de agregaci\u00f3n <code>$sort</code>:</p> PyMongoAgregaci\u00f3nSalida <pre><code>from pymongo import DESCENDING, ASCENDING\nsorted_cursor = movies.find(\n{ \"directors\": \"Sam Raimi\" },\n{ \"_id\": 0, \"year\": 1, \"title\": 1, \"cast\": 1 }\n).sort(\"year\", ASCENDING)\nfor movie in sorted_cursor:\nprint(movie)\n</code></pre> <pre><code>pipeline = [\n{ \"$match\": { \"directors\": \"Sam Raimi\" } },\n{ \"$project\": { \"_id\": 0, \"year\": 1, \"title\": 1, \"cast\": 1 } },\n{ \"$sort\": { \"year\": ASCENDING } }\n]\nsorted_aggregation = movies.aggregate( pipeline )\nfor movie in sorted_aggregation:\nprint(movie)\n</code></pre> <pre><code>[\n{\n\"cast\": [\n\"Bruce Campbell\",\n\"Ellen Sandweiss\",\n\"Richard DeManincor\",\n\"Betsy Baker\"\n],\n\"title\": \"The Evil Dead\",\n\"year\": 1981\n},\n{\n\"year\": 1987,\n\"title\": \"Evil Dead II\",\n\"cast\": [\n\"Bruce Campbell\",\n\"Sarah Berry\",\n\"Dan Hicks\",\n\"Kassie Wesley DePaiva\"\n]\n},\n{\n\"year\": 1990,\n...\n}\n]\n</code></pre> <p>En el caso de tener una clave compuesta de ordenaci\u00f3n, le pasaremos como par\u00e1metro una lista de tuplas clave/criterio:</p> PyMongoAgregaci\u00f3nSalida <pre><code>sorted_cursor = movies.find(\n{ \"cast\": \"Tom Hanks\" },\n{ \"_id\": 0, \"year\": 1, \"title\": 1, \"cast\": 1 }\n).sort([(\"year\", ASCENDING), (\"title\", ASCENDING)])\nfor movie in sorted_cursor:\nprint(movie)\n</code></pre> <pre><code>pipeline = [\n{ \"$match\": { \"cast\": \"Tom Hanks\" } },\n{ \"$project\": { \"_id\": 0, \"year\": 1, \"title\": 1, \"cast\": 1 } },\n{ \"$sort\": { \"year\": ASCENDING, \"title\": ASCENDING } }\n]\nsorted_aggregation = movies.aggregate( pipeline )\nfor movie in sorted_aggregation:\nprint(movie)\n</code></pre> <pre><code>[\n{\n\"cast\": [\n\"Tom Hanks\",\n\"Daryl Hannah\",\n\"Eugene Levy\",\n\"John Candy\"\n],\n\"title\": \"Splash\",\n\"year\": 1984\n},\n{\n\"cast\": [\n\"Tom Hanks\",\n\"Jackie Gleason\",\n\"Eva Marie Saint\",\n\"Hector Elizondo\"\n],\n\"title\": \"Nothing in Common\",\n\"year\": 1986\n},\n{\n\"cast\": [\n\"Tom Hanks\",\n\"Elizabeth Perkins\",\n\"Robert Loggia\",\n\"John Heard\"\n],\n\"title\": \"Big\",\n\"year\": 1988\n},\n{\n\"cast\": [\n\"Sally Field\",\n\"Tom Hanks\",\n\"John Goodman\",\n\"Mark Rydell\"\n],\n\"title\": \"Punchline\",\n\"year\": 1988\n},\n...\n]\n</code></pre>"},{"location":"sa/07pymongo.html#saltando","title":"Saltando","text":"<p>Cuando paginamos los resultados, para saltar los documentos, haremos uso del m\u00e9todo <code>.skip()</code>, el cual es similar a la operaci\u00f3n <code>$skip</code>.</p> <p>Por ejemplo, la siguiente consulta devuelve 13 documentos, de manera que al saltarnos 12, s\u00f3lo nos devolver\u00e1 uno:</p> PyMongoAgregaci\u00f3nSalida <pre><code>skipped_sorted_cursor = movies.find(\n{ \"directors\": \"Sam Raimi\" },\n{ \"_id\": 0, \"title\": 1, \"year\": 1, \"cast\": 1 } \n).sort(\"year\", ASCENDING).skip(12)\nfor movie in skipped_sorted_cursor:\nprint(movie)\n</code></pre> <pre><code>pipeline = [\n{ \"$match\": { \"directors\": \"Sam Raimi\" } },\n{ \"$project\": { \"_id\": 0, \"year\": 1, \"title\": 1, \"cast\": 1 } },\n{ \"$sort\": { \"year\": ASCENDING } },\n{ \"$skip\": 12 }\n]\nsorted_skipped_aggregation = movies.aggregate( pipeline )\nfor movie in sorted_skipped_aggregation:\nprint(movie)\n</code></pre> <pre><code>[\n{\n\"cast\": [\n\"James Franco\",\n\"Mila Kunis\",\n\"Rachel Weisz\",\n\"Michelle Williams\"\n],\n\"title\": \"Oz the Great and Powerful\",\n\"year\": 2013\n}\n]\n</code></pre>"},{"location":"sa/07pymongo.html#crud","title":"CRUD","text":"<p>Para estas operaciones, vamos a trabajar con la colecci\u00f3n <code>iabd.people</code> que utilizamos en la primera sesi\u00f3n de MongoDB.</p>"},{"location":"sa/07pymongo.html#insercion","title":"Inserci\u00f3n","text":"<pre><code>from pymongo import MongoClient\ncliente = MongoClient(\"mongodb+srv://iabd:iabdiabd@cluster0.4hm7u8y.mongodb.net/?retryWrites=true&amp;w=majority\", server_api=ServerApi('1'))\nbd = cliente.iabd\npeople = bd.people\nyo = { \"nombre\": \"Aitor Medrano\", \"edad\": 45, \"profesion\": \"Profesor\" }\nresultado = people.insert_one(yo)\nprint(resultado.acknowledged)   # True\nprint(resultado.inserted_id)    # 6366b5c85afaf1b75dc90a20\n</code></pre> <p>Tras realizar una operaci\u00f3n de inserci\u00f3n con <code>insert_one</code>, obtenemos un objeto <code>InsertOneResult</code> del cual cabe destacar dos campos:</p> <ul> <li><code>acknowledged</code>: un campo booleano que nos indica si la operaci\u00f3n ha sido exitosa, o <code>False</code> cuando indicamos un <code>WriteConcern(w=0)</code>, es decir, es escritura fire-and-forget.</li> <li><code>inserted_id</code>: valor del <code>ObjectId</code>.</li> </ul> <p>Si queremos insertar m\u00e1s de una documento a la vez, usaremos <code>insert_many</code>, el cual devuelve un objeto <code>InsertManyResult</code>.</p>"},{"location":"sa/07pymongo.html#join","title":"Join","text":"<p>Ya hemos estudiado que al insertar un documento que est\u00e1 relacionado con otro, necesitamos que los campos contengan el mismo valor (normalmente, el <code>ObjectId</code>)</p> <p>Por ejemplo, si queremos a\u00f1adir un comentario a una pel\u00edcula, hemos de unir el identificador de la pel\u00edcula en cada comentario haciendo uso de objeto <code>ObjectId</code>:</p> <pre><code>from bson.objectid import ObjectId\ncomments = db.comments\ncomment_doc = {\"name\": usuario.nombre, \"email\": usuario.email,\n\"movie_id\": ObjectId(movie_id), \"text\": comentario, \"date\": fecha}\ncomments.insert_one(comment_doc))\n</code></pre>"},{"location":"sa/07pymongo.html#gestion-de-errores","title":"Gesti\u00f3n de errores","text":"<p>A la hora de insertar un documento se puede dar el caso de lanzar un <code>DuplicateKeyError</code>, ya sea por el atributo identificador o por un \u00edndice de tipo \u00fanico. En dicho caso, podemos capturar la excepci\u00f3n y ajustar el comportamiento o informar al usuario, dependiendo de la gravedad del error.</p> <p>Por ejemplo, si insertamos una persona con un <code>_id</code> que ya existe:</p> <pre><code>doc = {\n\"_id\": 1,\n\"nombre\": \"Aitor Medrano\"\n}\ntry:\nresult = people.insert_one(doc)\nprint(res.inserted_id)\nexcept errors.DuplicateKeyError:\nusuario_id = doc[\"_id\"]\nprint(f\"El usuario #{usuario_id} ya existe en el sistema.\")\n</code></pre>"},{"location":"sa/07pymongo.html#borrado","title":"Borrado","text":"<p>El borrado de documento es similar a la creaci\u00f3n, pudiendo utilizar <code>delete_one</code> para borrar el primer documento encontrado, o <code>delete_many</code> para borrar todos los documentos encontrados:</p> <pre><code>resultado = people.delete_many({ \"edad\" : 45})\nprint(resultado.deleted_count)\n</code></pre> <p>En ambas operaciones, obtenemos un objeto <code>DeleteResult</code> del cual destacamos la propiedad <code>deleted_count</code> para averiguar cuantos documentos han sido eliminados.</p> <p>Borrado de colecciones</p> <p>Para vaciar una colecci\u00f3n, podemos borrar todos los documentos:</p> <pre><code>people.delete_many({})\n</code></pre> <p>Aunque es mejor borrar la colecci\u00f3n entera:</p> <pre><code>people.drop()\n</code></pre>"},{"location":"sa/07pymongo.html#modificacion","title":"Modificaci\u00f3n","text":"<p>De forma similar a como lo hemos realizado mediante mongosh, para modificar documentos emplearemos los m\u00e9todos <code>update_one</code> y <code>update_many</code>, los cuales devuelve un objeto <code>UpdateResult</code>:</p> <pre><code>resultado = people.update_one({\"nombre\":\"Aitor Medrano\"}, {\"$set\":{\"nombre\":\"Marina Medrano\", \"salario\": 123456}})\nprint(resultado.matched_count)  # (1)!\nprint(resultado.modified_count) # (2)!\n</code></pre> <ol> <li><code>matched_count</code> nos devuelve la cantidad de documentos encontrados</li> <li><code>modified_count</code> nos devuelve la cantidad de documentos modificados</li> </ol> <p>Tal como vimos, en las operaciones update, le podemos pasar un tercer par\u00e1metro (opcional) con <code>upsert=False</code> (valor por defecto) op <code>True</code>, cuando queramos que se inserte un nuevo documento si no encuentra ninguno. En este caso, <code>modified_count</code> y <code>matched_count</code> ser\u00e1n 0.</p> <p>Otro argumento opcional que conviene conocer es <code>bypass_document_validation=False</code> (valor por defecto), el cual, si lo ponemos a <code>True</code> ignorar\u00e1 las validaciones (si hay alguna) para los documentos que modifiquemos.</p> <p>Operador</p> <p>Recuerda utilizar un operador de modificaci\u00f3n en el segundo par\u00e1metro. Si no, el documento del segundo par\u00e1metro sustituir\u00e1 por completo al documento encontrado.</p>"},{"location":"sa/07pymongo.html#operaciones-consistentes","title":"Operaciones consistentes","text":""},{"location":"sa/07pymongo.html#preferencias-de-lectura","title":"Preferencias de lectura","text":"<p>Para realizar lecturas consistentes podemos configurar la preferencias de lectura, tal como vimos en la sesi\u00f3n anterior.</p> <p>Para ello, PyMongo ofrece un conjunto de clases para indicar las preferencias de lectura, las cuales podemos configurar a nivel de cliente:</p> <p>Niveles de lectura</p> <p>Los diferentes niveles vienen definidos en el objeto <code>ReadPreference</code> el cual ofrece los valores estudiados en la sesi\u00f3n anterior: <code>PRIMARY</code>, <code>PRIMARY_PREFERRED</code>, <code>SECONDARY</code>, <code>SECONDARY_PREFERRED</code> y <code>NEAREST</code>.</p> <pre><code>client = MongoClient(\n'localhost:27017',\nreplicaSet='iabd',\nreadPreference='secondaryPreferred')\n</code></pre> <p>Si en vez de indicar la preferencia a nivel de cliente, lo queremos realizar a nivel de base de datos o de colecci\u00f3n, hemos de emplear los m\u00e9todos get_database y get_collection pas\u00e1ndole un segundo par\u00e1metro con la opci\u00f3n deseada:</p> <pre><code>from pymongo import ReadPreference\nprint(client.read_preference)   # SecondaryPreferred(tag_sets=None)\ndb = client.get_database('iabd', read_preference=ReadPreference.SECONDARY)\nprint(db.read_preference)       # Secondary(tag_sets=None)\ncoll = db.get_collection('people', read_preference=ReadPreference.PRIMARY)\nprint(coll.read_preference)     # Primary()\n</code></pre> <p>Finalmente, si en cualquier momento queremos cambiar las preferencias a nivel de colecci\u00f3n, podemos emplear el m\u00e9todo with_options:</p> <pre><code>coll2 = coll.with_options(read_preference=ReadPreference.NEAREST)\nprint(coll.read_preference)     # Primary()\nprint(coll.read_preference)     # Nearest(tag_sets=None)\n</code></pre>"},{"location":"sa/07pymongo.html#escrituras-consistentes","title":"Escrituras consistentes","text":"<p>Tal como vimos en la sesi\u00f3n anterior, para indicar la consistencia en la escritura, haremos uso de la propiedad <code>write_concern</code>. Para ello, de la misma forma que hemos indicado la preferencia de lectura, hacemos uso del m\u00e9todo <code>with_options</code>:</p> <pre><code>coll.with_options(write_concern=WriteConcern(w=\"majority\")).insert_one({\n\"nombre\": nombre,\n\"email\": email,\n\"password\": hashed_pw\n})\n</code></pre> <p>Si tenemos una aplicaci\u00f3n cr\u00edtica, no nos podemos permitir perder los datos. Por ello, necesitamos que las escritura se propaguen a la mayor\u00eda de los nodos con la opci\u00f3n <code>w: majority</code> para asegurarnos que las escrituras se propagan a la mayor\u00eda de nodos del conjunto de nodos.</p> <p>Si sucede un problema en los nodos secundarios, puede ser que el primario no reciba los ACK necesarios. Si llegan m\u00e1s escrituras que lecturas, puede llegar el momento en que se produzca un atasco.</p> <p>Para evitar esto, para cada escritura que realicemos con la mayor\u00eda de los nodos, siempre hay que indicar un timeout. La longitud del timeout vendr\u00e1 determinada por la red y el hardware que dispongamos, pero siempre hemos de indicarlo.</p> <pre><code>coll.with_options(write_concern=WriteConcern(w=\"majority\", wtimeout=\"2500\").insert_one({\n\"nombre\": nombre,\n\"email\": email,\n\"password\": hashed_pw\n})\n</code></pre> <p>Bulk writes</p> <p>En ocasiones necesitamos ejecutar una bateria de operaciones a granel (bulk) las cuales se ejecutan como un proceso batch. Para ello se emplea el m\u00e9todo <code>bulk_write</code>:</p> <pre><code>result = db.test.bulk_write(array_operaciones)\n</code></pre>"},{"location":"sa/07pymongo.html#transacciones","title":"Transacciones","text":"<p>Ya hemos comentado en numerosas ocasiones toda operaci\u00f3n en un \u00fanico documento es at\u00f3mica, de ah\u00ed embeber documentos y arrays para modelar las relaciones de datos en un s\u00f3lo documento cubre la mayor\u00eda de los casos de usos transaccionales.</p> <p>Cuando necesitamos atomicidad de lecturas y escrituras entre varios documentos (en una o m\u00e1s colecciones), MongoDB soporta transacciones multidocumento. Mediante las transacciones distribuidas, las transacciones puede operar entre varias operaciones, colecciones, bases de datos, documentos y particiones (shards).</p>"},{"location":"sa/07pymongo.html#tipos-de-api","title":"Tipos de API","text":"<p>MongoDB ofrece dos API para utilizar transacciones. La primera, conocida como Core API, disponible desde la versi\u00f3n 4.0 de MongoDB, tiene una sintaxis similar a las bases de datos relacionales (por ejemplo, con operaciones como <code>start_transaction</code> y <code>commit_transaction</code>), y la segunda se conoce como Callback API, desde la versi\u00f3n 4.2, el cual es el enfoque actualmente recomendado.</p> <p>El Core API no ofrece l\u00f3gica de reintentos para la mayor\u00eda de errores y necesita que el desarrollador programe la l\u00f3gica de las operaciones, la funci\u00f3n transaccional que realiza commit y la l\u00f3gica de errores y reintentos necesaria.</p> <p>En cambio, el Callback API ofrece una \u00fanica funci\u00f3n que engloba un alto grado de funcionalidad comparadas con el Core API, incluyendo el inicio de una transacci\u00f3n asociada a una sesi\u00f3n l\u00f3gica, ejecutar la funci\u00f3n definida como callback y realizando el commit de la transacci\u00f3n (o abort\u00e1ndola en caso de error). Esta funci\u00f3n tambi\u00e9n incluye la l\u00f3gica de reintentos para manejar los errores al hacer commit.</p> <p>En ambas APIs, el desarrollador se responsabiliza de iniciar la sesi\u00f3n l\u00f3gica que se utilizar\u00e1 en la transacci\u00f3n. Ambas APIs requieren que las operaciones transaccionales se asocien a \u00e9sta sesi\u00f3n l\u00f3gica (pas\u00e1ndola como par\u00e1metro a cada operaci\u00f3n). Cada sesi\u00f3n l\u00f3gica en MongoDB registra el tiempo y la secuencia de las operaciones en el contexto completo del despliegue de MongoDB.</p>"},{"location":"sa/07pymongo.html#hola-mundo-callback-api","title":"Hola Mundo Callback API","text":"<p>Vamos a simular que tenemos una aplicaci\u00f3n de gesti\u00f3n de un almac\u00e9n, en la cual tenemos que realizar las siguientes operaciones dentro de una transacci\u00f3n:</p> <pre><code>pedidos.insert_one({\"producto\": \"ps5\", \"cantidad\": 100}, session=miSesion)\ninventario.update_one({\"producto\": \"ps5\", \"cantidad\": {\"$gte\": 100}},\n{\"$inc\": {\"cantidad\": -100}}, session=miSesion)\n</code></pre> <p>Veamos mediante un ejemplo el flujo del c\u00f3digo transaccional haciendo uso del Callback API.</p> almacenTransaccional.py<pre><code>from pymongo import MongoClient, ReadPreference\nfrom pymongo.write_concern import WriteConcern\nfrom pymongo.read_concern import ReadConcern\nuriString = 'mongodb+srv://iabd:iabdiabd@cluster0.4hm7u8y.mongodb.net/?retryWrites=true&amp;w=majority'\ncliente = MongoClient(uriString)\nmiWCMajority = WriteConcern('majority', wtimeout=1000)\n# Paso 0: Creamos dos colecciones e insertamos un documento en cada una\nbd = client.get_database( \"iabd\", write_concern=miWCMajority)\nbd.pedidos.insert_one({\"producto\": \"ps5\", \"cantidad\":0})\nbd.inventario.insert_one({\"producto\": \"ps5\", \"cantidad\": 1000})\n# Paso 1: Definir el callback que indica la secuencia de las operaciones a realizar dentro de la transacci\u00f3n\ndef callback(miSesion):\npedidos = miSesion.cliente.iabd.pedidos\ninventario = miSesion.cliente.iabd.inventario\n# Importante: Debemos pasarle la sesi\u00f3n a cada operaci\u00f3n\npedidos.insert_one({\"producto\": \"ps5\", \"cantidad\": 100}, session=miSesion)\ninventario.update_one({\"producto\": \"ps5\", \"cantidad\": {\"$gte\": 100}},\n{\"$inc\": {\"cantidad\": -100}}, session=miSesion)\n# Paso 2: Iniciar una sesi\u00f3n de cliente.\nwith cliente.start_session() as session:\n# Paso 3: Empleamos with_transaction para iniciar la transacci\u00f3n, ejecutar el callback y realizar el commit (o abortar en caso de error).\nsession.with_transaction(\ncallback,\nread_concern=ReadConcern(\"local\"),\nwrite_concern=miWCMajority,\nread_preference=ReadPreference.PRIMARY,\n)\n</code></pre> <p>PyMODM</p> <p>PyMODM es una librer\u00eda ODM que abstrae el acceso a MongoDB mediante un mapeo objeto-documento. De forma similar a los frameworks ORM en los entornos relacionales, como son Hibernate (Java), Doctrine/Eloquent (PHP) o el ORM de Django, abstrae y simplifica el acceso a la base de datos.</p> <p>Un ejemplo de definici\u00f3n de un objeto y su persistencia ser\u00eda:</p> <pre><code>class User(MongoModel):\n# Utiliza el 'email'como campo '_id'\nemail = fields.EmailField(primary_key=True)\nnombre = fields.CharField()\napellido = fields.CharField()\nusuario = User('a.medrano@edu.gva.es', 'Aitor', 'Medrano').save()\n</code></pre> <p>Hemos decidido no profundizar en su conocimiento ya que el equipo de MongoDB ha pausado su mantenimiento desde hace ya dos a\u00f1os.    </p>"},{"location":"sa/07pymongo.html#caso-de-uso-pia-login","title":"Caso de uso - PIA: Login","text":"<p>El siguiente proyecto se basa inicialmente en el art\u00edculo How To Add Authentication to Your App with Flask-Login.</p> <p>A partir de \u00e9l, vamos a crear una aplicaci\u00f3n en Flask que ataca a una base de datos de MongoDB para almacenar la informaci\u00f3n del proyecto PIA Lara.</p> <p>Esta primera versi\u00f3n de la aplicaci\u00f3n \u00fanicamente se centra en la gesti\u00f3n de los usuarios, distinguiendo entre los diferentes roles:</p> <ul> <li><code>Administrador</code>: superusuario, puede crear, editar y eliminar todo tipo de usuarios.</li> <li><code>T\u00e9cnico</code>: usuario que supervisar\u00e1 a los clientes, el cual, m\u00e1s adelante, puede llegar a crear textos predefinidos para los clientes.</li> <li><code>Cliente</code>: usuario final de la aplicaci\u00f3n que, m\u00e1s adelante, grabar\u00e1 los audios.</li> </ul> <p>Simplicidad</p> <p>El presente caso de uso se ha organizado para intentar simplificar al m\u00e1ximo el c\u00f3digo y preparar un esqueleto que facilite el crecimiento de la aplicaci\u00f3n. A\u00fan as\u00ed, una soluci\u00f3n basada en Django o el uso de herramientas de mapeo entre los datos y los objetos del dominio ser\u00edan un punto de partida para siguientes fases del proyecto.</p>"},{"location":"sa/07pymongo.html#estructura","title":"Estructura","text":"<p>Una vez descargado el proyecto y tras descomprimirlo, o clonado desde https://github.com/aitor-medrano/piafplogin, veremos que tiene la siguiente estructura:</p> <pre><code>PIAFPLOGIN/\n\u251c\u2500\u2500 migrations/\n\u2502   \u2514\u2500\u2500 user_migration.py\n\u251c\u2500\u2500 project/\n\u2502   \u251c\u2500\u2500 static/\n\u2502   \u2502   \u251c\u2500\u2500 pialara.js\n\u2502   \u2502   \u2514\u2500\u2500 pialara.png\n\u2502   \u251c\u2500\u2500 templates/\n\u2502   \u2502   \u251c\u2500\u2500 base.html\n\u2502   \u2502   \u251c\u2500\u2500 index.html\n\u2502   \u2502   \u251c\u2500\u2500 login.html\n\u2502   \u2502   \u2514\u2500\u2500 profile.html\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 auth.py\n\u2502   \u251c\u2500\u2500 db.py\n\u2502   \u251c\u2500\u2500 main.py\n\u2502   \u2514\u2500\u2500 models.py\n\u251c\u2500\u2500 .ini\n\u2514\u2500\u2500 requirements.txt\n</code></pre> <p>El primer paso es crear un entorno virtual:</p> <pre><code>python3 -m venv app-env\n</code></pre> <p>Y activarlo:</p> <pre><code>source app-env/bin/activate\n</code></pre> <p>A continuaci\u00f3n instalaremos las dependencias mediante:</p> <pre><code>pip3 install -r requirements.txt\n</code></pre>"},{"location":"sa/07pymongo.html#configuracion","title":"Configuraci\u00f3n","text":"<p>Para configurar el proyecto, partimos del fichero <code>.ini</code> que reside en la ra\u00edz del mismo y contiene los datos de configuraci\u00f3n a MongoDB y la clave secreta que utiliza Flask para encriptar la sesi\u00f3n:</p> .ini<pre><code>[PROD]\nSECRET_KEY = eac5e91171438960ddec0c9c469a4c3dd42e96aea462afc5ab830f78527ad80e\nPIALARA_DB_URI = mongodb+srv://usuario:contrase\u00f1a@cluster0.xyz.mongodb.net\nPIALARA_DB_NAME = pialara\n[LOCAL]\nSECRET_KEY = eac5e91171438960ddec0c9c469a4c3dd42e96aea462afc5ab830f78527ad80e\nPIALARA_DB_URI = localhost\nPIALARA_DB_NAME = pialara\n</code></pre> <p>Secret Key</p> <p>Para generar una clave secreta, tal como indica la documentaci\u00f3n de Flask, podemos ejecutar el siguiente comando:</p> <pre><code>python3 -c 'import secrets; print(secrets.token_hex())'\n</code></pre> <p>Una vez ya hemos configurado la conexi\u00f3n y antes de arrancar la aplicaci\u00f3n, vamos a cargar unos datos b\u00e1sicos con usuarios. Para ello, en la carpeta <code>migrations</code> tenemos el archivo <code>users_migration.py</code>, el cual lee la configuraci\u00f3n del archivo anterior, y crea tres usuarios:</p> users_migration.py<pre><code>from pymongo import MongoClient\nfrom werkzeug.security import generate_password_hash\nimport os\nimport configparser\nconfig = configparser.ConfigParser()\nconfig.read(os.path.abspath(os.path.join(\".ini\")))\nDB_URI = config['PROD']['PIALARA_DB_URI']\nDB_NAME = config['PROD']['PIALARA_DB_NAME']\n# DB_URI = config['LOCAL']['PIALARA_DB_URI']\n# DB_NAME = config['LOCAL']['PIALARA_DB_NAME']\ndb = MongoClient(DB_URI)[DB_NAME]\nusuarios = [\n{\"nombre\":\"Admin\", \"email\":\"admin@admin.com\", \"password\":generate_password_hash(\"admin\", method='sha256'), \"rol\":\"Administrador\"},\n{\"nombre\":\"Alumno\", \"email\":\"alumno@alumno.com\", \"password\":generate_password_hash(\"alumno\", method='sha256'), \"rol\":\"T\u00e9cnico\"},\n{\"nombre\":\"Severo Ochoa\", \"email\":\"s8a@s8a.com\", \"password\":generate_password_hash(\"s8a\", method='sha256'), \"rol\":\"Cliente\", \"parent\":\"alumno@alumno.com\"},\n]\ntry:\ndb.users.insert_many(usuarios)\nexcept Exception as e:\nprint(e)\n</code></pre> <p>Destacar que al definir los documentos con los usuarios, encriptamos la contrase\u00f1a mediante la funci\u00f3n <code>generate_password_hash</code> para no almacenarla en la base de datos en texto plano.</p> <p>As\u00ed pues, ejecutamos la migraci\u00f3n:</p> <pre><code>python3 migrations/users_migration.py\n</code></pre> <p>Finalmente podemos arrancar la aplicaci\u00f3n:</p> <pre><code>flask --app project --debug run\n</code></pre> <p>Y acceder a la aplicaci\u00f3n a trav\u00e9s de <code>http://127.0.0.1:5000/</code>:</p> Versi\u00f3n escritorioVersi\u00f3n m\u00f3vil <p> PIA Lara - Index </p> <p> PIA Lara - Index en m\u00f3vil </p> <p>Una vez que un usuario ha entrado a la aplicaci\u00f3n, por ejemplo, si es un administrador, dispondr\u00e1 de las opciones que hemos comentado anteriormente:</p> PIA Lara - Administrador"},{"location":"sa/07pymongo.html#blueprints","title":"Blueprints","text":"<p>El archivo .ini que hemos configurado previamente define unos valores que la aplicaci\u00f3n va a cargar desde el archivo <code>__init__.py</code>, el cual act\u00faa como factor\u00eda de la aplicaci\u00f3n y le indica a Flask los blueprints a utilizar:</p> __init__.py<pre><code>from flask import Flask\nfrom flask_login import LoginManager\nfrom . import db\nimport os\nimport configparser\nconfig = configparser.ConfigParser()\nconfig.read(os.path.abspath(os.path.join(\".ini\")))\ndef create_app():\napp = Flask(__name__)\n# cargamos la configuraci\u00f3n\napp.config['PIALARA_DB_URI'] = config['LOCAL']['PIALARA_DB_URI']\napp.config['PIALARA_DB_NAME'] = config['LOCAL']['PIALARA_DB_NAME']\napp.config['SECRET_KEY'] = config['LOCAL']['SECRET_KEY']\n# configuramos flask-login con la ruta del login\nlogin_manager = LoginManager()\nlogin_manager.login_view = 'auth.login'\nlogin_manager.init_app(app)\n# funci\u00f3n que utiliza flask-login para recuperar el usuario\n@login_manager.user_loader\ndef load_user(user_id):\nreturn db.get_user_by_id(user_id)\n# blueprint para las rutas de autenticaci\u00f3n\nfrom .auth import auth as auth_blueprint\napp.register_blueprint(auth_blueprint)\n# blueprint para la aplicaci\u00f3n\nfrom .main import main as main_blueprint\napp.register_blueprint(main_blueprint)\nreturn app\n</code></pre> <p>Un blueprint permite organizar un grupo de vistas y c\u00f3digo en m\u00f3dulos. En vez de registrar las vistas y el resto de c\u00f3digo en la aplicaci\u00f3n, se registran en el blueprint, y \u00e9ste es que se registra en la aplicaci\u00f3n en la funci\u00f3n <code>create_app</code>.</p> <p>En nuestro caso, vamos a empezar con dos blueprints, uno para las funciones de autenticaci\u00f3n, y otra para las funciones de gesti\u00f3n de usuarios. El c\u00f3digo de cada blueprint ir\u00e1 en un m\u00f3dulo separado. Como la gesti\u00f3n de usuarios necesita primero la autenticaci\u00f3n, vamos a ver c\u00f3mo funciona.</p>"},{"location":"sa/07pymongo.html#login","title":"Login","text":"<p>Para la gesti\u00f3n de la autenticaci\u00f3n, nos hemos apoyado en la librer\u00eda Flask-login que facilita la gesti\u00f3n la sesi\u00f3n del usuario.</p> <p>En archivo <code>auth.py</code> contiene la l\u00f3gica del login y el logout:</p> auth.py<pre><code>from flask import Blueprint, render_template, redirect, url_for, request, flash\nfrom flask_login import login_user, login_required, logout_user, current_user\nfrom werkzeug.security import check_password_hash\nfrom . import db\nauth = Blueprint('auth', __name__)\n@auth.route('/login')\ndef login():\nreturn render_template('login.html')\n@auth.route('/login', methods=['POST'])\ndef login_post():\nemail = request.form.get('email')\npassword = request.form.get('password')\nremember = True if request.form.get('remember') else False\nuser = db.get_user(email)\n# comprobamos si el usuario existe\n# cogemos la contrase\u00f1a, la hasheamos y la comparamos con la contrase\u00f1a hasheada\nif not user or not check_password_hash(user.password, password):\nflash('Por favor, comprueba tus datos y vu\u00e9lvelo a intentar.')\n# si el usuario no existe, o est\u00e1 mal la contrase\u00f1a, recargamos la p\u00e1gina\nreturn redirect(url_for('auth.login')) \n# marcamos al usuario como autenticado en flask_login \nlogin_user(user, remember=remember) \nreturn redirect(url_for('main.profile', nombre = current_user.nombre))\n@auth.route('/logout')\n@login_required\ndef logout():\nlogout_user()\nflash('Sesi\u00f3n cerrada con \u00e9xito')\nreturn redirect(url_for('auth.login'))\n</code></pre> <p>Los usuarios van a entrar al sistema mediante su email y una contrase\u00f1a. As\u00ed pues, una vez hayamos recuperado un usuario por dicho email, creamos el hash de la contrase\u00f1a recibida, y vemos si comprueba con la recuperada de la base de datos.</p> <p>El m\u00e9todo <code>login_user</code> de la l\u00ednea 27 pertenece a la librer\u00eda Flask-Login y se utiliza para indicar que el usuario ha sido autenticado, de manera que lo almacena en la sesi\u00f3n. La variable <code>user</code> es una clase propia que hemos definido nosotros con los atributos b\u00e1sicos de un usuario,el cual se encuentra en el archivo <code>models.py</code>:</p> models.py<pre><code>from flask_login import UserMixin\nclass User(UserMixin):\ndef __init__(self, id, email, nombre, password, rol, parent = \"\"):\nself.id = id\nself.email = email\nself.nombre = nombre\nself.password = password\nself.rol = rol\nself.parent = parent\ndef __str__(self):\nreturn f\"{self.email} ({self.nombre} / {self.password})\"\n</code></pre> <p>Como se puede observar, la clase define los atributos b\u00e1sicos de un usuario. El atributo <code>parent</code> lo vamos a emplear para que los clientes almacenen el email del t\u00e9cnico que tienen asignado.</p>"},{"location":"sa/07pymongo.html#plantillas","title":"Plantillas","text":"<p>Las diferentes plantillas heredan de una plantilla <code>base.html</code>, la cual emplea el framework Bulma para la apariencia de la web. Su funcionamiento es muy similar a Bootstrap.</p> <p>Por ejemplo, vamos a revisar un fragmento de la plantilla base para ver c\u00f3mo gestionamos la visualizaci\u00f3n del men\u00fa dependiendo del rol del usuario:</p> base.html<pre><code>...\n&lt;section class=\"hero is-white is-fullheight\"&gt;\n&lt;nav class=\"navbar is-transparent\"&gt;\n&lt;div class=\"navbar-brand\"&gt;\n&lt;a class=\"navbar-item\" href=\"https://piafplara.es\"&gt;\n&lt;img src=\"{{ url_for('static', filename='pialara.png') }}\" alt=\"PIA Lara: un proyecto que habla por ti\" width=\"112\" height=\"28\"&gt;\n&lt;/a&gt;\n&lt;div class=\"navbar-burger burger\" data-target=\"navbarPIALara\"&gt;\n&lt;span&gt;&lt;/span&gt;\n&lt;span&gt;&lt;/span&gt;\n&lt;span&gt;&lt;/span&gt;\n&lt;/div&gt;\n&lt;/div&gt;\n&lt;div id=\"navbarPIALara\" class=\"navbar-menu\"&gt;\n&lt;div class=\"navbar-start\"&gt;\n&lt;a href=\"{{ url_for('main.index') }}\" class=\"navbar-item\"&gt;\n                Inicio\n            &lt;/a&gt;\n            {% if not current_user.is_authenticated %}\n                &lt;a href=\"{{ url_for('auth.login') }}\" class=\"navbar-item\"&gt;\n                    Login\n                &lt;/a&gt;\n            {% endif %}\n            {% if current_user.is_authenticated %}\n                &lt;a href=\"{{ url_for('main.profile') }}\" class=\"navbar-item\"&gt;\n                    Perfil\n                &lt;/a&gt;\n                {% if current_user.rol == \"Administrador\" %}\n                &lt;div class=\"navbar-item has-dropdown is-hoverable\"&gt;\n&lt;a class=\"navbar-link\" href=\"#\"&gt;\n                    Usuarios\n                &lt;/a&gt;\n&lt;div class=\"navbar-dropdown is-hidden-mobile is-boxed\"&gt;\n&lt;a class=\"navbar-item\" href=\"{{ url_for('main.user_create') }}\"&gt;\n                    Alta\n                    &lt;/a&gt;\n&lt;a class=\"navbar-item\" href=\"{{ url_for('main.user_list') }}\"&gt;\n                    Listado\n                    &lt;/a&gt;\n&lt;/div&gt;\n&lt;/div&gt;\n                {% endif %}         \n...\n</code></pre> <p>En la l\u00ednea 6 utilizamos la funci\u00f3n <code>url_for</code> con el par\u00e1metro <code>static</code> para indicarle que cargue la imagen con el logo del proyecto desde la carpeta <code>static</code>.</p> <p>Al utilizar la librer\u00eda Flask Login, tendremos siempre disponible el usuario logueado en la variable <code>current_user</code>. Adem\u00e1s de las propiedades que hayamos definido en la clase, disponemos de la funci\u00f3n <code>is_authenticated</code> para comprobar si est\u00e1 autenticado (l\u00ednea 20). De igual forma, podemos comprobar el rol y condicionar el contenido dependiendo de si es <code>Administrador</code>, <code>T\u00e9cnico</code> o <code>Cliente</code> (l\u00ednea 24).</p>"},{"location":"sa/07pymongo.html#acceso-a-los-datos","title":"Acceso a los datos","text":"<p>Todo el acceso a los datos los hemos encapsulado en el archivo <code>db.py</code>:</p> db.py<pre><code>from pymongo import MongoClient\nfrom bson.objectid import ObjectId\nfrom pymongo import ASCENDING\nfrom flask import current_app, g\nfrom werkzeug.local import LocalProxy\nfrom project.models import User\ndef get_db():\n\"\"\"\n    M\u00e9todo de configuraci\u00f3n para obtener una instancia de db\n    \"\"\"\ndb = getattr(g, \"_database\", None)\nPIALARA_DB_URI = current_app.config[\"PIALARA_DB_URI\"]\nPIALARA_DB_DB_NAME = current_app.config[\"PIALARA_DB_NAME\"]\nif db is None:\ndb = g._database = MongoClient(\nPIALARA_DB_URI,\nmaxPoolSize=50,\ntimeoutMS=2500\n)[PIALARA_DB_DB_NAME]\nreturn db\n# Utilizamos LocalProxy para leer la variable global usando s\u00f3lo db\ndb = LocalProxy(get_db)\n</code></pre> <p>La funci\u00f3n <code>get_db</code> utiliza el objeto <code>g</code>, el cual en Flask, es un objeto especial que es \u00fanico para cada petici\u00f3n. Se utiliza para almacenar datos que ser\u00e1n accesibles desde m\u00faltiples funciones durante el <code>request</code>. As\u00ed pues, almacenamos la conexi\u00f3n, mejor dicho, el pool de conexiones a MongoDB en vez de crear un nuevo pool cada vez que queramos obtener acceso a la base de datos.</p> <p>A continuaci\u00f3n, creamos un <code>LocalProxy</code> para leer la variable global usando s\u00f3lo la referencia <code>db</code>, de manera que internamente cada referencia a <code>db</code> realmente est\u00e1 llamando a <code>get_db()</code>.</p> <p>A continuaci\u00f3n, mostramos un par de m\u00e9todos del mismo archivo que muestran c\u00f3mo obtenemos datos desde MongoDB haciendo uso de PyMongo:</p> db.py<pre><code>def get_all_users():\n\"\"\"\n    Devuelve una lista con todos los usuarios del sistema\n    \"\"\"\ntry:\nreturn list(db.users.find({}).sort(\"nombre\", ASCENDING))\nexcept Exception as e:\nreturn e\ndef get_user_by_id(id):\n\"\"\"\n    Devuelve un objeto User a partir de su id\n    \"\"\"\ntry:\nusuario = db.users.find_one({\"_id\":ObjectId(id)})\nusuario_obj = User( id=usuario[\"_id\"],\nemail=usuario.get(\"email\"),\nnombre=usuario.get(\"nombre\"),\npassword=usuario.get(\"password\"),\nrol=usuario.get(\"rol\"),\nparent=usuario.get(\"parent\"))\nreturn usuario_obj\nexcept Exception as e:\nreturn e\n...\n</code></pre> <p>Cuando recuperamos un usuario por su <code>id</code>, lo convertimos en un objeto <code>User</code> para que Flask Login falicita la gesti\u00f3n de la autenticaci\u00f3n. En cambio, en el listado de todos los usuarios, vamos a acceder al cursor de usuarios que ofrece MongoDB.</p>"},{"location":"sa/07pymongo.html#referencias","title":"Referencias","text":"<ul> <li>Tutorial oficial de PyMongo</li> <li>Introduction to Multi-Document ACID Transactions in Python</li> <li>How To Use Transactions in MongoDB</li> </ul>"},{"location":"sa/07pymongo.html#actividades","title":"Actividades","text":"<ol> <li> <p>(RA5074.3 / CE4.3d / 4p) A partir del caso de uso de PIA Login, se pide:</p> <ul> <li>(0.25) Configurar la URI de Mongo Atlas para atacar vuestra propia base de datos.</li> <li>(0.25) Modificar la migraci\u00f3n para introducir m\u00e1s usuarios (al menos uno m\u00e1s de cada rol)</li> <li>(0.75) Cuando un usuario pulsa sobre su nombre, actualmente aparece un formulario para editar sus datos, pero no puede cambiar la contrase\u00f1a. Modifica (o crea) el/los formulario/s adecuado/s para que cada usuario pueda cambiar su propia contrase\u00f1a.</li> <li>(0.75) Desde el rol <code>Administrador</code>, al crear un usuario, si es un cliente, debe mostrar un desplegable con todos los t\u00e9cnicos disponibles.</li> <li>(1) Tanto el <code>T\u00e9cnico</code> como el <code>Cliente</code>, al dar de alta o editar un cliente, almacenar\u00e1n datos necesarios para el proyecto, como son el sexo, la fecha de nacimiento y la patolog\u00eda.</li> <li>(1) Cuando un <code>T\u00e9cnico</code> visualiza el listado de sus clientes, debe recuperar \u00fanicamente el nombre, el sexo, la edad y su patolog\u00eda.</li> </ul> </li> </ol>"},{"location":"spark/index.html","title":"Anal\u00edtica de datos mediante Spark","text":""},{"location":"spark/index.html#resultados-de-aprendizaje","title":"Resultados de aprendizaje","text":"<ul> <li>RA5074.1 Aplica t\u00e9cnicas de an\u00e1lisis de datos que integran, procesan y analizan la informaci\u00f3n, adaptando e implementando sistemas que las utilicen.  </li> <li>RA5074.3 Gestiona y almacena datos facilitando la b\u00fasqueda de respuestas en grandes conjuntos de datos.  </li> <li>RA5075.1 Gestiona soluciones a problemas propuestos, utilizando sistemas de almacenamiento y herramientas asociadas al centro de datos.  </li> <li>RA5075.2 Gestiona sistemas de almacenamiento y el amplio ecosistema alrededor de ellos facilitando el procesamiento de grandes cantidades de datos sin fallos y de forma r\u00e1pida.  </li> <li>RA5075.3 Genera mecanismos de integridad de los datos, comprobando su mantenimiento en los sistemas de ficheros distribuidos y valorando la sobrecarga que conlleva en el tratamiento de los datos.</li> </ul>"},{"location":"spark/index.html#planificacion-24h","title":"Planificaci\u00f3n (24h)","text":"Sesi\u00f3n Fecha Duraci\u00f3n (h) 56.- Spark Mi\u00e9rcoles 11 Ene 1p + 1o 62.- Spark RDD Mi\u00e9rcoles 11 EneMi\u00e9rcoles 18 Ene 3p + 3o 64.- Spark DataFrames API Lunes 23 Ene 2p + 2o 66.- Agregaciones con DataFrames Mi\u00e9rcoles 25 Ene 2p + 2o 69.- Spark Catalog. Delta Lake Lunes 30 Ene 2p + 2o 105.- Spark Streaming Lunes 27 Mar 4p + 4o"},{"location":"spark/01rdd.html","title":"RDD","text":"<p>Un RDD (Resilient Distributed Datasets) es una estructura de datos que abstrae los datos para su procesamiento en paralelo.</p> <p>Antes de Spark 2.0, los RDD eran el interfaz principal para interactuar con los datos.</p> <p>Se trata de una colecci\u00f3n de elementos tolerantes a fallos que son immutables (una vez creados, no se pueden modificar) y dise\u00f1ados para su procesamiento distribuido. Cada conjunto de datos en los RDD se divide en particiones l\u00f3gicas, que se pueden calcular en diferentes nodos del cl\u00faster.</p> <p>Hay dos formas de crear un RDD:</p> <ul> <li>Paralelizando una colecci\u00f3n ya existente en nuestra aplicaci\u00f3n Spark.</li> <li>Referenciando un dataset de un sistema externo como HDFS, HBase, etc...</li> </ul> <p>Sobre los RDD se pueden realizar dos tipos de operaciones:</p> <ul> <li>Acci\u00f3n: devuelven un valor tras ejecutar una computaci\u00f3n sobre el conjunto de datos.</li> <li>Transformaci\u00f3n: es una operaci\u00f3n perezosa que crea un nuevo conjunto de datos a partir de otro RDD/Dataset, tras realizar un filtrado, join, etc...</li> </ul> <p>\u00bfRDD obsoleto?</p> <p>Antes de la versi\u00f3n 2.0, el principal interfaz para programar en Spark eran los RDD. Tras la versi\u00f3n 2.0, fueron sustituidos por los Dataset, que son RDD fuertemente tipados que adem\u00e1s est\u00e1n optimizados a bajo nivel. Aunque el interfaz RDD todav\u00eda tiene soporte, sin embargo, se recomienda el uso de los Dataset por su mejor rendimiento. A lo largo de estas sesiones iremos combinando ambos interfaces para conocer las similitudes y diferencias.</p>"},{"location":"spark/01rdd.html#acciones","title":"Acciones","text":"<p>A continuaci\u00f3n vamos a revisar las acciones m\u00e1s comunes. Puedes consultar todas las acciones disponibles en la documentaci\u00f3n oficial:</p>"},{"location":"spark/01rdd.html#parallelize","title":"Parallelize","text":"<p>Podemos crear RDD directamente desde cero sin necesidad de leer los datos desde un fichero. Para ello, a partir de un <code>SparkContext</code> podemos utilizar <code>parallelize</code> sobre una lista.</p> <p>Esta acci\u00f3n divide una colecci\u00f3n de elementos entre los nodos de nuestro cl\u00fasters. Por ejemplo:</p> <pre><code>miRDD = sc.parallelize([1,2,3,4,5,6,7,8,9])\nlista  = ['Hola', 'Adi\u00f3s', 'Hasta luego']\nlistaRDD = sc.parallelize(lista) # Creamos un RDD a partir de una lista\nlistaRDD4 = sc.parallelize(lista,4) # Creamos un RDD con 4 particiones\n</code></pre>"},{"location":"spark/01rdd.html#take-y-sample","title":"Take y Sample","text":"<p>Una vez tenemos un RDD, y sobre \u00e9l queremos recuperar un n\u00famero determinado de resultados, de forma similar a limit en SQL, tenemos la acci\u00f3n <code>take</code>:</p> <pre><code>miRDD.take(3)       # [1, 2, 3]\nlistaRDD.take(2)    # ['Hola', 'Adi\u00f3s']\n</code></pre> <p>Otra opci\u00f3n es utilizar <code>sample</code> para obtener una muestra de los datos, aunque en este caso no es una acci\u00f3n sino una transformaci\u00f3n, ya que va a obtener informaci\u00f3n posiblemente de varias particiones, teniendo que barajar los datos (shuffle):</p> <pre><code>miRDDmuestra = miRDD.sample(False, 0.5)\nmiRDDmuestra.collect()  # [2, 4, 6, 7, 8, 9] / [1, 2, 3, 4, 6] / [5, 8, 9]\n</code></pre> <p>Esta transformaci\u00f3n recibe varios par\u00e1metros:</p> <ul> <li><code>withReplacement</code>: booleano para indicar si queremos elementos repetidos</li> <li><code>fraction</code>: valor entre 0 y 1 que expresa la probabilidad de elegir cada elemento</li> <li>opcionalmente se le puede pasar un tercer valor con la semilla</li> </ul> <p>As\u00ed pues, en el ejemplo anterior, cada llamada a sample ha generado un RDD diferente, sin valores repetidos, pero con un tama\u00f1o de RDD variable.</p> <p>Muestra estratificada</p> <p>Si necesitamos que nuestra muestra est\u00e9 estratificada para que los datos no est\u00e9n sesgados podemos utilizar <code>sampleByKey</code>:</p> <pre><code>datos = sc.parallelize([(1, 'a'), (1, 'b'), (2, 'c'), (2, 'd'), (2, 'e'), (3, 'f')])\n# indicamos la probabilidad para cada clave\nfracciones = {1: 0.1, 2: 0.6, 3: 0.3}\napproxSample = datos.sampleByKey(False, fracciones)     # [(2, 'c'), (2, 'd')]\n</code></pre> <p>Para obtener una muestra mediante una acci\u00f3n, tenemos la opci\u00f3n takeSample que funciona de forma similar pero sin hacer shuffle y devuelve una lista:</p> <pre><code>miRDDmuestraT = miRDD.takeSample(False, 5)\nprint(miRDDmuestraT)  # [1, 8, 9, 7, 2]\n</code></pre> <p>El primer par\u00e1metro vuelve a indicar si hay repetidos, pero el segundo fija la cantidad de elementos a devolver.</p> <p>Por \u00faltimo, mediante <code>top</code> obtenemos los primeros elementos una vez ordenado el RDD:</p> <pre><code>miRDD.top(3)    # [9, 8, 7]\n</code></pre> <p>De forma similar, tenemos <code>takeOrdered</code> que recupera la cantidad de registros necesarios pero ordenados ascendentemente (al contrario que <code>top</code>), con la opci\u00f3n de ordenarlos descendentemente (similar a <code>top</code>):</p> <pre><code>miRDD.takeOrdered(3)    # [1, 2, 3]\nmiRDD.takeOrdered(3, lambda x: -x)    # [9, 8, 7]\n</code></pre> <p>Hay que tener cuidado si el conjunto de datos es muy grande, porque tanto <code>take</code> como <code>takeSample</code>, <code>takeOrdered</code> y <code>top</code> llevar\u00e1n todos los datos a memoria.</p> <p>Funciones lambda</p> <p>Spark hace un uso extensivo de las funciones lambda de Python para simplificar el c\u00f3digo.</p> <p>Una funci\u00f3n lambda no es m\u00e1s que una funci\u00f3n an\u00f3nima condensada en una sola l\u00ednea:</p> <pre><code># par1 y par2 son los par\u00e1metros de entrada, y expresi\u00f3n el c\u00f3digo de la funci\u00f3n\nlambda par1, par2: expresi\u00f3n\n</code></pre> <p>Por ejemplo, si tuvi\u00e9ramos una funci\u00f3n que suma dos n\u00fameros, podr\u00edamos hacerla en Python de estas dos maneras:</p> <pre><code>def suma(x,y):\nreturn(x + y)\nsumaL = lambda x,y : x + y\nres = suma(3, 4)\nresL = sumaL(3, 4)\n</code></pre> <p>A lo largo de los ejemplos de esta sesi\u00f3n y las siguientes nos iremos familiarizando con su uso.</p>"},{"location":"spark/01rdd.html#collect","title":"Collect","text":"<p>Un fallo muy posible a la hora de mostrar los datos de un RDD es utilizar <code>rdd.foreach(print)</code> o <code>rdd.map(print)</code>.</p> <p>En una \u00fanica m\u00e1quina, esta operaci\u00f3n generar\u00eda la salida esperada mostrando todos los elementos del RDD. Sin embargo, al trabajar en un cl\u00faster, la salida a stdout la realizar\u00edan los diferentes nodos y no el nodo principal.</p> <p>As\u00ed pues, para mostrar todos los elementos de un RDD/DataFrame/Dataset hemos de emplear el m\u00e9todo <code>collect</code>, el cual primero mostrar\u00e1 los RDD del nodo principal (driver node), y luego para cada nodo del cluster mostrar\u00e1 sus datos.</p> <pre><code>rdd.collect()\n</code></pre> <p>Out of memory</p> <p>Hay que tener mucho cuidado, ya que nos podemos quedar f\u00e1cilmente sin memoria, ya que <code>collect</code> se trae los datos de todos los ejecutores a un \u00fanico nodo, el que \u00e9sta ejecutando el c\u00f3digo (driver).</p> <p>Si s\u00f3lo necesitamos mostrar unos pocos elementos, un enfoque m\u00e1s seguro es utilizar <code>take</code>:</p> <pre><code>rdd.take(100)\n</code></pre>"},{"location":"spark/01rdd.html#transformaciones","title":"Transformaciones","text":"<p>En Spark, las estructuras de datos son inmutables, de manera que una vez creadas no se pueden modificar. Para poder modificar un RDD/DataFrame, hace falta realizar una transformaci\u00f3n, siendo el modo de expresar la l\u00f3gica de negocio mediante Spark.</p> <p>Todas las transformaciones en Spark se eval\u00faan de manera perezosa (lazy evaluation), de manera que los resultados no se computan inmediatamente, sino que se retrasa el c\u00e1lculo hasta que el valor sea necesario. Para ello, se van almacenando los pasos necesarios y se ejecutan \u00fanicamente cuando una acci\u00f3n requiere devolver un resultado al driver. Este dise\u00f1o facilita un mejor rendimiento (por ejemplo, imagina que tras una operaci\u00f3n map se realiza un reduce y en vez de devolver todo el conjunto de datos tras el map, s\u00f3lo le enviamos al driver el resultado de la reducci\u00f3n).</p> <p>As\u00ed pues, las acciones provocan la evaluaci\u00f3n de todas las transformaciones previas que se hab\u00edan evaluado de forma perezosa y estaban a la espera.</p> <p>Por defecto, cada transformaci\u00f3n RDD/DataSet se puede recalcular cada vez que se ejecute una acci\u00f3n. Sin embargo, podemos persistir un RDD en memoria mediante los m\u00e9todos <code>persist</code> (o <code>cache</code>), de manera que Spark mantendr\u00e1 los datos para un posterior acceso m\u00e1s eficiente. Tambi\u00e9n podemos persistir RDD en disco o replicarlo en m\u00faltiples nodos.</p>"},{"location":"spark/01rdd.html#tipos-de-transformaciones","title":"Tipos de transformaciones","text":"<p>Existen dos tipos de transformaciones, dependiendo de las dependencias entre las particiones de datos:</p> <ul> <li> <p>Transformaciones Narrow: consisten en dependencias estrechas en las que cada partici\u00f3n de entrada contribuye a una \u00fanica partici\u00f3n de salida.</p> </li> <li> <p>Transformaciones Wide: consisten en dependencias anchas de manera que varias particiones de entrada contribuyen a muchas otras particiones de salida, es decir, cada partici\u00f3n de salida depende de diferentes particiones de entrada. Este proceso tambi\u00e9n se conoce como shuffle, ya que Spark baraja los datos entre las particiones del cl\u00faster.</p> </li> </ul> Transformaciones Narrow vs Wide <p>Con las transformaciones narrow, Spark realiza un pipeline de las dependencias, de manera que si especificamos m\u00faltiples filtros sobre DataFrames/RDD, se realizar\u00e1n todos en memoria.</p> <p>Esto no sucede con las transformaciones wide, ya que al realizar un shuffle los resultados se persisten en disco.</p> <p>Cuidado con shuffle</p> <p>Las operaciones shuffle son computacionalmente caras, ya que implican E/S en disco, serializaci\u00f3n de datos y E/S en red. Para organizar los datos previos al shuffle, Spark genera un conjunto de tareas (tareas map para organizar los datos, y reduce para agregar los resultados).</p> <p>Internamente, el resultado de las tareas map se mantienen en memoria hasta que no caben. Entonces, se ordenan en la partici\u00f3n destino y se persisten en un \u00fanico archivo. En la fase de reducci\u00f3n, las tareas leen los bloques ordenados que son relevantes.</p> <p>Las operaciones reduceByKey y aggregateByKey son de las que m\u00e1s memoria consumen, al tener que crear las estructuras de datos para organizar los registros en las tareas de map, y luego generar los resultados agregados en la de reduce. Si los datos no caben en memoria, Spark los lleva a disco, incurriendo en operaciones adicionales de E/S en disco y del recolector de basura.</p> <p>A continuaci\u00f3n veremos las diferentes transformaciones que podemos realizar con Spark.</p>"},{"location":"spark/01rdd.html#transformaciones-narrow","title":"Transformaciones Narrow","text":"<p>Para los siguientes ejemplo, utilizaremos el siguiente fichero de empleados.txt que ya utilizamos en la sesi\u00f3n de Hive:</p> empleados.txt<pre><code>Michael|Montreal,Toronto|Male,30|DB:80|Product:Developer\u0004Lead\nWill|Montreal|Male,35|Perl:85|Product:Lead,Test:Lead\nShelley|New York|Female,27|Python:80|Test:Lead,COE:Architect\nLucy|Vancouver|Female,57|Sales:89,HR:94|Sales:Lead\n</code></pre>"},{"location":"spark/01rdd.html#map","title":"Map","text":"<p>La transformaci\u00f3n <code>map</code> aplica la funci\u00f3n recibida a cada elemento del RDD, de manera que vamos a poder a\u00f1adir una nueva columna, modificar una existente, etc...</p> <p>Por ejemplo, si la entrada es un RDD que contiene <code>[1, 2, 3, 4, 5]</code>, al hacer <code>rdd.map(lambda x: x*2)</code> obtendr\u00edamos un nuevo RDD con <code>[2, 4, 6, 8, 10]</code>:</p> <pre><code>rdd = sc.parallelize([1, 2, 3, 4, 5])\nresultRDD = rdd.map(lambda x: x*2)\nresultRDD.collect()          # [2, 4, 6, 8, 10]\n</code></pre> <p>Mediante la funci\u00f3n <code>textFile</code> podemos cargar un archivo. Supongamos que tenemos cargado en Hadoop el archivo empleados.txt:</p> <pre><code>rddLocal = sc.textFile(\"empleados.txt\")\nrdd = sc.textFile(\"hdfs://iabd-virtualbox:9000/user/iabd/datos/empleados.txt\") \nrdd.count()                 # 4 - cantidad de l\u00edneas\nresultRDD = rdd.map(len)    # obtenemos la cantidad de caracteres cada l\u00ednea\nresultRDD.collect()         # [61, 52, 60, 50]\n</code></pre> <p>Si quisi\u00e9ramos mostrar los datos de los empleados, podr\u00edamos recoger los datos del RDD y recorrerlo:</p> <pre><code>empleados = rdd.collect()\nfor empleado in empleados:\nprint(empleado)\n</code></pre>"},{"location":"spark/01rdd.html#flatmap","title":"FlatMap","text":"<p>La transformaci\u00f3n flatMap es muy similar a la anterior, pero en vez de devolver una lista con un elemento por cada entrada, devuelve una \u00fanica lista deshaciendo las colecciones en elementos individuales:</p> <pre><code>rdd = sc.textFile(\"empleados.txt\") \nresultFM = rdd.flatMap(lambda x: x.split(\"|\"))\nresultFM.collect()\n</code></pre> <p>Obtendr\u00edamos cada atributo separado y todos dentro de la misma lista:</p> <pre><code>['Michael',\n'Montreal,Toronto',\n'Male,30',\n'DB:80',\n'Product:Developer\\x04Lead',\n'Will',\n'Montreal',\n'Male,35',\n'Perl:85',\n'Product:Lead,Test:Lead',\n'Shelley',\n'New York',\n'Female,27',\n'Python:80',\n'Test:Lead,COE:Architect',\n'Lucy',\n'Vancouver',\n'Female,57',\n'Sales:89,HR:94',\n'Sales:Lead']\n</code></pre>"},{"location":"spark/01rdd.html#filter","title":"Filter","text":"<p>Permite filtrar los elementos que cumplen una condici\u00f3n mediante <code>filter</code>:</p> <pre><code>rdd = sc.parallelize([1, 2, 3, 4, 5])\nresultRDD = rdd.filter(lambda x: x%2==0)\nresultRDD.collect()     # [2, 4] \n</code></pre> <p>Tambi\u00e9n podemos anidar diferentes transformaciones. Para este ejemplo, vamos a crear tuplas formadas por un n\u00famero y su cuadrado, y luego quitar los que no coincide el n\u00famero con su cuadrado (s\u00f3lo coinciden el 0 y el 1), y luego aplanarlo en una lista:</p> <pre><code>rdd10 = sc.parallelize(range(10+1))\nrddPares = rdd10.map(lambda x: (x, x**2)).filter(lambda x: (x[0] != x[1])).flatMap(lambda x: x)\nrddPares.collect()      # [2, 4, 3, 9, 4, 16, 5, 25, 6, 36, 7, 49, 8, 64, 9, 81, 10, 100]\n</code></pre> <p>Veamos otro ejemplo. Retomamos los datos de los empleados y si queremos filtrar los empleados que son hombres, primero separamos por las <code>|</code> y nos quedamos con el tercer elemento que contiene el sexo y la edad. A continuaci\u00f3n, separamos por la coma para quedarnos en el sexo en la posici\u00f3n 0 y la edad en el 1, y comparamos con el valor deseado:</p> <pre><code>rdd = sc.textFile(\"empleados.txt\") \nhombres = rdd.filter(lambda x: x.split(\"|\")[2].split(\",\")[0] == \"Male\")\nresultFM.collect()\n</code></pre> <p>Obteniendo:</p> <pre><code>['Michael|Montreal,Toronto|Male,30|DB:80|Product:Developer\\x04Lead',\n'Will|Montreal|Male,35|Perl:85|Product:Lead,Test:Lead']\n</code></pre>"},{"location":"spark/01rdd.html#distinct","title":"Distinct","text":"<p>Si utilizamos distinct eliminaremos los elementos repetidos:</p> <pre><code>rdd = sc.parallelize([1,1,2,2,3,4,5])\nresultRDD = rdd.distinct()\nresultRDD.collect()     # [4, 1, 5, 2, 3]\n</code></pre>"},{"location":"spark/01rdd.html#trabajando-con-conjuntos","title":"Trabajando con conjuntos","text":""},{"location":"spark/01rdd.html#union","title":"Union","text":"<p>Mediante <code>union</code> unimos dos RDD en uno:</p> <pre><code>rdd1 = sc.parallelize([1,2,3,4])\nrdd2 = sc.parallelize([5,6,7,8])\nresultRDD = rdd1.union(rdd2)\nresultRDD.collect()     # [1, 2, 3, 4, 5, 6, 7, 8]\n</code></pre>"},{"location":"spark/01rdd.html#intersection","title":"Intersection","text":"<p>Mediante <code>intersection</code>, obtendremos los elementos que tengan en com\u00fan:</p> <pre><code>rdd1 = sc.parallelize([1,2,3,4])\nrdd2 = sc.parallelize([3,4,5,6])\nresultRDD = rdd1.intersection(rdd2)\nresultRDD.collect()     # [3, 4]\n</code></pre>"},{"location":"spark/01rdd.html#subtract","title":"Subtract","text":"<p>Mediante <code>subtract</code>, obtendremos los elementos propios que no est\u00e9n en el RDD recibido:</p> <pre><code>rdd1 = sc.parallelize([1,2,3,4])\nrdd2 = sc.parallelize([3,4,5,6])\nresultRDD = rdd1.subtract(rdd2)\nresultRDD.collect()     # [1, 2]\n</code></pre> <p>Autoevaluaci\u00f3n</p> <p>Si tenemos dos RDD (A y B):</p> <pre><code>rddA = sc.parallelize([1,2,3,4])\nrddB = sc.parallelize([3,4,5,6])\n</code></pre> EnunciadoSoluci\u00f3n <p>\u00bfC\u00f3mo conseguimos los elementos que est\u00e1n en A y no B y los de B que no est\u00e1n en A? (es decir <code>[1, 2, 5, 6]</code>)):</p> <pre><code>resultRDD = rddA.subtract(rddB).union(rddB.subtract(rddA))\nresultRDD.collect()     # [1, 2, 5, 6]\n</code></pre>"},{"location":"spark/01rdd.html#rdd-de-pares","title":"RDD de Pares","text":"<p>Una t\u00e9cnica muy com\u00fan a la hora de trabajar con RDD es hacerlo con elementos que tienen el formato <code>(clave, valor)</code>, pudiendo las claves y los valores ser de cualquier tipo.</p> <pre><code>listaTuplas = [(1,'a'), (2,'b'), (3,'c'), (4,'d')]\nrddTuplas= sc.parallelize(listaTuplas)\n</code></pre> <p>Sobre estos RDD podemos realizar algoritmos MapReduce para muchas funciones de procesamiento de datos, como es la agrupaci\u00f3n, ordenaci\u00f3n, join, count, etc...</p> <p>Para generar un RDD de pares, adem\u00e1s de crearlo nosotros a partir de una lista, podemos emplear las siguientes operaciones:</p> <ul> <li> <p><code>zip</code>: une dos RDDs del mismo tama\u00f1o:</p> <pre><code>lista1 = ['a','b','c','e','f','g','h']\nlista2 = [4, 5, 6, 7, 8, 9, 10]\nrddZip = sc.parallelize(lista1).zip(sc.parallelize(lista2)).collect()\n# [('a', 4), ('b', 5), ('c', 6), ('e', 7), ('f', 8), ('g', 9), ('h', 10)]\nrddZipSecuencia = sc.parallelize(zip(lista1,range(len(lista1)))) # usando el tama\u00f1o de la lista\n# [('a', 0), ('b', 1), ('c', 2), ('e', 3), ('f', 4), ('g', 5), ('h', 6)]\n</code></pre> <p>Otros m\u00e9todos relacionados son zipWithIndex y zipWithUniqueId.</p> </li> <li> <p><code>map</code>: asignando a cada elemento un valor o c\u00e1lculo sobre \u00e9l mismo:</p> <pre><code>lista  = ['Hola', 'Adi\u00f3s', 'Hasta luego']\nrddMap = sc.parallelize(lista).map(lambda x: (x, len(x)))\n# [('Hola', 4), ('Adi\u00f3s', 5), ('Hasta luego', 11)]\n</code></pre> </li> <li> <p><code>keyBy</code>: permite crear las claves a partir de cada elemento:</p> <pre><code>rddKeyBy = sc.parallelize(lista).keyBy(lambda x: x[0])  # creamos una clave con la primera letra\n# [('H', 'Hola'), ('A', 'Adi\u00f3s'), ('H', 'Hasta luego')]\n</code></pre> </li> </ul> <p>Autoevaluaci\u00f3n</p> <p>A partir de la lista <code>\"Perro Gato Loro Pez Le\u00f3n Tortuga Gallina\"</code></p> EnunciadoSoluci\u00f3n <ol> <li>Crea un RDD a partir de esta lista</li> <li>Convierte el RDD normal en un RDD de pares cuya clave sea la primera letra del animal</li> <li>Crea otro RDD de pares pero poniendo como clave un n\u00famero incremental</li> <li>\u00bfY si queremos que el \u00edndice incremental empiece en 100?</li> </ol> <pre><code>animales = \"Perro Gato Loro Pez Le\u00f3n Tortuga Gallina\"\nanimalesLista = animales.split(\" \")\nrdd1 = sc.parallelize(animalesLista)\nrdd2 = rdd1.keyBy(lambda x: x[0])\nrdd3 = sc.parallelize(zip(range(len(animalesLista)), animalesLista))\nrdd4 = sc.parallelize(zip(range(100,100+len(animalesLista)), animalesLista))\n</code></pre> <p>Sobre los RDD de pares, podemos realizar las siguientes transformaciones:</p> <ul> <li><code>keys</code>: devuelve las claves</li> <li><code>values</code>: devuelve los valores</li> <li><code>mapValues</code>: Aplica la funci\u00f3n sobre los valores</li> <li><code>flatMapValues</code> Aplica la funci\u00f3n sobre los valores y los aplana.</li> </ul> <p>A continuaci\u00f3n se muestra un fragmento de c\u00f3digo para poner en pr\u00e1ctica las transformaciones comentadas:</p> <pre><code>listaTuplas = [('a',1), ('z',3), ('b',4), ('c',3), ('a',4)]\nrddTuplas = sc.parallelize(listaTuplas)\nclaves = rddTuplas.keys()       # ['a', 'z', 'b', 'c', 'a']\nvalores = rddTuplas.values()    # [1, 3, 4, 3, 4]\nrddMapValues = rddTuplas.mapValues(lambda x: (x,x*2))\n# [('a', (1, 2)), ('z', (3, 6)), ('b', (4, 8)), ('c', (3, 6)), ('a', (4, 8))]\nrddFMV = rddTuplas.flatMapValues(lambda x: (x,x*2))\n# [('a', 1),\n#  ('a', 2),\n#  ('z', 3),\n#  ('z', 6),\n#  ('b', 4),\n# ...\n</code></pre>"},{"location":"spark/01rdd.html#transformaciones-wide","title":"Transformaciones Wide","text":"<p>Las siguientes transformaciones, adem\u00e1s de trabajar con RDD de pares, mezclan los datos de las particiones mediante el shuffle de los elementos.</p> <p>Para los siguientes ejemplos, utilizaremos un fichero de ventas pdi_sales.csv (versi\u00f3n extendida) / pdi_sales_small.csv (versi\u00f3n reducida) el cual tiene el siguiente formato:</p> pdi_sales.csv<pre><code>ProductID;Date;Zip;Units;Revenue;Country\n725;1/15/1999;41540          ;1;115.5;Germany\n787;6/6/2002;41540          ;1;314.9;Germany\n...\n</code></pre>"},{"location":"spark/01rdd.html#reducebykey","title":"ReduceByKey","text":"<p>Mediante la transformaci\u00f3n reducedByKey los datos se calculan utilizando una funci\u00f3n de reducci\u00f3n a partir de la clave combinando en la misma m\u00e1quina las parejas con la misma clave antes de que los datos se barajen.</p> <p>Vamos a comenzar con un ejemplo sencillo, contando cuantas ventas se han realizado en cada pa\u00eds, o lo que es lo mismo, las veces que aparece cada palabra en el fichero:</p> <pre><code>rdd = sc.textFile(\"pdi_sales_small.csv\")\n# Recogemos el pa\u00eds y las unidades de las ventas\nparPais1 = rdd.map(lambda x: (x.split(\";\")[-1].strip(), 1))\n# parPais1.collect()\n# [('Country', 1),\n#  ('Germany', 1),\n#  ('Germany', 1),\n#  ('Germany', 1), ...\n</code></pre> <p>Hemos creado un RDD de pares compuesto por el nombre del pa\u00eds y el n\u00famero uno, para luego en la fase de reducci\u00f3n sumar estos valores. Pero si nos fijamos, el archivo csv contiene el encabezado con los datos, el cual debemos quitar:</p> <pre><code>header = parPais1.first()\nparPais1SinHeader = parPais1.filter(lambda linea: linea != header)\n# parPais1SinHeader.collect()\n# [('Germany', 1),\n#  ('Germany', 1),\n#  ('Germany', 1), ...\n</code></pre> <p>Y finalmente, ya podemos reducir por la clave:</p> <pre><code>paisesTotal = parPais1SinHeader.reduceByKey(lambda a,b: a+b)\n# paisesTotal.collect()\n# [('Mexico', 30060), ('France', 30060), ('Germany', 30059), ('Canada', 30060)]\n</code></pre> <p>Funciones lambda en reduce</p> <p>Al aplicar una transformaci\u00f3n de tipo reduce, la funci\u00f3n lambda recibir\u00e1 dos par\u00e1metros, siendo el primero el valor acumulado y el segundo el valor del elemento a operar.</p> <p>Veamos otro ejemplo, en este caso vamos a calcular el total de unidades vendidas por pa\u00eds, de manera que vamos a coger el nombre del pa\u00eds (Country) y las unidades (Units) vendidas:</p> <pre><code>rdd = sc.textFile(\"pdi_sales_small.csv\")\n# Recogemos el pa\u00eds y las unidades de las ventas\npaisesUnidades = rdd.map(lambda x: (x.split(\";\")[-1].strip(), x.split(\";\")[3]))\n# Le quitamos el encabezado\nheader = paisesUnidades.first()\npaisesUnidadesSinHeader = paisesUnidades.filter(lambda linea: linea != header)\n# Pasamos las unidades a un n\u00famero entero\npaisesUnidadesInt = paisesUnidadesSinHeader.map(lambda x: (x[0], int(x[1])))\n# Reducimos por el pa\u00eds y sumamos las unidades\npaisesTotalUnidades = paisesUnidadesInt.reduceByKey(lambda a,b: a+b)\npaisesTotalUnidades.collect()\n</code></pre> <p>Y el resultado:</p> <pre><code>[('Mexico', 31095), ('France', 31739), ('Germany', 31746), ('Canada', 31148)]\n</code></pre> <p>Autoevaluaci\u00f3n</p> <p>Dada la siguiente lista de compra:</p> <pre><code>lista = [('pan',3), ('agua',2), ('az\u00facar',1), ('leche',2), ('pan',1), ('cereales',3), ('agua',0.5), ('leche',2), ('filetes',5)]\n</code></pre> EnunciadoSoluci\u00f3n <p>Calcula:</p> <ol> <li>El total que se ha gastado por cada producto</li> <li>Cu\u00e1nto es lo m\u00e1ximo que se ha pagado por cada producto</li> </ol> <pre><code>lista = [('pan',3), ('agua',2), ('az\u00facar',1), ('leche',2), ('pan',1), ('cereales',3), ('agua',0.5), ('leche',2), ('filetes',5)]\nrdd = sc.parallelize(lista)\nrdd1 = rdd.reduceByKey(lambda x,y: x+y)\nrdd2 = rdd.reduceByKey(lambda x,y: max(x,y))\n</code></pre>"},{"location":"spark/01rdd.html#groupbykey","title":"GroupByKey","text":"<p>Permite agrupar los datos a partir de una clave, repartiendo los resultados (shuffle) entre todos los nodos:</p> <pre><code>rdd = sc.textFile(\"pdi_sales_small.csv\")\n# Creamos un RDD de pares con el nombre del pa\u00eds como clave, y una lista con los valores\nventas = rdd.map(lambda x: (x.split(\";\")[-1].strip(), x.split(\";\")))\n# Quitamos el primer elemento que es el encabezado del CSV\nheader = paisesUnidades.first()\npaisesUnidadesSinHeader = paisesUnidades.filter(lambda linea: linea != header)\n# Agrupamos las ventas por nombre del pa\u00eds\npaisesAgrupados = ventas.groupByKey()\npaisesAgrupados.collect()\n</code></pre> <p>Obtendremos para cada pa\u00eds, un iterable con todos sus datos:</p> <pre><code>[('Canada', &lt;pyspark.resultiterable.ResultIterable at 0x7f814cd4b2e0&gt;),\n('France', &lt;pyspark.resultiterable.ResultIterable at 0x7f816c3a9700&gt;),\n('Germany', &lt;pyspark.resultiterable.ResultIterable at 0x7f814cd96eb0&gt;),\n('Mexico', &lt;pyspark.resultiterable.ResultIterable at 0x7f814cd965e0&gt;)]\n</code></pre> <p>Podemos transformar los iterables a una lista:</p> <pre><code>paisesAgrupadosLista = paisesAgrupados.map(lambda x: (x[0], list(x[1])))\npaisesAgrupadosLista.collect()\n</code></pre> <p>Obteniendo:</p> <pre><code>[('Canada ',\n[['725', '1/15/1999', 'H1B            ', '1', '115.4', 'Canada '],\n['2235', '1/15/1999', 'H1B            ', '2', '131.1', 'Canada '],\n['713', '1/15/1999', 'H1B            ', '1', '160.1', 'Canada '],\n...\n</code></pre> <p>Autoevaluaci\u00f3n</p> <p>Ahora tenemos las cuentas de las compras de 3 d\u00edas:</p> <ul> <li>d\u00eda 1: pan 3\u20ac, agua 2\u20ac, az\u00facar 1\u20ac, leche 2\u20ac, pan 4\u20ac</li> <li>d\u00eda 2: pan 1\u20ac, cereales 3\u20ac, agua 0.5\u20ac, leche 2\u20ac, filetes 5\u20ac</li> <li>d\u00eda 3: filetes 2\u20ac, cereales 1\u20ac</li> </ul> <p>Dada la siguiente lista de compra:</p> <pre><code>dia1 = [('pan',3), ('agua',2), ('az\u00facar',1), ('leche',2), ('pan',4)]\ndia2 = [('pan',1), ('cereales',3), ('agua',0.5), ('leche',2), ('filetes',5)]\ndia3 = [('filetes',2), ('cereales',1)]\n</code></pre> EnunciadoSoluci\u00f3n <ol> <li>\u00bfC\u00f3mo obtenemos lo que hemos gastado en cada producto?</li> <li>\u00bfY el gasto medio que hemos realizado en cada uno de ellos?</li> </ol> <pre><code>dia1 = [('pan',3), ('agua',2), ('az\u00facar',1), ('leche',2), ('pan',4)]\ndia2 = [('pan',1), ('cereales',3), ('agua',0.5), ('leche',2), ('filetes',5)]\ndia3 = [('filetes',2), ('cereales',1)]\nrdd = sc.parallelize(dia1).union(sc.parallelize(dia2)).union(sc.parallelize(dia3))\nrdd1=rdd.groupByKey()\n# [('leche', &lt;pyspark.resultiterable.ResultIterable at 0x7f3494aea130&gt;),\n#  ('agua', &lt;pyspark.resultiterable.ResultIterable at 0x7f3494acd4c0&gt;),\n#  ('pan', &lt;pyspark.resultiterable.ResultIterable at 0x7f3494acd2b0&gt;),\n#  ('cereales', &lt;pyspark.resultiterable.ResultIterable at 0x7f3494acd850&gt;),\n#  ('filetes', &lt;pyspark.resultiterable.ResultIterable at 0x7f34944e3be0&gt;),\n#  ('az\u00facar', &lt;pyspark.resultiterable.ResultIterable at 0x7f34944e3fa0&gt;)]\nrdd1a = [(x,list(y)) for x,y in rdd1.collect()]\n# rdd1a ya no es un RDD, es una lista que se ha cargado en el driver\nrdd1b = rdd1.map(lambda x: (x[0], list(x[1])))\n#rdd1b sigue siendo un RDD\n# [('leche', [2, 2]),\n#  ('agua', [2, 0.5]),\n#  ('pan', [3, 4, 1]),\n#  ('cereales', [3, 1]),\n#  ('filetes', [5, 2]),\n#  ('az\u00facar', [1])]\nrdd2 = rdd1.map(lambda x: (x[0], sum(x[1])/len(x[1])))\n# [('leche', 2.0),\n#  ('agua', 1.25),\n#  ('pan', 2.6666666666666665),\n#  ('cereales', 2.0),\n#  ('filetes', 3.5),\n#  ('az\u00facar', 1.0)]\n</code></pre> <p>Mejor <code>reduceByKey</code> que <code>groupByKey</code></p> <p>Si el tipo de operaci\u00f3n a realizar es posible mediante una operaci\u00f3n de reduce, su rendimiento ser\u00e1 una soluci\u00f3n m\u00e1s eficiente. M\u00e1s informaci\u00f3n en el art\u00edculo Avoid Group By</p>"},{"location":"spark/01rdd.html#sortbykey","title":"SortByKey","text":"<p>sortByKey permite ordenar los datos a partir de una clave. Los pares de la misma m\u00e1quina se ordenan primero por la misma clave, y luego los datos de las diferentes particiones se barajan.</p> <p>Para ello crearemos una tupla, siendo el primer elemento un valor num\u00e9rico por el cual ordenar, y el segundo el dato asociado.</p> <p>Vamos a partir del ejemplo anterior para ordenar los paises por la cantidad de ventas:</p> <pre><code># Ejemplo anterior\nrdd = sc.textFile(\"pdi_sales.csv\")\npaisesUnidades = rdd.map(lambda x: (x.split(\";\")[-1].strip(), x.split(\";\")[3]))\nheader = paisesUnidades.first()\npaisesUnidadesSinHeader = paisesUnidades.filter(lambda linea: linea != header)\npaisesTotalUnidades = paisesUnidadesSinHeader.reduceByKey(lambda a,b: int(a)+int(b))\n# Le damos la vuelta a la lista\nunidadesPaises = paisesTotalUnidades.map(lambda x: (x[1],x[0]))\nunidadesPaises.collect()\n</code></pre> <p>Ahora tendr\u00edamos:</p> <pre><code>[(77609, 'Canada'),\n(327730, 'France'),\n(244265, 'Germany'),\n(223463, 'Mexico')]\n</code></pre> <p>Y a continuaci\u00f3n los ordenamos:</p> <pre><code>unidadesPaisesOrdenadas = unidadesPaises.sortByKey()\nunidadesPaisesOrdenadas.collect()\n</code></pre> <p>Y comprobamos el resultado:</p> <pre><code>[(77609, 'Canada'),\n(223463, 'Mexico'),\n(244265, 'Germany'),\n(327730, 'France')]\n</code></pre> <p>Si quisi\u00e9ramos obtener los datos en orden descendente, le pasamos <code>False</code> a la transformaci\u00f3n:</p> <pre><code>unidadesPaisesOrdenadasDesc = unidadesPaises.sortByKey(False)\n</code></pre>"},{"location":"spark/01rdd.html#sortby","title":"SortBy","text":"<p>Mediante sortBy podemos ordenar los datos indicando nosotros la funci\u00f3n de ordenaci\u00f3n:</p> <pre><code>paisesTotalUnidades.sortBy(lambda x: x[1]).collect()\n</code></pre> <p>Obteniendo:</p> <pre><code>[('Canada', 77609),\n('Mexico', 223463),\n('Germany', 244265),\n('France', 327730)]\n</code></pre> <p>Si queremos ordenar descendentemente, le pasamos un segundo par\u00e1metro con valor <code>False</code> (indica si la ordenaci\u00f3n es ascendente):</p> <pre><code>paisesTotalUnidades.sortBy(lambda x: x[1], False).collect()\n</code></pre> <p>Join</p> <p>Aunque los RDD permitan realizar operaciones join, realmente este tipo de operaciones se realizan mediante DataFrames, por lo que omitimos su explicaci\u00f3n en esta sesi\u00f3n y la dejamos para la siguiente.</p>"},{"location":"spark/01rdd.html#particiones","title":"Particiones","text":"<p>Spark organiza los datos en particiones, consider\u00e1ndolas divisiones l\u00f3gicas de los datos entre los nodos del cl\u00faster. Por ejemplo, si el almacenamiento se realiza en HDFS, cada partici\u00f3n se asigna a un bloque.</p> <p>Cada una de las particiones va a llevar asociada una tarea de ejecuci\u00f3n, de manera que a m\u00e1s particiones, mayor paralelizaci\u00f3n del proceso.</p> <p>Veamos con c\u00f3digo como podemos trabajar con las particiones:</p> <pre><code>rdd = sc.parallelize([1,1,2,2,3,3,4,5])\nrdd.getNumPartitions() # 4\nrdd = sc.parallelize([1,1,2,2,3,3,4,5], 2)\nrdd.getNumPartitions() # 2\nrddE = sc.textFile(\"empleados.txt\")\nrddE.getNumPartitions() # 2\nrddE = sc.textFile(\"empleados.txt\", 3)\nrddE.getNumPartitions() # 3\n</code></pre> <p>La mayor\u00eda de operaciones / transformaciones / acciones que trabajan con los datos admiten un par\u00e1metro extra indicando la cantidad de particiones con las que queremos trabajar.</p>"},{"location":"spark/01rdd.html#mappartitions","title":"MapPartitions","text":"<p>A diferencia de la transformaci\u00f3n <code>map</code> que se invoca por cada elemento del RDD/DataSet, <code>mapPartitions</code> se llama por cada partici\u00f3n.</p> <p>La funci\u00f3n que recibe como par\u00e1metro recoger\u00e1 como entrada un iterador con los elementos de cada partici\u00f3n:</p> <pre><code>rdd = sc.parallelize([1,1,2,2,3,3,4,5], 2)\ndef f(iterator): yield sum(iterator)\nresultadoRdd = rdd.mapPartitions(f)\nresultadoRdd.collect()  # [6, 15]\nresultadoRdd2 = rdd.mapPartitions(lambda iterator: [list(iterator)])\nresultadoRdd2.collect() # [[1, 1, 2, 2], [3, 3, 4, 5]]\n</code></pre> <p>En el ejemplo, ha dividido los datos en dos particiones, la primera con <code>[1, 1, 2, 2]</code> y la otra con <code>[3, 3, 4, 5]</code>, y de ah\u00ed el resultado de sumar sus elementos es <code>[6, 15]</code>.</p>"},{"location":"spark/01rdd.html#mappartitionswithindex","title":"mapPartitionsWithIndex","text":"<p>De forma similar al caso anterior, pero ahora <code>mapPartitionsWithIndex</code> recibe una funci\u00f3n cuyos par\u00e1metros son el \u00edndice de la partici\u00f3n y el iterador con los datos de la misma:</p> <pre><code>def mpwi(indice, iterador):\nreturn [(indice, list(iterador))]\nresultadoRdd = rdd.mapPartitionsWithIndex(mpwi)\nresultadoRdd.collect()\n# [(0, [1, 1, 2, 2]), (1, [3, 3, 4, 5])]\n</code></pre>"},{"location":"spark/01rdd.html#modificando-las-particiones","title":"Modificando las particiones","text":"<p>Podemos modificar la cantidad de particiones mediante dos transformaciones wide: <code>coalesce</code> y <code>repartition</code>.</p> <p>Mediante <code>coalesce</code> podemos obtener un nuevo RDD con la cantidad de particiones a reducir:</p> <pre><code>rdd = sc.parallelize([1,1,2,2,3,3,4,5], 3)\nrdd.getNumPartitions() # 3\nrdd1p = rdd.coalesce(1)\nrdd1p.getNumPartitions() # 2\n</code></pre> <p>En cambio, mediante <code>repartition</code> podemos obtener un nuevo RDD con la cantidad exacta de particiones deseadas (al reducir las particiones, <code>repartition</code> realiza un shuffle para redistribuir los datos, por lo tanto, si queremos reducir la cantidad de particiones, es m\u00e1s eficiente utilizar coalesce):</p> <pre><code>rdd = sc.parallelize([1,1,2,2,3,3,4,5], 3)\nrdd.getNumPartitions() # 3\nrdd2p = rdd.repartition(2)\nrdd2p.getNumPartitions() # 2\n</code></pre>"},{"location":"spark/01rdd.html#referencias","title":"Referencias","text":"<ul> <li>Documentaci\u00f3n oficial de Apache Spark</li> <li>RDD Programming Guide</li> <li>Learning Apache Spark, 2nd Edition</li> <li>Spark RDD Cheatsheet en PDF y en formato web</li> <li>Repositorio GitHub con apuntes sobre Spark de Vivek Bombatkar</li> <li>Learning Apache Spark with Python</li> </ul>"},{"location":"spark/01rdd.html#actividades","title":"Actividades","text":"<p>(RA5074.1 / CE4.1b) En las siguientes actividades vamos a familiarizarnos con el uso de Spark con RDD y las diferentes acciones y transformaciones disponibles.</p> <ol> <li> <p>(1p) A partir de la lista siguiente <code>['Alicante','Elche','Valencia','Madrid','Barcelona','Bilbao','Sevilla']</code>:</p> <ol> <li>Almacena s\u00f3lo las ciudades que tengan la letra <code>e</code> en su nombre y mu\u00e9stralas.</li> <li>Muestra las ciudades que tienen la letra <code>e</code> y el n\u00famero de veces que aparece en cada nombre. Por ejemplo <code>('Elche', 2)</code>.</li> <li>Averigua las ciudades que solo tengan una \u00fanica <code>e</code>.</li> <li>Nos han enviado una nueva lista pero no han separado bien las ciudades. Reorganiza la lista y colocalas correctamente, y cuenta las apariciones de la letra <code>e</code> de cada ciudad. <code>ciudades_mal = [['Alicante.Elche','Valencia','Madrid.Barcelona','Bilbao.Sevilla'],['Murcia','San Sebasti\u00e1n','Melilla.Aspe']]</code></li> </ol> </li> <li> <p>(1p) A partir de las siguientes listas:</p> <ul> <li>Ingl\u00e9s: <code>hello, table, angel, cat, dog, animal, chocolate, dark, doctor, hospital, computer</code></li> <li>Espa\u00f1ol: <code>hola, mesa, angel, gato, perro, animal, chocolate, oscuro, doctor, hospital, ordenador</code></li> </ul> <p>Una vez creado un RDD con tuplas de palabras y su traducci\u00f3n (puedes usar <code>zip</code> para unir dos listas):</p> <pre><code>[('hello', 'hola'),\n('table', 'mesa'),\n('angel', 'angel'),\n('cat', 'gato')...\n</code></pre> <p>Averigua:</p> <ol> <li>Palabras que se escriben igual en ingl\u00e9s y en espa\u00f1ol</li> <li>Palabras que en espa\u00f1ol son distintas que en ingl\u00e9s</li> <li>Obt\u00e9n una \u00fanica lista con las palabras en ambos idiomas que son distintas entre ellas (<code>['hello', 'hola', 'table', ...</code>)</li> <li>Haz dos grupos con todas las palabras, uno con las que empiezan por vocal y otro con las que empiecen por consonante.</li> </ol> </li> <li> <p>(0.75p) A partir del fichero de El Quijote:</p> <ol> <li>Crear un RDD a partir del fichero y crea una lista con todas las palabras del documento.</li> <li>\u00bfCuantas veces aparece la palabra <code>Dulcinea</code> (independientemente de si est\u00e1 en may\u00fasculas o min\u00fasculas)? \u00bfY <code>Rocinante</code>? (86 y 120 ocurrencias respectivamente)</li> <li>Devuelve una lista ordenada seg\u00fan el n\u00famero de veces que sale cada palabra de m\u00e1s a menos (las primeras ocurrencias deben ser <code>[('que', 10731), ('de', 9035), ('y', 8668), ('la', 5014), ...</code>).</li> <li>Almacena el resultado en HDFS en  <code>/user/iabd/spark/wcQuijote</code> (investiga el m\u00e9todo <code>saveAsTextFile</code>).</li> </ol> </li> <li> <p>(0.75p) Dada una cadena que contiene una lista de nombres <code>Juan, Jimena, Luis, Cristian, Laura, Lorena, Cristina, Jacobo, Jorge</code>, una vez transformada la cadena en una lista y luego en un RDD:</p> <ol> <li> <p>Agr\u00fapalos seg\u00fan su inicial, de manera que tengamos tuplas formadas por la letra inicial y todos los nombres que comienzan por dicha letra:</p> <pre><code>[('J', ['Juan', 'Jimena', 'Jacobo', 'Jorge']),\n('L', ['Luis', 'Laura', 'Lorena']),\n('C', ['Cristian', 'Cristina'])]\n</code></pre> </li> <li> <p>De la lista original, obt\u00e9n una muestra de 5 elementos sin repetir valores.</p> </li> <li>Devuelve una muestra de datos de aproximadamente la mitad de registros que la lista original con datos que pudieran llegar a repetirse.</li> </ol> </li> <li> <p>(0.5p) Dada una lista de elementos desordenados y algunos repetidos, devolver una muestra de 5 elementos, que est\u00e9n en la lista, sin repetir y ordenados descendentemente.</p> <pre><code>lista = 4,6,34,7,9,2,3,4,4,21,4,6,8,9,7,8,5,4,3,22,34,56,98\n</code></pre> <ol> <li>Selecciona el elemento mayor de la lista resultante.</li> <li>Muestra los dos elementos menores.</li> </ol> </li> <li> <p>(0.5p) En una red social sobre cine, tenemos un fichero ratings.txt compuesta por el c\u00f3digo de la pel\u00edcula, el c\u00f3digo del usuario, la calificaci\u00f3n asignada y el timestamp de la votaci\u00f3n con el siguiente formato:</p> <pre><code>1::1193::5::978300760\n1::661::3::978302109\n1::914::3::978301968\n</code></pre> <p>Se pide crear dos script en Python, as\u00ed como los comandos necesarios para ejecutarlos (mediante <code>spark-submit</code>) para:</p> <ol> <li>Obtener para cada pel\u00edcula, la nota media de todas sus votaciones.</li> <li>Pel\u00edculas cuya nota media sea superior a 3.</li> </ol> </li> </ol>"},{"location":"spark/01rdd.html#proyecto","title":"Proyecto","text":"<p>A continuaci\u00f3n planteamos el siguiente proyecto para realizar en clase:</p> <ol> <li> <p>(1.5 ptos) Tenemos las calificaciones de las asignaturas de matem\u00e1ticas, ingl\u00e9s y f\u00edsica de los alumnos del instituto en 3 documentos de texto. A partir de estos ficheros:</p> <ol> <li>Crea 3 RDD de pares, uno para cada asignatura, con los alumnos y sus notas</li> <li>Crea un solo RDD con todas las notas</li> <li>\u00bfCu\u00e1l es la nota m\u00e1s baja que ha tenido cada alumno?</li> <li>\u00bfCu\u00e1l es la nota media de cada alumno?</li> <li>\u00bfCuantos estudiantes suspende cada asignatura? <code>[('Mates', 7), ('F\u00edsica', 8), ('Ingl\u00e9s', 7)]</code></li> <li>\u00bfEn qu\u00e9 asignatura suspende m\u00e1s gente?</li> <li>Total de notables o sobresalientes por alumno, es decir, cantidad de notas superiores o igual a 7.</li> <li>\u00bfQu\u00e9 alumno no se ha presentado a ingl\u00e9s?</li> <li>\u00bfA cu\u00e1ntas asignaturas se ha presentado cada alumno?</li> <li>Obt\u00e9n un RDD con cada alumno con sus notas</li> </ol> </li> </ol>"},{"location":"spark/01spark.html","title":"Spark","text":"<p>La anal\u00edtica de datos es el proceso de inspeccionar, limpiar, transformar y modelar los datos con el objetivo de descubrir informaci\u00f3n \u00fatil, obtener conclusiones sobre los datos y ayudar en la toma de decisiones.</p> <p>Para ello, el uso de Spark de la mano de Python, NumPy y Pandas como interfaz de la anal\u00edtica es clave en el d\u00eda a d\u00eda de un cient\u00edfico/ingeniero de datos.</p> <p>Podemos considerar Spark como una navaja suiza, ya que permite trabajar con todo el ciclo del datos, desde la ingesta y la validaci\u00f3n de los datos en raw, limpieza, transformaci\u00f3n y agregaci\u00f3n de los datos, as\u00ed como la realizaci\u00f3n de un an\u00e1lisis exploratorio de los mismos.</p> <p>La versi\u00f3n 3.0 de Apache Spark se lanz\u00f3 en 2020, diez a\u00f1os despu\u00e9s de su nacimiento. Esta versi\u00f3n incluye mejoras de rendimiento (el doble en consultas adaptativas), facilidad en el uso del API de Pandas, un nuevo interfaz gr\u00e1fico para el streaming que facilita el seguimiento y depuraci\u00f3n de las consultas y ajustes de rendimiento.</p> <p>En la actualidad ya vamos por la versi\u00f3n 3.3.1 (a diciembre de 2022).</p>"},{"location":"spark/01spark.html#introduccion","title":"Introducci\u00f3n","text":"Logo de Apache Spark <p>Spark es un framework de computaci\u00f3n distribuida similar a Hadoop-MapReduce (as\u00ed pues, Spark no es un lenguaje de programaci\u00f3n), pero que en vez de almacenar los datos en un sistema de ficheros distribuidos o utilizar un sistema de gesti\u00f3n de recursos, lo hace en memoria. El hecho de almacenar en memoria los c\u00e1lculos intermedios implica que sea mucho m\u00e1s eficiente que MapReduce.</p> <p>En el caso de tener la necesidad de almacenar los datos o gestionar los recursos, se apoya en sistemas ya existentes como HDFS, YARN o Apache Mesos. Por lo tanto, Hadoop y Spark son sistemas complementarios.</p> <p>El dise\u00f1o de Spark se basa principalmente en cuatro caracter\u00edsticas:</p> <ul> <li>Velocidad: enfocado al uso en un cl\u00faster de commodity hardware con una gesti\u00f3n eficiente del multihilo y procesamiento paralelo. Spark construye sus consultas mediante un grafo dirigido ac\u00edclico (DAG) y utiliza un planificador para descomponer el grafo en tareas que se ejecutan en paralelo en los nodos de los cl\u00fasters. Finalmente, utiliza un motor de ejecuci\u00f3n (Tungsten) que genera c\u00f3digo compacto para optimizar la ejecuci\u00f3n. Todo ello teniendo en cuenta que los resultados intermedios se almacenan en memoria.</li> <li>Facilidad de uso: Spark ofrece varias capas de abstracci\u00f3n sobre los datos, como son los RDD, DataFrames y Dataset. Al ofrecer un conjunto de transformaciones y acciones como operaciones de su API, Spark facilita el desarrollo de aplicaciones Big data.</li> <li>Modularidad: soporte para todo tipo de cargas mediante cualquiera de los lenguajes de programaci\u00f3n soportados: Scala, Java, Python, SQL y R, as\u00ed como los m\u00f3dulos de Spark SQL para consultas interactivas, Spark Structured Streaming para procesamiento de datos en streaming, Spark MLlib para machine learning y GraphX para trabajar con grafos. De esta manera, mediante una \u00fanica aplicaci\u00f3n Spark se puede hacer todo sin necesidad de utilizar APIs separadas.</li> <li>Extensibilidad: Al centrarse unicamente en el procesamiento, la gesti\u00f3n de los datos se puede realizar a partir de Hadoop, Cassandra, HBase, MongoDB, Hive o cualquier SGBD relacional, haciendo todo en memoria. Adem\u00e1s, se puede extender el API para utilizar otras fuentes de datos, como Apache Kafka, Amazon S3 o Azure Storage.</li> </ul> <p>En t\u00e9rminos de flexibilidad, Spark ofrece un stack unificado que permite resolver m\u00faltiples tipos de procesamiento de datos, tanto aplicaciones batch como consultas interactivas, algoritmos de machine learning que requieren muchas iteraciones, aplicaciones de ingesta en streaming con rendimiento cercado al tiempo real, etc... Antes de Spark, para cada uno de estos tipos de procesamiento necesit\u00e1bamos una herramienta diferente, ahora con Spark tenemos una bala de plata que reduce los costes y recursos necesarios.</p>"},{"location":"spark/01spark.html#spark-vs-hadoop","title":"Spark vs Hadoop","text":"<p>La principal diferencia es que la computaci\u00f3n se realiza en memoria, lo que puede implicar un mejora de hasta 100 veces mejor rendimiento. Para ello, se realiza una evaluaci\u00f3n perezosa de las operaciones, de manera, que hasta que no se realiza una operaci\u00f3n, los datos realmente no se cargan.</p> <p>Para solucionar los problemas asociados a MapReduce, Spark crea un espacio de memoria RAM compartida entre los ordenadores del cl\u00faster. Este permite que los NodeManager/WorkerNode compartan variables (y su estado), eliminando la necesidad de escribir los resultados intermedios en disco. Esta zona de memoria compartida se traduce en el uso de RDD, DataFrames y DataSets, permitiendo realizar procesamiento en memoria a lo largo de un cl\u00faster con tolerancia a fallos.</p>"},{"location":"spark/01spark.html#stack-unificado","title":"Stack unificado","text":"<p>El elemento principal es Spark Core el cual aporta toda la funcionalidad necesaria para preparar y ejecutar las aplicaciones distribuidas, gestionando la planificaci\u00f3n y tolerancia a fallos de las diferentes tareas. Para ello, el n\u00facleo ofrece un entorno NoSQL id\u00f3neo para el an\u00e1lisis exploratorio e interactivo de los datos. Spark se puede ejecutar en batch o en modo interactivo y tiene soporte para Python. Independientemente del lenguaje utilizado (ya sea Python, Java, Scala, R o SQL) el c\u00f3digo se despliega entre todos los nodos a lo largo del cl\u00faster.</p> <p>Adem\u00e1s, contiene otros 4 grandes componentes construidos sobre el core:</p> Componentes de Spark <ol> <li>Spark Streaming es una herramienta para la creaci\u00f3n de aplicaciones de procesamiento en streaming que ofrece un gran rendimiento con soporte para la tolerancia a fallos. Los datos pueden venir desde fuentes de datos tan diversas como Kafka, Flume, Twitter y tratarse en tiempo real.</li> <li> <p>Spark SQL ofrece un interfaz SQL para trabajar con Spark, permitiendo la lectura de datos tanto de una tabla de cualquier base de datos relacional como de ficheros con formatos estructurados (CSV, texto, JSON, Avro, ORC, Parquet, etc...) y construir tablas permanentes o temporales en Spark. Tras la lectura, permite combinar sentencias SQL para trabajar con los datos y cargar los resultados en un DataFrame de Spark.</p> <p>Por ejemplo, con este fragmento leemos un fichero JSON desde nuestro sistema de almacenamiento, creamos una tabla temporal y mediante una consulta SQL cargamos los datos en un DataFrame de Spark:</p> <pre><code>df_zips = spark.read.json(\"zips.json\")\ndf_zips.createOrReplaceTempView(\"zips\")\ndf_resultado = spark.sql(\"\"\"SELECT city, state\n    FROM zips WHERE pop &gt; 10000\n    ORDER BY pop DESC\"\"\")\n</code></pre> </li> <li> <p>Spark MLlib es un m\u00f3dulo de machine learning que ofrece la gran mayor\u00eda de algoritmos de ML y permite construir pipelines para el entrenamiento y evaluaci\u00f3n de los modelos IA.</p> </li> <li>GraphX permite procesar estructuras de datos en grafo, siendo muy \u00fatiles para recorrer las relaciones de una red social u ofrecer recomendaciones sobre gustos/afinidades. En este curso no vamos a entrar en detalle en este m\u00f3dulo.</li> </ol> <p>Adem\u00e1s, la comunidad de Spark dispone de un gran n\u00famero de conectores para diferentes fuentes de datos, herramientas de monitorizaci\u00f3n, etc... que conforman su propio ecosistema:</p> Ecosistema de Spark"},{"location":"spark/01spark.html#puesta-en-marcha","title":"Puesta en Marcha","text":"<p>En nuestra m\u00e1quina virtual, \u00fanicamente necesitamos ejecutar el comando <code>pyspark</code> el cual arrancar\u00e1 directamente un cuaderno Jupyter:</p> <pre><code>iabd@iabd-virtualbox:~/Spark$ pyspark\n[I 16:50:57.168 NotebookApp] Serving notebooks from local directory: /home/iabd/Spark\n[I 16:50:57.168 NotebookApp] The Jupyter Notebook is running at:\n[I 16:50:57.168 NotebookApp] http://localhost:8888/?token=b7b4c7232e5d9d3f7c7fdd51d75e5fe314c3f2c637e90652\n[I 16:50:57.168 NotebookApp]  or http://127.0.0.1:8888/?token=b7b4c7232e5d9d3f7c7fdd51d75e5fe314c3f2c637e90652\n[I 16:50:57.168 NotebookApp] Use Control-C to stop this server and shut down all kernels (twice to skip confirmation).\n[C 16:50:57.968 NotebookApp] To access the notebook, open this file in a browser:\n        file:///home/iabd/.local/share/jupyter/runtime/nbserver-9654-open.html\n    Or copy and paste one of these URLs:\n        http://localhost:8888/?token=b7b4c7232e5d9d3f7c7fdd51d75e5fe314c3f2c637e90652\n     or http://127.0.0.1:8888/?token=b7b4c7232e5d9d3f7c7fdd51d75e5fe314c3f2c637e90652\n[W 16:51:02.666 NotebookApp] 404 GET /api/kernels/a8119b9f-91ce-4eee-b32b-9be48a0d281e/channels?session_id=5860cf5e65fa481d9110c9ff9904d3f7 (127.0.0.1): Kernel does not exist: a8119b9f-91ce-4eee-b32b-9be48a0d281e\n[W 16:51:02.676 NotebookApp] 404 GET /api/kernels/a8119b9f-91ce-4eee-b32b-9be48a0d281e/channels?session_id=5860cf5e65fa481d9110c9ff9904d3f7 (127.0.0.1) 12.30ms referer=None\n</code></pre> <p>Jupyter Notebook</p> <p>Si instalamos PySpark seg\u00fan las instrucciones de la propia web, al ejecutar <code>pyspark</code> se lanzara el spark-shell:</p> <pre><code>(base) jovyan@d747fe4a9742:~$ pyspark\nPython 3.10.8 | packaged by conda-forge | (main, Nov 22 2022, 08:13:37) [GCC 10.4.0] on linux\n...\nWelcome to\n    ____              __\n    / __/__  ___ _____/ /__\n    _\\ \\/ _ \\/ _ `/ __/  '_/\n/__ / .__/\\_,_/_/ /_/\\_\\   version 3.3.1\n    /_/\nUsing Python version 3.10.8 (main, Nov 22 2022 08:13:37)\nSpark context Web UI available at http://127.0.0.1:4040\nSpark context available as 'sc' (master = local[*], app id = local-1672853494013).\nSparkSession available as 'spark'.\n&gt;&gt;&gt;\n</code></pre> <p>Para que se abra autom\u00e1ticamente Jupyter Lab, necesitamos exportar las siguientes variables de entorno:</p> ~/.bashrc<pre><code>export PYSPARK_DRIVER_PYTHON=jupyter\nexport PYSPARK_DRIVER_PYTHON_OPTS='notebook'\n</code></pre> <p>Es conveniente actualizar siempre Jupyter Lab a la \u00faltima versi\u00f3n:</p> <pre><code>pip install --upgrade jupyterlab\n</code></pre> <p>M\u00e1s informaci\u00f3n en https://www.sicara.ai/blog/2017-05-02-get-started-pyspark-jupyter-notebook-3-minutes</p> <p>As\u00ed pues, autom\u00e1ticamente se abrir\u00e1 una ventana en el navegador web donde crear/trabajar con los cuadernos Jupyter:</p> Cuadernos Jupyter con PySpark"},{"location":"spark/01spark.html#uso-de-docker","title":"Uso de Docker","text":"<p>Otra posibilidad es utilizar alguna de las im\u00e1genes Docker disponibles que facilitan su uso. En nuestro caso, recomendamos las im\u00e1genes disponibles en https://github.com/jupyter/docker-stacks.</p> <p>Para lanzar la imagen de PySpark con cuadernos Jupyter utilizaremos:</p> <pre><code>docker run -d -p 8888:8888 -p 4040:4040 -p 4041:4041 jupyter/pyspark-notebook\n</code></pre> <p>O si queremos crear un volumen con la carpeta actual:</p> <pre><code>docker run -d -v ${PWD}:/home/jovyan/work -p 8888:8888 -p 4040:4040 -p 4041:4041 --name pyspark jupyter/pyspark-notebook\n</code></pre>"},{"location":"spark/01spark.html#cluster-de-spark","title":"Cl\u00faster de Spark","text":"<p>Si queremos montar nosotros mismo un cl\u00faster de Spark, una vez tenemos todas las m\u00e1quinas instaladas con Java, Python y Spark, debemos distinguir entre:</p> <ul> <li> <p>Nodo maestro/driver - el cual deberemos arrancar con:</p> <pre><code>$SPARK_HOME/sbin/start-master.sh -h 0.0.0.0\n</code></pre> </li> <li> <p>Workers (esclavos) - los cuales arrancaremos con:</p> <pre><code>$SPARK_HOME/sbin/start-worker.sh spark://&lt;ip-servidor-driver&gt;:7077\n</code></pre> <p>Sobre los workers, le podemos indicar la cantidad de CPUs mediante la opci\u00f3n <code>-c</code> y la cantidad de RAM con <code>-m</code>. Por ejemplo, si quisi\u00e9ramos lanzar un worker con 8 n\u00facleos y 16GB de RAM har\u00edamos:</p> <pre><code>$SPARK_HOME/sbin/start-slave.sh spark://&lt;ip-servidor-driver&gt;:7077 -c 8 -m 16G\n</code></pre> </li> </ul> <p>Una vez arrancado, si accedemos a <code>http://ip-servidor-driver:8080</code> veremos el IU de Spark con los workers arrancados.</p> <p>M\u00e1s informaci\u00f3n en la documentaci\u00f3n oficial.</p>"},{"location":"spark/01spark.html#uso-en-la-nube","title":"Uso en la nube","text":"<p>Para trabajar con Spark desde la nube disponemos de varias alternativas, ya sean herramientas que permiten trabajar con cuadernos Jupyter como pueden ser Google Colab o Databricks, o montar un cl\u00faster mediante AWS EMR (Elastic MapReduce) o Azure HDInsight.</p>"},{"location":"spark/01spark.html#google-colab","title":"Google Colab","text":"<p>Primero nos vamos a centrar en Google Colab. A lo largo del curso, ya hemos empleado esta herramienta tanto en sistemas de aprendizaje como en el an\u00e1lisis exploratorio de los datos.</p> <p>Para que funcione Spark dentro de Google Colab, \u00fanicamente hemos de instalar las librer\u00edas. Se adjunta un cuaderno con ejemplo de c\u00f3digo:</p> <pre><code># 1. Instalar las dependencias\n!apt-get install openjdk-8-jdk-headless -qq &gt; /dev/null\n!wget -q https://downloads.apache.org/spark/spark-3.3.1/spark-3.3.1-bin-hadoop3.tgz\n!tar xvf spark-3.3.1-bin-hadoop3.tgz\n!pip install -q pyspark\n\n# 2. Configurar el entorno\nimport os\nos.environ[\"JAVA_HOME\"] = \"/usr/lib/jvm/java-8-openjdk-amd64\"\nos.environ[\"SPARK_HOME\"] = f\"/content/spark-3.3.1-bin-hadoop3\"\n\n# 3. Cargar Pyspark\nfrom pyspark.sql import SparkSession\nspark = SparkSession.builder.appName(\"s8a\").master(\"local[*]\").getOrCreate()\nspark\n</code></pre> <p>El cual podemos observar c\u00f3mo se ejecuta en Colab:</p> Ejemplo de cuaderno en Google Colab"},{"location":"spark/01spark.html#databricks","title":"Databricks","text":"<p>Databricks es una plataforma anal\u00edtica de datos basada en Apache Spark desarrollada por la compa\u00f1\u00eda con el mismo nombre. La empresa, creada en el 2013 por los desarrolladores principales de Spark, permite realizar anal\u00edtica Big Data e Inteligencia Artificial con Spark de una forma sencilla y colaborativa.</p> <p>Databricks se integra de forma transparente con AWS, Azure y Google Cloud. En una entrada del blog de la empresa de noviembre de 2021  anuncian un nuevo record de procesamiento que implica que su rendimiento es 3 veces superior a la competencia y con un coste menor.</p> <p>Para poder trabajar con Databricks de forma gratuita, podemos hacer uso de Databricks Community Edition, donde podemos crear nuestros propios cuadernos Jupyter y trabajar con Spark sin necesidad de instalar nada.</p> <p>Para crear una cuenta gratuita, clickando sobre Sign up, tras rellenar los datos personales, antes de seleccionar el proveedor cloud, en la parte inferior, hemos de pulsar sobre Get started with Community Edition:</p> Creaci\u00f3n de una cuenta Community en Databricks <p>El \u00fanico paso inicial tras registrarnos, es crear un cl\u00faster b\u00e1sico (con 15.3GB de memoria y dos n\u00facleos) desde la opci\u00f3n Create del men\u00fa de la izquierda:</p> Creaci\u00f3n de un cl\u00faster en Databricks <p>Tras un par de minutos se habr\u00e1 creado y lanzado el cl\u00faster, ya estaremos listos para crear un nuevo notebook y tener acceso a Spark directamente desde el objeto <code>spark</code>:</p> Ejemplo de cuaderno en Databricks <p>Si queremos, podemos hacer p\u00fablico el cuaderno y compartirlo con la comunidad.</p> <p>Navegador de archivos DBFS</p> <p>Por defecto, el navegador del sistema de archivos de DataBricks est\u00e1 oculto. Para facilitar el acceso a los datos y visualizar la estructura y ruta de los mismos, lo podemos activar desde: Settings \u2192 Admin Console \u2192 Workspace Settings \u2192 Advanced, y ponemos la opci\u00f3n DBFS File Browser a Enabled.</p>"},{"location":"spark/01spark.html#sparkcontext-vs-sparksession","title":"SparkContext vs SparkSession","text":"<p>SparkContext es el punto de entrada a Spark desde las versiones 1.x y se utiliza para crear de forma programativa RDD, acumuladores y variables broadcast en el cl\u00faster. Desde Spark 2.0, la mayor\u00eda de funcionalidades (m\u00e9todos) disponibles en SparkContext tambi\u00e9n los est\u00e1n en SparkSession. Su objeto <code>sc</code> est\u00e1 disponible en el spark-shell y se puede crear de forma programativa mediante la clase <code>SparkContext</code>.</p> <pre><code>from pyspark import SparkContext\nsc = SparkContext.getOrCreate()\n</code></pre> <p>SparkSession se introdujo en la versi\u00f3n 2.0 y es el punto de entrada para crear RDD, DataFrames y DataSets. El objeto <code>spark</code> se encuentra disponible por defecto en el spark-shell y se puede crear de forma programativa mediante el patr\u00f3n builder de <code>SparkSession</code>.</p> <pre><code>from pyspark.sql import SparkSession\nspark = SparkSession.builder.getOrCreate() \n</code></pre> <p>Adem\u00e1s, desde una sesi\u00f3n de Spark podemos obtener un contexto a trav\u00e9s de la propiedad <code>sparkContext</code>:</p> <pre><code>from pyspark.sql import SparkSession\nspark = SparkSession.builder.getOrCreate()\nsc = spark.sparkContext\n</code></pre>"},{"location":"spark/01spark.html#hola-spark","title":"Hola Spark","text":"<p>Lo primero que debemos hacer siempre es conectarnos a la sesi\u00f3n de Spark, el cual le indica a Spark como acceder al cl\u00faster. Si utilizamos la imagen de Docker, debemos obtener siempre la sesi\u00f3n a partir de la clase <code>SparkSession</code>:</p> ejemploDockerSpark.py<pre><code>from pyspark.sql import SparkSession\nspark = SparkSession.builder.getOrCreate() # SparkSession de forma programativa\nsc = spark.sparkContext                    # SparkContext a partir de la sesi\u00f3n\n# Suma de los 100 primeros n\u00fameros\nrdd = sc.parallelize(range(100 + 1))\nrdd.sum()\n</code></pre> <p>En cambio, si utilizamos la instalaci\u00f3n de PySpark (o la soluci\u00f3n de Databricks) que tenemos en la m\u00e1quina virtual, directamente podemos acceder a la instancia de <code>SparkSession</code> a trav\u00e9s del objeto global <code>spark</code>:</p> ejemploPySpark.py<pre><code>sc = spark.sparkContext     # spark es una instancia de la clase SparkSession\nrdd = sc.parallelize(range(100 + 1))\nrdd.sum()\n</code></pre> <p>En ambos casos, si mostramos el contenido del contexto obtendremos algo similar a:</p> <pre><code>Version\n    v3.3.1\nMaster\n    local[*]\nAppName\n    PySparkShell\n</code></pre> <p>A continuaci\u00f3n podemos ver el resultado completo en su ejecuci\u00f3n dentro de un cuaderno Jupyter:</p> Hola Spark <p>Nombre de la aplicaci\u00f3n</p> <p>Si queremos darle nombre a la aplicaci\u00f3n Spark, lo podemos hacer al obtener la SparkSession:</p> <pre><code>spark = SparkSession.builder.appName(\"spark-s8a\").getOrCreate()\n</code></pre>"},{"location":"spark/01spark.html#spark-submit","title":"Spark Submit","text":"<p>De la misma manera que mediante Hadoop pod\u00edamos lanzar un proceso al cl\u00faster para su ejecuci\u00f3n, Spark ofrece el comando <code>spark-submit</code> para enviar un script al driver para su ejecuci\u00f3n de forma distribuida.</p> <p>As\u00ed pues, si colocamos nuestro c\u00f3digo en un archivo de Python:</p> holaSpark.py<pre><code>from pyspark.sql import SparkSession\nspark = SparkSession.builder.getOrCreate()\nsc = spark.sparkContext\n# Suma de los 100 primeros n\u00fameros\nrdd = sc.parallelize(range(100 + 1))\nsuma = rdd.sum()\nprint(\"--------------\")\nprint(suma)\nprint(\"--------------\")\n</code></pre> <p>Lo podemos ejecutar mediante (en nuestra m\u00e1quina virtual antes debemos resetear una variable de entorno para que no ejecute autom\u00e1ticamente el cuaderno jupyter: <code>unset PYSPARK_DRIVER_PYTHON</code>):</p> <pre><code>spark-submit holaMundo.py\n</code></pre> <p>Si nuestro servidor estuviera en otra direcci\u00f3n IP, deber\u00edamos indicarle donde encontrar el master:</p> <pre><code>spark-submit --master spark://&lt;ip-servidor-driver&gt;:7077 holaMundo.py\n</code></pre> <p>M\u00e1s informaci\u00f3n en la documentaci\u00f3n oficial</p> <p>AWS desde Spark</p> <p>Para conectar a AWS desde Spark hace falta:</p> <ol> <li>Descargar dos librer\u00edas y configurarlas en <code>$SPARK_HOME/conf/spark-defaults.conf</code> (o colocarlas directamente en la carpeta <code>$SPARK_HOME/jars</code>):</li> </ol> <pre><code># https://mvnrepository.com/artifact/org.apache.hadoop/hadoop-aws \n# https://mvnrepository.com/artifact/com.amazonaws/aws-java-sdk-bundle/1.11.901\nspark.driver.extraClassPath = /opt/spark-3.3.1/conf/hadoop-aws-3.3.4.jar:/opt/spark-3.3.1/conf/aws-java-sdk-bundle-1.12.367.jar\nspark.executor.extraClassPath = /opt/spark-3.3.1/conf/hadoop-aws-3.3.4.jar:/opt/spark-3.3.1/conf/aws-java-sdk-bundle-1.12.367.jar\n</code></pre> <ol> <li> <p>Configurar las credencias de AWS en <code>.aws/credentials</code> (esto lo hicimos varias veces en las sesiones de cloud)</p> </li> <li> <p>Tras crear la sesi\u00f3n de Spark, configurar el proveedor de credenciales:</p> </li> </ol> <pre><code>spark = SparkSession.builder.getOrCreate()\nspark._jsc.hadoopConfiguration().set(\"fs.s3a.aws.credentials.provider\", \"com.amazonaws.auth.profile.ProfileCredentialsProvider\")\ndf = spark.read.csv(\"s3a://s8a-spark-s3/departure_delays.csv\")\n</code></pre>"},{"location":"spark/01spark.html#arquitectura","title":"Arquitectura","text":"<p>Ya hemos comentado que Spark es un sistema distribuido dise\u00f1ado para procesar grandes vol\u00famenes de datos de forma r\u00e1pida y eficiente. Este sistema normalmente se despliega en un conjunto de m\u00e1quinas que se conocen como un cl\u00faster Spark, pudiendo estar compuesta de unas pocas m\u00e1quinas o miles de ellas. Seg\u00fan el FAQ de Spark, el cl\u00faster m\u00e1s grande de Spark contiene m\u00e1s de 8000 nodos.</p> <p>A la hora del despliegue, se utiliza un sistema de gesti\u00f3n de recursos como el gestor propio de Spark (conocido como Spark Standalone), Apache Mesos, Kubernetes o YARN para gestionar de forma inteligente y eficiente el cl\u00faster.</p> <p>Los dos componentes principales del cl\u00faster son:</p> <ul> <li>el gestor de cl\u00faster: nodo maestro que sabe donde se localizan los esclavos, cuanta memoria disponen y el n\u00famero de cores CPU de cada nodo. Su mayor responsabilidad es orquestar el trabajo asign\u00e1ndolo a los diferentes nodos.</li> <li>los nodos trabajadores (workers): cada nodo ofrece recursos (memoria, CPU, etc...) al gestor del cl\u00faster y realiza las tareas que se le asignen.</li> </ul>"},{"location":"spark/01spark.html#aplicaciones-spark","title":"Aplicaciones Spark","text":"<p>Una aplicaci\u00f3n Spark se compone de dos partes:</p> <ol> <li>La l\u00f3gica de procesamiento de los datos, la cual realizamos mediante alguna de las API que ofrece Spark (Java, Scala, Python, etc...), desde algo sencillo que realice una ETL sobre los datos a problemas m\u00e1s complejos que requieran m\u00faltiples iteraciones y tarden varias horas como entrenar un modelo de machine learning.</li> <li>Driver: es el coordinador central encargado de interactuar con el cl\u00faster Spark y averiguar qu\u00e9 m\u00e1quinas deben ejecutar la l\u00f3gica de procesamiento. Para cada una de esas m\u00e1quinas, el driver realiza una petici\u00f3n al cl\u00faster para lanzar un proceso conocido como ejecutor (executor). Adem\u00e1s, el driver Spark es responsable de gestionar y distribuir las tareas a cada ejecutor, y si es necesario, recoger y fusionar los datos resultantes para presentarlos al usuario. Estas tareas se realizan a trav\u00e9s de la SparkSession.</li> </ol> <p>Cada ejecutor es un proceso JVM (Java Virtual Machine) dedicado para una aplicaci\u00f3n Spark espec\u00edfica. Un ejecutor vivir\u00e1 tanto como dure la aplicaci\u00f3n Spark, lo cual puede ser segundos, minutos o d\u00edas, dependiendo de la complejidad de la aplicaci\u00f3n. Conviene destacar que los ejecutores son elementos aislados que no se comparten entre aplicaciones Spark, por lo que la \u00fanica manera de compartir informaci\u00f3n entre diferente ejecutores es mediante un sistema de almacenamiento externo como HDFS.</p> Arquitectura entre una aplicaci\u00f3n Spark y el gestor del cl\u00faster <p>As\u00ed pues, Spark utiliza una arquitectura maestro/esclavo, donde el driver es el maestro, y los ejecutores los esclavos. Cada uno de estos componentes se ejecutan como un proceso independiente en el cl\u00faster Spark. Por lo tanto, una aplicaci\u00f3n Spark se compone de un driver y m\u00faltiples ejecutores. Cada ejecutor realiza lo que se le pide en forma de tareas, ejecutando cada una de ellas en un n\u00facleo CPU separado. As\u00ed es como el procesamiento paralelo acelera el tratamiento de los datos. Adem\u00e1s, cada ejecutor, bajo petici\u00f3n de la l\u00f3gica de la aplicaci\u00f3n, se responsabiliza de cachear un fragmento de los datos en memoria y/o disco.</p> <p>Al lanzar una aplicaci\u00f3n Spark, podemos indicar el n\u00famero de ejecutores que necesita la aplicaci\u00f3n, as\u00ed como la cantidad de memoria y n\u00famero de n\u00facleos que deber\u00eda tener cada ejecutor.</p> Cl\u00faster compuesto por un driver y tres ejecutores"},{"location":"spark/01spark.html#job-stage-y-task","title":"Job, Stage y Task","text":"<p>Cuando creamos una aplicaci\u00f3n Spark, por debajo, se distinguen los siguientes elementos:</p> <ul> <li>Job (trabajo): computaci\u00f3n paralela compuesta de m\u00faltiples tareas que se crean tras una acci\u00f3n de Spark (<code>save</code>, <code>collect</code>, etc...). Al codificar nuestro c\u00f3digo mediante PySpark, el driver convierte la aplicaci\u00f3n Spark en uno o m\u00e1s jobs, y a continuaci\u00f3n, estos jobs los transforma en un DAG (grafo). Este grafo, en esencia, es el plan de ejecuci\u00f3n, donde cada elemento dentro del DAG puede implicar una o varias stages (escenas).</li> <li>Stage (escena): cada job se divide en peque\u00f1os conjuntos de tareas que forman un escenario. Como parte del grafo, las stages se crean a partir de si las operaciones se pueden realizar de forma paralela o de forma secuencial. Como no todas las operaciones pueden realizarse en una \u00fanica stage, en ocasiones se dividen en varias, normalmente debido a los l\u00edmites computacionales de los diferentes ejecutores.</li> <li>Task (tarea): unidad de trabajo m\u00e1s peque\u00f1a que se env\u00eda a los ejecutores Spark. Cada escenario se compone de varias tareas. Cada una de las tareas se asigna a un \u00fanico n\u00facleo y trabaja con una \u00fanica partici\u00f3n de los datos. Por ello, un ejecutor con 16 n\u00facleos puede tener 16 o m\u00e1s tareas trabajando en 16 o m\u00e1s particiones en paralelo.</li> </ul> Driver \u2192 Job \u2192 Stage \u2192 Task"},{"location":"spark/01spark.html#dataframe","title":"DataFrame","text":"<p>La principal abstracci\u00f3n de los datos en Spark es el Dataset. Se pueden crear desde las fuentes de entrada de Hadoop (como ficheros que provienen de HDFS o S3) o mediante transformaciones de otros Datasets. Dado el cariz de Python, no necesitamos que los Dataset est\u00e9n fuertemente tipados, por eso, todos los Dataset que usemos ser\u00e1n <code>Dataset[Row]</code> (si trabaj\u00e1semos mediante Java o Scala s\u00ed deber\u00edamos indicar el tipo de sus datos), y por consistencia con el concepto de Pandas y R, los llamaremos DataFrame.</p> <p>Por ejemplo, veamos c\u00f3mo podemos crear un DataFrame a partir de un fichero de texto:</p> <pre><code>from pyspark.sql import SparkSession\nspark = SparkSession.builder.getOrCreate() \nquijoteTxt = spark.read.text(\"el_quijote.txt\")\nquijoteTxt.count()  # n\u00famero de filas del DataFrame - 2186\nquijoteTxt.first()  # primera fila - Row(value='DON QUIJOTE DE LA MANCHA')\n# Transformamos un DataFrame en otro nuevo\nlineasConQuijote = quijoteTxt.filter(quijoteTxt.value.contains(\"Quijote\"))  # DataFrame con las l\u00edneas que contiene la palabra Quijote\nlineasConQuijote.count()  # cantidad de l\u00edneas con la palabra Quijote - 584\n# Las transformaciones se pueden encadenar\nquijoteTxt.filter(quijoteTxt.value.contains(\"Quijote\")).count()     # idem - 584\n</code></pre> <p>Estudiaremos los DataFrame en profundidad en la pr\u00f3ximas sesiones.</p>"},{"location":"spark/01spark.html#spark-ui","title":"Spark UI","text":"<p>Si accedemos a la direcci\u00f3n http://127.0.0.1:4040/, veremos un interfaz gr\u00e1fico donde podemos monitorizar y analizar el c\u00f3digo Spark ejecutado. La barra superior muestra un men\u00fa con las opciones para visualizar los jobs, stages, el almacenamiento, el entorno y sus variables de configuraci\u00f3n, y finalmente los ejecutores:</p> Spark Shell UI <p>Por ejemplo, si ejecutamos el ejemplo de <code>groupByKey</code> de la siguiente sesi\u00f3n, obtenemos el siguiente DAG:</p> Ejemplo de DAG <p>Si pulsamos por ejemplo sobre la fase de <code>groupBy</code> obtendremos sus estad\u00edsticas de ejecuci\u00f3n:</p> Estad\u00edsticas de una fase <p>Spark UI en Databricks</p> <p>Para acceder a la herramienta de monitorizaci\u00f3n en Databricks, una vez creado un cl\u00faster, en la opci\u00f3n calcular podremos seleccionar el cl\u00faster creado y en la pesta\u00f1a IU de Spark acceder al mismo interfaz gr\u00e1fico:</p> <p> Spark UI en Databricks </p>"},{"location":"spark/01spark.html#referencias","title":"Referencias","text":"<ul> <li>Documentaci\u00f3n oficial de Apache Spark</li> <li>Learning Apache Spark, 2nd Edition</li> <li>Repositorio GitHub con apuntes sobre Spark de Vivek Bombatkar</li> <li>Learning Apache Spark with Python</li> </ul>"},{"location":"spark/01spark.html#actividades","title":"Actividades","text":"<ol> <li>(RA5075.4 / CE5.4a, CE5.4b  / 2p) Reproduce el ejemplo de DataFrames sobre el fichero de El Quijote adjuntado varias capturas de pantalla (entorno, ejecuci\u00f3n y monitorizaci\u00f3n) al realizarlo en:<ul> <li>la m\u00e1quina virtual o un entorno Docker.</li> <li>y en Databricks.</li> </ul> </li> </ol>"},{"location":"spark/02agregaciones.html","title":"Spark DataFrames II","text":""},{"location":"spark/02agregaciones.html#agregaciones","title":"Agregaciones","text":"<p>Una vez tenemos un DataFrame, podemos realizar anal\u00edtica de datos sobre el dataset entero, o sobre una o m\u00e1s columnas y aplicar una funci\u00f3n de agregaci\u00f3n que permita sumar, contar o calcular la media de cualquier grupo, entre otras opciones.</p> <p>Para ello, PySpark ofrece un amplio conjunto de funciones. En nuestro caso, vamos a realizar algunos ejemplos para practicar con las funciones m\u00e1s empleadas.</p>"},{"location":"spark/02agregaciones.html#contando","title":"Contando","text":"countcount_distinctapprox_count_distinct <p>count: Devuelve la cantidad de elementos no nulos:</p> <pre><code>from pyspark.sql.functions import count\ndf.select(count(\"Country\")).show()\n# +--------------+\n# |count(Country)|\n# +--------------+\n# |        120239|\n# +--------------+\n</code></pre> <p>count_distinct / countDistinct: Devuelve la cantidad de elementos no nulos diferentes:</p> <pre><code>from pyspark.sql.functions import count_distinct\ndf.select(count_distinct(\"Country\"), count_distinct(\"Zip\")).show()\n# +-----------------------+-------------------+\n# |count(DISTINCT Country)|count(DISTINCT Zip)|\n# +-----------------------+-------------------+\n# |                      4|               2585|\n# +-----------------------+-------------------+\n</code></pre> <p>approx_count_distinct / approxCountDistinct: Devuelve aproximadamente la cantidad de elementos no nulos diferentes (puede recibir un segundo par\u00e1metro la m\u00e1ximo desviaci\u00f3n est\u00e1ndar admitida). Este m\u00e9todo es mucho m\u00e1s r\u00e1pido que contar exactamente el n\u00famero de resultado, y para datasets muy grandes, en ocasiones puede ser \u00fatil:</p> <pre><code>from pyspark.sql.functions import approx_count_distinct\ndf.select(approx_count_distinct(\"Country\"), approx_count_distinct(\"Zip\")).show()\n# +------------------------------+--------------------------+\n# |approx_count_distinct(Country)|approx_count_distinct(Zip)|\n# +------------------------------+--------------------------+\n# |                             4|                      2737|\n# +------------------------------+--------------------------+\n</code></pre>"},{"location":"spark/02agregaciones.html#calculando","title":"Calculando","text":"min y maxsumsum_distinctavg <p>min y max permiten obtener el menor y el mayor valor respectivamente:</p> <pre><code>from pyspark.sql.functions import min, max\ndf.select(min(\"Units\"), max(\"Units\")).show()\n# +----------+----------+\n# |min(Units)|max(Units)|\n# +----------+----------+\n# |         1|        77|\n# +----------+----------+\n</code></pre> <p>sum permite sumar todos los valores de una columna:</p> <pre><code>from pyspark.sql.functions import sum\ndf.select(sum(\"Units\"), sum(\"Revenue\")).show()\n# +----------+--------------------+\n# |sum(Units)|        sum(Revenue)|\n# +----------+--------------------+\n# |    125728|5.0107274999986745E7|\n# +----------+--------------------+\n</code></pre> <p>sum_distinct / sumDistinct suma los valores diferentes de una columna:</p> <pre><code>from pyspark.sql.functions import sum_distinct\ndf.select(sum_distinct(\"Units\"), sum_distinct(\"Revenue\")).show()\n# +-------------------+---------------------+\n# |sum(DISTINCT Units)|sum(DISTINCT Revenue)|\n# +-------------------+---------------------+\n# |                308|   1189127.0999999985|\n# +-------------------+---------------------+\n</code></pre> <p>avg calcula la media aritm\u00e9tica:</p> <pre><code>from pyspark.sql.functions import sum, count, avg\ndf.select(avg(\"Revenue\"), sum(\"Revenue\")/count(\"Revenue\")).show()\n# +-----------------+-------------------------------+\n# |     avg(Revenue)|(sum(Revenue) / count(Revenue))|\n# +-----------------+-------------------------------+\n# |416.7306364822291|              416.7306364822291|\n# +-----------------+-------------------------------+\n</code></pre> <p>Asimetr\u00eda, varianza y desviaci\u00f3n est\u00e1ndar</p> <p>Si nos interesa obtener informaci\u00f3n estad\u00edstica sobre los datos, tambi\u00e9n disponemos de las funciones <code>skewness</code>, <code>kurtosis</code>, <code>variance</code>, <code>var_pop</code>, <code>stddev</code> y <code>stddev_pop</code>.</p>"},{"location":"spark/02agregaciones.html#agrupando","title":"Agrupando","text":"<p>Si agrupamos varias columnas de tipo categ\u00f3ricas (con una cardinalidad baja), podemos realizar c\u00e1lculos sobre el resto de columnas.</p> <p>Sobre un DataFrame, podemos agrupar los datos por la columna que queramos utilizando el m\u00e9todo groupBy, el cual nos devuelve un GroupedData, sobre el que posteriormente realizar operaciones como <code>avg(cols)</code>, <code>count()</code>, <code>mean(cols)</code>, <code>min(cols)</code>, <code>max(cols)</code> o <code>sum(cols)</code>:</p> countsum <pre><code>from pyspark.sql.functions import sum\ndf.groupBy(\"Country\").count().show()\n# +-------+-----+\n# |Country|count|\n# +-------+-----+\n# |Germany|30059|\n# | France|30060|\n# | Mexico|30060|\n# | Canada|30060|\n# +-------+-----+\n</code></pre> <pre><code>df.groupBy(\"Country\").sum(\"Revenue\").show()\n# +-------+--------------------+\n# |Country|        sum(Revenue)|\n# +-------+--------------------+\n# |Germany|1.4982119999999512E7|\n# | France|1.2087942100000832E7|\n# | Mexico| 1.139459870000116E7|\n# | Canada|1.1642614200001905E7|\n# +-------+--------------------+\n</code></pre> <p>Si necesitamos realizar m\u00e1s de un agregaci\u00f3n sobre el mismo grupo, mediante agg podemos indicar una o m\u00e1s expresiones de columnas:</p> <pre><code>from pyspark.sql.functions import sum, count\ndf.groupBy(\"Country\").agg(sum(\"Revenue\"), count(\"Revenue\")).show()\n# +-------+--------------------+--------------+\n# |Country|        sum(Revenue)|count(Revenue)|\n# +-------+--------------------+--------------+\n# |Germany|1.4982119999999512E7|         30059|\n# | France|1.2087942100000832E7|         30060|\n# | Mexico| 1.139459870000116E7|         30060|\n# | Canada|1.1642614200001905E7|         30060|\n# +-------+--------------------+--------------+\n</code></pre> <p>Tambi\u00e9n podemos indicar los elementos a calcular mediante un diccionario donde las claves son los campos y los valores la funci\u00f3n a calcular:</p> <pre><code>df.groupBy(\"Country\").agg({\"Zip\":\"count\", \"Revenue\":\"avg\"}).show()\n# +-------+----------+------------------+\n# |Country|count(Zip)|      avg(Revenue)|\n# +-------+----------+------------------+\n# |Germany|     30059| 498.4237665923521|\n# | France|     30060| 402.1271490352905|\n# | Mexico|     30060| 379.0618330007039|\n# | Canada|     30060|387.31251497012323|\n# +-------+----------+------------------+\n</code></pre>"},{"location":"spark/02agregaciones.html#agrupando-colecciones","title":"Agrupando colecciones","text":"<p>En ocasiones necesitamos agrupar en una colecci\u00f3n todos los valores para un grupo en particular. Para ello, podemos usar collect_list (con repetidos) o collect_set (sin repeticiones):</p> <p>Por ejemplo, para cada pa\u00eds, vamos a recuperar un listado con los c\u00f3digos postales de aquellos pedidos que hayan superado las 5 unidades:</p> <pre><code>from pyspark.sql.functions import collect_list, collect_set\ndf.where(\"Units &gt; 5\").groupBy(\"Country\").agg(collect_list(\"Zip\"), collect_set(\"Zip\")).show()\n# +-------+--------------------+--------------------+\n# |Country|   collect_list(Zip)|    collect_set(Zip)|\n# +-------+--------------------+--------------------+\n# |Germany|[22397, 22111, 40...|[22111, 12589, 22...|\n# | France|[75213 CEDEX 16, ...|[06082 CEDEX 1, 0...|\n# | Mexico|[7100, 7810, 9739...|[9739, 10300, 781...|\n# | Canada|[T2X, V6G, V6G, T6V]|     [V6G, T2X, T6V]|\n# +-------+--------------------+--------------------+\n</code></pre>"},{"location":"spark/02agregaciones.html#tablas-pivote","title":"Tablas pivote","text":"<p>Las tablas pivote permite obtener un resumen de los datos a partir de columnas categ\u00f3ricas sobre la que realizar c\u00e1lculos, tal como se hace en las hojas de c\u00e1lculo con las tablas din\u00e1micas.</p> <p>Por ejemplo, vamos a obtener la cantidad recaudada por las ventas de cada a\u00f1o por cada pais:</p> <pre><code>df.groupBy(year(\"Date\")).pivot(\"Country\").sum(\"Revenue\").show()\n# +----------+------------------+------------------+------------------+------------------+\n# |year(Date)|            Canada|            France|           Germany|            Mexico|\n# +----------+------------------+------------------+------------------+------------------+\n# |      2003| 2360085.999999947|1105230.9000000046|1407120.0000000007|         1049457.5|\n# |      2004| 1539140.499999946|              null|              null|              null|\n# |      2001| 2193437.799999908|              null|              null|233419.20000000004|\n# |      2000|1806678.3999999042|1108846.8999999764| 4510606.799999941| 4240448.399999928|\n# |      1999|1382756.6999999764| 7594921.200000435| 5928459.100000297|3419368.2000001906|\n# |      2002|2360514.7999998857| 2278943.099999957| 3135934.099999964|2451905.3999999263|\n# +----------+------------------+------------------+------------------+------------------+\n</code></pre> <p>Tambi\u00e9n podemos hacer m\u00e1s de un c\u00e1lculo sobre la tabla pivote:</p> <pre><code>df.groupBy(year(\"Date\")).pivot(\"Country\").agg(sum(\"Revenue\").alias(\"total\"), sum(\"Units\").alias(\"cantidad\")).show()\n# +----------+------------------+---------------+------------------+---------------+------------------+----------------+------------------+---------------+\n# |year(Date)|      Canada_total|Canada_cantidad|      France_total|France_cantidad|     Germany_total|Germany_cantidad|      Mexico_total|Mexico_cantidad|\n# +----------+------------------+---------------+------------------+---------------+------------------+----------------+------------------+---------------+\n# |      2003| 2360085.999999947|           6375|1105230.9000000046|           2794|1407120.0000000007|            3099|         1049457.5|           2510|\n# |      2004| 1539140.499999946|           3636|              null|           null|              null|            null|              null|           null|\n# |      2001| 2193437.799999908|           5976|              null|           null|              null|            null|233419.20000000004|            583|\n# |      2000|1806678.3999999042|           5049|1108846.8999999764|           2456| 4510606.799999941|            9738| 4240448.399999928|          11935|\n# |      1999|1382756.6999999764|           3964| 7594921.200000435|          20432| 5928459.100000297|           12266|3419368.2000001906|           9895|\n# |      2002|2360514.7999998857|           6148| 2278943.099999957|           6057| 3135934.099999964|            6643|2451905.3999999263|           6172|\n# +----------+------------------+---------------+------------------+---------------+------------------+----------------+------------------+---------------+\n</code></pre>"},{"location":"spark/02agregaciones.html#joins","title":"Joins","text":"<p>Hasta ahora todo la anal\u00edtica la hemos realizado sobre un \u00fanico DataFrame. Aunque si seguimos un proceso ELT es probable que tengamos todos los datos en un \u00fanico lugar, en ocasiones necesitamos cruzar la informaci\u00f3n de dos datasets.</p> <p>Si nos basamos en el planteamiento de una base de datos relacional, para unir dos DataFrames necesitamos unir la clave ajena de uno con la clave primaria del otro.</p> <p>Para estos ejemplos, vamos a cambiar de datasets y utilizar datos de vuelos de avi\u00f3n que han tenido alg\u00fan tipo de retraso (departure_delays.csv) y otro con los c\u00f3digos de los aeropuertos (airport-codes-na.tsv).</p> Vuelos con retrasoC\u00f3digos de aeropuertos <p>Fichero CSV con la coma como separador de campos.</p> departure_delays.csv<pre><code>date,delay,distance,origin,destination\n01011245,6,602,ABE,ATL\n01020600,-8,369,ABE,DTW\n01021245,-2,602,ABE,ATL\n01020605,-4,602,ABE,ATL\n</code></pre> <p>Fichero TSV con el tabulador como separador campos, donde el campo <code>IATA</code> es la clave de cada aeropuerto.</p> airport-codes-na.tsv<pre><code>City State Country IATA\nAbbotsford BC Canada YXX\nAberdeen SD USA ABR\nAbilene TX USA ABI\nAkron OH USA CAK\nAlamosa CO USA ALS\nAlbany GA USA ABY\n</code></pre> <p>As\u00ed pues, lo primero que vamos a hacer es cargar ambos DataFrames:</p> <pre><code>from pyspark.sql import SparkSession\nspark = SparkSession.builder.appName(\"s8a-dataframes-joins\").getOrCreate()\ndf_vuelos = spark.read.option(\"sep\",\",\").option(\"header\", \"true\").option(\"inferSchema\", \"true\").csv(\"departure_delays.csv\")\n# df_vuelos.printSchema()\n# df_vuelos.count()   # 1391578\ndf_aeropuertos = spark.read.option(\"sep\",\"\\t\").option(\"header\", \"true\").option(\"inferSchema\", \"true\").csv(\"airport-codes-na.tsv\")\n# df_aeropuertos.printSchema()\n</code></pre>"},{"location":"spark/02agregaciones.html#mediante-sql","title":"Mediante SQL","text":"<p>Si queremos hacer un join mediante SQL, s\u00f3lo tenemos que emplear la misma sintaxis que con cualquier sistema relacional, de manera que primero crearemos las vistas temporales:</p> <pre><code>df_vuelos.createOrReplaceTempView(\"vuelos\")\ndf_aeropuertos.createOrReplaceTempView(\"aeropuertos\")\n</code></pre> <p>Y a continuaci\u00f3n realizamos la consulta:</p> <pre><code>df_join = spark.sql(\"select v.origin, a.city from vuelos v join aeropuertos a on v.origin == a.IATA\")\ndf_join.show(3)\n# +------+---------+\n# |origin|     city|\n# +------+---------+\n# |   ABE|Allentown|\n# |   ABE|Allentown|\n# |   ABE|Allentown|\n# +------+---------+\n# only showing top 3 rows\n</code></pre> <p>Si quisi\u00e9ramos obtener el nombre de los dos aeropuertos, necesitamos realizar dos veces el join:</p> <pre><code>df_join = spark.sql(\"select v.*, a.City as originCity, b.City as destinationCity from vuelos v JOIN aeropuertos a on v.origin == a.IATA join aeropuertos b on v.destination = b.IATA\")\ndf_join.show(3)\n# +-------+-----+--------+------+-----------+----------+---------------+\n# |   date|delay|distance|origin|destination|originCity|destinationCity|\n# +-------+-----+--------+------+-----------+----------+---------------+\n# |1011245|    6|     602|   ABE|        ATL| Allentown|        Atlanta|\n# |1020600|   -8|     369|   ABE|        DTW| Allentown|        Detroit|\n# |1021245|   -2|     602|   ABE|        ATL| Allentown|        Atlanta|\n# +-------+-----+--------+------+-----------+----------+---------------+\n# only showing top 3 rows\n</code></pre> <p>Si existiera alg\u00fan vuelo cuyos c\u00f3digos de aeropuerto no tuvi\u00e9ramos disponible en el dataset de los c\u00f3digos de aeropuertos, no nos aparecer\u00eda. Por tanto, ser\u00eda m\u00e1s conveniente realizar un left join:</p> <pre><code>df_left_join = spark.sql(\"select v.*, a.City as originCity, b.City as destinationCity from vuelos v LEFT JOIN aeropuertos a on v.origin == a.IATA LEFT JOIN aeropuertos b on v.destination = b.IATA\")\ndf_left_join.show(3)\ndf_left_join.count()    # 1391578\n</code></pre> <p>Todo tipo de joins</p> <p>Adem\u00e1s de los casos vistos, podemos realizar otros tipos de joins como cross, semi, full, outer, etc... M\u00e1s informaci\u00f3n en la documentaci\u00f3n oficial</p> <p>Un caso particular que conviene conocer es el left anti join. Este tipo de join permite obtener aquellos registros de la izquierda que no aparecen en la parte derecha, de manera que si seguimos con el ejemplo, podemos recuperar aquellos vuelos cuyos aeropuertos no tenemos en el dataset con los c\u00f3digos:</p> <pre><code>df_left_anti_join = spark.sql(\"select * from vuelos v LEFT ANTI JOIN aeropuertos a ON v.origin == a.IATA \")\ndf_left_anti_join.count()   # 14416\n</code></pre>"},{"location":"spark/02agregaciones.html#mediante-python","title":"Mediante Python","text":"<p>Si no queremos utilizar SQL o ya tenemos fragmentos de c\u00f3digo que interact\u00faan con el DataFrame API, podemos utilizar el m\u00e9todo join.</p> <p>Este m\u00e9todo une dos DataFrames, indicando la expresi\u00f3n de uni\u00f3n y opcionalmente el tipo:</p> <pre><code>exprJoin1 = df_vuelos.origin == df_aeropuertos.IATA\ndf_joinp1 = df_vuelos.join(df_aeropuertos, exprJoin1, \"inner\")\ndf_joinp1.count()    # 1377162\n</code></pre> <p>Forma corta</p> <p>Si las columnas que unen los DataFrames tienen el mismo nombre, podemos simplificar el c\u00f3digo indicando \u00fanicamente su nombre:</p> <pre><code>df1.join(df2, \"user_id\")\n</code></pre> <p>Adem\u00e1s, si queremos hacer un inner join, podemos no indicarlo ya que es el tipo por defecto.</p> <p>En vez de pasarle <code>inner</code>, le podemos indicar el tipo de join: <code>left</code>, <code>right</code>, <code>cross</code>, <code>left_anti</code>, etc...</p> <pre><code>expr_join1 = df_vuelos.origin == df_aeropuertos.IATA\ndf_left_anti_join = df_vuelos.join(df_aeropuertos, expr_join1, \"left_anti\")\ndf_left_anti_join.count()   # 14416\n</code></pre> <p>Finalmente, como en nuestro caso ten\u00edamos dos joins, tanto para los vuelos de origen como los de destino, necesitamos volver a unir:</p> <pre><code>from pyspark.sql.functions import col\n# le indicamos alias a los campos para eliminar ambig\u00fcedades\nexpr_join2 = col(\"a.destination\") == col(\"b.IATA\")\ndf_joinp2 = (df_joinp1.alias(\"a\")).join((df_aeropuertos.alias(\"b\")), expr_join2, \"inner\")\ndf_joinp2.count()    # 1361141\n</code></pre>"},{"location":"spark/02agregaciones.html#funciones","title":"Funciones","text":"<p>Para dominar realmente Spark, hay que tener destreza en todas las funciones existente para el tratamiento de fechas, cadenas, operaciones matem\u00e1ticas, para trabajar con colecciones, etc...</p> <p>Adem\u00e1s, siempre podemos crear nuestras propias funciones de usuario para ampliar el lenguaje.</p> <p>Aunque ya hemos utilizado algunas a lo largo de los apuntes, a continuaci\u00f3n vamos a repasar las funciones m\u00e1s empleadas.</p>"},{"location":"spark/02agregaciones.html#fechas","title":"Fechas","text":"<ul> <li>Si necesitamos convertir de texto a fecha: <code>to_date</code>, <code>to_timestamp</code>, <code>unix_timestamp</code></li> <li>Para formatear las fechas: <code>date_format</code>, <code>from_unixtime</code> (patrones de fechas)</li> <li>Para realizar c\u00e1lculos sobre fechas: <code>datediff</code>, <code>months_between</code>, <code>last_day</code>, <code>date_add</code>, <code>date_sub</code>, <code>next_day</code></li> <li>Extraer un valor de una fecha: <code>year</code>, <code>month</code>, <code>weekofyear</code>, <code>dayofmonth</code>, <code>dayofyear</code>, <code>hour</code>, <code>minute</code>, <code>second</code></li> </ul> <p>M\u00e1s informaci\u00f3n en la documentaci\u00f3n oficial</p> <pre><code>from pyspark.sql import SparkSession\nfrom pyspark.sql.functions import to_date\nspark = SparkSession.builder.appName(\"s8a-dataframes-sql\").getOrCreate()\ndf = spark.read.option(\"sep\",\";\").option(\"header\", \"true\").option(\"inferSchema\", \"true\").csv(\"pdi_sales_small.csv\")\n# Cambiamos el tipo de dato a fecha\ndf = df.withColumn(\"Date\", to_date(df.Date, \"M/d/yyy\"))\nimport pyspark.sql.functions\ndf.select(\"Date\", date_format(\"Date\", \"dd-MM-yyy\"),\nnext_day(\"Date\", \"Sun\"), last_day(\"Date\"),\ndayofmonth(\"Date\"), dayofyear(\"Date\"),\nmonth(\"Date\"), year(\"Date\")).show(2)\n# +----------+----------------------------+-------------------+--------------+----------------+---------------+-----------+----------+\n# |      Date|date_format(Date, dd-MM-yyy)|next_day(Date, Sun)|last_day(Date)|dayofmonth(Date)|dayofyear(Date)|month(Date)|year(Date)|\n# +----------+----------------------------+-------------------+--------------+----------------+---------------+-----------+----------+\n# |1999-01-15|                  15-01-1999|         1999-01-17|    1999-01-31|              15|             15|          1|      1999|\n# |2002-06-06|                  06-06-2002|         2002-06-09|    2002-06-30|               6|            157|          6|      2002|\n# +----------+----------------------------+-------------------+--------------+----------------+---------------+-----------+----------+\n# only showing top 2 rows\n</code></pre>"},{"location":"spark/02agregaciones.html#cadenas","title":"Cadenas","text":"<p>Por ejemplo, tenemos las funciones para quitar espacios (<code>ltrim</code>, <code>rtrim</code>, <code>trim</code>) y pasar a may\u00fasculas/min\u00fasculas (<code>lower</code>, <code>upper</code>):</p> <pre><code>df.select(\"Zip\", ltrim(\"Zip\").alias(\"l\"), rtrim(\"Zip\").alias(\"r\"), \nlower(\"Zip\"), upper(\"Zip\")\n).where(trim(df.Country)==\"Canada\").show(3)\n# +---------------+---------------+---+---------------+---------------+\n# |            Zip|              l|  r|     lower(Zip)|     upper(Zip)|\n# +---------------+---------------+---+---------------+---------------+\n# |H1B            |H1B            |H1B|h1b            |H1B            |\n# +---------------+---------------+---+---------------+---------------+\n# only showing top 1 row\n</code></pre> <p>O funciones para poner la inicial en may\u00fasculas (<code>initcap</code>), darle la vuelta (<code>reverse</code>), obtener su tama\u00f1o (<code>length</code>)o reemplazar caracteres (<code>translate</code>):</p> <pre><code>df.select(\"Country\", initcap(\"Country\"), reverse(\"Country\"),\nlength(\"Country\"), translate(\"Country\", \"na\", \"pe\")\n).where(trim(df.Country)==\"Canada\").show(1)\n# +-------+----------------+----------------+---------------+--------------------------+\n# |Country|initcap(Country)|reverse(Country)|length(Country)|translate(Country, na, pe)|\n# +-------+----------------+----------------+---------------+--------------------------+\n# |Canada |         Canada |          adanaC|              7|                   Cepede |\n# +-------+----------------+----------------+---------------+--------------------------+\n# only showing top 1 row\n</code></pre> <p>Tambi\u00e9n podemos trabajar con subcadenas (<code>substring</code>), encontrar ocurrencias (<code>locate</code>) o partir una cadena en trozos (<code>split</code>):</p> <pre><code>df.select(\"Country\", split(\"Country\", \"a\"), locate(\"a\", \"Country\"),\nsubstring(\"Country\",3,2)\n).where(trim(df.Country)==\"Canada\").show(1)\n+-------+---------------------+---------------------+------------------------+\n|Country|split(Country, a, -1)|locate(a, Country, 1)|substring(Country, 3, 2)|\n+-------+---------------------+---------------------+------------------------+\n|Canada |         [C, n, d,  ]|                    2|                      na|\n+-------+---------------------+---------------------+------------------------+\nonly showing top 1 row\n</code></pre> <p>Otras funciones que se suelen utilizar son <code>concat</code> y  <code>concat_ws</code> para unir cadenas, <code>levenshtein</code> para calcular la distancia entre dos cadenas, <code>lpad</code> y <code>rpad</code> para completar con espacios, etc... Si necesitas trabajar con expresiones regulares puedes utilizar <code>regexp_extract</code> para extraer parte de una cadena como <code>regexp_replace</code> para sustituir.</p>"},{"location":"spark/02agregaciones.html#colecciones","title":"Colecciones","text":"<p>Para probar las funciones que trabajan con colecciones, vamos a cambiar de dataset y trabajar con uno compartido por Kaggle con datos de negocios de Yelp que tenemos almacenados en una versi\u00f3n reducida en yelp_academic_dataset_business.json. Los negocios tienen una propiedad denominada <code>categories</code> que contiene un array con las categor\u00edas de los mismos:</p> persons.json<pre><code>{\n\"business_id\":\"O_X3PGhk3Y5JWVi866qlJg\",\n\"full_address\":\"1501 W Bell Rd\\nPhoenix, AZ 85023\",\n\"hours\":{\n\"Monday\":{\n\"close\":\"18:00\",\n\"open\":\"11:00\"\n},\n\"Tuesday\":{\n\"close\":\"18:00\",\n\"open\":\"11:00\"\n},\n...\n},\n\"open\":true,\n\"categories\":[\n\"Active Life\",\n\"Arts &amp; Entertainment\",\n\"Stadiums &amp; Arenas\",\n\"Horse Racing\"\n],\n\"city\":\"Phoenix\",\n...\n}\n</code></pre> <p>El primer paso es cargar el documento y ver el esquema le\u00eddo por Spark:</p> <pre><code>from pyspark.sql import SparkSession\nspark = SparkSession.builder.appName(\"s8a-dataframes-arrays\").getOrCreate()\ndf = spark.read.option(\"inferSchema\", \"true\").option(\"multiline\",True).json(\"yelp_academic_dataset_business.json\")\ndf.printSchema()\n</code></pre> <p>Como podemos observar, sigue una estructura de elementos anidados:</p> <pre><code>root\n |-- attributes: struct (nullable = true)\n |    |-- Accepts Credit Cards: boolean (nullable = true)\n |    |-- Alcohol: string (nullable = true)\n |    |-- Ambience: struct (nullable = true)\n |    |    |-- casual: boolean (nullable = true)\n |    |    |-- classy: boolean (nullable = true)\n |    |    |-- divey: boolean (nullable = true)\n |    |    |-- hipster: boolean (nullable = true)\n |    |    |-- intimate: boolean (nullable = true)\n |    |    |-- romantic: boolean (nullable = true)\n |    |    |-- touristy: boolean (nullable = true)\n |    |    |-- trendy: boolean (nullable = true)\n |    |    |-- upscale: boolean (nullable = true)\n |    |-- Attire: string (nullable = true)\n ...\n |    |-- Wi-Fi: string (nullable = true)\n |-- business_id: string (nullable = true)\n |-- categories: array (nullable = true)\n |    |-- element: string (containsNull = true)\n |-- city: string (nullable = true)\n |-- full_address: string (nullable = true)\n ...\n</code></pre> <p>Por ejemplo, vamos a ver mediante un ejemplo las siguientes funciones:</p> <ul> <li><code>size</code>: devuelve el tama\u00f1o de la colecci\u00f3n</li> <li><code>sort_array</code>: ordena la colecci\u00f3n</li> <li><code>array_contains</code>: comprueba si hay un elemento en la colecci\u00f3n</li> </ul> <pre><code>from pyspark.sql.functions import *\ndf.select(\"name\", \"hours.Sunday\", size(\"categories\").alias(\"totalCategorias\"),\nsort_array(\"categories\").alias(\"categorias\"),\narray_contains(\"categories\", \"Restaurants\").alias(\"Restaurantes\")).show(10, truncate=False)\n# +-------------------------------+--------------+---------------+---------------------------------------------------------------------------------+------------+\n# |name                           |Sunday        |totalCategorias|categorias                                                                       |Restaurantes|\n# +-------------------------------+--------------+---------------+---------------------------------------------------------------------------------+------------+\n# |Turf Paradise Race Course      |{18:00, 11:00}|4              |[Active Life, Arts &amp; Entertainment, Horse Racing, Stadiums &amp; Arenas]             |false       |\n# |Sam's Club Members Only        |null          |5              |[Automotive, Department Stores, Fashion, Shopping, Tires]                        |false       |\n# |Forever 21                     |{18:00, 11:00}|5              |[Accessories, Fashion, Men's Clothing, Shopping, Women's Clothing]               |false       |\n# |Loving Hands Pet Care          |{19:00, 06:00}|3              |[Pet Boarding/Pet Sitting, Pet Services, Pets]                                   |false       |\n# |Amec Mid-City Animal Hospital  |null          |2              |[Pets, Veterinarians]                                                            |false       |\n# |Los Armandos Asadero Y Mariscos|{03:00, 20:00}|2              |[Mexican, Restaurants]                                                           |true        |\n# |Clayton Companies              |null          |4              |[Home Services, Property Management, Real Estate, Real Estate Services]          |false       |\n# |Bertha's Caf\u00e9                  |null          |5              |[Bakeries, Breakfast &amp; Brunch, Food, Restaurants, Sandwiches]                    |true        |\n# |Jerry's Artarama               |{17:00, 11:00}|4              |[Art Supplies, Arts &amp; Crafts, Framing, Shopping]                                 |false       |\n# |Shauna Brown Fitness           |null          |5              |[Active Life, Fitness &amp; Instruction, Health &amp; Medical, Massage Therapy, Trainers]|false       |\n# +-------------------------------+--------------+---------------+---------------------------------------------------------------------------------+------------+\nonly showing top 10 rows\n</code></pre> <p>Tip</p> <p>Recuerda que en el apartado Agrupando colecciones vimos como podemos crear colecciones al realizar una agrupaci\u00f3n.</p> <p>As\u00ed pues, adem\u00e1s del nombre, hemos obtenido el horario de los domingos utilizando la notaci\u00f3n <code>.</code> para acceder a los campos anidados, la cantidad de categor\u00edas de cada comercio, un listado ordenado con sus categor\u00edas y finalmente si es un restaurante.</p> <p>Otro tipo de operaci\u00f3n que podemos realizar es desenrollar una colecci\u00f3n mediante la funci\u00f3n <code>explode</code> y generar una fila nueva por cada elemento de la colecci\u00f3n:</p> <pre><code>df.select(\"name\", explode(\"categories\")).show(10, truncate=False)\n# +-------------------------+--------------------+\n# |name                     |col                 |\n# +-------------------------+--------------------+\n# |Turf Paradise Race Course|Active Life         |\n# |Turf Paradise Race Course|Arts &amp; Entertainment|\n# |Turf Paradise Race Course|Stadiums &amp; Arenas   |\n# |Turf Paradise Race Course|Horse Racing        |\n# |Sam's Club Members Only  |Tires               |\n# |Sam's Club Members Only  |Automotive          |\n# |Sam's Club Members Only  |Fashion             |\n# |Sam's Club Members Only  |Shopping            |\n# |Sam's Club Members Only  |Department Stores   |\n# |Forever 21               |Women's Clothing    |\n# +-------------------------+--------------------+\n# only showing top 10 rows\n</code></pre>"},{"location":"spark/02agregaciones.html#json","title":"JSON","text":"<p>Es com\u00fan que se de el caso de que los datos que leemos desde un sistema externo est\u00e9n en formato JSON pero que el proceso de ingesta lo haya realizado como si fuera una cadena de texto.</p> <p>Supongamos que tenemos la siguiente cadena y generados un DataFrame a partir de un RDD:</p> <pre><code>tareas = [\"\"\"{\"dia\": \"Lunes\", \"tareas\": [\"Corregir ejercicios\", \"Ir a nadar\", \"Comprar pan\"]}\"\"\"]\n# ['{\"dia\": \"Lunes\", \"tareas\": [\"Corregir ejercicios\", \"Ir a nadar\", \"Comprar pan\"]}']\ntareasRDD = spark.sparkContext.parallelize(tareas)\ntareasStrDF = tareasRDD.toDF(\"string\")\n# tareasStrDF es un DF con una columna con nombre value de tipo string\ntareasStrDF.printSchema()\n# root\n#  |-- value: string (nullable = true)\ntareasStrDF.show()\n# +--------------------+\n# |               value|\n# +--------------------+\n# |{\"dia\": \"Lunes\", ...|\n# +--------------------+\n</code></pre> <p>Para pasarlo a JSON, necesitamos definir un esquema con la estructura del documento JSON:</p> <pre><code>from pyspark.sql.types import StructType, StructField, StringType, ArrayType\nesquemaTareas = StructType([\nStructField(\"dia\", StringType(), False),\nStructField(\"tareas\", ArrayType(StringType(), False), False)\n])\n</code></pre> <p>Y a continuaci\u00f3n ya podemos transformar el formato mediante la funci\u00f3n <code>from_json</code>:</p> <pre><code>todosDF = tareasStrDF.select(from_json(\"value\", esquemaTareas).alias(\"datos\"))\ntodosDF.printSchema()\n# root\n#  |-- datos: struct (nullable = true)\n#  |    |-- dia: string (nullable = true)\n#  |    |-- tareas: array (nullable = true)\n#  |    |    |-- element: string (containsNull = true)\n</code></pre> <p>Y ahora ya podemos acceder a los datos (en el siguiente ejemplo empleamos la funci\u00f3n <code>getItem</code> para acceder a un elemento de una columna):</p> <pre><code>todosDF.select(col(\"datos\").getItem(\"dia\"),\n\"datos.tareas\",\n(todosDF.datos.getItem(\"tareas\")[0]).alias(\"tarea1\")).show(truncate=False)\n+---------+----------------------------------------------+-------------------+\n|datos.dia|tareas                                        |tarea1             |\n+---------+----------------------------------------------+-------------------+\n|Lunes    |[Corregir ejercicios, Ir a nadar, Comprar pan]|Corregir ejercicios|\n+---------+----------------------------------------------+-------------------+\n</code></pre> <p>Para terminar, si necesitamos la operaci\u00f3n inversa, y lo que queremos es crear una representaci\u00f3n JSON de una columna, podemos utilizar la funci\u00f3n <code>getItem</code>:</p> <pre><code>todosDF.select(to_json(\"datos\")).show(truncate=False)\n# +---------------------------------------------------------------------------+\n# |to_json(datos)                                                             |\n# +---------------------------------------------------------------------------+\n# |{\"dia\":\"Lunes\",\"tareas\":[\"Corregir ejercicios\",\"Ir a nadar\",\"Comprar pan\"]}|\n# +---------------------------------------------------------------------------+\n</code></pre>"},{"location":"spark/02agregaciones.html#udf","title":"UDF","text":"<p>Adem\u00e1s de las funciones que ofrece Spark, en cualquier momento podemos crear nuestras funciones de usuario (User-Defined Functions) para ampliar la expresividad de Spark. Antes de utilizarlas, las hemos de definir y registrar.</p> <p>Si volvemos al dataset de ventas, ten\u00edamos la siguiente informaci\u00f3n:</p> <pre><code>df.select(\"ProductID\", \"Revenue\", \"Units\").sort(\"Units\", ascending=False).show(5)\n# +---------+-------+-----+\n# |ProductID|Revenue|Units|\n# +---------+-------+-----+\n# |      495|43194.1|   77|\n# |     2091| 6347.7|   41|\n# |     2091| 6240.1|   41|\n# |     2091| 3652.7|   24|\n# |     2091| 3560.9|   23|\n# +---------+-------+-----+\n# only showing top 5 rows\n</code></pre> <p>Vamos a crear una funci\u00f3n para que, si vende m\u00e1s de una unidad, se le asigne a cada producto un bonus de un 1%. Para ello, primero definiremos la funci\u00f3n mediante Python, y posteriormente, la registraremos mediante la funci\u00f3n <code>udf</code>:</p> <pre><code>from pyspark.sql.functions import udf\nfrom pyspark.sql.types import DoubleType\ndef bonus(unidades, ventas):\nif unidades == 1 :\nreturn 0.0\nelse:\nreturn unidades * ventas / 100\nudfBonus = udf(bonus, DoubleType())\n</code></pre> <p>As\u00ed pues, si realizamos una consulta, ya podemos utilizar la funci\u00f3n reci\u00e9n creada como si fuera una propia de Spark:</p> <pre><code>df.select(\"ProductID\", \"Revenue\", \"Units\", udfBonus(df.Units, df.Revenue)).sort(\"Units\", ascending=False).show(5)\n# +---------+-------+-----+---------------------+\n# |ProductID|Revenue|Units|bonus(Units, Revenue)|\n# +---------+-------+-----+---------------------+\n# |      495|43194.1|   77|   33259.456999999995|\n# |     2091| 6347.7|   41|             2602.557|\n# |     2091| 6240.1|   41|   2558.4410000000003|\n# |     2091| 3652.7|   24|    876.6479999999999|\n# |     2091| 3560.9|   23|              819.007|\n# +---------+-------+-----+---------------------+\n# only showing top 5 rows\n</code></pre> <p>Si queremos definir la funci\u00f3n para poder utilizarla dentro de Spark SQL y obtener el mismo resultado, hemos de registrar la funci\u00f3n mediante <code>spark.udf.register</code>, la cual recibe el nombre que le asignaremos a la funci\u00f3n, el nombre de la funci\u00f3n Python a invocar, y el tipo de dato que devuelve:</p> <pre><code>spark.udf.register(\"udfBonus\", bonus, DoubleType())\nspark.sql(\"select ProductID, Revenue, Units,  udfBonus(Units, Revenue) as bonus from ventas order by Units desc\").show(5)\n</code></pre> <p>UDF y Python</p> <p>En un principio, se desaconseja la creaci\u00f3n de UDF mediante Python, ya que su uso penaliza de forma significativa el rendimiento. Los ejecutores son procesos en m\u00e1quinas virtuales de Java que est\u00e1n escritos en Java, y por ello, ejecutan c\u00f3digo Java o Scala de forma nativa. En cambio, para Python tiene que ejecutar un proceso separado para ejecutar la UDF, lo que implica un coste extra para serializar y volver a deserializar los datos para cada fila del dataset.</p>"},{"location":"spark/02agregaciones.html#cacheando","title":"Cacheando","text":"<p>Un DataFrame se puede persistir/cachear en memoria conforme necesitemos (tambi\u00e9n lo podemos hacer con los RDD). Su principal prop\u00f3sito es cuando vamos a acceder a un DataFrame una y otra vez y no necesitamos que se vuelvan a evaluar todas las operaciones (como pueden ser los algoritmos iterativos utilizados en Machine Learning).</p> <p>M\u00e1s informaci\u00f3n</p> <p>Si est\u00e1s interesado en optimizar el uso de memoria al trabajar con DataFrames,  Brayan Buitrago tiene una serie de art\u00edculos sobre Spark Performace: Cache() &amp; Persist() muy interesantes.</p> <p>Cuando persistimos un dataset, cada nodo almacena sus datos particionados en memoria y/o disco y los reutiliza en otras operaciones sobre dicho dataset.</p> <p>Para ello, se emplean los m\u00e9todos <code>cache</code> / <code>persist</code> y <code>unpersist</code> para cachear y liberar los datos.</p> <pre><code>df.persist()\ndf.count()  # forzamos la evaluaci\u00f3n perezosa\n</code></pre> <p>Si queremos realizarlo con SparkSQL:</p> <pre><code>ventasCanada.createOrReplaceTempView(\"ventasCanada\")\n// Si queremos cachear la tabla mediante SQl\nspark.catalog.cacheTable(\"ventasCanada\")\n</code></pre> <p>Una vez persistidos los datos, si accedemos a http://localhost:4040 veremos en la pesta\u00f1a Storage que se ha creado la tabla, su tipo de almacenamiento y particiones cacheadas:</p> Elementos cacheados con Spark UI <p>Una diferencia fundamental a la hora de persistir un DataFrame en comparaci\u00f3n con un RDD, es que como Spark SQL conoce el esquema de los datos en el DataFrame, puede organizarlos de forma columnar y aplicar compresi\u00f3n sobre \u00e9stos para minimizar el espacio necesario.</p>"},{"location":"spark/02agregaciones.html#dataframes-y-pandas","title":"DataFrames y Pandas","text":"<p>En cualquier momento podemos pasar los datos de un DataFrame de PySpark a uno de Pandas para poder aprovechar su API.</p> <p>Si seguimos con el dataset de Yelp, vamos a preparar una consulta de nos devuelva la cantidad de votos recibidos y puntuaci\u00f3n media de cada ciudad:</p> <pre><code>from pyspark.sql.functions import count, avg, round\ndfVotosCiudades = df.groupBy(\"city\").agg(count(\"city\").alias(\"votos\"), round(avg(\"stars\"), 3).alias(\"media\")).orderBy(\"votos\", ascending=False).limit(10)\ndfVotosCiudades.show()\n# +----------+-----+-----+\n# |      city|votos|media|\n# +----------+-----+-----+\n# |   Phoenix| 5492|3.658|\n# |Scottsdale| 2617|3.809|\n# |     Tempe| 1444| 3.64|\n# |      Mesa| 1348|3.644|\n# |  Chandler| 1178|3.677|\n# |  Glendale|  821|3.588|\n# |   Gilbert|  630|3.755|\n# |    Peoria|  385|3.614|\n# |  Surprise|  241|3.598|\n# |  Goodyear|  214|3.498|\n# +----------+-----+-----+\n</code></pre> <p>Nos traemos esos datos a Pandas mediante el m\u00e9todo <code>.toPandas()</code>.:</p> <pre><code>pdVC = dfVotosCiudades.toPandas()\n</code></pre> <p>A partir de este momento <code>pdVC</code> es un DataFrame de Pandas:</p> Conversi\u00f3n a un DataFrame de Pandas <p>Y con el DataFrame de Pandas, ya podemos generar gr\u00e1ficos:</p> <pre><code>import pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nplt.figure(figsize=(10,6))\nplt.ticklabel_format(useOffset=False, style=\"plain\")\nsns.set_theme(style=\"whitegrid\")\nsns.barplot(x=\"votos\", y=\"city\", data=pdVC).set_title(\"Votos por Ciudad\")\nplt.xlabel(\"Votos emitidos\")\nplt.ylabel(\"Ciudades\")\nplt.show()\n</code></pre> Gr\u00e1fico generado mediante Pandas y Spark <p>O por ejemplo, si queremos unir dos gr\u00e1ficos:</p> <pre><code>plt.figure(figsize=(10,6))\nsns.set_theme(style=\"white\")\nax = sns.barplot(data = pdVC, y=\"votos\", x=\"city\")\nax2 = ax.twinx()\nsns.lineplot(data = pdVC['media'], marker='o', color='crimson', ax=ax2)\nplt.show()\n</code></pre> <p>Obteniendo:</p> Gr\u00e1fico generado mediante Pandas y Spark <p>Out of Memory</p> <p>Mucho cuidado al utilizar Pandas, ya que al convertir el DataFrame nos vamos a traer todos los datos al driver, perdiendo la distribuci\u00f3n de los datos y pudiendo provocar un error de falta de memoria.</p> <p>As\u00ed pues, hay que evitar a toda costa utilizar Pandas para tratar los datos, ya que perdemos toda la potencia de trabajo en cl\u00faster (Pandas s\u00f3lo puede utilizar los recursos del nodo principal). \u00danicamente lo utilizaremos cuando vayamos a visualizar los datos mediante Matplotlib / Seaborn como requisito de estas librer\u00edas.</p> <p>Pandas y Koalas</p> <p>Desde la versi\u00f3n 3.2 de Spark, la librer\u00eda de Koalas se ha integrado en Spark, dando lugar a poder utilizar el API de Pandas directamente desde Spark, lo que facilita el aprendizaje de Spark para aquellos desarrolladores que ya dominan Pandas.</p> <p>Para ello, \u00fanicamente hemos de importar la librer\u00eda:</p> <pre><code>import pyspark.pandas as ps\n</code></pre> <p>Y acceder a <code>ps</code> de la misma manera que usamos <code>pd</code> al trabajar con Pandas.</p> <p>Un art\u00edculo muy interesante es Run Pandas as Fast as Spark.</p>"},{"location":"spark/02agregaciones.html#referencias","title":"Referencias","text":"<ul> <li>Documentaci\u00f3n oficial sobre Spark SQL, DataFrames and Datasets Guide</li> <li>Beginning Apache Spark 3: With DataFrame, Spark SQL, Structured Streaming, and Spark Machine Learning Library</li> <li>Spark by Examples</li> <li>The Most Complete Guide to pySpark DataFrames</li> <li>Spark SQL Cheatsheet en PDF y en formato web</li> </ul>"},{"location":"spark/02agregaciones.html#actividades","title":"Actividades","text":"<p>(RA5075.1 / CE5.1d y CE5.1e) En las siguientes actividades vamos a realizar agregaciones mediante el uso del API de DataFrames de Spark (cada apartado vale 0,25p).</p> <ol> <li> <p>(1p) Sobre las pel\u00edculas de la sesi\u00f3n anterior:</p> <ol> <li>\u00bfCuantas pel\u00edculas diferentes hay?</li> <li>\u00bfEn cuantas pel\u00edculas ha trabajado <code>Murphy, Eddie (I)</code>?</li> <li>\u00bfCu\u00e1les son los actores que han aparecido en m\u00e1s de 30 pel\u00edculas?</li> <li>\u00bfEn que pel\u00edcula anterior a 1980 aparecen al menos 25 int\u00e9rpretes?</li> <li>Muestra la cantidad de pel\u00edculas producidas cada a\u00f1o (solo debe mostrar el a\u00f1o y la cantidad), ordenando el listado por la cantidad de forma descendente.</li> <li>A partir de la consulta anterior, crea un gr\u00e1fico de barras que muestre el a\u00f1o y la cantidad de pel\u00edculas, ordenados por fecha.</li> </ol> </li> <li> <p>(1p) Nos han enviado un nuevo archivo llamado <code>movie-ratings.tsv</code> que contiene las calificaciones de las pel\u00edculas.</p> <ol> <li>Crea un DataFrame que contenga los datos de ambos datasets.</li> <li>Muestra para cada a\u00f1o, la pel\u00edcula con mayor puntuaci\u00f3n (a\u00f1o, t\u00edtulo de la pel\u00edcula, puntuaci\u00f3n)</li> <li>Sobre los datos anteriores, obt\u00e9n tambi\u00e9n una lista con los nombres de los int\u00e9rpretes.</li> <li>Averigua las tres parejas de int\u00e9rpretes han trabajado juntos en m\u00e1s ocasiones. La salida debe tener tres columnas: <code>interprete1</code>, <code>interprete2</code> y <code>cantidad</code>. (necesitas utilizar un self-join)</li> </ol> </li> <li> <p>(1.5p) Hemos recibido un dataset con las ventas de 2019 de una tienda americana de productos de tecnolog\u00eda, mediante un conjunto de ficheros en formato CSV comprimidos en salesdata.zip.</p> <ol> <li>Una vez descomprimidos los datos, crea un DataFrame con todos los datos, infiriendo el esquema.</li> <li> <p>Vuelve a realizar la lectura de los datos pero con el siguiente esquema:</p> <pre><code>from pyspark.sql.types import StructType, StructField, StringType, IntegerType, DoubleType\nesquema = StructType([\nStructField(\"Order ID\", IntegerType(), False),\nStructField(\"Product\", StringType(), False),\nStructField(\"Quantity Ordered\", IntegerType(), True),\nStructField(\"Price Each\", DoubleType(), False),\nStructField(\"Order Date\", StringType(), False),\nStructField(\"Purchase Address\", StringType(), False)\n])\n</code></pre> </li> <li> <p>Tras la lectura, vamos a realizar la limpieza de datos. El primer paso ser\u00e1 renombrar la columnas para eliminar los espacios en blanco.</p> </li> <li>Elimina las filas que contengan alg\u00fan campo nulo.</li> <li>Comprueba si las cabeceras de los archivos aparecen como datos del dataset (por ejemplo, un producto cuyo nombre sea <code>Product</code>). Si fuera el caso, elimina dichas filas.</li> <li>A partir del campo direcci\u00f3n, crea dos nuevas columnas para almacenar la ciudad (<code>City</code>) y el estado (<code>State</code>). Por ejemplo, para la direcci\u00f3n <code>136 Church St, New York City, NY 10001</code>, la ciudad es <code>New York City</code> y el estado es <code>NY</code>.</li> <li>Modifica el campo con la fecha del pedido para que su formato sea timestamp.</li> <li>Sobre el campo anterior, crea dos nuevas columnas, con el mes (<code>Month</code>) y el a\u00f1o (<code>Year</code>) del pedido.</li> </ol> </li> <li> <p>(1.5p) Una vez realizada la transformaci\u00f3n de los datos, vamos a realizar su carga y extraer informaci\u00f3n`, utilizando Spark SQL siempre que sea posible:</p> <ol> <li>Almacena los datos en formato Parquet en la carpeta <code>salesoutput</code> particionando los datos por a\u00f1o y mes. Tras ejecutar esta operaci\u00f3n, comprueba en disco la estructura de archivos creada.</li> <li>Sobre los datos almacenados, realiza una nueva lectura pero solo leyendo los datos de 2019 los cuales deber\u00edan estar almacenados en <code>./salesdataoutput/Year=2019</code>.</li> <li> <p>Averigua cual ha sido el mes que ha recaudado m\u00e1s. Para ello, deber\u00e1s multiplicar el precio por la cantidad de unidades, y posteriormente, realizar alguna agregaci\u00f3n. Sobre el resultado, crea un gr\u00e1fico similar al siguiente:</p> <p> Ventas por mes </p> </li> <li> <p>Obt\u00e9n un gr\u00e1fico con las 10 ciudades que m\u00e1s unidades han vendido.</p> <p> Ciudades con m\u00e1s unidades vendidas </p> </li> <li> <p>Cantidad de pedidos por Horas en las que se ha realizado un pedido que conten\u00eda al menos dos productos:</p> <p> Pedidos de al menos dos productos por horas </p> </li> <li> <p>Listado con los productos del estado de <code>NY</code> que se han comprado a la vez, obteniendo un resultado similar a:</p> <pre><code>+------------------------------------------------------------+-----+\n|Productos                                                   |count|\n+------------------------------------------------------------+-----+\n|[iPhone, Lightning Charging Cable]                          |126  |\n|[Google Phone, USB-C Charging Cable]                        |124  |\n|[Google Phone, Wired Headphones]                            |52   |\n...\n</code></pre> </li> </ol> </li> </ol>"},{"location":"spark/02catalog.html","title":"Spark JDBC y uso del cat\u00e1logo. Delta Lake","text":""},{"location":"spark/02catalog.html#conectando-con-bases-de-datos","title":"Conectando con bases de datos","text":"<p>Para conectar desde Spark con una base de datos relacional (RDBMS) necesitamos:</p> <ul> <li>un driver JDBC compatible</li> <li>las propiedades de conexi\u00f3n a la base de datos.</li> </ul> <p>En PySpark, el driver lo podemos a\u00f1adir directamente a la carpeta <code>jars</code> disponible en <code>$SPARK_HOME</code>, o a la hora de lanzar Spark utilizando la opci\u00f3n <code>--jars &lt;fichero1.jar&gt;,&lt;fichero2.jar&gt;</code> o <code>--packages &lt;groupId:artifactId:version&gt;</code>.</p> <p>As\u00ed pues, para conectar con nuestra base de datos <code>retail_db</code> que tenemos configurada en la m\u00e1quina virtual, primero copiaremos el driver de MySQL en la carpeta <code>$SPARK_HOME/jars</code>.</p> <p>Si tuvi\u00e9ramos problemas a la hora de crear la conexi\u00f3n con la base de datos, indicaremos en la configuraci\u00f3n qu\u00e9 archivos a\u00f1adimos al classpath:</p> <pre><code>spark = SparkSession.builder.appName(\"s8a-dataframes-jdbc\") \\\n    .config('spark.driver.extraClassPath', 'mysql-connector-j-8.0.31.jar') \\\n    .getOrCreate()\n</code></pre> <p>El siguiente paso es configurar la conexi\u00f3n a la base de datos:</p> <pre><code>url = \"jdbc:mysql://localhost/retail_db\"\npropiedades = {\n\"driver\": \"com.mysql.cj.jdbc.Driver\",\n\"user\": \"iabd\",\n\"password\": \"iabd\"\n}\n</code></pre> <p>Spark y MySQL con Docker</p> <p>Para poder acceder a MySQL desde la imagen de Spark, necesitamos que formen parte de la misma red. Para ello, lo m\u00e1s c\u00f3modo es utilizar Docker Compose y definir las dependencias:</p> <pre><code>services:\nspark:\nimage: jupyter/pyspark-notebook\ncontainer_name: iabd-spark\nports:\n- \"8888:8888\"\n- \"4040:4040\"\n- \"4041:4041\"\nlinks:\n- mysql\nvolumes:\n- ./:/home/jovyan/work\n- ./mysql-connector-j-8.0.31.jar:/usr/local/spark/jars/mysql-connector-j-8.0.31.jar\nmysql:\nimage: mysql:latest\ncontainer_name: iabd-mysql\ncommand: --default-authentication-plugin=mysql_native_password\nports:\n- \"3306:3306\"\nenvironment:\nTZ: Europe/Madrid\nMYSQL_ROOT_PASSWORD: iabd\nMYSQL_DATABASE: retail_db\nMYSQL_USER: iabd\nMYSQL_PASSWORD: iabd\n</code></pre> <p>Una vez colocado el driver de MySQL en la misma carpeta, lanzamos docker-compose:</p> <pre><code>docker-compose -p iabd-spark-mysql up -d\n</code></pre> <p>Tras arrancar los contenedores, la primera vez, deberemos cargar la base de datos:</p> <pre><code>docker exec -i iabd-mysql mysql -h 0.0.0.0 -P 3306 -uiabd -piabd retail_db &lt; create_db.sql\n</code></pre> <p>A partir de aqu\u00ed, es importante destacar que la url de conexi\u00f3n a la base de datos, en vez de acceder a <code>localhost</code>, lo hace al nombre del contenedor <code>iabd-mysql</code>:</p> <pre><code>url = \"jdbc:mysql://iabd-mysql/retail_db\"\n</code></pre>"},{"location":"spark/02catalog.html#leyendo-datos","title":"Leyendo datos","text":"<p>Para finalmente cargar los datos mediante el m\u00e9todo <code>read.jdbc</code>:</p> <pre><code>df = spark.read.jdbc(url=url,\\\n    table=\"customers\",\\\n    properties=propiedades) \n</code></pre> <p>Y sobre el dataframe, ya podemos obtener su esquema y realizar las transformaciones que necesitemos:</p> <pre><code>df.printSchema()\n# root\n#  |-- customer_id: integer (nullable = true)\n#  |-- customer_fname: string (nullable = true)\n#  |-- customer_lname: string (nullable = true)\n#  |-- customer_email: string (nullable = true)\n#  |-- customer_password: string (nullable = true)\n#  |-- customer_street: string (nullable = true)\n#  |-- customer_city: string (nullable = true)\n#  |-- customer_state: string (nullable = true)\n#  |-- customer_zipcode: string (nullable = true)\ndf.show(2)\n# +-----------+--------------+--------------+--------------+-----------------+--------------------+-------------+--------------+----------------+\n# |customer_id|customer_fname|customer_lname|customer_email|customer_password|     customer_street|customer_city|customer_state|customer_zipcode|\n# +-----------+--------------+--------------+--------------+-----------------+--------------------+-------------+--------------+----------------+\n# |          1|       Richard|     Hernandez|     XXXXXXXXX|        XXXXXXXXX|  6303 Heather Plaza|  Brownsville|            TX|           78521|\n# |          2|          Mary|       Barrett|     XXXXXXXXX|        XXXXXXXXX|9526 Noble Embers...|    Littleton|            CO|           80126|\n# +-----------+--------------+--------------+--------------+-----------------+--------------------+-------------+--------------+----------------+\n# only showing top 2 rows\n</code></pre> <p>Si necesitamos configurar en m\u00e1s detalle la forma de recoger los datos, es mejor acceder mediante el m\u00e9todo <code>format</code> (cuidado con el nombre de la tabla que ahora utiliza el atributo <code>dbtable</code>):</p> <pre><code>df_format = spark.read.format(\"jdbc\") \\\n  .option(\"url\", url_iabd) \\\n  .option(\"dbtable\", \"customers\") \\\n  .option(\"user\", \"iabd\") \\\n  .option(\"password\", \"iabd\") \\\n  .load()\n</code></pre> <p>Un caso particular es cuando queremos asignarle a un dataframe el resultado de una consulta. Para ello, podemos indicarle en el par\u00e1metro <code>query</code> la consulta SQL con la informaci\u00f3n a recoger:</p> <pre><code>df_query = spark.read.format(\"jdbc\") \\\n  .option(\"url\", url_iabd) \\\n  .option(\"query\", \"(select customer_id, customer_fname, customer_lname from customers where customer_city='Las Vegas')\") \\\n  .option(\"user\", \"iabd\") \\\n  .option(\"password\", \"iabd\") \\\n  .load()\ndf_query.printSchema()\n# root\n#  |-- customer_id: integer (nullable = true)\n#  |-- customer_fname: string (nullable = true)\n#  |-- customer_lname: string (nullable = true)\ndf_query.show(3)\n# +-----------+--------------+--------------+\n# |customer_id|customer_fname|customer_lname|\n# +-----------+--------------+--------------+\n# |         99|         Betty|         Munoz|\n# |        204|          Mary|         Smith|\n# |        384|       Mildred|    Cunningham|\n# +-----------+--------------+--------------+\n# only showing top 3 rows\n</code></pre> <p>M\u00e1s opciones</p> <p>M\u00e1s informaci\u00f3n sobre todas las opciones disponibles en la documentaci\u00f3n oficial.</p>"},{"location":"spark/02catalog.html#escribiendo-datos","title":"Escribiendo datos","text":"<p>Si lo que queremos es almacenar el resultado en una base de datos, utilizaremos el m\u00e9todo write.jdbc o <code>write.format('jdbc')</code> finalizando con <code>save</code>:</p> write.jdbc()write.format('jdbc') <pre><code>df.write.jdbc(url=url, \\\n        table=\"&lt;nueva_tabla&gt;\", \\\n        properties=propiedades) \n</code></pre> <pre><code>df.write.format(\"jdbc\") \\\n  .option(\"url\", \"&lt;jdbc_url&gt;\") \\\n  .option(\"dbtable\", \"&lt;nueva_tabla&gt;\") \\\n  .option(\"user\", \"&lt;usuario&gt;\") \\\n  .option(\"password\", \"&lt;contrase\u00f1a&gt;\") \\\n  .save()\n</code></pre> <p>Por ejemplo, vamos a crear una copia del DataFrame de clientes con s\u00f3lo tres columnas, y almacenaremos este DataFrame en una nueva tabla:</p> <pre><code>jdbcSelectDF = jdbcDF.select(\"customer_id\", \"customer_fname\", \"customer_lname\")\njdbcSelectDF.show(3)\n# +-----------+--------------+--------------+\n# |customer_id|customer_fname|customer_lname|\n# +-----------+--------------+--------------+\n# |          1|       Richard|     Hernandez|\n# |          2|          Mary|       Barrett|\n# |          3|           Ann|         Smith|\n# +-----------+--------------+--------------+\n# only showing top 3 rows\njdbcSelectDF.count()\n# 12435\njdbcSelectDF.write.format(\"jdbc\") \\\n    .option(\"driver\", \"com.mysql.cj.jdbc.Driver\") \\\n    .option(\"url\", \"jdbc:mysql://iabd-mysql\") \\\n    .option(\"dbtable\", \"retail_db.clientes\") \\\n    .option(\"user\", \"iabd\") \\\n    .option(\"password\", \"iabd\") \\\n    .save()\n</code></pre> <p>Si accedemos a MySQL, podremos comprobar c\u00f3mo se han insertado 12435 registros.</p> <p>Si volvemos a realizar la persistencia de los datos, obtendremos un error porque la tabla ya existe. Para evitar este error, podemos a\u00f1adir los datos a una tabla existente mediante el m\u00e9todo <code>mode</code> con valor <code>append</code>, o para machacarlos con el valor <code>overwrite</code>:</p> <pre><code>jdbcSelectDF.write \\\n    .format(\"jdbc\") \\\n    .option(\"driver\", \"com.mysql.cj.jdbc.Driver\") \\\n    .option(\"url\", \"jdbc:mysql://localhost/retail_db\") \\\n    .option(\"dbtable\", \"clientes2\") \\\n    .option(\"user\", \"iabd\") \\\n    .option(\"password\", \"iabd\") \\\n    .mode(\"append\") \\\n    .save()\n</code></pre> <p>overwrite borra la tabla</p> <p>Mediante <code>mode(\"overwrite\")</code>, la tabla se elimina y se vuelven a cargar los datos desde cero. Si queremos que se vuelvan a cargar los datos pero no se cree de nuevo la tabla (por que no queremos que se borren las claves ni los \u00edndices existentes), hemos de a\u00f1adirle la opci\u00f3n <code>option(\"truncate\", \"true\")</code> para que limpie la tabla pero sin eliminarla ni volver a crearla.</p>"},{"location":"spark/02catalog.html#utilizando-databricks","title":"Utilizando Databricks","text":"<p>Si trabajamos con Databricks y queremos recuperar o almacenar datos via JDBC, ya tenemos parte del trabajo hecho porque tiene los drivers instalados (pero utiliza los drivers de MariaDB en vez de MySQL).</p> <p>As\u00ed pues, por ejemplo, para recuperar los datos de una base de datos remota (por ejemplo, la base de datos que creamos en la sesi\u00f3n de cloud con RDS) har\u00edamos:</p> <pre><code>driver = \"org.mariadb.jdbc.Driver\"\ndatabase_host = \"iabd-retail.cdexqeikfdkr.us-east-1.rds.amazonaws.com\"\ndatabase_port = \"3306\"\ndatabase_name = \"retail_db\"\ntable = \"customers\"\nuser = \"admin\"\npassword = \"adminadmin\"\nurl = f\"jdbc:mysql://{database_host}:{database_port}/{database_name}\"\ndf_remoto = (spark.read\n.format(\"jdbc\")\n.option(\"driver\", driver)\n.option(\"url\", url)\n.option(\"dbtable\", table)\n.option(\"user\", user)\n.option(\"password\", password)\n.load()\n)\n</code></pre> <p>Desde la versi\u00f3n 12 de Databricks, podemos utilizar directamente el formato <code>mysql</code> (o <code>postgresql</code> si fuera el caso):</p> <pre><code>df_remoto_mysql = (spark.read.format(\"mysql\")\n.option(\"dbtable\", table)\n.option(\"host\", database_host)\n.option(\"port\", 3306)\n.option(\"database\", database_name)\n.option(\"user\", user)\n.option(\"password\", password)\n.load()\n)\n</code></pre>"},{"location":"spark/02catalog.html#spark-sql-catalog","title":"Spark SQL Catalog","text":"<p>Los cat\u00e1logos de datos son un elemento esencial dentro de una organizaci\u00f3n, al ofrecer una vista de los datos disponibles, los cuales se pueden extender para describir su creaci\u00f3n (persona, equipo u organizaci\u00f3n). Este cat\u00e1logo lo gestionan los data stewards, un rol muy espec\u00edfico de los equipos big data que no solo se encargan de administrar el uso y los enfoques de los datos en la empresa, sino que tratan de asegurar la calidad de la informaci\u00f3n, el cumplimiento de las pol\u00edticas de privacidad, la correcta comunicaci\u00f3n entre los diferentes departamentos y la educaci\u00f3n inform\u00e1tica y tecnol\u00f3gica de los empleados relacionada con el mundo del dato.</p> <p>Volviendo al cat\u00e1logo de datos, el cual al final es un conjunto de metadatos, act\u00faa como un contrato p\u00fablico que se establece durante la vida del dato, definiendo el c\u00f3mo, cu\u00e1ndo y el porqu\u00e9 se consume un determinado dato, por ejemplo, indicando la disponibilidad de cada campo (por ejemplo, si tendr\u00e1 un valor por defecto o nulo), as\u00ed como reglas sobre la gobernanza y acceso de cada campo, etc...</p> <p>El cat\u00e1logo de datos por excelencia es el que forma parte de Apache Hive, y se conoce como el Hive Metastore, el cual ofrece una fuente veraz para describir la localizaci\u00f3n, codificaci\u00f3n de los datos (texto, Parquet, ORC, ...), el esquema de las columnas, y estad\u00edsticas de las tablas almacenadas para facilitar su uso a todos los roles que interact\u00faan con los datos (ingenieros de datos, analistas, ingenieros de ML, ...)</p>"},{"location":"spark/02catalog.html#bases-de-datos","title":"Bases de datos","text":"<p>El cat\u00e1logo se organiza, en su primer nivel, en bases de datos, la cuales agrupan y categorizan las tablas que utiliza nuestro equipo de trabajo, permitiendo identificar su propietario y restringir el acceso. Dentro del Hive Metastore, una base de datos funciona como un prefijo dentro de una ruta f\u00edsica de nuestro data warehouse, evitando colisiones entre nombres de tablas.</p> <p>Una base de datos por equipo</p> <p>Es conveniente que cada equipo de trabajo o unidad de negocio utilice sus propias bases de datos en Spark.</p>"},{"location":"spark/02catalog.html#configurando-spark-con-hive","title":"Configurando Spark con Hive","text":"<p>En nuestra m\u00e1quina virtual ya tenemos configurado el uso del Hive Metastore como cat\u00e1logo de Spark. Para ello, hemos colocado dentro de <code>$SPARK_HOME/conf</code> una copia del archivo <code>hive-site.xml</code> con la informaci\u00f3n de acceso:</p> hive-site.xml<pre><code>&lt;configuration&gt;\n&lt;property&gt;\n&lt;name&gt;javax.jdo.option.ConnectionURL&lt;/name&gt;\n&lt;value&gt;jdbc:mysql://localhost:3306/hive?createDatabaseIfNotExist=true&lt;/value&gt;\n&lt;/property&gt;\n&lt;property&gt;\n&lt;name&gt;javax.jdo.option.ConnectionDriverName&lt;/name&gt;\n&lt;value&gt;com.mysql.cj.jdbc.Driver&lt;/value&gt;\n&lt;/property&gt;\n&lt;property&gt;\n&lt;name&gt;javax.jdo.option.ConnectionUserName&lt;/name&gt;\n&lt;value&gt;iabd&lt;/value&gt;\n&lt;/property&gt;\n&lt;property&gt;\n&lt;name&gt;javax.jdo.option.ConnectionPassword&lt;/name&gt;\n&lt;value&gt;iabd&lt;/value&gt;\n&lt;/property&gt;\n&lt;/configuration&gt;\n</code></pre> <p>Y en el archivo de configuraci\u00f3n de Spark, en <code>$SPARK_HOME/conf/spark-defaults.conf</code> hemos a\u00f1adido dos propiedades para indicarle que vamos a utilizar la implementaci\u00f3n del cat\u00e1logo de Hive y que queremos que almacene las bases de datos que creemos en <code>/opt/spark-3.3.1/warehouse/</code>:</p> spark-defaults.conf<pre><code># The default location to read and write distributed SQL tables.\n# This location can be located on the local file system and on any HDFS compatible file system.\nspark.sql.warehouse.dir /opt/spark-3.3.1/warehouse/\n# Defines the backing SQL catalog for the Spark session.\nspark.sql.catalogImplementation hive\n</code></pre> <p>Si hubi\u00e9semos querido que las bases de datos que creemos desde Spark tambi\u00e9n lo hicieran dentro de HDFS (que ser\u00eda lo recomendable), deber\u00edamos indicar la ruta:</p> <pre><code>spark.sql.warehouse.dir hdfs://iabd-virtualbox:9000/user/hive/warehouse/\n</code></pre>"},{"location":"spark/02catalog.html#accediendo-al-catalogo","title":"Accediendo al cat\u00e1logo","text":"<p>A partir de la sesi\u00f3n de Spark, podemos acceder al objeto <code>catalog</code> que contiene un conjunto de m\u00e9todos para interactuar con \u00e9l.</p> <p>Podemos comprobar su uso mediante una consulta a <code>show databases</code> o accediendo al m\u00e9todo <code>listDatabases()</code> del <code>catalog</code>:</p> <pre><code>spark.sql(\"show databases\").show()\n# +---------+\n# |namespace|\n# +---------+\n# |  default|\n# |     iabd|\n# +---------+\nspark.catalog.listDatabases()\n# [Database(name='default', description='Default Hive database', locationUri='hdfs://iabd-virtualbox:9000/user/hive/warehouse'),\n#  Database(name='iabd', description='', locationUri='hdfs://iabd-virtualbox:9000/user/hive/warehouse/iabd.db')]\n</code></pre> <p>De manera que obtenemos las bases de datos que est\u00e1 utilizando actualmente (como puedes observar, son las bases de datos que hemos creado previamente en la sesi\u00f3n de Hive).</p> <p>Si queremos ver cual es nuestra base de datos activa, utilizaremos el m\u00e9todo <code>currentDatabase</code>:</p> <pre><code>spark.catalog.currentDatabase()\n# 'default'\n</code></pre>"},{"location":"spark/02catalog.html#creando-una-base-de-datos","title":"Creando una base de datos","text":"<p>De la misma manera que hemos creado sentencias SQL en Spark, podemos generar sentencias DDL y DML. As\u00ed pues, para crear una base de datos, hemos de hacer uso del API SQL y utilizar la sentencia DDL de <code>CREATE DATABASE</code>. Por ejemplo, vamos a crear una base de datos <code>s8a</code> donde colocaremos las tablas que crearemos en esta sesi\u00f3n:</p> <pre><code>spark.sql(\"create database if not exists s8a\")\n</code></pre> <p>Una vez creada, la activamos mediante <code>use</code>:</p> <pre><code>spark.sql(\"use s8a\")\n</code></pre> <p>Si comprobamos la ruta, podemos ver c\u00f3mo la ha creado en el almac\u00e9n de Spark que hemos indicado previamente en la configuraci\u00f3n:</p> <pre><code>spark.catalog.listDatabases()\n# [Database(name='default', description='Default Hive database', locationUri='hdfs://iabd-virtualbox:9000/user/hive/warehouse'),\n#  Database(name='iabd', description='', locationUri='hdfs://iabd-virtualbox:9000/user/hive/warehouse/iabd.db'),\n#  Database(name='s8a', description='', locationUri='file:/opt/spark-3.3.1/warehouse/s8a.db')]\n</code></pre>"},{"location":"spark/02catalog.html#trabajando-con-tablas","title":"Trabajando con tablas","text":"<p>Vamos a suponer que tenemos el DataFrame de clientes que hemos cargado previamente desde JDBC, y creamos una vista sobre \u00e9l:</p> <pre><code>jdbcDF = spark.read \\\n    .format(\"jdbc\") \\\n    .option(\"driver\", \"com.mysql.cj.jdbc.Driver\") \\\n    .option(\"url\", \"jdbc:mysql://localhost\") \\\n    .option(\"dbtable\", \"retail_db.customers\") \\\n    .option(\"port\", \"3306\") \\\n    .option(\"user\", \"iabd\") \\\n    .option(\"password\", \"iabd\") \\\n    .load()\njdbcDF.createOrReplaceTempView(\"clientes\")\n</code></pre> <p>Si comprobamos las tablas de nuestra base de datos mediante el m\u00e9todo <code>listTables</code>, aparecer\u00e1 la vista como una tabla temporal (<code>TEMPORARY</code>), lo que significa que s\u00f3lo est\u00e1 disponible en memoria:</p> <pre><code>spark.catalog.listTables()\n# [Table(name='clientes', database=None, description=None, tableType='TEMPORARY', isTemporary=True)]\n</code></pre> <p>Al ser temporal, al detener Spark, dicha tabla desaparecer\u00e1. Si queremos que la tabla est\u00e9 disponible en nuestro data lake y que podamos consultarla desde el cat\u00e1logo del Hive Metastore, necesitamos persistirla.</p>"},{"location":"spark/02catalog.html#persistiendo-tablas","title":"Persistiendo tablas","text":"<p>Cuando tenemos un DataFrame lo podemos persistir como una tabla, lo que en terminolog\u00eda de Hive ser\u00eda una tabla interna o gestionada, mediante <code>saveAsTable</code>:</p> <pre><code>jdbcDF.write.mode(\"errorIfExists\") \\  # (1)!\n.saveAsTable(\"clientes\")\n</code></pre> <ol> <li>Hemos configurado el modo de escritura a <code>errorIfExists</code> para asegurarnos que no borramos ning\u00fan datos de nuestro datalake.</li> </ol> <p>Si volvemos a comprobar las tablas, podemos ver como la nueva tabla ahora forma parte de la base de datos <code>s8a</code> y que tu tipo es <code>MANAGED</code>:</p> <pre><code>spark.catalog.listTables()\n# [Table(name='clientes', database='s8a', description=None, tableType='MANAGED', isTemporary=False),\n#  Table(name='clientes', database=None, description=None, tableType='TEMPORARY', isTemporary=True)]\n</code></pre> <p>Podemos configurar diferentes opciones a la hora de persistir las tablas. Por ejemplo, si queremos persistir la tabla en formato JSON sobrescribiendo los datos hemos de indicarlo con <code>format('json')</code> y <code>mode('overwrite')</code>:</p> <pre><code>jdbcDF.write.format(\"json\").mode(\"overwrite\").saveAsTable(\"clientesj\")\n</code></pre> <p>Por defecto en formato Parquet</p> <p>Por defecto, al persistir una tabla, se realiza en formato Parquet y comprimido mediante Snappy.</p>"},{"location":"spark/02catalog.html#tablas-externas","title":"Tablas externas","text":"<p>Si queremos crear una tabla no gestionada, tambi\u00e9n conocida como tabla externa, la cual se almacena como tablas en Hive, necesitamos indicar la ruta de los datos en el momento de la creaci\u00f3n mediante la clausula <code>LOCATION</code>.</p> <p>Vamos a crear una tabla de clientes con los datos que tenemos almacenados en HDFS que cargamos mediante Sqoop en la sesi\u00f3n de Hive en la ruta <code>/user/iabd/hive/customer</code>.</p> <p>As\u00ed pues, nuestra sentencia DDL ser\u00eda:</p> <pre><code>spark.sql(\"\"\"\nCREATE EXTERNAL TABLE IF NOT EXISTS clientese\n(\n  custId INT,\n  fName STRING,\n  lName STRING,\n  city STRING\n)\nROW FORMAT DELIMITED\nFIELDS TERMINATED BY '|'\nSTORED AS TEXTFILE\nLOCATION 'hdfs://iabd-virtualbox:9000/user/iabd/hive/customer'\"\"\")\n</code></pre> <p>Si volvemos a comprobar las tablas, veremos que que la ha marcado <code>EXTERNAL</code>:</p> <pre><code>spark.catalog.listTables()\n# [Table(name='clientes', database='s8a', description='Datos de clientes obtenidos desde retail_db.customers', tableType='MANAGED', isTemporary=False),\n#  Table(name='clientese', database='s8a', description=None, tableType='EXTERNAL', isTemporary=False),\n#  Table(name='clientesj', database='s8a', description=None, tableType='MANAGED', isTemporary=False)]\n</code></pre> <p>Y si realizamos una consulta, obtenemos los mismos datos que hay almacenados en HDFS:</p> <pre><code>spark.sql(\"select * from clientese limit 3\").show();\n# +------+-------+---------+-----------+\n# |custId|  fName|    lName|       city|\n# +------+-------+---------+-----------+\n# |     1|Richard|Hernandez|Brownsville|\n# |     2|   Mary|  Barrett|  Littleton|\n# |     3|    Ann|    Smith|     Caguas|\n# +------+-------+---------+-----------+\n</code></pre> <p>Tambi\u00e9n podemos crear una tabla externa indicando la opci\u00f3n <code>path</code>, de manera que nos crear\u00e1 los datos en HDFS (recuerda que por defecto almacena los datos en formato Parquet):</p> <pre><code>jdbcDF.write.option(\"path\", \"hdfs://iabd-virtualbox:9000/user/iabd/spark/customer\").saveAsTable(\"clienteses\")\n</code></pre>"},{"location":"spark/02catalog.html#cargando-tablas","title":"Cargando tablas","text":"<p>Una vez las tablas ya est\u00e1n persistidas, en cualquier momento podemos recuperarlas y asociarlas a un nuevo DataFrame mediante el m\u00e9todo <code>table</code>:</p> <pre><code>df_clientes = spark.table(\"clientes\")\ndf_clientes.printSchema()\n# root\n#  |-- customer_id: integer (nullable = true)\n#  |-- customer_fname: string (nullable = true)\n#  |-- customer_lname: string (nullable = true)\n#  |-- customer_email: string (nullable = true)\n#  |-- customer_password: string (nullable = true)\n#  |-- customer_street: string (nullable = true)\n#  |-- customer_city: string (nullable = true)\n#  |-- customer_state: string (nullable = true)\n#  |-- customer_zipcode: string (nullable = true)\n</code></pre>"},{"location":"spark/02catalog.html#cacheando-tablas","title":"Cacheando tablas","text":"<p>En la sesi\u00f3n anterior estudiamos c\u00f3mo persistir los DataFrames y vimos como tambi\u00e9n podemos persistir una vista, incluso c\u00f3mo comprobar su estado en el Spark UI.</p> <p>Para cachear tablas, usaremos el m\u00e9todo <code>cacheTable</code>:</p> <pre><code>spark.catalog.cacheTable(\"clientes\")\n</code></pre> <p>Si por el contrario, queremos liberar la memoria de una tabla que ha sido cacheada, usaremos el m\u00e9todo <code>uncacheTable</code>:</p> <pre><code>spark.catalog.uncacheTable(\"clientes\")\n</code></pre> <p>Si queremos limpiar toda la cach\u00e9, disponemos del m\u00e9todo <code>clearCache</code>:</p> <pre><code>spark.catalog.clearCache()\n</code></pre> <p>Refrescando la cach\u00e9</p> <p>Un caso muy com\u00fan al trabajar con datos cacheados es que desde una aplicaci\u00f3n externa se actualicen los datos y la cach\u00e9 contenga una copia obsoleta.</p> <p>Para refrescar los datos, podemos utilizar el m\u00e9todo <code>refreshTable</code>:</p> <pre><code>spark.catalog.refreshTable(\"clientes\")\n</code></pre> <p>Un punto a destacar es que si una aplicaci\u00f3n Spark sobrescribe una tabla que hab\u00edamos cacheado, Spark directamente invalidar\u00e1 la cach\u00e9 local, de manera que no ser\u00e1 necesario que en nuestra l\u00f3gica de aplicaci\u00f3n refresquemos las tablas de forma expl\u00edcita.</p> <p>S\u00f3lo lo haremos si la sobrescritura de los datos la realiza una aplicaci\u00f3n ajena a Spark sobre una tabla externa.</p>"},{"location":"spark/02catalog.html#borrando-tablas","title":"Borrando tablas","text":"<p>Si dejamos de utilizar una tabla y la queremos eliminar del Metastore, podemos realizarlo directamente mediante su sentencia de DDL <code>DROP TABLE</code>:</p> <pre><code>spark.sql(\"DROP TABLE IF EXISTS cliente\")\n</code></pre>"},{"location":"spark/02catalog.html#spark-y-el-metastore","title":"Spark y el Metastore","text":"<p>Para comprender c\u00f3mo se almacenan los metadatos de las bases de datos y las tablas gestionadas es importante conocer donde se almacenan los metadatos.</p> <p>Si abrimos un terminal y accedemos al MySQL de nuestra m\u00e1quina virtual, podemos ver todas las tablas que utiliza el Hive Metastore:</p> <pre><code>$ mysql -uiabd -piabd\nWelcome to the MariaDB monitor.  Commands end with ; or \\g.\nYour MariaDB connection id is 143\nServer version: 10.3.37-MariaDB-0ubuntu0.20.04.1 Ubuntu 20.04\n\nCopyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.\n\nType 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.\n\nMariaDB [(none)]&gt; use hive\nDatabase changed\n\nMariaDB [hive]&gt; show tables;\n+-------------------------------+\n| Tables_in_hive                |\n+-------------------------------+\n| AUX_TABLE                     |\n| BUCKETING_COLS                |\n| CDS                           |\n| COLUMNS_V2                    |\n| COMPACTION_QUEUE              |\n| COMPLETED_COMPACTIONS         |\n| COMPLETED_TXN_COMPONENTS      |\n| CTLGS                         |\n| DATABASE_PARAMS               |\n| DBS                           |\n...\n| WRITE_SET                     |\n+-------------------------------+\n74 rows in set (0,000 sec)\nMariaDB [hive]&gt; </code></pre> <p>De todas las tablas, nos vamos a centrar en la tabla DBS, que almacena las bases de datos creadas, donde podemos observar, adem\u00e1s de su nombre, la localizaci\u00f3n de cada base de datos y su propietario:</p> <pre><code>MariaDB [hive]&gt; select * from DBS;\n+-------+-----------------------+---------------------------------------------------------+---------+------------+------------+-----------+\n| DB_ID | DESC                  | DB_LOCATION_URI                                         | NAME    | OWNER_NAME | OWNER_TYPE | CTLG_NAME |\n+-------+-----------------------+---------------------------------------------------------+---------+------------+------------+-----------+\n|     1 | Default Hive database | hdfs://iabd-virtualbox:9000/user/hive/warehouse         | default | public     | ROLE       | hive      |\n|    21 | NULL                  | hdfs://iabd-virtualbox:9000/user/hive/warehouse/iabd.db | iabd    | iabd       | USER       | hive      |\n|    31 |                       | file:/opt/spark-3.3.1/warehouse/s8a.db                  | s8a     | iabd       | USER       | hive      |\n+-------+-----------------------+---------------------------------------------------------+---------+------------+------------+-----------+\n3 rows in set (0,001 sec)\n</code></pre> <p>Si nos quedamos con el identificador de cada base de datos (<code>DB_ID</code>), el cual act\u00faa como clave primaria, vamos a poder consultar las tablas de una determinada base de datos consultando la tabla <code>TBLS</code>:</p> <pre><code>MariaDB [hive]&gt; select * from TBLS where DB_ID = 31;\n+--------+-------------+-------+------------------+-------+------------+-----------+-------+-----------+---------------+--------------------+--------------------+--------------------+\n| TBL_ID | CREATE_TIME | DB_ID | LAST_ACCESS_TIME | OWNER | OWNER_TYPE | RETENTION | SD_ID | TBL_NAME  | TBL_TYPE      | VIEW_EXPANDED_TEXT | VIEW_ORIGINAL_TEXT | IS_REWRITE_ENABLED |\n+--------+-------------+-------+------------------+-------+------------+-----------+-------+-----------+---------------+--------------------+--------------------+--------------------+\n|     61 |  1673256646 |    31 |                0 | iabd  | NULL       |         0 |   111 | clientes  | MANAGED_TABLE | NULL               | NULL               |                    |\n|     62 |  1673256649 |    31 |                0 | iabd  | NULL       |         0 |   112 | clientesj | MANAGED_TABLE | NULL               | NULL               |                    |\n+--------+-------------+-------+------------------+-------+------------+-----------+-------+-----------+---------------+--------------------+--------------------+--------------------+\n</code></pre> <p>Y repetimos el proceso, ahora nos quedamos con el identificador de la tabla, y consultamos la tabla <code>TABLE_PARAMS</code>, donde podemos ver donde se almacena toda la informaci\u00f3n que utiliza Spark para leer las tablas de forma autom\u00e1tica:</p> <pre><code>MariaDB [hive]&gt; select * from TABLE_PARAMS where TBL_ID = 61;\n+--------+----------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| TBL_ID | PARAM_KEY                  | PARAM_VALUE                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |\n+--------+----------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n|     61 | numFiles                   | 1                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |\n|     61 | spark.sql.create.version   | 3.3.1                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |\n|     61 | spark.sql.sources.provider | parquet                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |\n|     61 | spark.sql.sources.schema   | {\"type\":\"struct\",\"fields\":[{\"name\":\"customer_id\",\"type\":\"integer\",\"nullable\":true,\"metadata\":{\"scale\":0}},{\"name\":\"customer_fname\",\"type\":\"string\",\"nullable\":true,\"metadata\":{\"scale\":0}},{\"name\":\"customer_lname\",\"type\":\"string\",\"nullable\":true,\"metadata\":{\"scale\":0}},{\"name\":\"customer_email\",\"type\":\"string\",\"nullable\":true,\"metadata\":{\"scale\":0}},{\"name\":\"customer_password\",\"type\":\"string\",\"nullable\":true,\"metadata\":{\"scale\":0}},{\"name\":\"customer_street\",\"type\":\"string\",\"nullable\":true,\"metadata\":{\"scale\":0}},{\"name\":\"customer_city\",\"type\":\"string\",\"nullable\":true,\"metadata\":{\"scale\":0}},{\"name\":\"customer_state\",\"type\":\"string\",\"nullable\":true,\"metadata\":{\"scale\":0}},{\"name\":\"customer_zipcode\",\"type\":\"string\",\"nullable\":true,\"metadata\":{\"scale\":0}}]} |\n|     61 | totalSize                  | 251792                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |\n|     61 | transient_lastDdlTime      | 1673256646                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |\n+--------+----------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n6 rows in set (0,001 sec)\n</code></pre>"},{"location":"spark/02catalog.html#facilitando-el-descubrimiento-de-datos","title":"Facilitando el descubrimiento de datos","text":"<p>Una vez sabemos c\u00f3mo se almacenan los metadatos, podemos consultarlos para descubrir los datos, proceso que se conoce como data discovery.</p> <p>Volviendo a nuestros cuadernos Jupyter, si nos centramos en la base de datos <code>s8a</code> y consultamos sus tablas mediante <code>listTables</code>, observamos que no tienen descripci\u00f3n, lo cual a la hora de poder descubrir datos no es nada positivo:</p> <pre><code>spark.sql(\"use s8a\")\nspark.catalog.listTables()\n# [Table(name='clientes', database='s8a', description=None, tableType='MANAGED', isTemporary=False),\n#  Table(name='clientesj', database='s8a', description=None, tableType='MANAGED', isTemporary=False)]\n</code></pre> <p>Para poder a\u00f1adirle la descripci\u00f3n a las tablas, mediante DML modificamos las propiedades de la tabla, en concreto la propiedad <code>comment</code>:</p> <pre><code>spark.sql(\n\"\"\"\nALTER TABLE clientes\nSET TBLPROPERTIES (\n  'comment' = 'Datos de clientes obtenidos desde retail_db.customers',\n  'active' = 'true'\n)\n\"\"\")\n</code></pre> <p>Si volvemos a consultar las tablas, ya podemos ver su descripci\u00f3n:</p> <pre><code>spark.catalog.listTables()\n# [Table(name='clientes', database='s8a', description='Datos de clientes obtenidos desde retail_db.customers', tableType='MANAGED', isTemporary=False),\n#  Table(name='clientesj', database='s8a', description=None, tableType='MANAGED', isTemporary=False)]\n</code></pre> <p>Vamos a comprobar ahora las columnas de las tablas mediante <code>listColumns</code>:</p> <pre><code>spark.catalog.listColumns(\"clientes\")\n# [Column(name='customer_id', description=None, dataType='int', nullable=True, isPartition=False, isBucket=False),\n#  Column(name='customer_fname', description=None, dataType='string', nullable=True, isPartition=False, isBucket=False),\n#  Column(name='customer_lname', description=None, dataType='string', nullable=True, isPartition=False, isBucket=False),\n#  Column(name='customer_email', description=None, dataType='string', nullable=True, isPartition=False, isBucket=False),\n#  Column(name='customer_password', description=None, dataType='string', nullable=True, isPartition=False, isBucket=False),\n#  Column(name='customer_street', description=None, dataType='string', nullable=True, isPartition=False, isBucket=False),\n#  Column(name='customer_city', description=None, dataType='string', nullable=True, isPartition=False, isBucket=False),\n#  Column(name='customer_state', description=None, dataType='string', nullable=True, isPartition=False, isBucket=False),\n#  Column(name='customer_zipcode', description=None, dataType='string', nullable=True, isPartition=False, isBucket=False)]\n</code></pre> <p>Igual que antes, tenemos la descripci\u00f3n en blanco (valor <code>None</code>), por lo que mediante DML modificamos el comentario de cada columna:</p> <pre><code>spark.sql(\"ALTER TABLE clientes ALTER COLUMN customer_id COMMENT 'Identificador un\u00edvoco (PK) del cliente'\")\nspark.sql(\"ALTER TABLE clientes ALTER COLUMN customer_fname COMMENT 'Nombre del cliente'\");\n</code></pre> <p>Y comprobamos como han cambiado ambos campos:</p> <pre><code>spark.catalog.listColumns(\"clientes\")\n# [Column(name='customer_id', description='Identificador un\u00edvoco (PK) del cliente', dataType='int', nullable=True, isPartition=False, isBucket=False),\n#  Column(name='customer_fname', description='Nombre del cliente', dataType='string', nullable=True, isPartition=False, isBucket=False),\n#  Column(name='customer_lname', description=None, dataType='string', nullable=True, isPartition=False, isBucket=False),\n#  Column(name='customer_email', description=None, dataType='string', nullable=True, isPartition=False, isBucket=False),\n#  Column(name='customer_password', description=None, dataType='string', nullable=True, isPartition=False, isBucket=False),\n#  Column(name='customer_street', description=None, dataType='string', nullable=True, isPartition=False, isBucket=False),\n#  Column(name='customer_city', description=None, dataType='string', nullable=True, isPartition=False, isBucket=False),\n#  Column(name='customer_state', description=None, dataType='string', nullable=True, isPartition=False, isBucket=False),\n#  Column(name='customer_zipcode', description=None, dataType='string', nullable=True, isPartition=False, isBucket=False)]\n</code></pre>"},{"location":"spark/02catalog.html#delta-lake","title":"Delta Lake","text":"Logo de Delta Lake <p>En la sesi\u00f3n de Data Lakes ya estudiamos qu\u00e9 ofrece un data lake y sus diferencias respecto a los data warehouses, as\u00ed como una peque\u00f1a introducci\u00f3n al concepto de data lakehouse.</p> <p>Delta Lake es un producto que ofrece transaccionalidad y soporte para upserts y merges en data lakes manteniendo una escalabilidad horizontal y ofreciendo la separaci\u00f3n del almacenamiento y la computaci\u00f3n que necesita el big data. As\u00ed pues, podemos considerar a Delta Lake como una implementaci\u00f3n del concepto de data lakehouse, el cual combina lo mejor de los data warehouses y data lakes, ofreciendo transacciones ACID, gesti\u00f3n escalable de los metadatos, un modelo unificado para procesar datos tanto por lotes como en streaming, hist\u00f3rico auditable y soporte para sentencias DML sobre los datos.</p> <p>Podemos ejecutarlo sobre data lakes ya existentes y es completamente compatibles con varios motores de procesamiento como es el caso de Apache Spark, y de ah\u00ed, el motivo de estudiarlo en esta sesi\u00f3n.</p> <p>Data Lakehouse por dentro</p> <p>El almacenamiento de un data lakehouse se cede a servicios de almacenamiento de objetos, los cuales son muy econ\u00f3micos, como son Amazon S3 o Azure ADLs, almacenando los dato en formatos abiertos como Apache Parquet.</p> <p>Sin embargo, para ser un data lakehouse, necesitamos soporte para transacciones ACID. Para ello, debemos tener una capa de metadatos transaccionales sobre el almacenamiento cloud, que defina que objetos forman parte de que versi\u00f3n de tabla.</p> <p>Para conseguir un gran rendimiento en las consultas SQL es necesario ofrecer servicios de cach\u00e9, estructuras de datos auxiliares como \u00edndices y estad\u00edsticas para poder optimizar la capa de datos.</p> <p>La herramienta final es el desarrollo de un API est\u00e1ndar, como es la DataFrame API, la cual soportan herramientas como TensorFlow o Spark MLlib, la cual permite, de forma declarativa, la construcci\u00f3n de un grafo DAG con su ejecuci\u00f3n. </p> <p>Otros productos alternativos como implementaci\u00f3n del concepto de data lakehouse son Apache Iceberg y Apache Hudi.</p> <p>Formalmente, podemos decir que Delta Lake ofrece una capa de metadatos, cach\u00e9 e indexaci\u00f3n sobre el almacenamiento de un data lake, de manera que ofrece un nivel de abstracci\u00f3n con soporte para transacciones ACID y versionado de los datos.</p> <p>Se trata de un proyecto open-source desde que en 2019 Databricks lo liber\u00f3. Por supuesto, Databricks ofrece soporte completo de Delta Lake como capa de persistencia de datos.</p>"},{"location":"spark/02catalog.html#caracteristicas","title":"Caracter\u00edsticas","text":"<p>Delta Lake ofrece las siguientes caracter\u00edsticas:</p> <ul> <li>Transacciones ACID. Todas las transacciones realizadas con Spark se realizan de manera durable y se exponen a otros consumidores de forma at\u00f3mica, gracias al Delta Transaction Log.</li> <li>Soporte completo de DML, pudiendo realizar borrados y modificados, pero tambi\u00e9n fusiones complejas de datos o escenarios upserts, lo que simplifica la creaci\u00f3n de dimensiones y tablas de hechos al construir un MDW (modern data warehouse), as\u00ed como cumplir la GDPR respecto a la modificaci\u00f3n y/o borrado de datos.</li> <li>Time travel. El fichero de log de transacciones de Delta Lake guarda cada cambio realizado sobre los datos en el orden en el que se han realizado. Este log se convierte en un herramienta de auditoria completa, lo que facilita que administradores y desarrolladores puedan revertir a una versi\u00f3n anterior de los datos, y asea para auditor\u00edas, rollbacks o la realizaci\u00f3n de pruebas. Esta caracter\u00edstica se conoce como Time Travel.</li> <li>Unificaci\u00f3n del procesamiento batch y streaming en un \u00fanico modelo, ya que puede realizar merges de los flujos de datos (requisito muy com\u00fan al trabajar con IoT).</li> <li>Evoluci\u00f3n y aplicaci\u00f3n de esquemas, al provocar el cumplimiento de un esquema a la hora de leer o escribir datos desde el lago, permitiendo una evoluci\u00f3n segura del esquema para casos de uso donde los datos necesitan evolucionar.</li> <li>Soporte de metadatos ricos y escalables, ya que los metadatos pueden crecer y convertirse en big data y no escalar correctamente, de manera que Delta Lake facilita el escalado y procesamiento eficiente mediante Spark pudiendo manejar petabytes de datos.</li> </ul>"},{"location":"spark/02catalog.html#arquitectura-medallion","title":"Arquitectura Medallion","text":"<p>La arquitectura Medallion es un patr\u00f3n de dise\u00f1o de datos que se utiliza para organizar los datos en un lakehouse, con el objetivo de mejorar progresivamente la estructura y calidad de los datos conforme fluyen a trav\u00e9s de las diferentes capas de la arquitectura (de la capa raw/bronce a la plata, y de ah\u00ed a la oro.)</p> Arquitectura Medallion de un lago de datos - databricks.com <p>Conforme los datos transicionan de la capa bronce y plata a la de oro (conforme evoluci\u00f3n los datos valen m\u00e1s, y de ah\u00ed su material) obtenemos datos m\u00e1s precisos. Cuando realizamos la ingesta de datos mediante procesos batch o en streaming los almacenamos en la capa de bronce en su formato crudo (raw), tras limpiarlos, normalizarlos y realizar el procesado necesario para realizar nuestras consultas, los volvemos a almacenar en la capa de plata (curated). Finalmente, en la capa de oro almacenamos los datos agregados, con las tablas de sumario que contienen los KPI o las tablas necesarias para la visualizaci\u00f3n de los datos por parte de las herramientas de negocio como PowerBI o Tableau.</p> <p>Para este flujo de datos entre capas, Databricks ofrece las tablas Delta Live y el uso de pipelines (esta opci\u00f3n no est\u00e1 habilitada en la versi\u00f3n educativa y no la vamos a poder probar). Ten\u00e9is un ejemplo completo en Getting Started with Delta Live Tables.</p>"},{"location":"spark/02catalog.html#arquitectura-de-un-lakehouse","title":"Arquitectura de un Lakehouse","text":"<p>El uso de la arquitectura que propone Delta Lake permite el procesamiento simult\u00e1neos de los datos batch y en streaming, de manera que podemos tener escribir los datos batch y los flujos en streaming en la misma tabla, y a su vez, se escriben de manera progresiva en otras tablas m\u00e1s limpias y refinadas.</p> <p>La arquitectura de un lakehouse se compone de tres capas, y en nuestro caso, se concreta en:</p> <ul> <li>la capa de almacenamiento, por ejemplo, sobre S3.</li> <li>la capa transaccional, que la implementa Delta Lake.</li> <li>la capa de procesamiento, que la aporta Spark.</li> </ul> Arquitectura de un lakehouse con Delta Lake"},{"location":"spark/02catalog.html#el-ecosistema-delta","title":"El ecosistema Delta","text":"<p>Delta Lake se utiliza en su mayor medida como lakehouse por m\u00e1s de 7000 empresas, procesando exabytes de datos por d\u00eda.</p> <p>Sin embargo, los data warehouses y las aplicaciones de machine learning no son el \u00fanico objetivo de Delta Lake, ya que el soporte transaccional ACID aporta confiabilidad al data lake y permite ingestar y consumir datos tanto en streaming como por lotes.</p> <p>El ecosistema de DeltaLake se compone de una conjunto de componentes individuales entre los que destacan Delta Lake Storage, Delta Sharing, y Delta Connectors.</p>"},{"location":"spark/02catalog.html#delta-lake-storage","title":"Delta Lake Storage","text":"<p>Se trata de una capa de almacenamiento que corre sobre los lagos de datos basados en el cloud, como son Azure Data Lake Storage (ADLS), AWS S3 o Google Cloud Storage (GCS), a\u00f1adiendo transaccionalidad al lago de datos y las tablas, y por tanto, ofreciendo caracter\u00edsticas de un data warehouse a un data lake.</p> <p>Se trata del componente principal, ya que el resto de elementos del ecosistema dependen de \u00e9l.</p>"},{"location":"spark/02catalog.html#delta-sharing","title":"Delta Sharing","text":"<p>Todo lago de datos va a tener que compartir sus datos en alg\u00fan momento, lo que requiere una soluci\u00f3n segura y confiable que nos asegure la privacidad deseada en los datos.</p> <p>Delta Sharing es un protocolo para compartir datos seguros para grandes conjuntos de datos almacenados en el data lake, de manera que podemos compartir los datos almacenados en S3 o ADLS y acceder mediante Spark o PowerBI sin necesidad de desplegar ning\u00fan componente adicional, facilitando compartir los datos incluso entre diferentes proveedores cloud sin necesidad de ning\u00fan desarrollo.</p> Delta Sharing <p>Por ejemplo, podemos:</p> <ul> <li>Procesar en AWS mediante Spark datos que est\u00e1n almacenados en Azure ADLS.</li> <li>Procesar en Google mediante Rust datos que est\u00e1n almacenados en S3.</li> </ul> <p>M\u00e1s informaci\u00f3n sobre el ecosistema de Delta Sharing en la p\u00e1gina de Sharing de Delta Lake.</p>"},{"location":"spark/02catalog.html#delta-connectors","title":"Delta Connectors","text":"<p>El principal objetivo de los conectores Delta es llevar Delta Lake a otros motores de procesamiento ajenos a Spark. Para ello, ofrece conectores open source que realizan la conexi\u00f3n directa a DeltaLake sin necesidad de pasar por Spark.</p> <p>Los conectores m\u00e1s destacados son:</p> <ul> <li>Delta Standalone: librer\u00edas Java/Python/Rust/etc... para desarrollar aplicaciones que leen y escriben en Delta Lake.</li> <li>Hive. Lectura de datos desde Apache Hive.</li> <li>Flink. Lectura y escritura de datos desde Apache Flink.</li> <li>Sql-delta-import. Permite importar datos desde cualquier fuente de datos JDBC.</li> <li>Power BI. Funci\u00f3n de Power Query que permite la lectura  de una tabla Delta desde cualquier fuente de datos soportado por Power BI.</li> </ul> <p>M\u00e1s informaci\u00f3n sobre los conectores existentes, donde cada d\u00eda hay m\u00e1s, en la p\u00e1gina de Integrations de Delta Lake.</p>"},{"location":"spark/02catalog.html#hola-delta","title":"Hola Delta","text":"<p>Probando Delta Lake</p> <p>Para poder realizar los ejemplos y practicar DeltaLake, en esta sesi\u00f3n nos vamos a centrar en la m\u00e1quina virtual o mediante DataBricks, ya que no existe (de momento) una imagen de DeltaLake para Docker.</p> <p>Si nos centramos en nuestra instalaci\u00f3n de la m\u00e1quina virtual, cuando lanzamos <code>pyspark</code> tenemos que indicarle que vamos a utilizar <code>delta</code> mediante la opci\u00f3n <code>packages</code>:</p> <pre><code>pyspark --packages io.delta:delta-core_2.12:2.1.0 --conf \"spark.sql.extensions=io.delta.sql.DeltaSparkSessionExtension\" --conf \"spark.sql.catalog.spark_catalog=org.apache.spark.sql.delta.catalog.DeltaCatalog\"\n</code></pre> <p>Para facilitar su uso, en nuestro m\u00e1quina virtual hemos creado un alias:</p> <pre><code>pysparkdl\n</code></pre> <p>Si partimos de los datos que ten\u00edamos en el DataFrame de clientes, podemos persistirlos en Delta indicando su formato mediante <code>format(\"delta\")</code>:</p> <pre><code>spark.sql(\"use s8a\")\ndf = spark.table(\"clientes\")\n# DeltaLake el Local\ndf.write.format(\"delta\").save(\"/tmp/raw/clientes\")\n# DeltaLake el DataBricks\ndf.write.format(\"delta\").save(\"/delta/raw/clientes\")\n# DeltaLake el HDFS\ndf.write.format(\"delta\").save(\"hdfs://iabd-virtualbox:9000/user/iabd/delta/raw/clientes\")\n</code></pre> <p>Si intentamos volver a escribir los datos en la misma ruta, obtendremos un error. Si queremos sobrescribir los datos, necesitamos indicarle el modo <code>overwrite</code>:</p> <pre><code>df.write.format(\"delta\").mode(\"overwrite\").save(\"/tmp/raw/clientes\")\n</code></pre> <p>Para recuperar los datos, realizamos una lectura indicando siempre el formato <code>delta'</code>:</p> <pre><code># DeltaLake el Local\ndfdeltal = spark.read.format(\"delta\").load(\"/tmp/raw/clientes\")\ndfdeltahdfs = spark.read.format(\"delta\").load(\"hdfs://iabd-virtualbox:9000/user/iabd/delta/raw/clientes\")\n</code></pre>"},{"location":"spark/02catalog.html#por-dentro","title":"Por dentro","text":"<p>Si accedemos al sistema de archivos local, HDFS o Databricks DBFS, podemos analizar la estructura de archivos que ha utilizado para almacenar la informaci\u00f3n.</p> <p>Delta Lake almacena los datos en formato Parquet en la ruta indicada (y si hubi\u00e9ramos indicando particiones, en sus subcarpetas), y luego crea una carpeta denominada <code>_delta_log</code> donde almacena el DeltaLog o log transaccional en formato JSON, en el cual va registrando los cambios delta que se realizan sobre los datos. </p> <p>Vamos a comprobar qu\u00e9 datos se han almacenado en HDFS:</p> <pre><code>iabd@iabd-virtualbox:~/datos$ hdfs dfs -ls -R /user/iabd/delta/raw/clientes\ndrwxr-xr-x   - iabd supergroup          0 2023-01-29 12:23 /user/iabd/delta/raw/clientes/_delta_log\n-rw-r--r--   1 iabd supergroup       2605 2023-01-29 12:23 /user/iabd/delta/raw/clientes/_delta_log/00000000000000000000.json\n-rw-r--r--   3 iabd supergroup     251875 2023-01-29 12:23 /user/iabd/delta/raw/clientes/part-00000-05cb7b9c-c529-4f5e-83ab-0dc79d0422bf-c000.snappy.parquet\n</code></pre> <p>Si realizamos otra operaci\u00f3n, por ejemplo, sobrescribimos la tabla, generar\u00e1 nuevos datos y otro fichero de log:</p> <pre><code>df.write.format(\"delta\").mode(\"overwrite\").save(\"hdfs://iabd-virtualbox:9000/user/iabd/delta/raw/clientes\")\n</code></pre> <p>Lo comprobamos volviendo a listar los archivos almacenados:</p> <pre><code>iabd@iabd-virtualbox:~/datos$ hdfs dfs -ls -R /user/iabd/delta/raw/clientes\ndrwxr-xr-x   - iabd supergroup          0 2023-01-29 12:29 /user/iabd/delta/raw/clientes/_delta_log\n-rw-r--r--   1 iabd supergroup       2605 2023-01-29 12:23 /user/iabd/delta/raw/clientes/_delta_log/00000000000000000000.json\n-rw-r--r--   1 iabd supergroup       1592 2023-01-29 12:29 /user/iabd/delta/raw/clientes/_delta_log/00000000000000000001.json\n-rw-r--r--   3 iabd supergroup     251875 2023-01-29 12:23 /user/iabd/delta/raw/clientes/part-00000-05cb7b9c-c529-4f5e-83ab-0dc79d0422bf-c000.snappy.parquet\n-rw-r--r--   3 iabd supergroup     251875 2023-01-29 12:29 /user/iabd/delta/raw/clientes/part-00000-1f226209-881f-4ff7-af04-6eedd64e1581-c000.snappy.parquet\n</code></pre> <p>Ahora vamos a a\u00f1adir nuevos datos, utilizando un nuevo dataframe e indicando el modo de escritura con <code>append</code>:</p> <pre><code>cols = ['customer_id', 'customer_fname', 'customer_lname']\ndatos = [\n(88888, \"Aitor\", \"Medrano\"), \n(99999, \"Pedro\", \"Casas\")\n]\nnuevosClientes = spark.createDataFrame(datos, cols)\n# cambiamos el tipo a int pq por defecto le asigna long\nnuevosClientes = nuevosClientes.withColumn(\"customer_id\", nuevosClientes.customer_id.cast(\"int\"))\nnuevosClientes.write.format(\"delta\").mode(\"append\").save(\"hdfs://iabd-virtualbox:9000/user/iabd/delta/raw/clientes\")\n</code></pre> <p>Fusionando el esquema</p> <p>Si los tipos de los datos no cuadran con el esquema almacenado en DeltaLake, tendremos un error. Para habilitar que fusione los esquemas podemos indicarlo con <code>.option(\"mergeSchema\", \"true\")</code>:</p> <pre><code>nuevosClientes.write.format(\"delta\").mode(\"append\").option(\"mergeSchema\", \"true\").save(\"hdfs://iabd-virtualbox:9000/user/iabd/delta/raw/clientes\")\n</code></pre> <p>Ahora podemos ver como ha creado un nuevo archivo de log pero dos archivos de datos. En concreto, el archivo de log ha registrado las dos inserciones, y cada archivo de Parquet contiene \u00fanicamente cada uno de los registros:</p> <pre><code>iabd@iabd-virtualbox:~/datos$ hdfs dfs -ls -R /user/iabd/delta/raw/clientes\ndrwxr-xr-x   - iabd supergroup          0 2023-01-29 12:39 /user/iabd/delta/raw/clientes/_delta_log\n-rw-r--r--   1 iabd supergroup       2605 2023-01-29 12:23 /user/iabd/delta/raw/clientes/_delta_log/00000000000000000000.json\n-rw-r--r--   1 iabd supergroup       1592 2023-01-29 12:29 /user/iabd/delta/raw/clientes/_delta_log/00000000000000000001.json\n-rw-r--r--   1 iabd supergroup       1309 2023-01-29 12:39 /user/iabd/delta/raw/clientes/_delta_log/00000000000000000002.json\n-rw-r--r--   3 iabd supergroup     251875 2023-01-29 12:23 /user/iabd/delta/raw/clientes/part-00000-05cb7b9c-c529-4f5e-83ab-0dc79d0422bf-c000.snappy.parquet\n-rw-r--r--   3 iabd supergroup     251875 2023-01-29 12:29 /user/iabd/delta/raw/clientes/part-00000-1f226209-881f-4ff7-af04-6eedd64e1581-c000.snappy.parquet\n-rw-r--r--   3 iabd supergroup       1035 2023-01-29 12:39 /user/iabd/delta/raw/clientes/part-00000-b7124036-ce26-4b95-a759-080e829b8de6-c000.snappy.parquet\n-rw-r--r--   3 iabd supergroup       1020 2023-01-29 12:39 /user/iabd/delta/raw/clientes/part-00001-6164f53a-ca34-4b73-96ef-8d2f2cfbbb47-c000.snappy.parquet\n</code></pre> <p>Por ejemplo, si descargamos y visualizamos uno de los archivos de Parquet veremos sus datos:</p> <pre><code>iabd@iabd-virtualbox:~/Descargas$ parquet-tools show part-00000-b7124036-ce26-4b95-a759-080e829b8de6-c000.snappy.parquet +---------------+------------------+------------------+\n|   customer_id | customer_fname   | customer_lname   |\n|---------------+------------------+------------------|\n|         88888 | Aitor            | Medrano          |\n+---------------+------------------+------------------+\n</code></pre> <p>Finalmente, si queremos comprobar los datos, a partir del dataframe que hab\u00edamos le\u00eddo desde HDFS, podemos comprobar como los datos ya aparecen:</p> <pre><code>dfdeltahdfs.sort(\"customer_id\", ascending=False).show(3)\n# +-----------+--------------+--------------+--------------+-----------------+----------------+-------------+--------------+----------------+\n# |customer_id|customer_fname|customer_lname|customer_email|customer_password| customer_street|customer_city|customer_state|customer_zipcode|\n# +-----------+--------------+--------------+--------------+-----------------+----------------+-------------+--------------+----------------+\n# |      99999|         Pedro|         Casas|          null|             null|            null|         null|          null|            null|\n# |      88888|         Aitor|       Medrano|          null|             null|            null|         null|          null|            null|\n# |      12435|         Laura|        Horton|     XXXXXXXXX|        XXXXXXXXX|5736 Honey Downs|  Summerville|            SC|           29483|\n# +-----------+--------------+--------------+--------------+-----------------+----------------+-------------+--------------+----------------+\n# only showing top 3 rows\n</code></pre>"},{"location":"spark/02catalog.html#trabajando-con-tablas-delta","title":"Trabajando con tablas Delta","text":"<p>Para trabajar con tablas Delta, aunque podemos realizar todas las operaciones mediante SQL, Delta Lake ofrece un API para realizar modificaciones condicionales, borrados o upserts de datos en las tablas.</p> <p>Para ello, el primer paso obtener una tabla delta mediante el m\u00e9todo <code>DeltaTable.forPath</code>:</p> <pre><code>from delta.tables import *\ndtabla = DeltaTable.forPath(spark, \"hdfs://iabd-virtualbox:9000/user/iabd/delta/raw/clientes\")\n</code></pre> <p>Una vez tenemos la tabla, ya podemos, por ejemplo, modificar las ciudades haciendo uso del m\u00e9todo <code>update(condici\u00f3n, valor)</code>:</p> <pre><code>dtabla.update(\"customer_city = 'Bruklyn'\",  {\"customer_city\": \"'Brooklyn'\"})\n</code></pre> <p>O borrar los clientes de <code>Brownsville</code>, mediante el m\u00e9todo <code>delete(condici\u00f3n)</code>:</p> <pre><code>dtabla.delete(\"customer_city = 'Brownsville'\"})\n# borramos los \u00faltimos clientes insertados\ndtabla.delete(\"customer_id &gt; 33333\")\n</code></pre>"},{"location":"spark/02catalog.html#viajando-en-el-tiempo","title":"Viajando en el tiempo","text":"<p>Podemos realizar consultas sobre snapshots de nuestras tablas delta mediante el time travel.</p> <p>Si queremos acceder a datos que hemos sobrescrito, podemos viajar al pasado de la tabla antes de que se sobrescribieran los datos mediante la opci\u00f3n <code>versionAsOf</code>:</p> <pre><code>df = spark.read.format(\"delta\").option(\"versionAsOf\", 0).load(\"hdfs://iabd-virtualbox:9000/user/iabd/delta/raw/clientes\")\ndf.show()\n</code></pre> <p>Si comprobamos los datos, veremos que tenemos los datos iniciales tras realizar la carga de los datos.</p>"},{"location":"spark/02catalog.html#referencias","title":"Referencias","text":"<ul> <li>Modern Data Engineering with Apache Spark - Scott Haines - Apress</li> <li>Construir data lakes fiables con Delta Lake - Carlos del Cacho</li> <li>Delta Lake: Up and Running - Bennie Haelen - O'Reilly</li> <li>Delta Lake: High-Performance ACID Table Storage over Cloud Object Stores</li> </ul>"},{"location":"spark/02catalog.html#actividades","title":"Actividades","text":"<p>(RA5074.1 / CE4.1b y CE4.1d) En las siguientes actividades vamos a familiarizarnos con el uso del API de Spark JDBC, el acceso al cat\u00e1logo y DeltaLake.</p> <ol> <li>(1p) Vamos a repetir una actividad que realizamos durante la sesi\u00f3n de Hive. Para ello, se pide recuperar desde la base de datos <code>retail_db</code> las tablas <code>customers</code> y <code>orders</code> en dos dataframes tal como hemos hecho en el apartado Leyendo Datos, y a continuaci\u00f3n, realizar un join de manera que contenga la informaci\u00f3n de cada pedido y la ciudad del cliente.</li> <li>(1p) Sobre el dataframe anterior, en la base de datos <code>iabd</code>, crea una tabla gestionada en el cat\u00e1logo cuyo nombre sea <code>pedidos_ciudad</code>, y a\u00f1ade comentarios tanto a a la tabla como a sus columnas.</li> <li>(1p) A partir de los ejercicios 3 y 4 de la sesi\u00f3n anterior donde tras consumir unos datos de ventas, realiz\u00e1bamos una limpieza de los datos, renombr\u00e1bamos columnas y posteriormente una serie de agregaciones para visualizar en gr\u00e1ficos el resultado, se pide crear tantas tablas en Delta Lake como consideres, siguiendo la arquitectura Medallion, utilizando una nomenclatura adecuada.</li> <li>(1p) Tras una auditoria, hemos descubierto que hab\u00eda un libro oculto de contabilidad con ciertas ventas que no hab\u00edan sido registradas en el sistema. As\u00ed pues, crea datos ficticios extra de ventas para el a\u00f1o 2019, col\u00f3calo en la capa raw, y a continuaci\u00f3n, actualiza los datos del resto de tablas.</li> </ol>"},{"location":"spark/02dataframeAPI.html","title":"Spark DataFrames / SQL","text":"<p>En la sesiones anteriores hemos introducido Spark y el uso de RDD para interactuar con los datos. Tal como comentamos, los RDD permiten trabajar a bajo nivel, siendo m\u00e1s c\u00f3modo y eficiente hacer uso de DataFrames y el lenguaje SQL.</p>"},{"location":"spark/02dataframeAPI.html#dataframes","title":"DataFrames","text":"<p>Un DataFrame es una estructura equivalente a una tabla de base de datos relacional, con un motor bien optimizado para el trabajo en un cl\u00faster. Los datos se almacenan en filas y columnas y ofrece un conjunto de operaciones para manipular los datos.</p> <p>El trabajo con DataFrames es m\u00e1s sencillo y eficiente que el procesamiento con RDD, por eso su uso es predominante en los nuevos desarrollos con Spark.</p> <p>A continuaci\u00f3n veremos c\u00f3mo podemos obtener y persistir DataFrames desde diferentes fuentes y formatos de datos</p>"},{"location":"spark/02dataframeAPI.html#creando-dataframes","title":"Creando Dataframes","text":"<p>El caso m\u00e1s b\u00e1sico es crear un DataFrame a partir de un RDD mediante <code>toDF</code>:</p> <pre><code>from pyspark.sql import SparkSession\nspark = SparkSession.builder.getOrCreate() # SparkSession de forma programativa\n# Creamos un RDD\ndatos = [(\"Aitor\", 182), (\"Pedro\", 178), (\"Marina\", 161)]\nrdd = spark.sparkContext.parallelize(datos)\n# Creamos un DataFrame y mostramos su esquema\ndfRDD = rdd.toDF()\ndfRDD.printSchema()\n</code></pre> <p>Y mediante <code>printSchema</code> obtenemos un resumen del esquema del DataFrame , donde para cada columna se indica el nombre, el tipo y si admite valores nulos:</p> <pre><code>root\n |-- _1: string (nullable = true)\n |-- _2: long (nullable = true)\n</code></pre> <p>Podemos ver como los nombres de las columnas son <code>_1</code> y <code>_2</code>. Para asignarle un nombre adecuado podemos pasarle una lista con los nombres a la hora de crear el DataFrame:</p> <pre><code>columnas = [\"nombre\",\"altura\"]\ndfRDD = rdd.toDF(columnas)\ndfRDD.printSchema()\n</code></pre> <p>Y ahora obtenemos:</p> <pre><code>root\n |-- nombre: string (nullable = true)\n |-- altura: long (nullable = true)\n</code></pre> <p>Si queremos mostrar sus datos, haremos uso del m\u00e9todo <code>show</code>:</p> <pre><code>df.show()\n</code></pre> <p>Obteniendo una vista de los datos en forma de tabla:</p> <pre><code>+------+------+\n|nombre|altura|\n+------+------+\n| Aitor|   182|\n| Pedro|   178|\n|Marina|   161|\n+------+------+\n</code></pre> <p>Tambi\u00e9n podemos crear un DataFrame directamente desde una SparkSession sin crear un RDD previamente mediante el m\u00e9todo <code>createDataFrame</code>:</p> <pre><code># Tambi\u00e9n podemos crear un DF desde SparkSession\ndfDesdeDatos = spark.createDataFrame(datos).toDF(*columnas)\ndfDesdeDatos.printSchema()\n</code></pre>"},{"location":"spark/02dataframeAPI.html#mostrando-los-datos","title":"Mostrando los datos","text":"<p>Para los siguientes apartados, supongamos que queremos almacenar ciertos datos de clientes, como son su nombre y apellidos, ciudad y sueldo:</p> <pre><code>clientes = [\n(\"Aitor\", \"Medrano\", \"Elche\", 3000),\n(\"Pedro\", \"Casas\", \"Elche\", 4000),\n(\"Laura\", \"Garc\u00eda\", \"Elche\", 5000), \n(\"Miguel\", \"Ruiz\", \"Torrellano\", 6000),\n(\"Isabel\", \"Guill\u00e9n\", \"Alicante\", 7000)\n]\ncolumnas = [\"nombre\",\"apellidos\", \"ciudad\", \"sueldo\"]\ndf = spark.createDataFrame(clientes, columnas)\n</code></pre> <p>Para mostrar los datos, ya hemos visto que podemos utilizar el m\u00e9todo <code>show</code>, al cual le podemos indicar o no la cantidad de registros a recuperar, as\u00ed como si queremos que los datos se trunquen o no, o si los queremos mostrar en vertical:</p> <pre><code>df.show(2)\n# +------+---------+------+------+\n# |nombre|apellidos|ciudad|sueldo|\n#\u00a0+------+---------+------+------+\n# | Aitor|  Medrano| Elche|  3000|\n# | Pedro|    Casas| Elche|  4000|\n# +------+---------+------+------+\n# only showing top 2 rows\ndf.show(truncate=False)\n# +------+---------+----------+------+\n# |nombre|apellidos|ciudad    |sueldo|\n# +------+---------+----------+------+\n# |Aitor |Medrano  |Elche     |3000  |\n# |Pedro |Casas    |Elche     |4000  |\n# |Laura |Garc\u00eda   |Elche     |5000  |\n# |Miguel|Ruiz     |Torrellano|6000  |\n# |Isabel|Guill\u00e9n  |Alicante  |7000  |\n# +------+---------+----------+------+\ndf.show(3, vertical=True)\n# -RECORD 0------------\n#  nombre    | Aitor   \n#  apellidos | Medrano \n#  ciudad    | Elche   \n#  sueldo    | 3000    \n# -RECORD 1------------\n#  nombre    | Pedro   \n#  apellidos | Casas   \n#  ciudad    | Elche   \n#  sueldo    | 4000    \n# -RECORD 2------------\n#  nombre    | Laura   \n#  apellidos | Garc\u00eda  \n#  ciudad    | Elche   \n#  sueldo    | 5000    \n# only showing top 3 rows\n</code></pre> <p>Si s\u00f3lo queremos recuperar unos pocos datos, podemos hacer uso de head o first los cuales devuelven objetos Row:</p> <pre><code>df.first()\n# Row(nombre='Aitor', apellidos='Medrano', ciudad='Elche', sueldo=3000)\ndf.head()\n# Row(nombre='Aitor', apellidos='Medrano', ciudad='Elche', sueldo=3000)\ndf.head(3)\n# [Row(nombre='Aitor', apellidos='Medrano', ciudad='Elche', sueldo=3000),\n#  Row(nombre='Pedro', apellidos='Casas', ciudad='Elche', sueldo=4000),\n#  Row(nombre='Laura', apellidos='Garc\u00eda', ciudad='Elche', sueldo=5000)]\n</code></pre> <p>Si queremos obtener un valor en concreto, una vez recuperada una fila, podemos acceder a sus columnas:</p> <pre><code>nom1 = df.first()[0]           # 'Aitor'\nnom2 = df.first()[\"nombre\"]    # 'Aitor'\n</code></pre> <p>Tambi\u00e9n podemos obtener un sumario de los datos (igual que con Pandas) mediante describe:</p> <pre><code>df.describe().show()\n# +-------+------+---------+----------+------------------+\n# |summary|nombre|apellidos|    ciudad|            sueldo|\n# +-------+------+---------+----------+------------------+\n# |  count|     5|        5|         5|                 5|\n# |   mean|  null|     null|      null|            5000.0|\n# | stddev|  null|     null|      null|1581.1388300841897|\n# |    min| Aitor|    Casas|  Alicante|              3000|\n# |    max| Pedro|     Ruiz|Torrellano|              7000|\n# +-------+------+---------+----------+------------------+\n</code></pre> <p>Si \u00fanicamente nos interesa saber cuantas filas tiene nuestro DataFrame, podemos hacer uso de count:</p> <pre><code>df.count()  # 5\n</code></pre> <p>Por \u00faltimo, como un DataFrame por debajo es un RDD, podemos usar <code>collect</code> y <code>take</code> conforme necesitemos y recuperar objetos de tipo Row:</p> <pre><code>df.collect()\n# [Row(nombre='Aitor', apellidos='Medrano', ciudad='Elche', sueldo=3000),\n#  Row(nombre='Pedro', apellidos='Casas', ciudad='Elche', sueldo=4000),\n#  Row(nombre='Laura', apellidos='Garc\u00eda', ciudad='Elche', sueldo=5000),\n#  Row(nombre='Miguel', apellidos='Ruiz', ciudad='Torrellano', sueldo=6000),\n#  Row(nombre='Isabel', apellidos='Guill\u00e9n', ciudad='Alicante', sueldo=7000)]\ndf.take(2)\n# [Row(nombre='Aitor', apellidos='Medrano', ciudad='Elche', sueldo=3000),\n#  Row(nombre='Pedro', apellidos='Casas', ciudad='Elche', sueldo=4000)]\nnom = df.collect()[0][0]        # 'Aitor'\n</code></pre>"},{"location":"spark/02dataframeAPI.html#cargando-diferentes-formatos","title":"Cargando diferentes formatos","text":"<p>Lo m\u00e1s usual es cargar los datos desde una archivo externo. Para ello, mediante el API de <code>DataFrameReader</code> cargaremos los datos directamente en un Dataframe mediante diferentes m\u00e9todos dependiendo del formato (admite tanto el nombre de un recurso como una ruta de una carpeta).</p> <p>Para cada formato, existe un m\u00e9todo corto que se llama como el formato en s\u00ed, y un m\u00e9todo general donde mediante <code>format</code> indicamos el formato y que finaliza con el m\u00e9todo <code>load</code> siempre dentro de <code>spark.read</code>:</p> CSVTXTJSONParquet <pre><code>dfCSV = spark.read.csv(\"datos.csv\")\ndfCSV = spark.read.csv(\"datos/*.csv\")   # Una carpeta entera\ndfCSV = spark.read.option(\"sep\", \";\").csv(\"datos.csv\")\ndfCSV = spark.read.option(\"header\", \"true\").csv(\"datos.csv\")\ndfCSV = spark.read.option(\"header\", True).option(\"inferSchema\", True).csv(\"datos.csv\")\ndfCSV = spark.read.options(sep=\";\", header=True, inferSchema=True).csv(\"pdi_sales.csv\")\ndfCSV = spark.read.format(\"csv\").load(\"datos.csv\") \ndfCSV = spark.read.load(path=\"datos.csv\", format=\"csv\", header=\"true\", sep=\";\", inferSchema=\"true\")\n</code></pre> <p>M\u00e1s informaci\u00f3n en la documentaci\u00f3n oficial</p> <pre><code>dfTXT = spark.read.text(\"datos.txt\")\n# cada fichero se lee entero como un registro\ndfTXT = spark.read.option(\"wholetext\", true).text(\"datos/\")\ndfTXT = spark.read.format(\"txt\").load(\"datos.txt\")\n</code></pre> <p>M\u00e1s informaci\u00f3n en la documentaci\u00f3n oficial</p> <pre><code>dfJSON = spark.read.json(\"datos.json\")\ndfJSON = spark.read.format(\"json\").load(\"datos.json\")\n</code></pre> <p>M\u00e1s informaci\u00f3n en la documentaci\u00f3n oficial</p> <p>DataFrames desde JSON</p> <p>Spark espera que cada documento JSON ocupe una \u00fanica l\u00ednea. Si cada documento ocupa m\u00e1s de una l\u00ednea, se lo indicamos mediante la opci\u00f3n <code>multiline</code>:</p> <pre><code>df = spark.read.option(\"multiline\",True).option(\"inferSchema\", \"true\").json(\"datos.json\")\n</code></pre> <pre><code>dfParquet = spark.read.parquet(\"datos.parquet\")\ndfParquet = spark.read.format(\"parquet\").load(\"datos.parquet\")\n</code></pre> <p>M\u00e1s informaci\u00f3n en la documentaci\u00f3n oficial</p> <p>Avro</p> <p>La fuente de datos en formato Avro se incluye como un m\u00f3dulo externo, y por lo tanto, para poder leer o escribir datos en dicho formato, previamente hemos de cargar una librer\u00eda.</p> <p>Para ello, al arrancar PySpark, le pasaremos como par\u00e1metro <code>--packages org.apache.spark:spark-avro_2.12:3.3.1</code>:</p> <pre><code>pyspark --packages org.apache.spark:spark-avro_2.12:3.3.1\n</code></pre> <p>Una vez arrancado, ya podemos leer y escribir datos en formato Avro de forma similar al resto:</p> <pre><code>df = spark.read.format(\"avro\").load(\"datos.avro\")\ndf.write.format(\"avro\").save(\"archivo.avro\")\n</code></pre> <p>La librer\u00eda tambi\u00e9n nos permite convertir columnas y estructuras de datos con las operaciones <code>to_avro()</code> y <code>from_avro()</code>. M\u00e1s informaci\u00f3n en la documentaci\u00f3n oficial.</p>"},{"location":"spark/02dataframeAPI.html#persistiendo-diferentes-formatos","title":"Persistiendo diferentes formatos","text":"<p>Si lo que queremos es persistir los datos, en vez de <code>read</code>, utilizaremos <code>write</code> (de manera que obtenemos un <code>DataFrameWriter</code>) y si usamos la forma general usaremos el m\u00e9todo <code>save</code>:</p> CSVTXTJSONParquet <pre><code>dfCSV.write.csv(\"datos.csv\")\ndfCSV.write.format(\"csv\").save(\"datos.csv\")\ndfCSV.write.format(\"csv\").mode(\"overwrite\").save(\"datos.csv\")\n</code></pre> <p>M\u00e1s informaci\u00f3n en la documentaci\u00f3n oficial</p> <pre><code>dfTXT.write.text(\"datos.txt\")\ndfTXT.write.option(\"lineSep\",\";\").text(\"datos.txt\")\ndfTXT.write.format(\"txt\").save(\"datos.txt\")\n</code></pre> <p>M\u00e1s informaci\u00f3n en la documentaci\u00f3n oficial</p> <pre><code>dfJSON.write.json(\"datos.json\")\ndfJSON.write.format(\"json\").save(\"datos.json\")\n</code></pre> <p>M\u00e1s informaci\u00f3n en la documentaci\u00f3n oficial</p> <pre><code>dfParquet.write.parquet(\"datos.parquet\")\ndfParquet.write.mode(\"overwrite\").partitionBy(\"fecha\").parquet(\"datos/\")\ndfParquet.write.format(\"parquet\").save(\"datos.parquet\")\n</code></pre> <p>M\u00e1s informaci\u00f3n en la documentaci\u00f3n oficial</p> <p>Un \u00fanico archivo de salida</p> <p>Por cada partici\u00f3n, Spark generar\u00e1 un archivo de salida. Recuerda que podemos reducir el n\u00famero de particiones mediante coalesce o repartition.</p> <p>Una vez vista la sintaxis, vamos a ver un ejemplo completo de lectura de un archivo CSV (el archivo <code>pdi_sales.csv</code> que hemos utilizado durante todo el curso) que est\u00e1 almacenado en HDFS y que tras leerlo, lo guardamos como JSON de nuevo en HDFS:</p> <pre><code>from pyspark.sql import SparkSession\nspark = SparkSession.builder.appName(\"s8a-dataframe-csv\").getOrCreate()\n# Lectura de CSV con el ; como separador de columnas y con encabezado\ndf = spark.read.option(\"delimiter\",\";\").option(\"header\", \"true\").csv(\"hdfs://iabd-virtualbox:9000/user/iabd/pdi_sales.csv\")\n# df.printSchema()\ndf.write.json(\"hdfs://iabd-virtualbox:9000/user/iabd/pdi_sales_json\")\n</code></pre> <p>Es conveniente destacar que para acceder a HDFS, \u00fanicamente hemos de indicar la URL del recurso con el prefijo <code>hdfs://</code> m\u00e1s el host del namenode.</p>"},{"location":"spark/02dataframeAPI.html#comprimiendo-los-datos","title":"Comprimiendo los datos","text":"<p>Para configurar el algoritmo de compresi\u00f3n, si los datos est\u00e1 en Parquet o Avro, a nivel de la sesi\u00f3n de Spark, podemos realizar su configuraci\u00f3n:</p> <pre><code>spark.setConf(\"spark.sql.parquet.compression.codec\",\"snappy\")\nspark.setConf(\"spark.sql.parquet.compression.codec\",\"none\")\nspark.setConf(\"spark.sql.avro.compression.codec\",\"snappy\")\n</code></pre> <p>Si s\u00f3lo queremos hacerlo para una operaci\u00f3n en particular, para cada lectura/escritura le a\u00f1adimos <code>.option(\"compression\", \"algoritmo\")</code>. Por ejemplo:</p> <pre><code>dfVentas = spark.read.option(\"compression\", \"snappy\").option(\"delimiter\",\";\").option(\"header\", \"true\").csv(\"pdi_sales.csv\")\ndfClientes = spark.read.option(\"compression\", \"snappy\").parquet(\"clientes.parquet\")\ndfVentas.write.option(\"compression\", \"snappy\").format(\"avro\").save(\"ventas.avro\")\n</code></pre>"},{"location":"spark/02dataframeAPI.html#datos-y-esquemas","title":"Datos y Esquemas","text":"<p>El esquema completo de un DataFrame se modela mediante un <code>StructType</code>, el cual contiene una colecci\u00f3n de objetos <code>StructField</code>. As\u00ed pues, cada columna de un DataFrame de Spark se modela mediante un objeto <code>StructField</code> indicando su nombre, tipo y gesti\u00f3n de los nulos.</p> <p>Hemos visto que al crear un DataFrame desde un archivo externo, podemos inferir el esquema. Si queremos crear un DataFrame desde un esquema propio utilizaremos los tipos <code>StructType</code>, <code>StructField</code>, as\u00ed como <code>StringType</code>, <code>IntegerType</code> o el tipo necesario para cada columna. Para ello, primero hemos de importarlos (como puedes observar, estas clases pertenecen a las librer\u00edas SQL de PySpark):</p> <pre><code>from pyspark.sql import SparkSession\nfrom pyspark.sql.types import StructType, StructField, StringType, IntegerType\n</code></pre> <p>Tipos</p> <p>Adem\u00e1s de cadenas y enteros, flotantes (<code>FloatType</code>) o dobles (<code>DoubleType</code>), tenemos tipos booleanos (<code>BooleanType</code>), de fecha (<code>DateType</code> y <code>TimestampType</code>), as\u00ed como tipos complejos como <code>ArrayType</code>, <code>MapType</code> y <code>StructType</code>. Para m\u00e1s informaci\u00f3n, consultar la documentaci\u00f3n oficial.</p> <p>Volvamos al ejemplo anterior donde tenemos ciertos datos de clientes, como son su nombre y apellidos, ciudad y sueldo:</p> <pre><code>clientes = [\n(\"Aitor\", \"Medrano\", \"Elche\", 3000),\n(\"Pedro\", \"Casas\", \"Elche\", 4000),\n(\"Laura\", \"Garc\u00eda\", \"Elche\", 5000), \n(\"Miguel\", \"Ruiz\", \"Torrellano\", 6000),\n(\"Isabel\", \"Guill\u00e9n\", \"Alicante\", 7000)\n]\n</code></pre> <p>Para esta estructura, definiremos un esquema con los campos, indicando para cada uno de ellos su nombre, tipo y si admite valores nulos:</p> <pre><code>esquema = StructType([\nStructField(\"nombre\", StringType(), False),\nStructField(\"apellidos\", StringType(), False),\nStructField(\"ciudad\", StringType(), True),\nStructField(\"sueldo\", IntegerType(), False)\n])\n</code></pre> <p>A continuaci\u00f3n ya podemos crear un DataFrame con datos propios que cumplen un esquema haciendo uso del m\u00e9todo <code>createDataFrame</code>:</p> <pre><code>df = spark.createDataFrame(data=clientes, schema=esquema)\ndf.printSchema()\n# root\n#  |-- nombre: string (nullable = false)\n#  |-- apellidos: string (nullable = false)\n#  |-- ciudad: string (nullable = true)\n#  |-- sueldo: integer (nullable = false)\ndf.show(truncate=False)\n# +------+---------+----------+------+\n# |nombre|apellidos|ciudad    |sueldo|\n# +------+---------+----------+------+\n# |Aitor |Medrano  |Elche     |3000  |\n# |Pedro |Casas    |Elche     |4000  |\n# |Laura |Garc\u00eda   |Elche     |5000  |\n# |Miguel|Ruiz     |Torrellano|6000  |\n# |Isabel|Guill\u00e9n  |Alicante  |7000  |\n# +------+---------+----------+------+\n</code></pre> <p>Si lo que queremos es asignarle un esquema a un DataFrame que vamos a leer desde una fuente de datos externa, hemos de emplear el m\u00e9todo <code>schema</code>:</p> <pre><code>dfClientes = spark.read.option(\"header\", True).schema(esquema).csv(\"clientes.csv\")\n</code></pre> <p>Rendimiento y esquema</p> <p>La inferencia de los tipos de los datos es un proceso computacionalmente costoso. Por ello, si nuestro conjunto de datos es grande, es muy recomendable crear el esquema de forma programativa y configurarlo en la carga de datos.</p> <p>Se recomienda la lectura del art\u00edculo Using schemas to speed up reading into Spark DataFrames.</p> <p>Respecto al esquema, tenemos diferentes propiedades como <code>columns</code>, <code>dtypes</code> y <code>schema</code> con las que obtener su informaci\u00f3n:</p> <pre><code>df.columns\n# ['nombre', 'apellidos', 'ciudad', 'sueldo']\ndf.dtypes\n# [('nombre', 'string'),\n#  ('apellidos', 'string'),\n#  ('ciudad', 'string'),\n#  ('sueldo', 'int')]\ndf.schema\n# StructType(List(StructField(nombre,StringType,false),StructField(apellidos,StringType,false),StructField(ciudad,StringType,true),StructField(sueldo,IntegerType,false)))\n</code></pre> <p>Si una vez hemos cargado un DataFrame queremos cambiar el tipo de una de sus columnas, podemos hacer uso del m\u00e9todo <code>withColumn</code>:</p> <pre><code># Forma larga\nfrom pyspark.sql.types import DoubleType\ndf = df.withColumn(\"sueldo\", df.sueldo.cast(DoubleType())\n# Forma corta\ndf = df.withColumn(\"sueldo\", df.sueldo.cast(\"double\"))\n# df = df.withColumn(\"fnac\", to_date(df.Date, \"M/d/yyy\"))\n</code></pre> <p>Errores al leer datos</p> <p>Si tenemos un error al leer un dato que contiene un tipo no esperado, por defecto, Spark lanzar\u00e1 una excepci\u00f3n y se detendr\u00e1 la lectura.</p> <p>Si queremos que asigne los tipos a los campos pero que no los valide, podemos pasarle el par\u00e1metro extra <code>verifySchema</code> a <code>False</code> al crear un DataFrame mediante spark.createDataFrame o <code>enforceSchema</code> tambi\u00e9n a <code>False</code> al cargar desde una fuente externa mediante <code>spark.read</code>, de manera que los datos que no concuerden con el tipo se quedar\u00e1n nulos, vac\u00edos o con valor 0, dependiendo del tipo de dato que tiene asignada la columna en el esquema.</p> <pre><code>dfClientes = spark.read.option(\"header\", True).option(\"enforceSchema\",False).schema(esquema).csv(\"clientes.csv\")\n</code></pre>"},{"location":"spark/02dataframeAPI.html#dataframe-api","title":"DataFrame API","text":"<p>Una vez tenemos un DataFrame podemos trabajar con los datos mediante un conjunto de operaciones estructuradas, muy similares al lenguaje relacional. Estas operaciones tambi\u00e9n se clasifican en transformaciones y acciones, recordando que las transformaciones utilizan una evaluaci\u00f3n perezosa.</p> <p>Es muy importante tener en cuenta que todas las operaciones que vamos a realizar a continuaci\u00f3n son immutables, es decir, nunca van a modificar el DataFrame sobre el que realizamos la transformaci\u00f3n. As\u00ed pues, realizaremos encadenamiento de transformaciones (transformation chaining) o asignaremos el resultado a un nuevo DataFrame.</p> <p>Preparaci\u00f3n</p> <p>Para los siguientes apartados, vamos a trabajar sobre el siguiente DataFrame con el fichero de ventas que hemos utilizado a lo largo del curso:</p> <pre><code>from pyspark.sql import SparkSession\nspark = SparkSession.builder.appName(\"s8a-dataframes-api\").getOrCreate()\n# Lectura de CSV con el ; como separador de columnas y con encabezado\ndf = spark.read.option(\"sep\",\";\").option(\"header\", \"true\").option(\"inferSchema\", \"true\").csv(\"pdi_sales_small.csv\")\ndf.printSchema()\n</code></pre> <p>El esquema generado es:</p> <pre><code>root\n|-- ProductID: integer (nullable = true)\n|-- Date: string (nullable = true)\n|-- Zip: string (nullable = true)\n|-- Units: integer (nullable = true)\n|-- Revenue: double (nullable = true)\n|-- Country: string (nullable = true)\n</code></pre>"},{"location":"spark/02dataframeAPI.html#proyectando","title":"Proyectando","text":"<p>La operaci\u00f3n select permite indicar las columnas a recuperar pas\u00e1ndolas como par\u00e1metros:</p> Consulta de columnasResultado <pre><code>df.select(\"ProductID\",\"Revenue\").show(3)\n</code></pre> <pre><code>+---------+-------+\n|ProductID|Revenue|\n+---------+-------+\n|      725|  115.5|\n|      787|  314.9|\n|      788|  314.9|\n+---------+-------+\nonly showing top 3 rows\n</code></pre> <p>Tambi\u00e9n podemos realizar c\u00e1lculos (referenciando a los campos con <code>nombreDataframe.nombreColumna</code>) sobre las columnas y crear un alias (operaci\u00f3n asociada a un campo):</p> C\u00e1lculos y creaci\u00f3n de aliasResultado <pre><code>df.select(df.ProductID,(df.Revenue+10).alias(\"VentasMas10\")).show(3)\n</code></pre> <pre><code>+---------+-----------+\n|ProductID|VentasMas10|\n+---------+-----------+\n|      725|      125.5|\n|      787|      324.9|\n|      788|      324.9|\n+---------+-----------+\nonly showing top 3 rows\n</code></pre> <p>Si tenemos un DataFrame con un gran n\u00famero de columnas y queremos recuperarlas todas a excepci\u00f3n de unas pocas, es m\u00e1s c\u00f3modo utilizar la transformaci\u00f3n drop, la cual funciona de manera opuesta a <code>select</code>, es decir, indicando las columnas que queremos quitar del resultado:</p> <pre><code># Obtenemos el mismo resultado\ndf.select(\"ProductID\", \"Date\", \"Zip\")\ndf.drop(\"Units\", \"Revenue\", \"Country\")\n</code></pre>"},{"location":"spark/02dataframeAPI.html#trabajando-con-columnas","title":"Trabajando con columnas","text":"<p>Para acceder a las columnas, debemos crear objetos Column. Para ello, podemos seleccionarlos a partir de un DataFrame como una propiedad o mediante la funci\u00f3n col:</p> <pre><code>nomCliente = df.nombre\nnomCliente = df[\"ProductID\"]\nnomCliente = col(\"ProductID\")\n</code></pre> <p>As\u00ed pues, podemos recuperar ciertas columnas de un DataFrame con cualquier de las siguientes expresiones:</p> <pre><code>from pyspark.sql.functions import col\ndf.select(\"ProductID\", \"Revenue\").show()\ndf.select(df.ProductID, df.Revenue).show()\ndf.select(df[\"ProductID\"], df[\"Revenue\"]).show()\ndf.select(col(\"ProductID\"), col(\"Revenue\")).show()\n</code></pre>"},{"location":"spark/02dataframeAPI.html#col-vs-expr","title":"col vs expr","text":"<p>En ocasiones se confunde el uso de la funci\u00f3n <code>col</code> con <code>expr</code>. Aunque podemos referenciar a una columna haciendo uso de <code>expr</code>, su uso provoca que se parse\u00e9 la cadena recibida para interpretarla.</p> <p>Para el siguiente ejemplo, supongamos que tenemos un DataFrame con datos de clientes. Utilizaremos tambi\u00e9n la funci\u00f3n concat_ws para concatenar textos utilizado un separador.</p> <pre><code>from pyspark.sql.functions import col,expr\ndf.select(concat_ws(\" \", col(\"nombre\"), col(\"apellidos\")).alias(\"nombreCompleto\"),\n\"sueldo\",\n(col(\"sueldo\")*1.1).alias(\"nuevoSueldo\")).show() \ndf.select(concat_ws(\" \", col(\"nombre\"), col(\"apellidos\")).alias(\"nombreCompleto\"),\n\"sueldo\",\nexpr(\"sueldo*1.1\").alias(\"nuevoSueldo\")).show() \n</code></pre>"},{"location":"spark/02dataframeAPI.html#anadiendo-columnas","title":"A\u00f1adiendo columnas","text":"<p>Una vez tenemos un DataFrame, podemos a\u00f1adir columnas mediante el m\u00e9todo withColumn:</p> <pre><code>dfNuevo = df.withColumn(\"total\", df.Units * df.Revenue)\ndfNuevo.show()\n# +---------+----------+---------------+-----+-------+-------+------+\n# |ProductID|      Date|            Zip|Units|Revenue|Country| total|\n# +---------+----------+---------------+-----+-------+-------+------+\n# |      725|1999-01-15|41540          |    1|  115.5|Germany| 115.5|\n# |      787|2002-06-06|41540          |    1|  314.9|Germany| 314.9|\n# |      788|2002-06-06|41540          |    1|  314.9|Germany| 314.9|\n# |      901|1999-02-15|13587          |    2|  818.9|Germany|1637.8|\n# ...\n</code></pre> <p>withColumn</p> <p>Anteriormente hemos utilizado el m\u00e9todo withColumn para cambiarle el tipo a un campo ya existente. As\u00ed pues, si referenciamos a una columna que ya existe, en vez de crearla, la sustituir\u00e1.</p> <p>Otra forma de a\u00f1adir una columna con una expresi\u00f3n es mediante la transformaci\u00f3n <code>selectExpr</code>. Por ejemplo, podemos conseguir el mismo resultado que en el ejemplo anterior de la siguiente manera:</p> <pre><code>df.selectExpr(\"*\", \"Units * Revenue as total\").show()`\n# +---------+----------+---------------+-----+-------+-------+------+\n# |ProductID|      Date|            Zip|Units|Revenue|Country| total|\n# +---------+----------+---------------+-----+-------+-------+------+\n# |      725|1999-01-15|41540          |    1|  115.5|Germany| 115.5|\n# |      787|2002-06-06|41540          |    1|  314.9|Germany| 314.9|\n# |      788|2002-06-06|41540          |    1|  314.9|Germany| 314.9|\n# |      901|1999-02-15|13587          |    2|  818.9|Germany|1637.8|\n# ...\n</code></pre> <p>Aunque m\u00e1s adelante veremos como realizar transformaciones con agregaciones, mediante <code>selectExpr</code> tambi\u00e9n podemos realizar anal\u00edtica de datos aprovechando la potencia de SQL:</p> <pre><code>df.selectExpr(\"count(distinct(ProductID)) as productos\",\"count(distinct(Country)) as paises\").show()\n# +---------+------+\n# |productos|paises|\n# +---------+------+\n# |      799|     4|\n# +---------+------+\n</code></pre>"},{"location":"spark/02dataframeAPI.html#cambiando-el-nombre","title":"Cambiando el nombre","text":"<p>Si por alg\u00fan extra\u00f1o motivo necesitamos cambiarle el nombre a una columna (por ejemplo, vamos a unir dos DataFrames que tienen columnas con el mismo nombre pero en posiciones diferentes, o que al inferir el esquema tenga un nombre cr\u00edptico o demasiado largo y queremos que sea m\u00e1s legible) podemos utilizar la transformaci\u00f3n withColumnRenamed:</p> <pre><code>df.withColumnRenamed(\"Zip\", \"PostalCode\").show(5)\n# +---------+----------+---------------+-----+-------+-------+\n# |ProductID|      Date|     PostalCode|Units|Revenue|Country|\n# +---------+----------+---------------+-----+-------+-------+\n# |      725|1999-01-15|41540          |    1|  115.5|Germany|\n# |      787|2002-06-06|41540          |    1|  314.9|Germany|\n# |      788|2002-06-06|41540          |    1|  314.9|Germany|\n# |      940|1999-01-15|22587          |    1|  687.7|Germany|\n# |      396|1999-01-15|22587          |    1|  857.1|Germany|\n# +---------+----------+---------------+-----+-------+-------+\n# only showing top 5 rows\n</code></pre>"},{"location":"spark/02dataframeAPI.html#filtrando","title":"Filtrando","text":"<p>Si queremos eliminar filas, usaremos el m\u00e9todo filter:</p> <pre><code>df.filter(df.Country==\"Germany\").show()\n# +---------+----------+---------------+-----+-------+-------+\n# |ProductID|      Date|            Zip|Units|Revenue|Country|\n# +---------+----------+---------------+-----+-------+-------+\n# |      725|1999-01-15|41540          |    1|  115.5|Germany|\n# |      787|2002-06-06|41540          |    1|  314.9|Germany|\n# |      788|2002-06-06|41540          |    1|  314.9|Germany|\n# |      940|1999-01-15|22587          |    1|  687.7|Germany|\n</code></pre> <p>Por similitud con SQL, podemos utilizar tambi\u00e9n <code>where</code> como un alias de <code>filter</code>:</p> <pre><code>df.where(df.Units&gt;20).show()\n# +---------+----------+---------------+-----+-------+-------+\n# |ProductID|      Date|            Zip|Units|Revenue|Country|\n# +---------+----------+---------------+-----+-------+-------+\n# |      495|1999-03-15|75213 CEDEX 16 |   77|43194.1| France|\n# |     2091|1999-05-15|9739           |   24| 3652.7| Mexico|\n# |     2091|1999-06-15|40213          |   41| 6240.1|Germany|\n# |     2091|1999-10-15|40213          |   41| 6347.7|Germany|\n# |     2091|1999-12-15|40213          |   23| 3560.9|Germany|\n# +---------+----------+---------------+-----+-------+-------+\n</code></pre> <p>Podemos utilizar los operadores l\u00f3gicos (<code>&amp;</code> para conjunci\u00f3n y <code>|</code> para la disyunci\u00f3n) para crear condiciones compuestas (recordad rodear cada condici\u00f3n entre par\u00e9ntesis):</p> <pre><code>df.filter((df.Country==\"Germany\") &amp; (df.Units&gt;20)).show()\n# +---------+----------+---------------+-----+-------+-------+\n# |ProductID|      Date|            Zip|Units|Revenue|Country|\n# +---------+----------+---------------+-----+-------+-------+\n# |     2091|1999-06-15|40213          |   41| 6240.1|Germany|\n# |     2091|1999-10-15|40213          |   41| 6347.7|Germany|\n# |     2091|1999-12-15|40213          |   23| 3560.9|Germany|\n# +---------+----------+---------------+-----+-------+-------+\ndf.filter((df.ProductID==2314) | (df.ProductID==1322)).show()\n# +---------+----------+---------------+-----+-------+-------+\n# |ProductID|      Date|            Zip|Units|Revenue|Country|\n# +---------+----------+---------------+-----+-------+-------+\n# |     2314|1999-05-15|46045          |    1|   13.9|Germany|\n# |     1322|2000-01-06|75593 CEDEX 12 |    1|  254.5| France|\n# +---------+----------+---------------+-----+-------+-------+\n</code></pre> <p>Un caso particular de filtrado es la eliminaci\u00f3n de los registros repetidos, lo cual lo podemos hacer de dos maneras:</p> <ul> <li>Haciendo uso del m\u00e9todo distinct tras haber realizado alguna transformaci\u00f3n</li> <li>Utilizando dropDuplicates sobre un DataFrame:</li> </ul> <pre><code>df.select(\"Country\").distinct().show()\ndf.dropDuplicates([\"Country\"]).select(\"Country\").show()\n# +-------+\n# |Country|\n# +-------+\n# |Germany|\n# | France|\n# | Mexico|\n# | Canada|\n# +-------+\n</code></pre>"},{"location":"spark/02dataframeAPI.html#ordenando","title":"Ordenando","text":"<p>Una vez recuperados los datos deseados, podemos ordenarlos mediante sort u orderBy (son operaciones totalmente equivalentes):</p> <pre><code>df.select(\"ProductID\",\"Revenue\").sort(\"Revenue\").show(5)\ndf.sort(\"Revenue\").show(5)\ndf.sort(\"Revenue\", ascending=True).show(5)\ndf.sort(df.Revenue.asc()).show(5)\n# Ordenaci\u00f3n descendiente\ndf.sort(df.Revenue.desc()).show(5)\ndf.sort(\"Revenue\", ascending=False).show(5)\nfrom pyspark.sql.functions import desc\ndf.sort(desc(\"Revenue\")).show(5)\n# Ordenaci\u00f3n diferente en cada columna\ndf.sort(df.Revenue.desc(), df.Units.asc()).show(5)\ndf.sort([\"Revenue\",\"Units\"], ascending=[0,1]).show(5)\n</code></pre> <p>Por ejemplo, con la \u00faltima operaci\u00f3n obtendr\u00edamos:</p> <pre><code>+---------+----------+---------------+-----+-------+-------+\n|ProductID|      Date|            Zip|Units|Revenue|Country|\n+---------+----------+---------------+-----+-------+-------+\n|      495|1999-03-15|75213 CEDEX 16 |   77|43194.1| France|\n|      495|2000-03-01|75391 CEDEX 08 |   18|10395.0| France|\n|      464|2003-06-11|75213 CEDEX 16 |   16|10075.8| France|\n|      464|2000-08-01|22397          |   17| 9817.5|Germany|\n|      495|2000-03-01|06175 CEDEX 2  |   16| 9240.0| France|\n+---------+----------+---------------+-----+-------+-------+\nonly showing top 5 rows\n</code></pre> <p>Normalmente, tras realizar una ordenaci\u00f3n, es habitual quedarse con un subconjunto de los datos. Para ello, podemos utilizar la transformaci\u00f3n limit.</p> <p>Por ejemplo, la siguiente transformaci\u00f3n es similar al ejemplo anterior, s\u00f3lo que ahora al driver \u00fanicamente le llegan 5 registros, en vez de traerlos todos y s\u00f3lo mostrar 5:</p> <pre><code>df.sort(df.Revenue.desc(), df.Units.asc()).limit(5).show()\n</code></pre>"},{"location":"spark/02dataframeAPI.html#anadiendo-filas","title":"A\u00f1adiendo filas","text":"<p>La \u00fanica manera de a\u00f1adir filas a un DataFrame es creando uno nuevo que sea el resultado de unir dos DataFrames que compartan el mismo esquema (mismo nombres de columnas y en el mismo orden). Para ello, utilizaremos la transformaci\u00f3n union que realiza la uni\u00f3n por el orden de las columnas:</p> <pre><code>nuevasVenta = [\n(6666, \"2022-03-24\", \"03206\", 33, 3333.33, \"Spain\"),\n(6666, \"2022-03-25\", \"03206\", 22, 2222.22, \"Spain\"),\n]\n# Creamos un nuevo DataFrame con las nuevas Ventas\nnvDF = spark.createDataFrame(nuevasVenta)\n# Unimos los dos DataFrames\ndfUpdated = df.union(nvDF)\n</code></pre> <p>Trabajando con conjuntos</p> <p>Considerando dos DataFrames como dos conjuntos, podemos emplear las operaciones union, intersect, intersectAll (mantiene los duplicados), exceptAll (mantiene los duplicados) y subtract .</p>"},{"location":"spark/02dataframeAPI.html#cogiendo-muestras","title":"Cogiendo muestras","text":"<p>Si necesitamos recoger un subconjunto de los datos, ya sea para preparar los datos para alg\u00fan modelo de machine learning como para una muestra aleatoria de los mismos, podemos utilizar las siguientes transformaciones:</p> <ul> <li> <p>sample permite obtener una muestra a partir de un porcentaje (no tiene porqu\u00e9 obtener una cantidad exacta). Tambi\u00e9n admite un semilla e indicar si queremos que pueda repetir los datos.</p> <pre><code>df.count()                  # 120239\nmuestra = df.sample(0.10)\nmuestra.count()             # 11876\nmuestraConRepetidos = df.sample(True, 0.10)\nmuestraConRepetidos.count() # 11923\n</code></pre> </li> <li> <p>randomSplit recupera diferentes DataFrames cuyos tama\u00f1os en porcentaje se indican como par\u00e1metros (si no suman uno, los par\u00e1metros se normalizan):</p> <pre><code>dfs = df.randomSplit([0.8, 0.2])\ndfEntrenamiento = dfs[0]\ndfPrueba = dfs[1]\ndfEntrenamiento.count()     # 96194\ndfPrueba.count()            # 24045\n</code></pre> </li> </ul>"},{"location":"spark/02dataframeAPI.html#trabajando-con-datos-sucios","title":"Trabajando con datos sucios","text":"<p>Hay tres formas de gestionar la suciedad de los datos o la omisi\u00f3n completa de los mismos:</p> <ol> <li>Eliminar las filas que tienen valores vac\u00edos en una o m\u00e1s columnas.</li> <li>Rellenar los valores nulos con valores que definimos nosotros.</li> <li>Sustituir los datos err\u00f3neos por alg\u00fan valor que sepamos como gestionarlo.</li> </ol> <p>Vamos a ver cada uno de estos casos a partir del siguiente dataset:</p> <pre><code>malasVentas = [\n(6666, \"2022-03-22\", \"03206\", 33, 3333.33, \"Spain\"),\n(6666, \"2022-03-22\", None, 33, 3333.33, \"Spain\"),\n(6666, \"2022-03-23\", \"03206\", None, 2222.22, \"Spain\"),\n(6666, \"2022-03-24\", \"03206\", None, None, \"Espain\"),\n(None, None, None, None, None, None)\n]\nmalDF = spark.createDataFrame(malasVentas, [\"ProductID\", \"Date\", \"Zip\", \"Units\", \"Revenue\" , \"Country\"])\nmalDF.show()\n# +---------+----------+-----+-----+-------+-------+\n# |ProductID|      Date|  Zip|Units|Revenue|Country|\n# +---------+----------+-----+-----+-------+-------+\n# |     6666|2022-03-22|03206|   33|3333.33|  Spain|\n# |     6666|2022-03-22| null|   33|3333.33|  Spain|\n# |     6666|2022-03-23|03206| null|2222.22|  Spain|\n# |     6666|2022-03-24|03206| null|   null| Espain|\n# |     null|      null| null| null|   null|   null|\n# +---------+----------+-----+-----+-------+-------+\n</code></pre> <p>Si queremos saber si una columna contiene nulos, podemos hacer un filtrado utilizando el m\u00e9todo isNull sobre los campos deseados (tambi\u00e9n podemos utilizar isNotNull si queremos el caso contrario):</p> <pre><code>malDF.filter(malDF.Zip.isNull()).show()\n# +---------+----------+----+-----+-------+-------+\n# |ProductID|      Date| Zip|Units|Revenue|Country|\n# +---------+----------+----+-----+-------+-------+\n# |     6666|2022-03-22|null|   33|3333.33|  Spain|\n# |     null|      null|null| null|   null|   null|\n# +---------+----------+----+-----+-------+-------+\n</code></pre> <p>Para trabajar con las filas que contengan alg\u00fan dato nulo, podemos acceder a la propiedad <code>na</code>, la cual devuelve un DataFrameNaFunctions sobre la que podemos indicarle:</p> <ul> <li> <p>que la elimine mediante el m\u00e9todo <code>drop</code> / <code>dropna</code>. Puede recibir <code>\"any\"</code> (borrar\u00e1 las filas que contengan alg\u00fan nulo) o <code>\"all\"</code> (borrar\u00e1 las filas que todas sus columnas contengan nulos) y una lista con las columnas a considerar:</p> <pre><code># Elimina todos los nulos\nmalDF.na.drop().show()\n# +---------+----------+-----+-----+-------+-------+\n# |ProductID|      Date|  Zip|Units|Revenue|Country|\n# +---------+----------+-----+-----+-------+-------+\n# |     6666|2022-03-22|03206|   33|3333.33|  Spain|\n# +---------+----------+-----+-----+-------+-------+\n# Elimina las filas que todas sus columnas son nulas\nmalDF.na.drop(\"all\").show()\n# +---------+----------+-----+-----+-------+-------+\n# |ProductID|      Date|  Zip|Units|Revenue|Country|\n# +---------+----------+-----+-----+-------+-------+\n# |     6666|2022-03-22|03206|   33|3333.33|  Spain|\n# |     6666|2022-03-22| null|   33|3333.33|  Spain|\n# |     6666|2022-03-23|03206| null|2222.22|  Spain|\n# |     6666|2022-03-24|03206| null|   null| Espain|\n# +---------+----------+-----+-----+-------+-------+\n# Elimina las filas que tienen el Zip nulo\nmalDF.na.drop(subset=[\"Zip\"]).show()\n# +---------+----------+-----+-----+-------+-------+\n# |ProductID|      Date|  Zip|Units|Revenue|Country|\n# +---------+----------+-----+-----+-------+-------+\n# |     6666|2022-03-22|03206|   33|3333.33|  Spain|\n# |     6666|2022-03-23|03206| null|2222.22|  Spain|\n# |     6666|2022-03-24|03206| null|   null| Espain|\n# +---------+----------+-----+-----+-------+-------+\n</code></pre> <p>Tambi\u00e9n podemos indicar la cantidad de valores no nulos que ha de contener cada fila para eliminarla mediante el par\u00e1metro <code>thresh</code>:</p> <pre><code># Elimina las filas que tengan menos de 3 valores rellenados\nmalDF.dropna(thresh = 3)\n# +---------+----------+-----+-----+-------+-------+\n# |ProductID|      Date|  Zip|Units|Revenue|Country|\n# +---------+----------+-----+-----+-------+-------+\n# |     6666|2022-03-22|03206|   33|3333.33|  Spain|\n# |     6666|2022-03-22| null|   33|3333.33|  Spain|\n# |     6666|2022-03-23|03206| null|2222.22|  Spain|\n# |     6666|2022-03-24|03206| null|   null| Espain|\n#\u00a0+---------+----------+-----+-----+-------+-------+    \n</code></pre> </li> <li> <p>que la rellene mediante el m\u00e9todo <code>fill</code> / <code>fillna</code>, indicando el valor y si queremos, sobre qu\u00e9 columnas aplicar la modificaci\u00f3n:</p> <pre><code># Rellenamos los zips vac\u00edos por 99999\nmalDF.na.fill(\"99999\", subset=[\"Zip\"]).show()\n# malDF.na.fill(\"99999\", [\"Zip\"]).show()\n# malDF.fillna({\"Zip\": \"99999\"})\n# +---------+----------+-----+-----+-------+-------+\n# |ProductID|      Date|  Zip|Units|Revenue|Country|\n#\u00a0+---------+----------+-----+-----+-------+-------+\n#\u00a0|     6666|2022-03-22|03206|   33|3333.33|  Spain|\n#\u00a0|     6666|2022-03-22|99999|   33|3333.33|  Spain|\n# |     6666|2022-03-23|03206| null|2222.22|  Spain|\n#\u00a0|     6666|2022-03-24|03206| null|   null| Espain|\n#\u00a0|     null|      null|99999| null|   null|   null|\n# +---------+----------+-----+-----+-------+-------+\n</code></pre> </li> <li> <p>que la sustituya mediante el m\u00e9todo <code>replace</code></p> <pre><code># Cambiamos Espain por Spain\nmalDF.na.replace(\"Espain\", \"Spain\").show()\n# +---------+----------+-----+-----+-------+-------+\n# |ProductID|      Date|  Zip|Units|Revenue|Country|\n# +---------+----------+-----+-----+-------+-------+\n# |     6666|2022-03-22|03206|   33|3333.33|  Spain|\n# |     6666|2022-03-22| null|   33|3333.33|  Spain|\n# |     6666|2022-03-23|03206| null|2222.22|  Spain|\n# |     6666|2022-03-24|03206| null|   null|  Spain|\n# |     null|      null| null| null|   null|   null|\n# +---------+----------+-----+-----+-------+-------+\n</code></pre> </li> </ul> <p>Otro caso muy com\u00fan es realizar una operaci\u00f3n sobre una columna para transformar su valor, por ejemplo, pasar todo el texto a min\u00fasculas o dividir una columna entre 100 para cambiar la escala.</p> <p>En nuestro caso, vamos a modificar las columnas Zip y Country para realizar un <code>trim</code> y borrar los espacios en blanco:</p> <pre><code>from pyspark.sql.functions import col, trim\ndf = df.withColumn(\"Country\", trim(col(\"Country\"))).withColumn(\"Zip\", trim(col(\"Zip\")))\n</code></pre>"},{"location":"spark/02dataframeAPI.html#usando-sql","title":"Usando SQL","text":"<p>En la era del big data SQL es la lengua franca, permitiendo a perfiles con pocos conocimientos de programaci\u00f3n trabajar de forma eficiente con los datos (siempre poniendo el foco en la anal\u00edtica de datos, no en el procesamiento transaccional).</p> <p>Spark soporta el ANSI SQL 2003, ampliamente establecido en el mundo de las bases de datos.</p> <p>Para correr SQL en Spark podemos hacerlo a trav\u00e9s de:</p> <ul> <li>El cliente SQL, es cual se ofrece como un comando en <code>./bin/spark-sql</code></li> <li>Mediante un servidor ODBC/JDBC</li> <li>De forma programativa mediante aplicaciones Spark.</li> </ul> <p>Las dos primeras opciones se integran con Apache Hive para utilizar su metastore. Ahora nos vamos a centrar en la \u00faltima.</p>"},{"location":"spark/02dataframeAPI.html#vistas-temporales","title":"Vistas temporales","text":"<p>Ya hemos visto que los DataFrames tienen una estructura similar a una tabla de una base de datos relacional. Para poder realizar consultas, necesitaremos crear vistas temporales mediante el m\u00e9todo <code>createTempView</code> o <code>createOrReplaceTempView</code> para posteriormente realizar una consulta sobre la vista creada a trav\u00e9s de <code>spark.sql</code>:</p> <pre><code># 1. definimos la vista\ndf.createOrReplaceTempView(\"ventas\")\n# 2. realizamos la consulta\nventasCanada = spark.sql(\"select * from ventas where trim(Country)='Canada'\")\nventasCanada.show(3)\n# +---------+---------+---------------+-----+-------+-------+\n# |ProductID|     Date|            Zip|Units|Revenue|Country|\n# +---------+---------+---------------+-----+-------+-------+\n# |      725|1/15/1999|H1B            |    1|  115.4|Canada |\n# |     2235|1/15/1999|H1B            |    2|  131.1|Canada |\n# |      713|1/15/1999|H1B            |    1|  160.1|Canada |\n# +---------+---------+---------------+-----+-------+-------+\n# only showing top 3 rows\n</code></pre>"},{"location":"spark/02dataframeAPI.html#vistas-globales","title":"Vistas globales","text":"<p>Las vistas temporales tienen un alcance de SparkSession, de manera que desaparecen una vez finalice la sesi\u00f3n que ha creado la vista. Si necesitamos tener una vista que se comparta entre todas las sesiones y que permanezca viva hasta que la aplicaci\u00f3n Spark finalice, podemos crear una vista temporal global mediante <code>createOrReplaceGlobalTempView</code></p> <p>Estas vistas se almacenan en la base de datos <code>global_temp</code> y en las consultas es necesario poner el prefijo <code>global_temp</code> para acceder a sus vistas.</p> <pre><code># 1. definimos la vista global\ndf.createOrReplaceGlobalTempView(\"ventasg\")\n# 2. realizamos la consulta\nventasCanadaG = spark.sql(\"select * from global_temp.ventasg where trim(Country)='Canada'\")\nventasCanadaG.show(3)\n# +---------+---------+---------------+-----+-------+-------+\n# |ProductID|     Date|            Zip|Units|Revenue|Country|\n# +---------+---------+---------------+-----+-------+-------+\n# |      725|1/15/1999|H1B            |    1|  115.4|Canada |\n# |     2235|1/15/1999|H1B            |    2|  131.1|Canada |\n# |      713|1/15/1999|H1B            |    1|  160.1|Canada |\n# +---------+---------+---------------+-----+-------+-------+\n# only showing top 3 rows\n# Creamos otra sesi\u00f3n y vemos como funciona\nspark.newSession().sql(\"select count(*) from global_temp.ventasg where trim(Country)='Canada'\").show()\n</code></pre>"},{"location":"spark/02dataframeAPI.html#eliminando-vistas","title":"Eliminando vistas","text":"<p>Para borrar una vista que hayamos creado, necesitamos acceder al Spark Catalog que veremos en una sesi\u00f3n posterior, y utilizar el m\u00e9todo <code>dropTempView</code> o <code>dropGlobalTempView</code> dependiendo del tipo de vista:</p> <pre><code>spark.catalog.dropTempView(\"ventas\")\nspark.catalog.dropGlobalTempView(\"ventasg\")\n</code></pre>"},{"location":"spark/02dataframeAPI.html#trabajando-con-databricks","title":"Trabajando con Databricks","text":"<p>En la sesi\u00f3n anterior ya vimos como crear RDDs con Databricks. En esta ocasi\u00f3n, vamos a trabajar mediante DataFrames y SQL para ver toda la flexibilidad que nos aporta.</p> <p>Una vez creado de nuevo el cluster, vamos a cargar los datos mediante la opci\u00f3n Data, subiendo el archivo <code>pdi_sales_small.csv</code>:</p> Subiendo datos a Databricks <p>Una vez cargado el archivo, pulsamos sobre el bot\u00f3n Create table in notebook de manera que nos crea un cuaderno Jupyter donde podemos consultar los datos y crear una vista temporal:</p> Cargados los datos en un DataFrame <p>Para que funcione correctamente con nuestro datos, vamos a modificar el c\u00f3digo:</p> <pre><code>infer_schema = \"true\"\nfirst_row_is_header = \"true\"\ndelimiter = \";\"\n</code></pre> <p>Y tras cargar el dataset, antes de crear la vista, vamos a limpiar los pa\u00edses:</p> <pre><code>from pyspark.sql.functions import trim\ndf = df.withColumn(\"Country\", trim(df.Country))\n</code></pre>"},{"location":"spark/02dataframeAPI.html#datos-visuales","title":"Datos visuales","text":"<p>Si volvemos a ejecutar el cuaderno, ahora s\u00ed que cargar\u00e1 correctamente los datos. Si nos vamos a la celda que realiza una consulta sobre todos los datos, podemos ver en la parte superior derecha como el lenguaje empleado en la celda es SQL, por ello la primera l\u00ednea comienza con <code>%sql</code>, y a continuaci\u00f3n ya podemos introducir directamente c\u00f3digo SQL, teniendo la opci\u00f3n de visualizar los datos tanto en modo texto como mediante gr\u00e1ficos:</p> Datos y gr\u00e1ficos mediante SQL"},{"location":"spark/02dataframeAPI.html#cuadro-de-mandos","title":"Cuadro de mandos","text":"<p>Adem\u00e1s, con las tablas y/o gr\u00e1ficos que generamos dentro de Databricks, podemos generar un sencillo cuadro de mandos.</p> <p>Vamos a crear un par de consultas, una para obtener las ventas medias por pa\u00eds:</p> <pre><code>%sql\nselect Country, avg(Revenue) as ventas\nfrom pdi_sales_small_csv\ngroup by Country\norder by ventas desc\n</code></pre> <p>Y otra para las unidas pedidas por cada pa\u00eds:</p> <pre><code>%sql\nselect Country, sum(Units) as pedidos\nfrom pdi_sales_small_csv\ngroup by Country\norder by pedidos desc\n</code></pre> <p>Si pulsamos sobre el icono del gr\u00e1fico de barras de la esquina superior derecha de una celda SQL, podemos a\u00f1adir el resultado de la celda a un dashboard:</p> Creando un cuadro de mandos <p>Una vez creado, s\u00f3lo tenemos que seleccionar las celdas que queramos, e ir a\u00f1adi\u00e9ndolas al cuadro de mandos creado. Posteriormente, podemos abrirlo, resituar los elementos y visualizarlo:</p> A\u00f1adiendo elementos a un cuadro de mandos"},{"location":"spark/02dataframeAPI.html#referencias","title":"Referencias","text":"<ul> <li>Documentaci\u00f3n oficial sobre Spark SQL, DataFrames and Datasets Guide</li> <li>Beginning Apache Spark 3: With DataFrame, Spark SQL, Structured Streaming, and Spark Machine Learning Library</li> <li>Spark by Examples</li> <li>The Most Complete Guide to pySpark DataFrames</li> <li>Spark SQL Cheatsheet en PDF y en formato web</li> </ul>"},{"location":"spark/02dataframeAPI.html#actividades","title":"Actividades","text":"<p>(RA5074.1 / CE4.1b) En las siguientes actividades vamos a familiarizarnos con el uso del API de DataFrames de Spark.</p> <ol> <li> <p>(1.5p) A partir del archivo nombres.json, crea un DataFrame y realiza las siguientes operaciones:</p> <ol> <li>Crea una nueva columna (columna <code>Mayor30</code>) que indique si la persona es mayor de 30 a\u00f1os.</li> <li>Crea una nueva columna (columna <code>FaltanJubilacion</code>) que calcule cuantos a\u00f1os le faltan para jubilarse (supongamos que se jubila a los 67 a\u00f1os)</li> <li>Crea una nueva columna (columna <code>Apellidos</code>) que contenga <code>XYZ</code> (puedes utilizar la funci\u00f3n <code>lit</code>)</li> <li>Elimina las columna <code>Mayor30</code> y <code>Apellidos</code>.</li> <li>Crea una nueva columna (columna <code>AnyoNac</code>) con el a\u00f1o de nacimiento de cada persona (puedes utilizar la funci\u00f3n <code>current_date</code>).</li> <li>A\u00f1ade un id incremental para cada fila (campo <code>Id</code>) y haz que al hacer un <code>show</code> se vea en primer lugar (puedes utilizar la funci\u00f3n <code>monotonically_increasing_id</code>) seguidos del <code>Nombre</code>, <code>Edad</code>, <code>AnyoNac</code>, <code>FaltaJubilacion</code> y <code>Ciudad</code></li> </ol> <p>Al realizar los seis pasos, el resultado del DataFrame ser\u00e1 similar a :</p> <pre><code>+---+-------+----+-------+----------------+--------+\n| Id|Nombre |Edad|AnyoNac|FaltanJubilacion|  Ciudad|\n+---+-------+----+-------+----------------+--------+\n|  0|  Aitor|  45|   1977|              22|   Elche|\n|  1| Marina|  14|   2008|              53|Alicante|\n|  2|  Laura|  19|   2003|              48|   Elche|\n|  3|  Sonia|  45|   1977|              22|    Aspe|\n|  4|  Pedro|null|   null|            null|   Elche|\n+---+-------+----+-------+----------------+--------+\n</code></pre> </li> <li> <p>(1p) A partir del archivo <code>VentasNulos.csv</code>:</p> <ol> <li> <p>Elimina las filas que tengan al menos 4 nulos.</p> </li> <li> <p>Con las filas restantes, sustituye:</p> <ol> <li>Los nombres nulos por <code>Empleado</code></li> <li> <p>Las ventas nulas por la media de las ventas de los compa\u00f1eros (redondeado a entero).</p> <p>Agrupando</p> <p>Para obtener la media, aunque lo veremos en la pr\u00f3xima sesi\u00f3n, debes agrupar y luego obtener la media de la columna:</p> <pre><code>valor = df.groupBy().avg('Ventas')\n</code></pre> </li> <li> <p>Los euros nulos por el valor del compa\u00f1ero que menos \u20ac ha ganado. (tras agrupar, puedes usar la funci\u00f3n <code>min</code>)</p> </li> <li>La ciudad nula por <code>C.V.</code> y el identificador nulo por <code>XYZ</code></li> </ol> <p>Para los pasos ii) y iii) puedes crear un DataFrame que obtenga el valor a asignar y luego pasarlo como par\u00e1metro al m\u00e9todo para rellenar los nulos.</p> </li> </ol> </li> <li> <p>(0.5p) A partir del archivo <code>movies.tsv</code>, crea una esquema de forma declarativa con los campos:</p> <ul> <li><code>interprete</code> de tipo <code>string</code></li> <li><code>pelicula</code> de tipo <code>string</code></li> <li><code>anyo</code> de tipo <code>int</code></li> </ul> <p>Cada fila del fichero implica que el actor/actriz ha trabajado en dicha pel\u00edcula en el a\u00f1o indicado.</p> <ol> <li>Una vez creado el esquema, carga los datos en un DataFrame.</li> <li>Muestra las pel\u00edculas en las que ha trabajado <code>Murphy, Eddie (I)</code>.</li> <li>Muestra los int\u00e9rpretes que aparecen tanto en <code>Superman</code> como en <code>Superman II</code>.</li> </ol> </li> </ol>"},{"location":"spark/03streaming.html","title":"Spark Streaming","text":"<p>Aunque ya estudiamos el concepto de Streaming en la sesi\u00f3n sobre Ingesta de Datos no viene mal recordar que cuando el procesamiento se realiza en streaming:</p> <ul> <li>Los datos se generan de manera continuada desde una o m\u00e1s fuentes de datos.</li> <li>Las fuentes de datos, por lo general, env\u00edan los datos de forma simult\u00e1nea.</li> <li>Los datos se reciben en peque\u00f1os fragmentos (del orden de KB).</li> </ul> <p>Vamos a considerar un stream como un flujo de datos continuo e ilimitado, sin un final definido que aporta datos a nuestros sistemas cada segundo.</p> <p>El desarrollo de aplicaciones que trabajan con datos en streaming suponen un mayor reto que las aplicaciones batch, dada la impredecibilidad de los datos, tanto su ritmo de llegada como su orden.</p> <p>Uno de los casos de uso m\u00e1s comunes del procesamiento en streaming es realizar alg\u00fan calculo agregado sobre los datos que llegan y resumirlos/sintetizarlos en un destino externo para que luego ya sea un aplicaci\u00f3n web o un motor de anal\u00edtica de datos los consuma.</p> <p>Las principales herramientas para el tratamiento de datos en streaming son Apache Samza, Apache Flink, Apache Kafka (de manera conjunta con Kafka Streams) y por supuesto, Apache Spark.</p>"},{"location":"spark/03streaming.html#streaming-en-spark","title":"Streaming en Spark","text":"<p>Spark Streaming es una extensi\u00f3n del n\u00facleo de Spark que permite el procesamiento de flujos de datos en vivo ofreciendo tolerancia a fallos, un alto rendimiento y altamente escalable.</p> <p>Los datos se pueden ingestar desde diversas fuentes de datos, como Kafka, sockets TCP, etc.. y se pueden procesar mediante funciones de alto nivel, ya sea mediante el uso de RDD y algoritmos MapReduce, o utilizando DataFrames y la sintaxis SQL. Finalmente, los datos procesados se almacenan en sistemas de ficheros, bases de datos o cuadros de mandos.</p> Streaming con Spark <p>De hecho, podemos utilizar tanto Spark MLlib y sus algoritmos de machine learning como el procesamiento de grafos en los flujos de datos.</p> <p>Spark dispone dos soluciones para trabajar con datos en streaming:</p> <ul> <li>Spark DStream: m\u00e1s antigua, conocida como la primera generaci\u00f3n,  basada en RDDs</li> <li>Spark Structured Streaming basada en el uso de DataFrames y dise\u00f1ada para construir aplicaciones que puedan reaccionar a los datos en tiempo real.</li> </ul> <p>Vamos a presentar ambas soluciones, pero en este sesi\u00f3n nos centraremos principalmente en Spark Structured Streaming.</p>"},{"location":"spark/03streaming.html#dstream","title":"DStream","text":"<p>Spark DStream (Discretized Stream), como ya hemos comentado, es la primera versi\u00f3n y actualmente no se recomienda su uso.</p> <p>Funciona mediante un modelo de micro-batching para dividir los flujos de entrada de datos en fragmentos que son procesados por el n\u00facleo de Spark. Este planteamiento ten\u00eda mucho sentido cuando el principal modelo de programaci\u00f3n de Spark eran los RDD, ya que cada fragmento recibido se representaba mediante un RDD.</p> <p>As\u00ed pues, Spark DStream recibe los datos de entrada en flujos y los divide en batches, por ejemplo en bloques cada N segundos, los cuales procesa Spark mediante RDD para generar los flujos de resultados procesados:</p> DStream por dentro"},{"location":"spark/03streaming.html#structured-streaming","title":"Structured Streaming","text":"<p>Spark Structured Streaming es la segunda generaci\u00f3n de motor para el tratamiento de datos en streaming, y fue dise\u00f1ado para ser m\u00e1s r\u00e1pido, escalable y con mayor tolerancia a los errores que DStream, ya que utiliza el motor de Spark SQL.</p> <p>Adem\u00e1s, podemos expresar los procesos en streaming de la misma manera que realizar\u00edamos un proceso batch con datos est\u00e1ticos. El motor de Spark SQL se encarga de ejecutar los datos de forma continua e incremental, y actualizar el resultado final como datos streaming. Para ello, podemos utilizar el API de Java, Scala, Python o R para expresar las agregaciones, ventanas de eventos, joins de stream a batch, etc.... Finalmente, el sistema asegura la tolerancia de fallos mediante la entrega de cada mensaje una sola vez (exactly-once) a trav\u00e9s de checkpoints y logs.</p> <p>Los pasos esenciales a realizar al codificar una aplicaci\u00f3n en streaming consiste en especificar uno o m\u00e1s fuentes de datos, ofreciendo la l\u00f3gica para manipular los flujos de entrada de datos mediante transformaciones de DataFrames, definir el trigger que provoca la lectura y el modo de salida, y finalmente indicar el destino de los datos (data sink) donde escribir los resultados.</p> Elementos para procesar datos en Streaming <p>Debido a que tanto el modo de salida como el trigger tienen valores por defecto, es posible que no tengamos que indicarlos ni configurarlos, lo que reduce el desarrollo de procesos a un bucle infinito de leer, transformar y enviar al destino (read + transform + sink). Cada una de las iteraciones de ese bucle infinito se conoce como un micro-batch, las cuales tienen unas latencias situadas alrededor de los 100 ms. Desde Spark 2.3 existe un nuevo modo de procesamiento de baja latencia conocido como Procesamiento Continuo, que puede obtener latencias de 1ms. Al tratarse todav\u00eda de un tecnolog\u00eda en fase de experimentaci\u00f3n, queda fuera de la presente sesi\u00f3n.</p>"},{"location":"spark/03streaming.html#caso-1-hola-spark-streaming","title":"Caso 1: Hola Spark Streaming","text":"<p>Para ver nuestro primer caso de uso, vamos a realizar un proceso de contar palabras sobre un flujo continuo de datos que proviene de un socket.</p> <p>Para ello, en un terminal, abrimos un listener de Netcat en el puerto 9999:</p> <pre><code>nc -lk 9999\n</code></pre> <p>Tras arrancar Netcat, ya podemos crear nuestra aplicaci\u00f3n Spark (vamos a indicar que cree 2 hilos, lo cual es el m\u00ednimo necesario para realizar streaming, uno para recibir y otro para procesar):</p> <pre><code>from pyspark.sql import SparkSession\nspark = SparkSession \\\n        .builder \\\n        .appName(\"Streaming IABD WordCount\") \\\n        .master(\"local[2]\") \\\n        .getOrCreate()\n# Creamos un flujo de escucha sobre netcat en localhost:9999\n# En Spark Streaming, la lectura se realiza mediante readStream\nlineasDF = spark.readStream \\\n        .format(\"socket\") \\\n        .option(\"host\", \"localhost\") \\\n        .option(\"port\", \"9999\") \\\n        .load()\n# Leemos las l\u00edneas y las pasamos a palabras.\n# Sobre ellas, realizamos la agrupaci\u00f3n count (transformaci\u00f3n)\nfrom pyspark.sql.functions import explode, split\npalabrasDF = lineasDF.select(explode(split(lineasDF.value, ' ')).alias('palabra'))\ncantidadDF = palabrasDF.groupBy(\"palabra\").count()\n# Mostramos las palabras por consola (sink)\n# En Spark Streaming, la persistencia se realiza mediante writeStream\n#  y en vez de realizar un save, ahora utilizamos start\nwordCountQuery = cantidadDF.writeStream \\\n        .format(\"console\") \\\n        .outputMode(\"complete\") \\\n        .start()\n# dejamos Spark a la escucha\nwordCountQuery.awaitTermination()\n</code></pre> <p>Conforme escribamos en el terminal de Netcat ir\u00e1n apareciendo en la consola de Spark los resultados:</p> Ejecuci\u00f3n de Streaming WordCount <p>Al ejecutar la consulta, Spark crea un proceso a la escucha de manera ininterrumpida de nuevos datos. Mientras no lleguen datos, Spark queda a la espera, de manera que cuando llegue alg\u00fan dato al flujo de entrada, se crear\u00e1 un nuevo micro-batch, lo que lanzar\u00e1 un nuevo job de Spark.</p> <p>Si queremos detenerlo, podemos hacerlo de forma expl\u00edcita:</p> <pre><code>wordCountQuery.stop()\n</code></pre> <p>O configurar la SparkSession para que detenga el streaming al finalizar el proceso:</p> <pre><code>spark = SparkSession.builder \\\n        .appName(\"Streaming WordCount\") \\\n        .config(\"spark.streaming.stopGracefullyOnShutdown\", \"true\") \\\n        .getOrCreate()\n</code></pre> <p>Por defecto, Spark utiliza 200 particiones para barajar los datos. Como no tenemos muchos datos, para obtener un mejor rendimiento, podemos reducir su cantidad:</p> <pre><code>spark = SparkSession.builder \\\n        .appName(\"Streaming WordCount\") \\\n        .config(\"spark.streaming.stopGracefullyOnShutdown\", \"true\") \\\n        .config(\"spark.sql.shuffle.partitions\", 3) \\\n        .getOrCreate()\n</code></pre>"},{"location":"spark/03streaming.html#elementos","title":"Elementos","text":"<p>La idea b\u00e1sica al trabajar los datos en streaming es similar a tener una tabla de entrada de tama\u00f1o ilimitado, y conforme llegan nuevos datos, tratarlos como un nuevo conjunto de filas que se adjuntan a la tabla.</p> Datos como registros <p>A continuaci\u00f3n vamos a repasar los elementos principales de un flujo en streaming, los cuales son la fuente de datos, las operaciones en streaming mediante las transformaciones, los modos de salida, trigger y los sink de datos.</p> <p>Hablemos del tiempo</p> <p> Eventos vs Procesamiento </p> <p>Existen dos tipos de tiempo, el tiempo del evento (event time) que representa cuando se crea el dato y el de procesado (processing time), que representa el momento en el que el motor de procesamiento/anal\u00edtica de datos procesa el dato. Por ejemplo, si nos centramos en un escenario IoT, el tiempo del evento es cuando se toma el dato del sensor, y el de procesamiento cuando nuestro motor de streaming realiza la transformaci\u00f3n/agregaci\u00f3n sobre los datos del sensor.</p> <p>A la hora de trabajar con los datos, hemos de realizarlo siempre con el tiempo de los eventos, ya que representan el instante en el que se crean los datos. En un estado ideal, los datos llegan y se procesan casi de forma instant\u00e1nea, pero la realidad es otra, y la latencia existente provoca la necesidad de descartar el tiempo de procesamiento.</p> <p>Para manejar los flujos de entrada ajenos a un flujo constante, una pr\u00e1ctica muy com\u00fan es dividir los datos en trozos utilizando el tiempo inicial y final como l\u00edmites de una ventana temporal.</p>"},{"location":"spark/03streaming.html#fuentes-de-datos","title":"Fuentes de Datos","text":"<p>Mientras que en el procesamiento batch las fuentes de datos son dataset est\u00e1ticos que residen en un almacenamiento como pueda ser un sistema local, HDFS o S3, al hablar de procesamiento en streaming las fuentes de datos generan los datos de forma continuada, por lo que necesitamos otro tipo de fuentes.</p> <p>Structured Streaming ofrece un conjunto predefinido de fuentes de datos que se leen a partir de un DataStreamReader. Los tipos existentes son:</p> <ul> <li> <p>Fichero: permite leer ficheros desde un directorio como un flujo de datos, con soporte para ficheros de texto, CSV, JSON, Parquet, ORC, etc...</p> <pre><code># Lee todos los ficheros csv de un directorio\nesquemaUsuario = StructType() \\\n    .add(\"nombre\", \"string\").add(\"edad\", \"integer\")\ncsvDF = spark.readStream \\\n    .option(\"sep\", \";\") \\\n    .schema(esquemaUsuario) \\\n    .csv(\"/path/al/directorio\")  # equivalente a format(\"csv\").load(\"/path/al/directorio\")\n</code></pre> <p>Podemos configurar otras opciones como <code>maxFilesPerTrigger</code> con la cantidad de archivos a cargar en cada trigger, as\u00ed como la pol\u00edtica de lectura cuando su n\u00famero sea mayor de uno mediante la propiedad booleana <code>latestFirst</code>.</p> </li> <li> <p>Kafka: para leer datos desde brokers Kafka (versiones 0.10 o superiores). Realizaremos un par de ejemplos en los siguientes apartados.</p> <pre><code>kafkaDF = spark.readStream \\\n    .format(\"kafka\") \\\n    .option(\"kafka.bootstrap.servers\", \"iabd-virtualbox:9092\") \\\n    .option(\"subscribe\", \"iabd-topic\") \\\n    .load()\n</code></pre> </li> <li> <p>Socket: lee texto UTF8 desde una conexi\u00f3n socket (es el que hemos utilizado en el caso de uso 1). S\u00f3lo se debe utilizar para pruebas ya que no ofrece garant\u00eda de tolerancia de fallos de punto a punto.</p> <pre><code>socketDF = spark \\\n    .readStream \\\n    .format(\"socket\") \\\n    .option(\"host\", \"localhost\") \\\n    .option(\"port\", 9999) \\\n    .load()\n</code></pre> </li> <li> <p>Rate: Genera datos indicando una cantidad de filas por segundo, donde cada fila contiene un timestamp y el valor de un contador secuencial (la primera fila contiene el 0). Esta fuente tambi\u00e9n se utiliza para la realizaci\u00f3n de pruebas y benchmarking.</p> <pre><code>socketDF = spark \\\n    .readStream \\\n    .format(\"rate\") \\\n    .option(\"rowsPerSecond\", 1)\n.load()\n</code></pre> </li> <li> <p>Tabla (desde Spark 3.1): Almacena los datos en una tabla temporal de SparkSQL, la cual podemos utilizar tanto para cargar como para persistir los c\u00e1lculos realizados. M\u00e1s informaci\u00f3n en la documentaci\u00f3n oficial.</p> <pre><code>tablaDF = spark \\\n    .readStream \\\n    .table(\"clientes\")\n</code></pre> </li> </ul>"},{"location":"spark/03streaming.html#sinks","title":"Sinks","text":"<p>De la misma manera, tambi\u00e9n tenemos un conjunto de Sinks predefinidos como destino de los datos, que se escriben a partir de un DataStreamWriter.:</p> <ul> <li> <p>Fichero: Podemos almacenar los resultados en un sistema de archivos, HDFS o S3, con soporte para los formatos CSV, JSON, ORC y Parquet.</p> <pre><code># Otros valores pueden ser \"json\", \"csv\", etc...\nwriteStream.format(\"parquet\") \\        \n    .option(\"path\", \"/path/al/directorio\") \\ \n    .start()\n</code></pre> </li> <li> <p>Kafka: Env\u00eda los datos a un cl\u00faster de Kafka:</p> <pre><code>writeStream.format(\"kafka\") \\        \n    .option(\"kafka.bootstrap.servers\", \"host1:port1,host2:port2\")\n.option(\"topic\", \"miTopic\")\n.start()\n</code></pre> </li> <li> <p>Foreach y ForeachBatch: permiten realizar operaciones y escribir l\u00f3gica sobre la salida de una consulta de streaming, ya sea a nivel de fila (foreach) como a nivel de micro-batch (foreachBatch). M\u00e1s informaci\u00f3n en la documentaci\u00f3n oficial.</p> </li> <li> <p>Consola: se emplea para pruebas y depuraci\u00f3n y permite mostrar el resultado por consola.</p> <pre><code>writeStream.format(\"console\") \\        \n    .start()\n</code></pre> <p>Admite las opciones <code>numRows</code> para indicar las filas a mostrar y <code>truncate</code> para truncar los datos si las filas son muy largas.</p> </li> <li> <p>Memoria: se emplea para pruebas y depuraci\u00f3n, ya que s\u00f3lo permite un volumen peque\u00f1o de datos para evitar un problema de falta de memoria en el driver para almacenar la salida. Los datos se almacenan en una tabla temporal a la cual podemos acceder desde SparkSQL:</p> <pre><code>writeStream.format(\"memory\") \\  \n    .queryName(\"nombreTabla\")  \n.start()\n</code></pre> </li> </ul>"},{"location":"spark/03streaming.html#modos-de-salida","title":"Modos de salida","text":"<p>El modo de salida determina como salen los datos a un sumidero de datos. Existen tres opciones:</p> <ul> <li>A\u00f1adir (<code>append</code>): para insertar los datos, cuando sabemos que no vamos a modificar ninguna salida anterior, y que cada batch \u00fanicamente escribir\u00e1 nuevos registros. Es el modo por defecto.</li> <li>Modificar (<code>update</code>): similar a un upsert, donde veremos solo registros que, bien son nuevos, bien son valores antiguos que debemos modificar.</li> <li>Completa (<code>complete</code>): para sobrescribir completamente el resultado, de manera que siempre recibimos la salida completa.</li> </ul> <p>En el caso 1 hemos utilizado el modo de salida completa, de manera que con cada dato nuevo, se mostraba como resultado todas las palabras y su cantidad. Si hubi\u00e9semos elegido el modo update, en cada micro-batch solo se mostrar\u00eda el resultado acumulado de cada batch.</p> <p>Por ejemplo, si introducimos:</p> <pre><code>Spark en el Severo Ochoa\nEl Severo Ochoa est\u00e1 en Elche\n</code></pre> <p>Dependiendo del modo de salida, al introducir la segunda frase con la siguiente consulta:</p> CompleteUpdate <pre><code>wordCountQuery = cantidadDF.writeStream \\\n    .format(\"console\") \\\n    .outputMode(\"complete\") \\\n    .start()\n</code></pre> <p>Aparece la cuenta de todas las palabras:</p> <pre><code>+---------+-----+\n|  palabra|count|\n+---------+-----+\n|    Spark|    1|\n|    Elche|    1|\n|    Ochoa|    2|\n|       El|    1|\n|       en|    2|\n|Streaming|    1|\n|     est\u00e1|    1|\n|   Severo|    2|\n|       el|    1|\n+---------+-----+\n</code></pre> <pre><code>wordCountQuery = cantidadDF.writeStream \\\n    .format(\"console\") \\\n    .outputMode(\"update\") \\\n    .start()\n</code></pre> <p>S\u00f3lo aparecen las palabras del segundo micro-batch:</p> <pre><code>+-------+-----+\n|palabra|count|\n+-------+-----+\n|     El|    1|\n|  Ochoa|    2|\n|  Elche|    1|\n| Severo|    2|\n|   est\u00e1|    1|\n|     en|    2|\n+-------+-----+\n</code></pre> <p>Con este ejemplo, el modo append no tiene sentido (ya que para contar las palabras necesitamos las anteriores), y Spark es tan listo que cuando realizamos agregaciones no permite su uso y lanza una excepci\u00f3n del tipo <code>AnalysisException</code>:</p> <pre><code>AnalysisException: Append output mode not supported when there are streaming aggregations on streaming DataFrames/DataSets without watermark;\nAggregate [palabra#59], [palabra#59, count(1) AS count#63L]\n</code></pre> <p>Si dejase, solo deber\u00edan aparecer las palabra <code>El</code>, <code>est\u00e1</code> y <code>Elche</code>, ya que son los elementos que no exist\u00edan previamente.</p> <p>En resumen, el modo <code>append</code> es s\u00f3lo para inserciones, <code>update</code> para modificaciones e inserciones y finalmente <code>complete</code> sobrescribe los resultados previos.</p> <p>Adem\u00e1s, no todos los tipos de salida se pueden aplicar siempre, va a depender del tipo de operaciones que realicemos. Volveremos a tratarlos cuando veamos las marcas de agua en el apartado Watermarking.</p>"},{"location":"spark/03streaming.html#transformaciones","title":"Transformaciones","text":"<p>Dentro de Spark Structured Streaming tenemos dos tipos de transformaciones:</p> <ul> <li>Sin estado (stateless): los datos de cada micro-batch son independientes de los anteriores, y por tanto, podemos realizar las transformaciones <code>select</code>, <code>filter</code>, <code>map</code>, <code>flatMap</code>, <code>explode</code>. Es importante destacar que estas transformaciones no soportan el modo de salida complete, por lo que s\u00f3lo podemos utilizar los modos append o update.</li> <li> <p>Con estado (stateful): aquellas que implica realizar agrupaciones, agregaciones, windowing y/o joins, ya que mantienen el estado entre los diferentes micro-batches. Destacar que un abuso del estado puede causar problemas de falta de memoria, ya que el estado se almacena en la memoria de los ejecutores (executors). Por ello, Spark ofrece dos tipos de operaciones con estado:</p> <ul> <li>Gestionadas (managed): Spark gestiona el estado y libera la memoria conforme sea necesario.</li> <li>Sin gestionar (unmanaged): permite que el desarrollador defina las pol\u00edticas de limpieza del estado (y su liberaci\u00f3n de memoria), por ejemplo, a partir de pol\u00edticas basadas en el tiempo. A d\u00eda de hoy s\u00f3lo est\u00e1n disponibles mediante Java o Spark.</li> </ul> </li> </ul> <p>Adem\u00e1s, hay que tener en cuenta que no todas las operaciones que realizamos con DataFrames est\u00e1n soportadas al trabajar en streaming, como pueden ser <code>limit</code>, <code>distinct</code>, <code>cube</code> o <code>sort</code> (podemos ordenar en algunos casos despu\u00e9s de haber realizado una agregaci\u00f3n), ya que los datos no est\u00e1n acotados y provocar\u00e1 una excepci\u00f3n del tipo <code>AnalysisException</code>.</p>"},{"location":"spark/03streaming.html#triggers","title":"Triggers","text":"<p>Un trigger define el intervalo (timing) temporal de procesamiento de los datos en streaming, indicando si la consulta se ejecutar\u00e1 como un micro-batch mediante un intervalo fijo o con una consulta con procesamiento continuo.</p> <p>As\u00ed pues, un trigger es un mecanismo para que el motor de Spark SQL determine cuando ejecutar la computaci\u00f3n en streaming.</p> <p>Los posibles tipos son:</p> <ul> <li>Sin especificar, de manera que cada micro-batch se va a ejecutar tan pronto como lleguen datos.</li> <li>Por intervalo de tiempo. Si indicamos un intervalo de un minuto, una vez finalizado un job, si no ha pasado un minuto, se esperar\u00e1 a ejecutarse. Si el micro-batch tardase m\u00e1s de un minuto, el siguiente se ejecutar\u00eda inmediatamente. As\u00ed pues, de esta manera, Spark permite colectar datos de entrada y procesarlos de manera conjunta (en vez de procesar individualmente cada registro de entrada).</li> <li>Un intervalo, de manera que funciona como un proceso batch est\u00e1ndar, creando un \u00fanico proceso micro-batch.</li> <li>Continuo, para permitir latencias del orden de milisegundos mediante Continuous Processing. Se trata de una opci\u00f3n experimental desde la versi\u00f3n 2.3 de Spark.</li> </ul>"},{"location":"spark/03streaming.html#caso-2-facturas","title":"Caso 2: Facturas","text":"<p>En este caso de uso vamos a poner en pr\u00e1ctica algunos de los conceptos que acabamos de ver.</p> <p>Vamos a suponer que tenemos un empresa compuesta de diferentes sucursales. Cada una de ellas, cada 5 minutos genera un fichero con los datos de las facturas (invoices.zip) que han generado. Cada una de las facturas contiene una o m\u00e1s l\u00edneas de factura, las cuales queremos separar en facturas simples.</p> <p>As\u00ed pues, vamos a partir de documentos JSON con la siguiente estructura:</p> <pre><code>{\n\"InvoiceNumber\":\"51402977\",\n\"CreatedTime\":1595688900348,\n\"StoreID\":\"STR7188\",\n\"PosID\":\"POS956\",\n\"CashierID\":\"OAS134\",\n\"CustomerType\":\"PRIME\",\n\"CustomerCardNo\":\"4629185211\",\n\"TotalAmount\":11114.0,\n\"NumberOfItems\":4,\n\"PaymentMethod\":\"CARD\",\n\"TaxableAmount\":11114.0,\n\"CGST\":277.85,\n\"SGST\":277.85,\n\"CESS\":13.8925,\n\"DeliveryType\":\"TAKEAWAY\",\n\"InvoiceLineItems\":[\n{\"ItemCode\":\"458\",\"ItemDescription\":\"Wine glass\",\"ItemPrice\":1644.0,\"ItemQty\":2,\"TotalValue\":3288.0},\n{\"ItemCode\":\"283\",\"ItemDescription\":\"Portable Lamps\",\"ItemPrice\":2236.0,\"ItemQty\":1,\"TotalValue\":2236.0},\n{\"ItemCode\":\"498\",\"ItemDescription\":\"Carving knifes\",\"ItemPrice\":1424.0,\"ItemQty\":2,\"TotalValue\":2848.0},\n{\"ItemCode\":\"523\",\"ItemDescription\":\"Oil-lamp clock\",\"ItemPrice\":1371.0,\"ItemQty\":2,\"TotalValue\":2742.0}]}\n</code></pre> <p>Y a partir de \u00e9l, generaremos 4 documentos (uno por cada l\u00ednea de factura) con la siguiente estructura:</p> <pre><code>{\n\"InvoiceNumber\":\"51402977\",\n\"CreatedTime\":1595688900348,\n\"StoreID\":\"STR7188\",\n\"PosID\":\"POS956\",\n\"CustomerType\":\"PRIME\",\n\"PaymentMethod\":\"CARD\",\n\"DeliveryType\":\"TAKEAWAY\",\n\"ItemCode\":\"458\",\n\"ItemDescription\":\"Wine glass\",\n\"ItemPrice\":1644.0,\n\"ItemQty\":2,\n\"TotalValue\":3288.0\n}\n</code></pre>"},{"location":"spark/03streaming.html#cargando-los-datos","title":"Cargando los datos","text":"<p>Las facturas que nos env\u00edan las colocan en una carpeta a la que tenemos acceso (para este ejercicio, podemos descargar los archivos y colocarlos en la carpeta <code>entrada</code>), de manera que primero crearemos la sesi\u00f3n y realizaremos la lectura desde dicha carpeta. Es importante destacar que para que funcione la inferencia de la estructura del documento, debemos disponer de alg\u00fan archivo en nuestra carpeta de <code>entrada</code> y activar la propiedad <code>spark.sql.streaming.schemaInference</code>:</p> <pre><code>from pyspark.sql import SparkSession\nspark = SparkSession \\\n        .builder \\\n        .appName(\"Streaming de Ficheros\") \\\n        .master(\"local[2]\") \\\n        .config(\"spark.streaming.stopGracefullyOnShutdown\", \"true\") \\\n        .config(\"spark.sql.shuffle.partitions\", 3) \\\n        .config(\"spark.sql.streaming.schemaInference\", \"true\") \\\n        .getOrCreate()\nraw_df = spark.readStream \\\n        .format(\"json\") \\\n        .option(\"path\", \"entrada\") \\\n        .load()\nraw_df.printSchema()\n# root\n#  |-- CESS: double (nullable = true)\n#  |-- CGST: double (nullable = true)\n#  |-- CashierID: string (nullable = true)\n#  |-- CreatedTime: long (nullable = true)\n#  |-- CustomerCardNo: string (nullable = true)\n#  |-- CustomerType: string (nullable = true)\n#  |-- DeliveryAddress: struct (nullable = true)\n#  |    |-- AddressLine: string (nullable = true)\n#  |    |-- City: string (nullable = true)\n#  |    |-- ContactNumber: string (nullable = true)\n#  |    |-- PinCode: string (nullable = true)\n#  |    |-- State: string (nullable = true)\n#  |-- DeliveryType: string (nullable = true)\n#  |-- InvoiceLineItems: array (nullable = true)\n#  |    |-- element: struct (containsNull = true)\n#  |    |    |-- ItemCode: string (nullable = true)\n#  |    |    |-- ItemDescription: string (nullable = true)\n#  |    |    |-- ItemPrice: double (nullable = true)\n#  |    |    |-- ItemQty: long (nullable = true)\n#  |    |    |-- TotalValue: double (nullable = true)\n#  |-- InvoiceNumber: string (nullable = true)\n#  |-- NumberOfItems: long (nullable = true)\n#  |-- PaymentMethod: string (nullable = true)\n#  |-- PosID: string (nullable = true)\n#  |-- SGST: double (nullable = true)\n#  |-- StoreID: string (nullable = true)\n#  |-- TaxableAmount: double (nullable = true)\n#  |-- TotalAmount: double (nullable = true)\n</code></pre> <p>Aunque en este caso hemos realizado la inferencia de la estructura de los datos de entrada, lo normal es indicar el esquema de los datos.</p>"},{"location":"spark/03streaming.html#proyectando","title":"Proyectando","text":"<p>El siguiente paso es seleccionar los datos que nos interesan. Para ello, tras revisar la estructura de salida que deseamos, realizamos una selecci\u00f3n de las columnas y utilizaremos la funci\u00f3n <code>explode</code> para desenrollar el array de facturas <code>InvoiceLineItems</code>:</p> <pre><code>explode_df = raw_df.selectExpr(\"InvoiceNumber\", \"CreatedTime\", \"StoreID\",\n\"PosID\", \"CustomerType\",\n\"PaymentMethod\", \"DeliveryType\",\n\"explode(InvoiceLineItems) as LineItem\")\nexplode_df.printSchema()\n# root\n#  |-- InvoiceNumber: string (nullable = true)\n#  |-- CreatedTime: long (nullable = true)\n#  |-- StoreID: string (nullable = true)\n#  |-- PosID: string (nullable = true)\n#  |-- CustomerType: string (nullable = true)\n#  |-- PaymentMethod: string (nullable = true)\n#  |-- DeliveryType: string (nullable = true)\n#  |-- LineItem: struct (nullable = true)\n#  |    |-- ItemCode: string (nullable = true)\n#  |    |-- ItemDescription: string (nullable = true)\n#  |    |-- ItemPrice: double (nullable = true)\n#  |    |-- ItemQty: long (nullable = true)\n#  |    |-- TotalValue: double (nullable = true)\n</code></pre> <p>Direcciones de las facturas</p> <p>Cuando el tipo de entrega no es <code>TAKEAWAY</code>, tendremos rellenada la direcci\u00f3n de los pedidos. En ese caso, podemos asignar los campos y aunque haya documentos que no tengan dichos elementos, nuestro pipeline funcionar\u00e1 para ambos casos.</p> <pre><code>explode_df = raw_df.selectExpr(\"InvoiceNumber\", \"CreatedTime\", \"StoreID\", \"PosID\",\n\"CustomerType\", \"PaymentMethod\", \"DeliveryType\", \"DeliveryAddress.City\",\n\"DeliveryAddress.State\",\n\"DeliveryAddress.PinCode\", \"explode(InvoiceLineItems) as LineItem\")\n</code></pre> <p>Tras ello, vamos a renombrar los campos para quitar los campos anidados (creando columnas nuevas con el nombre deseando y eliminando la columna <code>LineItem</code>):</p> <pre><code>from pyspark.sql.functions import expr\nlimpio_df = explode_df \\\n    .withColumn(\"ItemCode\", expr(\"LineItem.ItemCode\")) \\\n    .withColumn(\"ItemDescription\", expr(\"LineItem.ItemDescription\")) \\\n    .withColumn(\"ItemPrice\", expr(\"LineItem.ItemPrice\")) \\\n    .withColumn(\"ItemQty\", expr(\"LineItem.ItemQty\")) \\\n    .withColumn(\"TotalValue\", expr(\"LineItem.TotalValue\")) \\\n    .drop(\"LineItem\")\nlimpio_df.printSchema()\n# root\n#  |-- InvoiceNumber: string (nullable = true)\n#  |-- CreatedTime: long (nullable = true)\n#  |-- StoreID: string (nullable = true)\n#  |-- PosID: string (nullable = true)\n#  |-- CustomerType: string (nullable = true)\n#  |-- PaymentMethod: string (nullable = true)\n#  |-- DeliveryType: string (nullable = true)\n#  |-- ItemCode: string (nullable = true)\n#  |-- ItemDescription: string (nullable = true)\n#  |-- ItemPrice: double (nullable = true)\n#  |-- ItemQty: long (nullable = true)\n#  |-- TotalValue: double (nullable = true)\n</code></pre>"},{"location":"spark/03streaming.html#guardando-el-resultado","title":"Guardando el resultado","text":"<p>Una vez tenemos el proceso de transformaci\u00f3n de datos, s\u00f3lo nos queda crear el WriterQuery para escribir el resultado del flujo de datos. En este caso, vamos a almacenarlo tambi\u00e9n como ficheros en la carpeta <code>salida</code> en formato JSON a intervalos de un minuto:</p> <pre><code>facturaWriterQuery = limpio_df.writeStream \\\n    .format(\"json\") \\\n    .queryName(\"Facturas Writer\") \\\n    .outputMode(\"append\") \\\n    .option(\"path\", \"salida\") \\\n    .option(\"checkpointLocation\", \"chk-point-dir\") \\\n    .trigger(processingTime=\"1 minute\") \\\n    .start()\n</code></pre>"},{"location":"spark/03streaming.html#refinando","title":"Refinando","text":"<p>Una vez que vemos que todo funciona, podemos realizar unos ajustes de configuraci\u00f3n.</p> <p>Por ejemplo, vamos a configurar que s\u00f3lo consuma un fichero cada vez. Para ello, en el reader configuramos la opci\u00f3n <code>maxFilesPerTrigger</code>, la cual permite limitar la cantidad de ficheros de cada micro-batch.</p> <p>Otras opciones que se usan de manera conjunta son <code>cleanSource</code> y <code>sourceArchiveDir</code>, que permiten archivar los ficheros procesados de forma autom\u00e1tica. La opci\u00f3n <code>cleanSource</code> puede tomar los valores <code>archive</code> o <code>delete</code>. Si decidimos archivar, mediante <code>sourceArchiveDir</code> indicamos el destino donde se mover\u00e1n.</p> <pre><code>raw_df = spark.readStream \\\n    .format(\"json\") \\\n    .option(\"path\", \"entrada\") \\\n    .option(\"maxFilesPerTrigger\", 1) \\\n    .option(\"cleanSource\", \"delete\") \\\n    .load()\n</code></pre> <p>Hay que tener en cuenta, que tanto archivar como eliminar van a impactar negativamente en el rendimiento de cada micro-batch. Nosotros hemos de limpiar el directorio de entrada, eso es un hecho. Si ejecutamos micro-batch largos, podemos usar la opci\u00f3n <code>cleanSource</code>. En cambio, si nuestros batches son muy cortos y el utilizar <code>cleanSource</code> no es factible por la demora que introduce, debemos crear un proceso de limpieza separado que se ejecute cada X horas y que limpie nuestro directorio de entrada.</p>"},{"location":"spark/03streaming.html#monitorizacion","title":"Monitorizaci\u00f3n","text":"<p>Una vez hemos realizado una consulta, podemos obtener informaci\u00f3n sobre la misma de forma programativa:</p> <pre><code>facturaWriterQuery.explain() # muestra una explicaci\u00f3n detalla del plan de ejecuci\u00f3n\n# == Physical Plan ==\n# *(1) Project [InvoiceNumber#314, CreatedTime#308L, StoreID#319, PosID#317, CustomerType#310, PaymentMethod#316, DeliveryType#312, _extract_City#339 AS City#52, _extract_State#340 AS State#53, _extract_PinCode#341 AS PinCode#54, LineItem#55.ItemCode AS ItemCode#67, LineItem#55.ItemDescription AS ItemDescription#81, LineItem#55.ItemPrice AS ItemPrice#96, LineItem#55.ItemQty AS ItemQty#112L, LineItem#55.TotalValue AS TotalValue#129]\n# ...\nfacturaWriterQuery.recentProgress # muestra una lista de los \u00faltimos progresos de la consulta\n# [{'id': '3b6d37cf-6a3c-405e-a715-1dc787f34b00',\n#   'runId': '3dc7c478-626a-4558-87ea-4912da55114d',\n#   'name': 'Facturas Writer',\n#   'timestamp': '2022-05-11T08:20:49.058Z',\n#   'batchId': 0,\n#   'numInputRows': 500,\n#   'inputRowsPerSecond': 0.0,\n#   'processedRowsPerSecond': 113.55893708834887,\n#   'durationMs': {'addBatch': 2496,\n# ...\nfacturaWriterQuery.lastProgress # muestra el \u00faltimo progreso\n# {'id': '3b6d37cf-6a3c-405e-a715-1dc787f34b00',\n#  'runId': '3dc7c478-626a-4558-87ea-4912da55114d',\n#  'name': 'Facturas Writer',\n#  'timestamp': '2022-05-11T08:33:00.001Z',\n#  'batchId': 3,\n#  'numInputRows': 0,\n#  'inputRowsPerSecond': 0.0,\n#  'processedRowsPerSecond': 0.0,\n#  'durationMs': {'latestOffset': 5, 'triggerExecution': 8},\n# ...\n</code></pre> <p>Estas mismas estad\u00edsticas las podemos obtener de forma gr\u00e1fica. Al ejecutar procesos en Streaming, si accedemos a Spark UI, ahora podremos ver la pesta\u00f1a Structured Streaming con informaci\u00f3n detallada de la cantidad datos de entrada, tiempo procesado y duraci\u00f3n de los micro-batches:</p> Spark UI en Structured Streaming <p>Adem\u00e1s, podemos iniciar tantas consultas como queramos en una \u00fanica sesi\u00f3n de Spark, las cuales se ejecutar\u00e1n de forma concurrente utilizando los recursos del cl\u00faster de Spark.</p>"},{"location":"spark/03streaming.html#tolerancia-a-fallos","title":"Tolerancia a fallos","text":"<p>Un aplicaci\u00f3n en streaming se espera que se ejecute de forma ininterrumpida mediante un bucle infinito de micro-batches.</p> <p>Realmente, un escenario de ejecuci\u00f3n infinita no es posible, ya que la aplicaci\u00f3n se detendr\u00e1 por:</p> <ul> <li>un fallo, ya sea por un dato mal formado o un error de red.</li> <li>mantenimiento del sistema, para actualizar la aplicaci\u00f3n o el hardware donde corre.</li> </ul> <p>Tipos de entrega</p> <p>Cuando los datos llegar a un motor de streaming de datos, este es responsable de su procesado. Para tratar la tolerancia a fallos, existen tres escenarios posibles:</p> <p> Tipos de entrega de mensajes </p> <ul> <li>Una vez como mucho (at most once): no se entrega m\u00e1s de una copia de un dato. Es decir, puede darse el caso de que no llegue, pero no habr\u00e1 repetidos.</li> <li>Una vez al menos (at least once): en este caso no habr\u00e1 p\u00e9rdidas, pero un dato puede llegar m\u00e1s de una vez. </li> <li>Una vez exacta (exactly once): se garantiza que cada dato se entrega una \u00fanica vez, sin p\u00e9rdidas ni duplicados.</li> </ul> <p>Por ello, una aplicaci\u00f3n Spark Streaming se debe reiniciar de forma transparente para mantener la caracter\u00edstica de exactly-once la cual implica que:</p> <ol> <li>No se pierde ning\u00fan registro</li> <li>No crea registros duplicados.</li> </ol> <p>Para ello, Spark Structured Streaming mantiene el estado de los micro-batches mediante checkpoints que se almacenan en la carpeta indicada por la opci\u00f3n <code>checkpointLocation</code>:</p> <pre><code>facturaWriterQuery = limpio_df.writeStream \\\n    .format(\"json\") \\\n    .queryName(\"Facturas Writer\") \\\n    .outputMode(\"append\") \\\n    .option(\"path\", \"salida\") \\\n    .option(\"checkpointLocation\", \"chk-point-dir\") \\\n    .trigger(processingTime=\"1 minute\") \\\n    .start()\n</code></pre> <p>La localizaci\u00f3n de esta carpeta deber\u00eda ser un sistema de archivo confiable y tolerante a fallos, como HDFS o Amazon S3.</p> <p>Esta carpeta contiene dos elementos:</p> <ul> <li>Posici\u00f3n de lectura, que realiza la misma funci\u00f3n que los offset en Kafka, y representa el inicio y el final del rango de datos procesados por el actual micro-batch, de manera que Spark conoce el progreso exacto del procesamiento. Una vez ha finalizado el micro-batch, Spark realiza un commit para indicar que se han procesado los datos de forma exitosa.</li> <li>Informaci\u00f3n del estado, que contiene los datos intermedios del micro-batch, como la cantidad total de palabras contadas.</li> </ul> <p>De esta manera, Spark mantiene toda la informaci\u00f3n necesaria para reiniciar un micro-batch que no ha finalizado. Sin embargo, la capacidad de reiniciarse no tiene por qu\u00e9 garantizar la pol\u00edtica exactly-once. Para ello, es necesario cumplir los siguientes requisitos:</p> <ol> <li>Reiniciar la aplicaci\u00f3n con el mismo <code>checkpointLocation</code>. Si se elimina la carpeta o se ejecuta la misma consulta sobre otro directorio de checkpoint es como si realiz\u00e1semos una consulta desde 0.</li> <li>Utilizar una fuente de datos que permita volver a leer los datos incompletos del micro-batch, por ejemplo, tanto los ficheros de texto como Kafka permiten volver a leer los datos desde un punto determinado. Sin embargo, los datos que provienen de un socket no permite volver a leerlos.</li> <li>Asegurar que la l\u00f3gica de aplicaci\u00f3n, dados los mismos datos de entrada, produce siempre el mismo resultado (aplicaci\u00f3n determinista). Si por ejemplo, nuestra l\u00f3gica de aplicaci\u00f3n utilizar\u00e1 alguna dependencia basada en fechas o el tiempo, ya no obtendr\u00edamos el mismo resultado.</li> <li>El destino (sink) debe ser capaz de identificar los elementos duplicados e ignorarlos o actualizar la copia antigua con el mismo registro, es decir, son idempotentes.</li> </ol>"},{"location":"spark/03streaming.html#caso-3-consumiendo-kafka","title":"Caso 3: Consumiendo Kafka","text":"<p>Cuando el tiempo de procesamiento debe ser inferior del orden de minutos, trabajar con ficheros deja de ser una opci\u00f3n.</p> <p>Para este caso, vamos a simular el caso anterior, pero en vez de ficheros, vamos a cargar los datos desde Kafka y seguiremos generando los datos en un sistema de archivos.</p> Arquitectura caso 3 <p>Antes de comenzar, necesitamos configurar el paquete <code>spark-sql-kafka</code> en Spark. De manera similar a como realizamos al arrancar PySpark, necesitamos arrancarlo pas\u00e1ndole el paquete con la librer\u00eda:</p> <pre><code>pyspark --packages org.apache.spark:spark-sql-kafka-0-10_2.12:3.3.1\n</code></pre> <p>Una vez arrancado, creamos la sesi\u00f3n y el DataFrame de lectura:</p> <pre><code>from pyspark.sql import SparkSession\nspark = SparkSession \\\n    .builder \\\n    .appName(\"Kafka Streaming\") \\\n    .master(\"local[3]\") \\\n    .getOrCreate()\nkafkaDF = spark.readStream \\\n    .format(\"kafka\") \\\n    .option(\"kafka.bootstrap.servers\", \"iabd-virtualbox:9092\") \\\n    .option(\"subscribe\", \"facturas\") \\\n    .option(\"startingOffsets\", \"earliest\") \\\n    .load()\n</code></pre> <p>De esta manera nos subscribimos al topic <code>facturas</code> y realizamos la lectura desde el inicio.</p> <p>Antes de poder ejecutar el reader, hemos de arrancar Kafka y crear el topic <code>facturas</code>. Para ello, una vez estamos en la carpeta de instalaci\u00f3n de Kafka (en nuestro caso <code>/opt/kafka_2.13-2.8.1</code>), ejecutaremos los siguientes comandos:</p> <pre><code>zookeeper-server-start.sh ./config/zookeeper.properties\nkafka-server-start.sh ./config/server.properties\nkafka-topics.sh --create --topic facturas --bootstrap-server iabd-virtualbox:9092\n</code></pre> <p>Si mostramos el esquema tenemos:</p> <pre><code>kafkaDF.printSchema()\n# root\n#  |-- key: binary (nullable = true)\n#  |-- value: binary (nullable = true)\n#  |-- topic: string (nullable = true)\n#  |-- partition: integer (nullable = true)\n#  |-- offset: long (nullable = true)\n#  |-- timestamp: timestamp (nullable = true)\n#  |-- timestampType: integer (nullable = true)\n</code></pre> <p>Donde podemos ver que cada mensaje tiene una <code>key</code> y un <code>value</code>, as\u00ed como otros campos relativos a Kafka que Spark utilizar\u00e1 para gestionar la tolerancia a fallos.</p> <p>Es importante destacar que el campo <code>value</code> es de tipo binario, por lo que necesitamos pasarlo a formato JSON.</p>"},{"location":"spark/03streaming.html#leyendo-datos","title":"Leyendo datos","text":"<p>Para poder leer los datos, necesitamos indicar el esquema del campo <code>value</code>. Para ello, primero definimos el esquema:</p> <pre><code>from pyspark.sql.types import StructType, StructField, StringType, LongType, DoubleType, IntegerType, ArrayType\nesquema = StructType([\nStructField(\"InvoiceNumber\", StringType()),\nStructField(\"CreatedTime\", LongType()),\nStructField(\"StoreID\", StringType()),\nStructField(\"PosID\", StringType()),\nStructField(\"CashierID\", StringType()),\nStructField(\"CustomerType\", StringType()),\nStructField(\"CustomerCardNo\", StringType()),\nStructField(\"TotalAmount\", DoubleType()),\nStructField(\"NumberOfItems\", IntegerType()),\nStructField(\"PaymentMethod\", StringType()),\nStructField(\"CGST\", DoubleType()),\nStructField(\"SGST\", DoubleType()),\nStructField(\"CESS\", DoubleType()),\nStructField(\"DeliveryType\", StringType()),\nStructField(\"DeliveryAddress\", StructType([\nStructField(\"AddressLine\", StringType()),\nStructField(\"City\", StringType()),\nStructField(\"State\", StringType()),\nStructField(\"PinCode\", StringType()),\nStructField(\"ContactNumber\", StringType())\n])),\nStructField(\"InvoiceLineItems\", ArrayType(StructType([\nStructField(\"ItemCode\", StringType()),\nStructField(\"ItemDescription\", StringType()),\nStructField(\"ItemPrice\", DoubleType()),\nStructField(\"ItemQty\", IntegerType()),\nStructField(\"TotalValue\", DoubleType())\n]))),\n])\n</code></pre> <p>Una vez que tenemos el esquema, necesitamos realizar un casting de la columna para cargarla como si fuese un string y deserializar los datos a formato JSON mediante <code>from_json</code>:</p> <p>Kafka Source - CSV y Avro</p> <p>Si los datos estuviesen en formato CSV usaremos <code>from_csv</code> o si el formato fuese Avro utilizar\u00edamos <code>from_avro</code>).</p> <p>M\u00e1s informaci\u00f3n sobre Avro y Spark en la documentaci\u00f3n oficial.</p> <pre><code>from pyspark.sql.functions import from_json, col\nvalueDF = kafkaDF.select(from_json(col(\"value\").cast(\"string\"), esquema).alias(\"value\"))\nvalueDF.printSchema()\n# root\n#  |-- value: struct (nullable = true)\n#  |    |-- InvoiceNumber: string (nullable = true)\n#  |    |-- CreatedTime: long (nullable = true)\n#  |    |-- StoreID: string (nullable = true)\n#  |    |-- PosID: string (nullable = true)\n#  |    |-- CashierID: string (nullable = true)\n#  |    |-- CustomerType: string (nullable = true)\n#  |    |-- CustomerCardNo: string (nullable = true)\n#  |    |-- TotalAmount: double (nullable = true)\n#  |    |-- NumberOfItems: integer (nullable = true)\n#  |    |-- PaymentMethod: string (nullable = true)\n#  |    |-- CGST: double (nullable = true)\n#  |    |-- SGST: double (nullable = true)\n#  |    |-- CESS: double (nullable = true)\n#  |    |-- DeliveryType: string (nullable = true)\n#  |    |-- DeliveryAddress: struct (nullable = true)\n#  |    |    |-- AddressLine: string (nullable = true)\n#  |    |    |-- City: string (nullable = true)\n#  |    |    |-- State: string (nullable = true)\n#  |    |    |-- PinCode: string (nullable = true)\n#  |    |    |-- ContactNumber: string (nullable = true)\n#  |    |-- InvoiceLineItems: array (nullable = true)\n#  |    |    |-- element: struct (containsNull = true)\n#  |    |    |    |-- ItemCode: string (nullable = true)\n#  |    |    |    |-- ItemDescription: string (nullable = true)\n#  |    |    |    |-- ItemPrice: double (nullable = true)\n#  |    |    |    |-- ItemQty: integer (nullable = true)\n#  |    |    |    |-- TotalValue: double (nullable = true)\n</code></pre> <p>De la misma manera que hicimos en el caso anterior, vamos a realizar la operaci\u00f3n <code>explode</code> para desenrollar las l\u00edneas de facturas (en este caso, con los campos de direcci\u00f3n incluidos) y luego renombramos los campos:</p> <pre><code>from pyspark.sql.functions import expr\nexplodeDF = valueDF.selectExpr(\"value.InvoiceNumber\", \"value.CreatedTime\",\n\"value.StoreID\", \"value.PosID\", \"value.CustomerType\",\n\"value.PaymentMethod\", \"value.DeliveryType\", \"value.DeliveryAddress.City\",\n\"value.DeliveryAddress.State\", \"value.DeliveryAddress.PinCode\",\n\"explode(value.InvoiceLineItems) as LineItem\")\nlimpioDF = explodeDF \\\n.withColumn(\"ItemCode\", expr(\"LineItem.ItemCode\")) \\\n.withColumn(\"ItemDescription\", expr(\"LineItem.ItemDescription\")) \\\n.withColumn(\"ItemPrice\", expr(\"LineItem.ItemPrice\")) \\\n.withColumn(\"ItemQty\", expr(\"LineItem.ItemQty\")) \\\n.withColumn(\"TotalValue\", expr(\"LineItem.TotalValue\")) \\\n.drop(\"LineItem\")\n</code></pre>"},{"location":"spark/03streaming.html#comprobando-el-resultado","title":"Comprobando el resultado","text":"<p>Y finalmente creamos la consulta de streaming:</p> <pre><code>facturaWriterQuery  = limpioDF.writeStream \\\n    .format(\"json\") \\\n    .queryName(\"Facturas Kafka Writer\") \\\n    .outputMode(\"append\") \\\n    .option(\"path\", \"salida\") \\\n    .option(\"checkpointLocation\", \"chk-point-dir\") \\\n    .trigger(processingTime=\"1 minute\") \\\n    .start()\nfacturaWriterQuery.awaitTermination()\n</code></pre> <p>Una vez lanzado, volvemos a un terminal y creamos un productor:</p> <pre><code>kafka-console-producer.sh --topic facturas --bootstrap-server iabd-virtualbox:9092\n</code></pre> <p>Y sobre el terminal, le pegamos una factura:</p> <pre><code>{\"InvoiceNumber\":\"51402977\",\"CreatedTime\":1595688900348,\"StoreID\":\"STR7188\",\"PosID\":\"POS956\",\"CashierID\":\"OAS134\",\"CustomerType\":\"PRIME\",\"CustomerCardNo\":\"4629185211\",\"TotalAmount\":11114.0,\"NumberOfItems\":4,\"PaymentMethod\":\"CARD\",\"TaxableAmount\":11114.0,\"CGST\":277.85,\"SGST\":277.85,\"CESS\":13.8925,\"DeliveryType\":\"TAKEAWAY\",\"InvoiceLineItems\":[{\"ItemCode\":\"458\",\"ItemDescription\":\"Wine glass\",\"ItemPrice\":1644.0,\"ItemQty\":2,\"TotalValue\":3288.0},{\"ItemCode\":\"283\",\"ItemDescription\":\"Portable Lamps\",\"ItemPrice\":2236.0,\"ItemQty\":1,\"TotalValue\":2236.0},{\"ItemCode\":\"498\",\"ItemDescription\":\"Carving knifes\",\"ItemPrice\":1424.0,\"ItemQty\":2,\"TotalValue\":2848.0},{\"ItemCode\":\"523\",\"ItemDescription\":\"Oil-lamp clock\",\"ItemPrice\":1371.0,\"ItemQty\":2,\"TotalValue\":2742.0}]}\n</code></pre> <p>Si nos vamos a la carpeta <code>salida</code>, veremos que ha creado un fichero con tantos documentos como l\u00edneas de factura tiene el documento anterior:</p> <pre><code>{\"InvoiceNumber\":\"51402977\",\"CreatedTime\":1595688900348,\"StoreID\":\"STR7188\",\"PosID\":\"POS956\",\"CustomerType\":\"PRIME\",\"PaymentMethod\":\"CARD\",\"DeliveryType\":\"TAKEAWAY\",\"ItemCode\":\"458\",\"ItemDescription\":\"Wine glass\",\"ItemPrice\":1644.0,\"ItemQty\":2,\"TotalValue\":3288.0}\n{\"InvoiceNumber\":\"51402977\",\"CreatedTime\":1595688900348,\"StoreID\":\"STR7188\",\"PosID\":\"POS956\",\"CustomerType\":\"PRIME\",\"PaymentMethod\":\"CARD\",\"DeliveryType\":\"TAKEAWAY\",\"ItemCode\":\"283\",\"ItemDescription\":\"Portable Lamps\",\"ItemPrice\":2236.0,\"ItemQty\":1,\"TotalValue\":2236.0}\n{\"InvoiceNumber\":\"51402977\",\"CreatedTime\":1595688900348,\"StoreID\":\"STR7188\",\"PosID\":\"POS956\",\"CustomerType\":\"PRIME\",\"PaymentMethod\":\"CARD\",\"DeliveryType\":\"TAKEAWAY\",\"ItemCode\":\"498\",\"ItemDescription\":\"Carving knifes\",\"ItemPrice\":1424.0,\"ItemQty\":2,\"TotalValue\":2848.0}\n{\"InvoiceNumber\":\"51402977\",\"CreatedTime\":1595688900348,\"StoreID\":\"STR7188\",\"PosID\":\"POS956\",\"CustomerType\":\"PRIME\",\"PaymentMethod\":\"CARD\",\"DeliveryType\":\"TAKEAWAY\",\"ItemCode\":\"523\",\"ItemDescription\":\"Oil-lamp clock\",\"ItemPrice\":1371.0,\"ItemQty\":2,\"TotalValue\":2742.0}\n</code></pre> <p>Si nos dedicamos a pegar diferentes facturas (tienes m\u00e1s en <code>facturasKafka.json</code>), cada minuto se generar\u00e1 un nuevo archivo.</p> <p>Limpieza</p> <p>Recuerda que si quieres volver a ejecutar el c\u00f3digo, debes eliminar la carpeta <code>chk-point-dir</code> as\u00ed como la carpeta de <code>salida</code>.</p>"},{"location":"spark/03streaming.html#caso-4-produciendo-a-kafka","title":"Caso 4: Produciendo a Kafka","text":"<p>Vamos a plantear que en vez de los ficheros de datos que gener\u00e1bamos con las l\u00edneas de las facturas, queremos crear un documento que contenga:</p> <ul> <li>c\u00f3digo del cliente: <code>CustomerCardNo</code></li> <li>cantidad total: <code>TotalAmount</code></li> <li>puntos de fidelidad obtenidos: <code>EarnedLoyaltyPoints</code>, el cual se obtiene a partir de <code>TotalAmount</code> * <code>0.2</code></li> </ul> Arquitectura caso 4 <p>Adem\u00e1s, este documento que generamos lo queremos enviar a un nuevo topic de Kafka (<code>notificaciones</code>) para que lo consuma otra aplicaci\u00f3n, indicando como clave el n\u00famero de factura (<code>InvoiceNumber</code>) y como valor el documento creado.</p> <p>Comenzamos de la misma forma que el caso anterior, creando los recursos de Kafka en diferentes terminales:</p> <pre><code>zookeeper-server-start.sh ./config/zookeeper.properties\nkafka-server-start.sh ./config/server.properties\nkafka-topics.sh --create --topic facturas --bootstrap-server iabd-virtualbox:9092\nkafka-topics.sh --create --topic notificaciones --bootstrap-server iabd-virtualbox:9092\n</code></pre> <p>A continuaci\u00f3n, en nuestro cuaderno Jupyter, creamos la sesi\u00f3n y conectamos con Kafka:</p> <pre><code>from pyspark.sql import SparkSession\nspark = SparkSession \\\n        .builder \\\n        .appName(\"Kafka Streaming Sink\") \\\n        .master(\"local[3]\") \\\n        .getOrCreate()\nkafkaDFS = spark.readStream \\\n        .format(\"kafka\") \\\n        .option(\"kafka.bootstrap.servers\", \"iabd-virtualbox:9092\") \\\n        .option(\"subscribe\", \"facturas\") \\\n        .option(\"startingOffsets\", \"earliest\") \\\n        .load()\n</code></pre> <p>Y volvemos a definir el esquema:</p> <pre><code>from pyspark.sql.types import StructType, StructField, StringType, LongType, DoubleType, IntegerType, ArrayType\nesquema = StructType([\nStructField(\"InvoiceNumber\", StringType()),\nStructField(\"CreatedTime\", LongType()),\nStructField(\"StoreID\", StringType()),\nStructField(\"PosID\", StringType()),\nStructField(\"CashierID\", StringType()),\nStructField(\"CustomerType\", StringType()),\nStructField(\"CustomerCardNo\", StringType()),\nStructField(\"TotalAmount\", DoubleType()),\nStructField(\"NumberOfItems\", IntegerType()),\nStructField(\"PaymentMethod\", StringType()),\nStructField(\"CGST\", DoubleType()),\nStructField(\"SGST\", DoubleType()),\nStructField(\"CESS\", DoubleType()),\nStructField(\"DeliveryType\", StringType()),\nStructField(\"DeliveryAddress\", StructType([\nStructField(\"AddressLine\", StringType()),\nStructField(\"City\", StringType()),\nStructField(\"State\", StringType()),\nStructField(\"PinCode\", StringType()),\nStructField(\"ContactNumber\", StringType())\n])),\nStructField(\"InvoiceLineItems\", ArrayType(StructType([\nStructField(\"ItemCode\", StringType()),\nStructField(\"ItemDescription\", StringType()),\nStructField(\"ItemPrice\", DoubleType()),\nStructField(\"ItemQty\", IntegerType()),\nStructField(\"TotalValue\", DoubleType())\n]))),\n])\n</code></pre>"},{"location":"spark/03streaming.html#creando-las-notificaciones","title":"Creando las notificaciones","text":"<p>Una vez hemos recuperado los datos con el esquema, vamos a elegir las columnas que necesitamos y posteriormente vamos a transformar el DataFrame para crear solo dos columnas (este es el requisito de los mensajes de Kafka), una formada por la clave que llamaremos <code>key</code> y que contendr\u00e1 el campo <code>InvoiceNumber</code>, y otra columna que llamaremos <code>value</code> y contendr\u00e1 el documento JSON serializado con los campos que nos interesan enviar al topic de <code>notificaciones</code>:</p> <pre><code>from pyspark.sql.functions import from_json, col, expr\nvalueDF = kafkaDFS.select(from_json(col(\"value\").cast(\"string\"), esquema).alias(\"value\"))\nnotificationDF = valueDF.select(\"value.InvoiceNumber\",\n\"value.CustomerCardNo\", \"value.TotalAmount\") \\\n    .withColumn(\"LoyaltyPoints\", expr(\"TotalAmount * 0.2\"))\n# Transformamos las cuatro columnas en lo que espera Kafka, un par de (key, value)\nkafkaTargetDF = notificationDF.selectExpr(\"InvoiceNumber as key\",\n\"\"\"to_json(named_struct(\n        'CustomerCardNo', CustomerCardNo,\n        'TotalAmount', TotalAmount,\n        'EarnedLoyaltyPoints', TotalAmount * 0.2)) as value\"\"\")\n</code></pre> <p>La funci\u00f3n <code>named_struct</code> crea un mapa formado por m\u00faltiples pares de (clave, valor), los cuales recibe de forma secuencial. Pues ver ejemplos de su uso de la mano de <code>to_json</code> en la documentaci\u00f3n oficial.</p> <p>Kafka Sink - CSV y Avro</p> <p>Del mismo modo que hemos explicado antes, si queremos trabajar con CSV podemos utilizar la funci\u00f3n <code>to_csv</code>. En cambio, si el formato de nuestros datos fuera Avro utilizar\u00edamos la funci\u00f3n <code>to_avro</code>.</p> <p>Finalmente, lanzamos la consulta, destacando que para indicar el topic ahora utilizaremos la opci\u00f3n <code>topic</code> (en vez de <code>subscribe</code> que utilizamos en el reader) :</p> <pre><code>notificacionWriterQuery = kafkaTargetDF \\\n    .writeStream \\\n    .queryName(\"Notificaciones Writer\") \\\n    .format(\"kafka\") \\\n    .option(\"kafka.bootstrap.servers\", \"iabd-virtualbox:9092\") \\\n    .option(\"topic\", \"notificaciones\") \\\n    .outputMode(\"append\") \\\n    .option(\"checkpointLocation\", \"chk-point-dir\") \\\n    .start()\nnotificacionWriterQuery.awaitTermination()\n</code></pre> <p>Para comprobar que funciona correctamente, una vez lanzada la consulta, volvemos a un terminal y creamos un consumidor que quede a la escucha del topic <code>notificaciones</code>:</p> <pre><code>kafka-console-consumer.sh --topic notificaciones --from-beginning --bootstrap-server iabd-virtualbox:9092\n</code></pre> <p>Y tras ello, lanzamos un productor al topic <code>facturas</code>:</p> <pre><code>kafka-console-producer.sh --topic facturas --bootstrap-server iabd-virtualbox:9092\n</code></pre> <p>Y sobre el terminal, le pegamos una factura al productor:</p> <pre><code>{\"InvoiceNumber\":\"51402977\",\"CreatedTime\":1595688900348,\"StoreID\":\"STR7188\",\"PosID\":\"POS956\",\"CashierID\":\"OAS134\",\"CustomerType\":\"PRIME\",\"CustomerCardNo\":\"4629185211\",\"TotalAmount\":11114.0,\"NumberOfItems\":4,\"PaymentMethod\":\"CARD\",\"TaxableAmount\":11114.0,\"CGST\":277.85,\"SGST\":277.85,\"CESS\":13.8925,\"DeliveryType\":\"TAKEAWAY\",\"InvoiceLineItems\":[{\"ItemCode\":\"458\",\"ItemDescription\":\"Wine glass\",\"ItemPrice\":1644.0,\"ItemQty\":2,\"TotalValue\":3288.0},{\"ItemCode\":\"283\",\"ItemDescription\":\"Portable Lamps\",\"ItemPrice\":2236.0,\"ItemQty\":1,\"TotalValue\":2236.0},{\"ItemCode\":\"498\",\"ItemDescription\":\"Carving knifes\",\"ItemPrice\":1424.0,\"ItemQty\":2,\"TotalValue\":2848.0},{\"ItemCode\":\"523\",\"ItemDescription\":\"Oil-lamp clock\",\"ItemPrice\":1371.0,\"ItemQty\":2,\"TotalValue\":2742.0}]}\n</code></pre> <p>Y veremos como el consumidor nos muestra el documento con las diferentes notificaciones:</p> <pre><code>{\"CustomerCardNo\":\"4629185211\",\"TotalAmount\":11114.0,\"EarnedLoyaltyPoints\":2222.8}\n{\"CustomerCardNo\":\"2762345282\",\"TotalAmount\":8272.0,\"EarnedLoyaltyPoints\":1654.4}\n{\"CustomerCardNo\":\"2599848717\",\"TotalAmount\":3374.0,\"EarnedLoyaltyPoints\":674.8000000000001}\n{\"CustomerCardNo\":\"4629185211\",\"TotalAmount\":11114.0,\"EarnedLoyaltyPoints\":2222.8}\n</code></pre> <p>M\u00e1s informaci\u00f3n en la documentaci\u00f3n oficial sobre integraci\u00f3n de Kafka con Spark Streaming.</p>"},{"location":"spark/03streaming.html#caso-5-windowing","title":"Caso 5: Windowing","text":"<p>Al realizar agregaciones basadas en el tiempo, es importante aclarar el concepto de ventana temporal (windowing). Una ventana temporal puede durar una semana, una hora, un minuto o incluso un segundo.</p> <p>Estas ventanas permiten acotar los datos sobre un flujo que en principio no tiene un inicio ni un fin predefinidos.</p> <p>Existen diferentes tipos de ventanas temporales:</p> <ul> <li>de tama\u00f1o fijo (fixed/tumbling window): divide los flujos de datos en segmentos fijos, con un tama\u00f1o de ventana, un tiempo de inicio y uno de finalizaci\u00f3n. En este tipo, cada dato se asigna a una \u00fanica ventana, de manera que es f\u00e1cil realizar agregaciones como la suma, el m\u00e1ximo o la media.</li> <li>deslizantes (sliding): cada ventana tiene una longitud y un intervalo de deslizamiento. Si el intervalo tiene el mismo tama\u00f1o que la ventana, act\u00faa igual que una ventana de tama\u00f1o fijo. En la imagen podemos ver un intervalo de deslizamiento m\u00e1s peque\u00f1o que el tama\u00f1o de la ventana, lo que implica que un dato puede llegar a m\u00e1s de una ventana. Como las ventana deslizantes se solapan, la agregaciones de datos producen resultados m\u00e1s precisos que con ventanas de tama\u00f1o fijo.</li> <li>de sesi\u00f3n (session): se utiliza para analizar el comportamiento de usuario de un sitio web. No tienen un tama\u00f1o definido, sino que se define por la duraci\u00f3n de la navegaci\u00f3n del usuario.</li> </ul> Tipos de ventanas temporales"},{"location":"spark/03streaming.html#ventana-fija","title":"Ventana fija","text":"<p>Del c\u00f3digo del caso 1, vamos a modificar algunos aspectos para agrupar los datos recibidos en una ventana de dos minutos. Al leer los datos, vamos a indicar que queremos obtener el timestamp de cada dato:</p> <pre><code>lines_df = spark.readStream \\\n    .format(\"socket\") \\\n    .option(\"host\", \"localhost\") \\\n    .option(\"port\", \"9999\") \\\n    .option('includeTimestamp', 'true')\\\n    .load()\n</code></pre> <p>Cuando preparamos el dataframe con las palabras, vamos a incluir tambi\u00e9n el timestamp:</p> <pre><code>from pyspark.sql.functions import explode, split\nwords_df = lines_df.select(\nexplode(split(lines_df.value, ' ')).alias('palabra'),\nlines_df.timestamp)\n</code></pre> <p>Y con las palabras, utilizando la funci\u00f3n <code>window</code> con una ventana fija de 2 minutos, agrupamos tanto la ventana temporal como cada palabra para obtener su cantidad:</p> <pre><code>from pyspark.sql.functions import window\nwindowedCounts = words_df.groupBy(\nwindow(words_df.timestamp, \"2 minutes\"), words_df.palabra\n).count().orderBy('window')\n</code></pre> <p>Finalmente, realizamos la consulta (vamos a indicar que no trunque los datos para poder visualizar toda la informaci\u00f3n de la ventana)</p> <pre><code>word_count_query = windowedCounts.writeStream \\\n    .format(\"console\") \\\n    .outputMode(\"complete\") \\\n    .option('truncate', 'false')\\\n    .start()\n</code></pre> <p>Tras ejecutar el servidor de sockets:</p> <pre><code>nc -lk 9999\n</code></pre> <p>Introducimos la siguientes frases:</p> <pre><code>Hola Mundo\nHola desde el Severo\n</code></pre> <p>Y obtenemos:</p> <pre><code>-------------------------------------------\nBatch: 1\n-------------------------------------------\n+------------------------------------------+-------+-----+\n|window                                    |palabra|count|\n+------------------------------------------+-------+-----+\n|{2022-05-05 17:32:00, 2022-05-05 17:34:00}|Mundo  |1    |\n|{2022-05-05 17:32:00, 2022-05-05 17:34:00}|Hola   |1    |\n+------------------------------------------+-------+-----+\n-------------------------------------------\nBatch: 2\n-------------------------------------------\n+------------------------------------------+-------+-----+\n|window                                    |palabra|count|\n+------------------------------------------+-------+-----+\n|{2022-05-05 17:32:00, 2022-05-05 17:34:00}|el     |1    |\n|{2022-05-05 17:32:00, 2022-05-05 17:34:00}|Mundo  |1    |\n|{2022-05-05 17:32:00, 2022-05-05 17:34:00}|desde  |1    |\n|{2022-05-05 17:32:00, 2022-05-05 17:34:00}|Severo |1    |\n|{2022-05-05 17:32:00, 2022-05-05 17:34:00}|Hola   |2    |\n+------------------------------------------+-------+-----+\n</code></pre> <p>Para cada palabra introducida dentro de la misma ventana temporal (en nuestro caso la hemos definido de 2 minutos, nos cuenta sus ocurrencias).</p> <p>Si nos esperamos un par de minutos y enviamos <code>Severo Ochoa y el Mundo</code>, obtenemos:</p> <pre><code>-------------------------------------------\nBatch: 3\n-------------------------------------------\n+------------------------------------------+-------+-----+\n|window                                    |palabra|count|\n+------------------------------------------+-------+-----+\n|{2022-05-05 17:32:00, 2022-05-05 17:34:00}|el     |1    |\n|{2022-05-05 17:32:00, 2022-05-05 17:34:00}|Mundo  |1    |\n|{2022-05-05 17:32:00, 2022-05-05 17:34:00}|desde  |1    |\n|{2022-05-05 17:32:00, 2022-05-05 17:34:00}|Severo |1    |\n|{2022-05-05 17:32:00, 2022-05-05 17:34:00}|Hola   |2    |\n|{2022-05-05 17:34:00, 2022-05-05 17:36:00}|Mundo  |1    |\n|{2022-05-05 17:34:00, 2022-05-05 17:36:00}|Ochoa  |1    |\n|{2022-05-05 17:34:00, 2022-05-05 17:36:00}|Severo |1    |\n|{2022-05-05 17:34:00, 2022-05-05 17:36:00}|el     |1    |\n|{2022-05-05 17:34:00, 2022-05-05 17:36:00}|y      |1    |\n+------------------------------------------+-------+-----+\n</code></pre> <p>Podemos observar como las palabras de esta \u00faltima frase han entrado en una ventana diferente, y por tanto, al agruparse se cuentan desde 0.</p>"},{"location":"spark/03streaming.html#ventanas-deslizantes","title":"Ventanas deslizantes","text":"<p>Ya hemos visto como funcionan las ventanas fijas. Con las ventanas deslizantes, vamos a poder recoger datos en m\u00e1s de una ventana a la vez:</p> Ventana deslizante <p>Centr\u00e1ndonos en el mismo ejemplo, \u00fanicamente vamos a modificar el fragmento de c\u00f3digo donde agrupamos los datos, para que manteniendo una ventana de 2 minutos, ahora tenga un deslizamiento de un minuto:</p> <pre><code>from pyspark.sql.functions import window\nwindowedCounts = words_df.groupBy(\nwindow(words_df.timestamp, \"2 minutes\", \"1 minute\"), words_df.palabra\n).count().orderBy('window')\n</code></pre> <p>Al introducir <code>Hola Mundo</code>, ha duplicado los datos recibidos para darles cabida en las dos ventanas que van a cubrir cada instante temporal:</p> <pre><code>-------------------------------------------\nBatch: 1\n-------------------------------------------\n+------------------------------------------+-------+-----+\n|window                                    |palabra|count|\n+------------------------------------------+-------+-----+\n|{2022-05-05 17:56:00, 2022-05-05 17:58:00}|Mundo  |1    |\n|{2022-05-05 17:56:00, 2022-05-05 17:58:00}|Hola   |1    |\n|{2022-05-05 17:57:00, 2022-05-05 17:59:00}|Hola   |1    |\n|{2022-05-05 17:57:00, 2022-05-05 17:59:00}|Mundo  |1    |\n+------------------------------------------+-------+-----+\n</code></pre> <p>En el mismo instante, introducimos <code>Severo Ochoa</code>, lo que provoca que vuelta a realizar el mismo proceso, introduciendo ambas palabras en las dos ventanas existentes:</p> <pre><code>-------------------------------------------\nBatch: 2\n-------------------------------------------\n+------------------------------------------+-------+-----+\n|window                                    |palabra|count|\n+------------------------------------------+-------+-----+\n|{2022-05-05 17:56:00, 2022-05-05 17:58:00}|Ochoa  |1    |\n|{2022-05-05 17:56:00, 2022-05-05 17:58:00}|Severo |1    |\n|{2022-05-05 17:56:00, 2022-05-05 17:58:00}|Mundo  |1    |\n|{2022-05-05 17:56:00, 2022-05-05 17:58:00}|Hola   |1    |\n|{2022-05-05 17:57:00, 2022-05-05 17:59:00}|Severo |1    |\n|{2022-05-05 17:57:00, 2022-05-05 17:59:00}|Hola   |1    |\n|{2022-05-05 17:57:00, 2022-05-05 17:59:00}|Ochoa  |1    |\n|{2022-05-05 17:57:00, 2022-05-05 17:59:00}|Mundo  |1    |\n+------------------------------------------+-------+-----+\n</code></pre> <p>Dentro de la misma ventana introducimos <code>Hola Mundo desde el Severo Ochoa</code>, obteniendo el tercer micro-batch:</p> <pre><code>-------------------------------------------\nBatch: 3\n-------------------------------------------\n+------------------------------------------+-------+-----+\n|window                                    |palabra|count|\n+------------------------------------------+-------+-----+\n|{2022-05-05 17:56:00, 2022-05-05 17:58:00}|Ochoa  |2    |\n|{2022-05-05 17:56:00, 2022-05-05 17:58:00}|el     |1    |\n|{2022-05-05 17:56:00, 2022-05-05 17:58:00}|Severo |2    |\n|{2022-05-05 17:56:00, 2022-05-05 17:58:00}|Mundo  |2    |\n|{2022-05-05 17:56:00, 2022-05-05 17:58:00}|Hola   |2    |\n|{2022-05-05 17:56:00, 2022-05-05 17:58:00}|desde  |1    |\n|{2022-05-05 17:57:00, 2022-05-05 17:59:00}|el     |1    |\n|{2022-05-05 17:57:00, 2022-05-05 17:59:00}|Severo |2    |\n|{2022-05-05 17:57:00, 2022-05-05 17:59:00}|desde  |1    |\n|{2022-05-05 17:57:00, 2022-05-05 17:59:00}|Hola   |2    |\n|{2022-05-05 17:57:00, 2022-05-05 17:59:00}|Ochoa  |2    |\n|{2022-05-05 17:57:00, 2022-05-05 17:59:00}|Mundo  |2    |\n+------------------------------------------+-------+-----+\n</code></pre> <p>Finalmente, nos esperamos un poco para provocar entrar en otra ventana e introducimos <code>Segunda ventana</code>:</p> <pre><code>-------------------------------------------\nBatch: 4\n-------------------------------------------\n+------------------------------------------+-------+-----+\n|window                                    |palabra|count|\n+------------------------------------------+-------+-----+\n|{2022-05-05 17:56:00, 2022-05-05 17:58:00}|Ochoa  |2    |\n|{2022-05-05 17:56:00, 2022-05-05 17:58:00}|el     |1    |\n|{2022-05-05 17:56:00, 2022-05-05 17:58:00}|Severo |2    |\n|{2022-05-05 17:56:00, 2022-05-05 17:58:00}|Mundo  |2    |\n|{2022-05-05 17:56:00, 2022-05-05 17:58:00}|Hola   |2    |\n|{2022-05-05 17:56:00, 2022-05-05 17:58:00}|desde  |1    |\n|{2022-05-05 17:57:00, 2022-05-05 17:59:00}|Segunda|1    |\n|{2022-05-05 17:57:00, 2022-05-05 17:59:00}|Severo |2    |\n|{2022-05-05 17:57:00, 2022-05-05 17:59:00}|desde  |1    |\n|{2022-05-05 17:57:00, 2022-05-05 17:59:00}|el     |1    |\n|{2022-05-05 17:57:00, 2022-05-05 17:59:00}|Hola   |2    |\n|{2022-05-05 17:57:00, 2022-05-05 17:59:00}|Ochoa  |2    |\n|{2022-05-05 17:57:00, 2022-05-05 17:59:00}|ventana|1    |\n|{2022-05-05 17:57:00, 2022-05-05 17:59:00}|Mundo  |2    |\n|{2022-05-05 17:58:00, 2022-05-05 18:00:00}|ventana|1    |\n|{2022-05-05 17:58:00, 2022-05-05 18:00:00}|Segunda|1    |\n+------------------------------------------+-------+-----+\n</code></pre> <p>Finalmente, introducimos <code>Segunda ventana Ochoa</code> para comprobar como rellena las dos \u00faltimas ventanas:</p> <pre><code>-------------------------------------------\nBatch: 5\n-------------------------------------------\n+------------------------------------------+-------+-----+\n|window                                    |palabra|count|\n+------------------------------------------+-------+-----+\n|{2022-05-05 17:56:00, 2022-05-05 17:58:00}|Ochoa  |2    |\n|{2022-05-05 17:56:00, 2022-05-05 17:58:00}|el     |1    |\n|{2022-05-05 17:56:00, 2022-05-05 17:58:00}|Severo |2    |\n|{2022-05-05 17:56:00, 2022-05-05 17:58:00}|Mundo  |2    |\n|{2022-05-05 17:56:00, 2022-05-05 17:58:00}|Hola   |2    |\n|{2022-05-05 17:56:00, 2022-05-05 17:58:00}|desde  |1    |\n|{2022-05-05 17:57:00, 2022-05-05 17:59:00}|Segunda|2    |\n|{2022-05-05 17:57:00, 2022-05-05 17:59:00}|Severo |2    |\n|{2022-05-05 17:57:00, 2022-05-05 17:59:00}|desde  |1    |\n|{2022-05-05 17:57:00, 2022-05-05 17:59:00}|el     |1    |\n|{2022-05-05 17:57:00, 2022-05-05 17:59:00}|Hola   |2    |\n|{2022-05-05 17:57:00, 2022-05-05 17:59:00}|Ochoa  |3    |\n|{2022-05-05 17:57:00, 2022-05-05 17:59:00}|ventana|2    |\n|{2022-05-05 17:57:00, 2022-05-05 17:59:00}|Mundo  |2    |\n|{2022-05-05 17:58:00, 2022-05-05 18:00:00}|ventana|2    |\n|{2022-05-05 17:58:00, 2022-05-05 18:00:00}|Ochoa  |1    |\n|{2022-05-05 17:58:00, 2022-05-05 18:00:00}|Segunda|2    |\n+------------------------------------------+-------+-----+\n</code></pre>"},{"location":"spark/03streaming.html#caso-6-bolsa-i","title":"Caso 6: Bolsa I","text":"<p>Para este caso de uso, vamos a suponer que recibimos un fichero con eventos sobre valores de un mercado financiero con el siguiente formato:</p> <pre><code>{\"CreatedTime\": \"2022-05-09 10:05:00\", \"Type\": \"BUY\", \"Amount\": 500, \"BrokerCode\": \"AME\"}\n{\"CreatedTime\": \"2022-05-09 10:12:00\", \"Type\": \"BUY\", \"Amount\": 300, \"BrokerCode\": \"AME\"}\n{\"CreatedTime\": \"2022-05-09 10:20:00\", \"Type\": \"BUY\", \"Amount\": 800, \"BrokerCode\": \"AME\"}\n{\"CreatedTime\": \"2022-05-09 10:40:00\", \"Type\": \"BUY\", \"Amount\": 900, \"BrokerCode\": \"AME\"}\n{\"CreatedTime\": \"2022-05-09 10:25:00\", \"Type\": \"SELL\", \"Amount\": 400, \"BrokerCode\": \"AME\"}\n{\"CreatedTime\": \"2022-05-09 10:48:00\", \"Type\": \"SELL\", \"Amount\": 600, \"BrokerCode\": \"AME\"}\n{\"CreatedTime\": \"2022-05-09 10:50:00\", \"Type\": \"SELL\", \"Amount\": 100, \"BrokerCode\": \"AME\"}\n</code></pre> <p>Nuestro departamento de visualizaci\u00f3n nos pide que transformemos los datos recibidos para crear la siguiente estructura:</p> TInicio TFin Compras Ventas Neto 9:00 9:15 0 0 0 9:15 9:30 1000 300 700 9:30 9:45 1500 700 800 9:45 10:00 1600 900 700 <p>As\u00ed pues, necesitamos agrupar los datos con una ventana fija de 15 minutos, e ir acumulando las cantidades (<code>Amount</code>), dependiendo de que el tipo (<code>Type</code>) sea una compra (<code>BUY</code>) o una venta (<code>SELL</code>) para luego calcular su valor neto como la diferencia de estos dos \u00faltimos.</p> <p>Nuestro primer paso, ser\u00e1 crear la conexi\u00f3n a Spark y la lectura de la carpeta donde ir\u00e1n llegando los ficheros de datos:</p> <pre><code>from pyspark.sql import SparkSession\nspark = SparkSession \\\n        .builder \\\n        .appName(\"Bolsa Streaming s8a\") \\\n        .master(\"local[2]\") \\\n        .config(\"spark.streaming.stopGracefullyOnShutdown\", \"true\") \\\n        .config(\"spark.sql.shuffle.partitions\", 3) \\\n        .getOrCreate()\n# Definimos el esquema de los datos de entrada\nfrom pyspark.sql.types import StructType, StructField, StringType, IntegerType\nbolsaSchema = StructType([\nStructField(\"CreatedTime\", StringType()),\nStructField(\"Type\", StringType()),\nStructField(\"Amount\", IntegerType()),\nStructField(\"BrokerCode\", StringType())\n])\n# Configuramos la lectura de fichero en formato JSON\nrawDF = spark.readStream \\\n        .format(\"json\") \\\n        .option(\"path\", \"entrada\") \\\n        .option(\"maxFilesPerTrigger\", 1) \\\n        .schema(bolsaSchema) \\\n        .load()\nrawDF.printSchema()\n# root\n#  |-- CreatedTime: string (nullable = true)\n#  |-- Type: string (nullable = true)\n#  |-- Amount: integer (nullable = true)\n#  |-- BrokerCode: string (nullable = true)\n</code></pre> <p>El siguiente paso, es crear las columnas con la fecha en formato timestamp y las nuevas columnas <code>Compras</code> y <code>Ventas</code>:</p> <pre><code>from pyspark.sql.functions import to_timestamp, col, expr\naccionesDF = rawDF.withColumn(\"CreatedTime\", to_timestamp(col(\"CreatedTime\"), \"yyyy-MM-dd HH:mm:ss\")) \\\n    .withColumn(\"Compras\", expr(\"case when Type == 'BUY' then Amount else 0 end\")) \\\n    .withColumn(\"Ventas\", expr(\"case when Type == 'SELL' then Amount else 0 end\"))\naccionesDF.printSchema()\n# root\n#  |-- CreatedTime: timestamp (nullable = true)\n#  |-- Type: string (nullable = true)\n#  |-- Amount: integer (nullable = true)\n#  |-- BrokerCode: string (nullable = true)\n#  |-- Compras: integer (nullable = true)\n#  |-- Ventas: integer (nullable = true)\n</code></pre> <p>Si queremos ver el resultado e intentamos realizar <code>accionesDF.show()</code>, nos dar\u00e1 un error al no haber realizar un start del streaming. Para probarlo como si fuera un proceso batch s\u00f3lo tenemos que cambiar el m\u00e9todo <code>readStream</code> de la lectura por <code>read</code> y ya funcionar\u00e1:</p> <pre><code>rawDF = spark.read \\\n        .format(\"json\") \\\n        ...\naccionesDF.show()\n# +-------------------+----+------+----------+-------+------+\n# |        CreatedTime|Type|Amount|BrokerCode|Compras|Ventas|\n# +-------------------+----+------+----------+-------+------+\n# |2022-05-09 10:05:00| BUY|   500|       AME|    500|     0|\n# |2022-05-09 10:12:00| BUY|   300|       AME|    300|     0|\n# |2022-05-09 10:20:00| BUY|   800|       AME|    800|     0|\n# |2022-05-09 10:40:00| BUY|   900|       AME|    900|     0|\n# |2022-05-09 10:25:00|SELL|   400|       AME|      0|   400|\n# |2022-05-09 10:48:00|SELL|   600|       AME|      0|   600|\n# |2022-05-09 10:50:00|SELL|   100|       AME|      0|   100|\n# +-------------------+----+------+----------+-------+------+\n</code></pre> <p>Una vez hemos comprobado que hemos preparado los datos con el formato y contenido adecuados, vamos a agruparlos con una ventana de 15 minutos:</p> <pre><code>from pyspark.sql.functions import window, sum\nwindowDF = accionesDF \\\n    .groupBy(  # col(\"BrokerCode\"),\nwindow(col(\"CreatedTime\"), \"15 minutes\")) \\\n    .agg(sum(\"Compras\").alias(\"Compras\"),\nsum(\"Ventas\").alias(\"Ventas\"))\nsalidaDF = windowDF.select(\"window.start\", \"window.end\", \"Compras\", \"Ventas\")\nbolsaWriterQuery = salidaDF.writeStream \\\n    .format(\"console\") \\\n    .outputMode(\"complete\") \\\n    .start()\nbolsaWriterQuery.awaitTermination()\n</code></pre> <p>Y tras volver a poner <code>readStream</code> y arrancarlo, obtenemos:</p> <pre><code>+-------------------+-------------------+-------+------+\n|              start|                end|Compras|Ventas|\n+-------------------+-------------------+-------+------+\n|2022-05-09 10:00:00|2022-05-09 10:15:00|    800|     0|\n|2022-05-09 10:15:00|2022-05-09 10:30:00|    800|   400|\n|2022-05-09 10:30:00|2022-05-09 10:45:00|    900|     0|\n|2022-05-09 10:45:00|2022-05-09 11:00:00|      0|   700|\n+-------------------+-------------------+-------+------+\n</code></pre> <p>Estos datos se parecen a la informaci\u00f3n que quer\u00edamos, pero \u00fanicamente esta sumando los datos de cada ventana, sin acumularlos con todos los datos anteriores. A d\u00eda de hoy, la \u00fanica forma de sumar todos los datos agregados es utilizar las funciones ventana (similares a las que vimos al trabajar con Hive) dentro de un proceso batch.</p> <p>As\u00ed pues, vamos a almacenar los datos en un fichero en formato Parquet, para que luego desde un proceso Batch realizar los c\u00e1lculos que nos faltan. Pero antes necesitamos introducir el concepto de marca de agua.</p>"},{"location":"spark/03streaming.html#watermarking","title":"Watermarking","text":"<p>Cuando los datos llegan tarde a nuestro sistema (se generan en la ventana N, pero llegan a Spark en la ventana N+M), Spark gestiona todas las ventanas y actualiza los c\u00e1lculos. Estos c\u00e1lculos, como hemos comentado, son el estado de las transformaciones y se almacenan en los diferentes ejecutores del cl\u00faster de Spark.</p> <p>\u00bfQu\u00e9 sucede con un dato que se genera a las 12:04 pero llega a Spark a las 12:11, si nuestras ventanas tienen un tama\u00f1o de 10 minutos? Como se mantiene el estado, Spark puede modificar la ventana de las 12:00 a las 12:10 y actualizar los c\u00e1lculos:</p> Gesti\u00f3n de datos tard\u00edos <p>El problema es que estos c\u00e1lculos se almacenan para todos los datos, con lo cual el estado crece ininterrumpidamente. Para definir que las ventanas expiren, necesitamos conocer el concepto de marca de agua (watermark), el cual va a permitir indicar el tiempo que el sistema debe esperar a datos que llegan tarde, de manera que si exceden la marca de agua, los datos se desechan. Al definir las marcas de agua, Spark Streaming realiza un seguimiento de los tiempos de los eventos de los datos e intenta limpiar los datos caducados de los ejecutores.</p> <p>La decisi\u00f3n de la definici\u00f3n de la marca de agua pertenece a negocio, y debe responder a:</p> <ul> <li>\u00bfCu\u00e1l es el m\u00e1ximo retraso posible/aceptable?</li> <li>\u00bfCu\u00e1ndo dejan los datos de ser relevantes?</li> </ul> <p>Una vez tenemos claro el rango temporal en el que los datos son aceptables, los definimos antes de agrupar y utilizando las mismas columnas de agrupaci\u00f3n (en nuestro caso, por la columna <code>timestamp</code>) mediante el m\u00e9todo withWatermark:</p> <pre><code>from pyspark.sql.functions import window\nwindowedCounts = words_df \\\n    .withWatermark(words_df.timestamp, \"30 minutes\") \\\n    .groupBy(\nwindow(words_df.timestamp, \"2 minutes\", \"1 minute\"), words_df.palabra) \\\n    .count().orderBy('window')\n</code></pre> <p>De esta manera, si llega una palabra con un retraso de m\u00e1s de 30 minutos, se desechar\u00e1. Adem\u00e1s, el estado de la ventana se limpiar\u00e1 cuando pasen esos 30 minutos, de manera que su tama\u00f1o siempre estar\u00e1 limitado por el timestamp de los datos recibidos en los \u00faltima media hora.</p> <p>Si utilizamos marcas de agua para limitar el estado de la ventana, es importante tener en cuenta que si el modo de salida es completo, no se limpiar\u00e1 el estado, es decir, es como si no utiliz\u00e1semos marcas de agua.</p>"},{"location":"spark/03streaming.html#modo-update","title":"Modo update","text":"<p>En cambio, mediante el modo update s\u00ed que se limpia la ventana de estado, realizando operaciones de tipo upsert, por ejemplo con un sink que s\u00ed soporte las modificaciones, como cualquiera base de datos. Aunque hay que tener cuidado si nuestro sink es de tipo fichero, ya que no puede modificar los ficheros JSON/Parquet y crear\u00e1 archivos duplicados.</p> <p>Veamos un ejemplo donde definimos una marca de agua de 10 minutos sobre una ventana tambi\u00e9n de 10 minutos sobre la columna timestamp con triggers cada 5 minutos:</p> Marca de agua - modo update <p>La l\u00ednea punteada en azul representa el mayor evento le\u00eddo, el cual va a definir la marca de agua (tiempo del mayor evento menos 10 minutos)</p> <p>Cuando llega el dato dog de las 12:14, fija la marca de agua a las 12:04 para el siguiente trigger. Todo lo que sea anterior a las 12:04 se desechar\u00e1 y lo posterior, se tratar\u00e1 (por ejemplo, al llegar cat a las 12:09) y se contabiliza en las dos ventanas posibles.</p> <p>Sin embargo, cuando llega owl a las 12:21, fija la marca de agua a las 12:11, y por tanto limpia la ventana que va de las 12:00 a las 12:10, y todos los datos posteriores que llegan anteriores a la marca de agua como donkey a las 12:04 se descartan por llegar demasiado tarde.</p> <p>Tras cada trigger, por el modo update, los c\u00e1lculos (filas en lila) se escriben en el destino.</p>"},{"location":"spark/03streaming.html#modo-append","title":"Modo append","text":"<p>Aunque anteriormente comentamos que no pod\u00edamos utilizar el modo append con la agregaciones, ya que Spark necesita saber que los registros no se actualizar\u00e1n o modificar\u00e1n en el futuro. Al definir una marca de agua, ahora s\u00ed que podremos hacerlo. Para ello, s\u00f3lo emitir\u00e1 el resultado una vez ha finalizado una ventana y no pueda tener aceptar nuevos eventos tard\u00edos.</p> <p>Supongamos que nuestra marca de agua es de treinta minutos, teniendo un ventana de estado actual de 10:00 a 10:30, con un tama\u00f1o de ventana de 15 minutos. Si nos llega un mensaje a las 10:45, nuestra ventana de estado pasar\u00e1 a ser de 10:15 a 10:45, y a la ventana de 10:00 a 10:15 ya no podr\u00e1 llegar ning\u00fan mensaje, de manera que puede mostrar los c\u00e1lculos y realizar el append de dichos datos.</p> <p>Si el retraso de la marca de agua no es cr\u00edtica para nuestro sistema, mediante watermarking y el modo de salida append, podemos utilizar un sink de tipo fichero.</p> <p>Si retomamos el mismo ejemplo de antes, pero ahora con el modo append, y nos fijamos en los pasos finales, cuando la marca de agua pasaba a ser a las 12:11 provocaba que caducase la ventana de las 12:00 a las 12:10. En el siguiente trigger es cuando dichos datos se persisten en el sink:</p> Marca de agua - modo append"},{"location":"spark/03streaming.html#caso-7-bolsa-ii","title":"Caso 7: Bolsa II","text":"<p>Ahora que ya hemos visto el concepto de marca de agua, podemos crear un marco para que los valores que lleguen tarde se descarten y poder almacenar la informaci\u00f3n en fichero en formato Parquet con el modo de salida append.</p> <p>As\u00ed pues, cuando agrupamos los datos, vamos a definir una marca de agua de 30 minutos:</p> <pre><code>from pyspark.sql.functions import window, sum\nwindowDF = accionesDF \\\n    .withWatermark(\"CreatedTime\", \"30 minutes\") \\\n    .groupBy(  # col(\"BrokerCode\"),\nwindow(col(\"CreatedTime\"), \"15 minutes\")) \\\n    .agg(sum(\"Compras\").alias(\"Compras\"),\nsum(\"Ventas\").alias(\"Ventas\"))\n</code></pre> <p>Y posteriormente ya podemos almacenar los datos en un fichero:</p> <pre><code>bolsaWriterQuery = salidaDF.writeStream \\\n    .format(\"parquet\") \\\n    .queryName(\"BolsaWQuery\") \\\n    .outputMode(\"append\") \\\n    .option(\"path\", \"salida\") \\\n    .option(\"checkpointLocation\", \"chk-point-dir\") \\\n    .trigger(processingTime=\"1 minute\") \\\n    .start()\n</code></pre> <p>Si vamos a la carpeta, tendremos diferentes fichero. Si creamos un nuevo fichero con un dato que se salga de la marca de agua, los datos antiguos caducar\u00e1n y se persistir\u00e1n en disco. As\u00ed pues, si ahora los cargamos mediante un proceso batch, podremos ver los datos:</p> <pre><code>rawBolsaDF = spark.read \\\n    .format(\"parquet\") \\\n    .option(\"path\", \"salida\") \\\n    .load()\nrawBolsaDF.show()\n# +-------------------+-------------------+-------+------+\n# |              start|                end|Compras|Ventas|\n# +-------------------+-------------------+-------+------+\n# |2022-05-09 10:00:00|2022-05-09 10:15:00|    800|     0|\n# |2022-05-09 10:15:00|2022-05-09 10:30:00|    800|   400|\n# |2022-05-09 10:45:00|2022-05-09 11:00:00|      0|   700|\n# |2022-05-09 10:30:00|2022-05-09 10:45:00|    900|     0|\n# +-------------------+-------------------+-------+------+\n</code></pre> <p>Ahora ya podemos hacer uso de las funciones ventanas, y calcular el total acumulado:</p> <pre><code>from pyspark.sql import Window\nventanaTotal = Window.orderBy(\"end\") \\\n    .rowsBetween(Window.unboundedPreceding, Window.currentRow)\nsalidaDF = rawBolsaDF \\\n    .withColumn(\"Compras\", sum(\"Compras\").over(ventanaTotal)) \\\n    .withColumn(\"Ventas\", sum(\"Ventas\").over(ventanaTotal)) \\\n    .withColumn(\"Neto\", expr(\"Compras - Ventas\"))\nsalidaDF.show(truncate=False)\n# +-------------------+-------------------+-------+------+----+\n# |start              |end                |Compras|Ventas|Neto|\n# +-------------------+-------------------+-------+------+----+\n# |2022-05-09 10:00:00|2022-05-09 10:15:00|800    |0     |800 |\n# |2022-05-09 10:15:00|2022-05-09 10:30:00|1600   |400   |1200|\n# |2022-05-09 10:30:00|2022-05-09 10:45:00|1600   |1100  |500 |\n# |2022-05-09 10:45:00|2022-05-09 11:00:00|2500   |1100  |1400|\n# +-------------------+-------------------+-------+------+----+\n</code></pre>"},{"location":"spark/03streaming.html#join","title":"Join","text":"<p>Una de las cosas m\u00e1s curiosas que podemos hacer con un DataFrame en streaming es realizar un join con otro DataFrame est\u00e1tico u otro en streaming, es decir, con datos que todav\u00eda no existen.</p> <p>Realizar un join es una operaci\u00f3n compleja y la parte divertida es que no todos los datos est\u00e1n disponibles en el momento de realizar el join, por lo tanto su resultado se genera de forma incremental tras cada trigger, de forma similar a como se generan las agregaciones.</p> <p>Unir un stream con un DataFrame est\u00e1tico es una operaci\u00f3n sin estado, ya que Spark no necesita mantener el estado y s\u00f3lo est\u00e1 uniendo los datos de un \u00fanico micro-batch.</p> <pre><code>estaticoDF = spark.read. ...\nstreamingDF = spark.readStream. ...\nstreamingDF.join(estaticoDF, \"claveAjena\")  # inner join entre streaming y est\u00e1tico\nstreamingDF.join(estaticoDF, \"claveAjena\", \"left_outer\")  # left outer join con est\u00e1tico\n</code></pre> <p>En cambio, unir dos DataFrames en streaming s\u00ed que es una operaci\u00f3n con estado, ya que Spark necesita almacenar los datos de ambos en el almacenamiento del estado y comprobar continuamente si hay relaci\u00f3n entre los nuevos datos que llegan en cada micro-batch. Dado que los DataFrames en stream no tienen un final definido, Spark Structured Streaming debe mantener todos los datos recogidos de ambos DataFrames de un join, ya que pueden llegar futuros datos que s\u00ed cumplan la relaci\u00f3n. Para evitar que el estado se quede sin memoria disponible, podemos utilizar marcas de agua en ambos DataFrames e incluir una restricci\u00f3n basada en el tiempo de evento definido en la condici\u00f3n de join.</p> <p>Supongamos que queremos unir un flujo de impresiones de anuncios (cuando se muestra un anuncio) con otro flujo de los clicks que los usuarios realizan sobre los anuncios para correlacionarlos y monetizar los clicks:</p> <pre><code>from pyspark.sql.functions import expr\nimpresiones = spark.readStream. ...\nclicks = spark.readStream. ...\n# Le asignamos una marca de agua a las columnas de tiempos de eventos\nimpresionesConMarcaAgua = impresiones.withWatermark(\"impresionTime\", \"2 hours\")\nclicksConMarcaAgua = clicks.withWatermark(\"clickTime\", \"3 hours\")\n# Join con restricciones temporales\n# Los clicks solo se pueden recibir una vez impreso el anuncio y hasta una hora despu\u00e9s\nimpresionesConMarcaAgua.join(\nclicksConMarcaAgua,\nexpr(\"\"\"\n    clickAnuncioId = impresionAnuncioId AND\n    clickTime &gt;= impresionTime AND\n    clickTime &lt;= impresionTime + interval 1 hour\n    \"\"\")\n)\n</code></pre> <p>Limpieza</p> <p>Conviene recordar que la limpieza de los registros del estado que quedan fuera de la marca de agua puede realizar tan pronto como cambie la marca o se puede retrasar debido a optimizaciones de Spark. As\u00ed pues, Spark no garantiza que los registros que est\u00e1n fuera de la marca de agua se ignoren por completo, sino que lo que est\u00e9n dentro nunca se descartar\u00e1n.</p> <p>El soporte que hay para los diferentes tipos de join depende de los tipos de DataFrames:</p> Izquierda + Derecha Inner Join Left Join Right Join Full Outer Est\u00e1tico + Streaming S\u00ed No S\u00ed No Streaming + Streaming S\u00ed Condicional. Debe especificar marca de agua en el lado derecho y restricci\u00f3n temporal Condicional. Debe especificar marca de agua en el lado izquierdo y restricci\u00f3n temporal Condicional. Debe especificar marca de agua en un lado y restricci\u00f3n temporal <p>En todos los casos que se indican restricciones temporales, opcionalmente se puede especificar marca de agua en el otro lado para facilitar la limpieza del estado.</p>"},{"location":"spark/03streaming.html#caso-8-join-entre-kafka-y-mariadb","title":"Caso 8: Join entre Kafka y MariaDB","text":"<p>En este caso de uso a leer datos de Kafka y unir la informaci\u00f3n recibida con una fuente de datos est\u00e1tica como puede ser MariaDB.</p> <p>Vamos a simular que recibimos informaci\u00f3n sobre usuarios que han realizado login en una aplicaci\u00f3n externa y hemos de cruzar sus datos con una base de datos que centraliza todos los usuarios de nuestra empresa.</p> <p>Para ello, en MariaDB vamos a crear una base de datos y una tabla con informaci\u00f3n sobre usuarios:</p> <pre><code>CREATE DATABASE `spark` /*!40100 DEFAULT CHARACTER SET utf8mb4 */;\nCREATE TABLE spark.usuarios (\nid BIGINT UNSIGNED auto_increment NOT NULL,\nnombre varchar(100) NOT NULL,\nultimoLogin TIMESTAMP NOT NULL,\nCONSTRAINT usuarios_PK PRIMARY KEY (id)\n)\nENGINE=InnoDB\nDEFAULT CHARSET=utf8mb4\nCOLLATE=utf8mb4_general_ci;\nDROP TABLE IF EXISTS spark.usuarios;\n</code></pre> <p>En esta tabla, almacenamos los datos centralizados de los usuarios de nuestra empresa:</p> <pre><code>INSERT INTO spark.usuarios (id, nombre, ultimoLogin) VALUES\n(1, 'Aitor Medrano','2022-05-13 13:36:58.0'),\n(2, 'Pedro Casas','2022-05-14 13:46:58.0'),\n(3, 'Laura Garc\u00eda','2022-05-15 13:56:58.0'),\n(4, 'M\u00aa Josep Vidal','2022-05-16 14:06:58.0');\n</code></pre> <p>Mediante Kafka, vamos a recibir los datos de los usuarios que entran a nuestras aplicaciones desde un topic llamado <code>usuariosk</code> con mensaje con el siguiente formato:</p> <pre><code>{\"login_id\": \"1\", \"login_time\": \"2022-05-17 12:15:00\"}\n{\"login_id\": \"3\", \"login_time\": \"2022-05-18 12:15:00\"}\n{\"login_id\": \"2\", \"login_time\": \"2022-05-19 12:15:00\"}\n{\"login_id\": \"5\", \"login_time\": \"2022-05-20 12:15:00\"}\n</code></pre> <p>Una vez que crucemos los datos, si el usuario ya exist\u00eda en nuestra base de datos (coinciden <code>id</code> y <code>login_id</code>) modificaremos la fecha de su <code>ultimoLogin</code>.</p> <p>Una vez tenemos claro los datos de entrada, arrancamos Kafka y creamos el topic:</p> <pre><code>zookeeper-server-start.sh ./config/zookeeper.properties\nkafka-server-start.sh ./config/server.properties\nkafka-topics.sh --create --topic usuariosk --bootstrap-server iabd-virtualbox:9092\n</code></pre>"},{"location":"spark/03streaming.html#lectura-en-streaming","title":"Lectura en streaming","text":"<p>Vamos a comenzar con el fragmento de c\u00f3digo que realiza la lectura desde Kafka, creando la sesi\u00f3n Spark y leyendo del topic <code>usuariosk</code>:</p> <pre><code>spark = SparkSession \\\n    .builder \\\n    .master(\"local[3]\") \\\n    .appName(\"s8a Kafka join MariaDB\") \\\n    .config(\"spark.streaming.stopGracefullyOnShutdown\", \"true\") \\\n    .config(\"spark.sql.shuffle.partitions\", 2) \\\n    .getOrCreate()\nkafkaSchema = StructType([\nStructField(\"login_id\", StringType()),\nStructField(\"login_time\", StringType())\n])\nkafkaDF = spark \\\n    .readStream \\\n    .format(\"kafka\") \\\n    .option(\"kafka.bootstrap.servers\", \"iabd-virtualbox:9092\") \\\n    .option(\"subscribe\", \"usuariosk\") \\\n    .option(\"startingOffsets\", \"earliest\") \\\n    .load()\n# Pasamos el value de Kafka a string y luego a JSON\nvalueDF = kafkaDF.select(from_json(col(\"value\").cast(\"string\"), kafkaSchema).alias(\"value\"))\n# Cast del campo login_time a tipo fecha\nloginDF = valueDF.select(\"value.*\") \\\n    .withColumn(\"login_time\", to_timestamp(col(\"login_time\"), \"yyyy-MM-dd HH:mm:ss\"))\n</code></pre> <p>As\u00ed pues, <code>loginDF</code> es un DataFrame que realiza streaming sobre Kafka.</p>"},{"location":"spark/03streaming.html#lectura-estatica","title":"Lectura est\u00e1tica","text":"<p>El segundo paso es crear otro DataFrame que obtenga los datos desde MariaDB (en esta caso un DataFrame est\u00e1tico, sin streaming). Para ello, primero hemos de copiar el driver JDBC de Mysql en nuestro sistema (en mi caso lo he hecho en <code>/opt/spark-3.2.0/conf</code> y configurar en <code>spark-defaults.conf</code> que vamos a emplear dicho driver JDBC:</p> spark-defaults.conf<pre><code>spark.driver.extraClassPath = /opt/spark-3.2.0/conf/mysql-connector-java-5.1.49-bin.jar\nspark.executor.extraClassPath = /opt/spark-3.2.0/conf/mysql-connector-java-5.1.49-bin.jar\n</code></pre> <p>Con el driver JDBC ya cargado en Spark, realizamos la lectura de los datos:</p> <pre><code>jdbcDF = spark.read \\\n    .format(\"jdbc\") \\\n    .option(\"driver\", \"com.mysql.jdbc.Driver\") \\\n    .option(\"url\", \"jdbc:mysql://localhost\") \\\n    .option(\"dbtable\", \"spark.usuarios\") \\\n    .option(\"user\", \"iabd\") \\\n    .option(\"password\", \"iabd\") \\\n    .load()\n</code></pre>"},{"location":"spark/03streaming.html#join_1","title":"Join","text":"<p>Finalmente, un vez le\u00eddos los datos desde MariaDB, ya podemos hacer el join:</p> <pre><code>joinExpr = loginDF.login_id == jdbcDF.id\njoinType = \"inner\"\njoinDF = loginDF.join(jdbcDF, joinExpr, joinType) \\\n    .drop(loginDF.login_id)\njoinDF.printSchema()\n# root\n#  |-- login_time: timestamp (nullable = true)\n#  |-- id: decimal(20,0) (nullable = true)\n#  |-- nombre: string (nullable = true)\n#  |-- ultimoLogin: timestamp (nullable = true)\nresultadoDF = joinDF.select(col(\"id\"), col(\"nombre\"), col(\"login_time\"), col(\"ultimoLogin))\nqueryWriter = resultadoDF.writeStream \\\n    .format(\"console\") \\\n    .outputMode(\"update\") \\\n    .option(\"checkpointLocation\", \"chk-point-dir\") \\\n    .trigger(processingTime=\"1 minute\") \\\n    .start()\nqueryWriter.awaitTermination()\n</code></pre> <p>Una vez lanzado, creamos un productor de Kafka:</p> <pre><code>kafka-console-producer.sh --topic usuariosk --bootstrap-server iabd-virtualbox:9092\n</code></pre> <p>y le enviamos datos de entrada a la aplicaci\u00f3n:</p> <pre><code>{\"login_id\": \"1\", \"login_time\": \"2022-05-17 12:15:00\"}\n</code></pre> <p>Si vamos a la consola de Spark, veremos como ha creado el join:</p> <pre><code>-------------------------------------------                                     Batch: 1\n-------------------------------------------\n+---+-------------+-------------------+-------------------+\n| id|       nombre|        ultimoLogin|         login_time|\n+---+-------------+-------------------+-------------------+\n|  1|Aitor Medrano|2022-05-16 13:36:58|2022-05-17 12:15:00|\n+---+-------------+-------------------+-------------------+\n</code></pre> <p>Si queremos preparar el DataFrame para que tenga la misma estructura que nuestra base de datos cuando creamos el resultado:</p> <pre><code>resultadoDF = joinDF.select(col(\"id\"), col(\"nombre\"), col(\"login_time\").alias(\"ultimoLogin))\nresultadoDF.printSchema()\n# root\n#  |-- id: decimal(20,0) (nullable = true)\n#  |-- nombre: string (nullable = true)\n#  |-- ultimoLogin: timestamp (nullable = true)\n</code></pre>"},{"location":"spark/03streaming.html#datos-duplicados","title":"Datos duplicados","text":"<p>Aunque Spark Streaming asegura la fiabilidad de los datos mediante la entrega de mensajes exactly-one, es posible que desde nuestras fuentes de datos nos env\u00eden un dato m\u00e1s de una vez (por problemas con la red o fallos de transmisi\u00f3n).</p> <p>Dentro de Structured Streaming podemos gestionar los datos duplicados tanto con marcas de agua como sin ellas. Debes tener en cuenta que si no utilizamos watermarking, el estado de Spark necesite almacenar de manera ilimitada todos los datos, lo que puede llevar a un problema de falta de memoria.</p> <p>Para evitar los registros duplicados, los diferente eventos deber\u00edan tener un identificador \u00fanico:</p> <pre><code>streamingDF = spark.readStream. ...\n# Sin marcas de agua\nstreamingDF.dropDuplicates(\"id\")\n# Mediante marca de agua, eliminamos tanto por el identificador como la ventana temporal\nstreamingDF \\\n  .withWatermark(\"ts\", \"10 minutes\") \\\n  .dropDuplicates(\"id\", \"ts\")\n</code></pre> <p>Procesamiento con estado (Stateful operations)</p> <p>Si necesitamos realizar operaciones avanzadas que requiere realizar un seguimiento sobre diferentes eventos dentro de una misma sesi\u00f3n (por ejemplo, ver si ha llegado m\u00e1s de 3 veces una temperatura superior a X grados), podemos utilizar las funciones <code>mapGroupWithState</code> y <code>flatMapGroupsWithState</code> (solo disponibles a d\u00eda de hoy mediante Java y Scala), que permiten definir una funci\u00f3n de usuario a aplicar sobre el estado.</p>"},{"location":"spark/03streaming.html#referencias","title":"Referencias","text":"<ul> <li>Documentaci\u00f3n oficial sobre Spark Structured Streaming</li> <li>Beginning Apache Spark 3: With DataFrame, Spark SQL, Structured Streaming, and Spark Machine Learning Library</li> <li>Real-Time Stream Processing Using Apache Spark 3 for Python Developers</li> </ul>"},{"location":"spark/03streaming.html#actividades","title":"Actividades","text":"<ol> <li> <p>Realiza el caso de uso 1 e introduce datos para generar 5 micro-batchs. Accede al Spark UI y comprueba los jobs y stages creados, y justifica su cantidad.</p> </li> <li> <p>Realiza el caso de uso 2, realizando capturas de la carpeta <code>salida</code> tras la colocaci\u00f3n de los datos de cada archivo de facturas en la carpeta de <code>entrada</code>. Previamente, configura el reader para que tras cargar cada archivo, lo elimine. Finalmente muestra un resumen de las estad\u00edsticas tanto del plan de ejecuci\u00f3n como de los \u00faltimos progresos.</p> </li> <li> <p>Realiza los casos de uso 3 y 4 en un \u00fanico cuaderno Jupyter, de manera que s\u00f3lo haya un reader, pero creando dos WriterQuery. Hay dos aspectos que debes tener en cuenta:</p> <ol> <li> <p>En vez de indicar en cada escritor que espere a que finalice:</p> <pre><code>facturaWriterQuery.awaitTermination()\nnotificacionWriterQuery.awaitTermination()\n</code></pre> <p>Le diremos a Spark que espere que termine alguno de ellos mediante awaitAnyTermination:</p> <pre><code>spark.streams.awayAnyTermination()\n</code></pre> </li> <li> <p>Deber\u00e1s configurar diferentes carpetas para <code>checkpointLocation</code> (cada WriterQuery debe tener su propia carpeta para los checkpoints)</p> </li> </ol> </li> <li> <p>(opcional) El archivo bizums.zip contiene una simulaci\u00f3n de datos de bizum que llegan a nuestra cuenta. Crea una aplicaci\u00f3n de Spark Streaming que muestre para cada persona, cual es bizum m\u00e1s alto.</p> <p>Para ello, disponemos de un script Python que, al ejecutarlo, se encarga de simular el env\u00edo de bizums:</p> <pre><code>python3 Bizums.py\n</code></pre> <p>El formato de estos datos es CSV formado por el <code>Nombre;Cantidad;Concepto</code> (dos nombres en may\u00fasculas y en min\u00fasculas son de la misma persona). Un ejemplo de un bizum recibido ser\u00eda similar a:</p> <pre><code>Aitor;25;Cena restaurante\n</code></pre> <p>Muestra el resultado completo por consola.</p> </li> <li> <p>Realiza el caso de uso 5, tanto con ventanas fijas como deslizantes.</p> </li> <li>Realiza los casos de uso que trabajan los conceptos de ventanas y watermarking, es decir, los casos de uso 6 y 7.</li> <li>(opcional) Realiza el caso de uso 8. Adem\u00e1s, modif\u00edcalo para crear una ventana temporal de 15 minutos y env\u00eda nuevos datos de usuarios que entran al sistema que provoquen la limpieza del estado.</li> </ol>"}]}